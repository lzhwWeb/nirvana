<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
 <meta name="referrer" content="no-referrer"/>

  <link rel="apple-touch-icon" sizes="180x180" href="/nirvana/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/nirvana/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/nirvana/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/nirvana/images/logo.svg" color="#222">

<link rel="stylesheet" href="/nirvana/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.2/css/all.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"lzhwweb.github.io","root":"/nirvana/","images":"/nirvana/images","scheme":"Gemini","version":"8.2.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/nirvana/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}};
  </script>
<meta name="description" content="个人学习笔记">
<meta property="og:type" content="website">
<meta property="og:title" content="涅槃快乐是金">
<meta property="og:url" content="https://lzhwweb.github.io/nirvana/page/4/index.html">
<meta property="og:site_name" content="涅槃快乐是金">
<meta property="og:description" content="个人学习笔记">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="nirvana">
<meta property="article:tag" content="前端,javascript,node,git,webpack,css">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://lzhwweb.github.io/nirvana/page/4/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>
<title>涅槃快乐是金</title>
  




  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/nirvana/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">涅槃快乐是金</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/nirvana/" rel="section">首页</a></li>
        <li class="menu-item menu-item-git"><a href="/nirvana/categories/git" rel="section">git</a></li>
        <li class="menu-item menu-item-linux"><a href="/nirvana/categories/linux" rel="section">linux</a></li>
        <li class="menu-item menu-item-android"><a href="/nirvana/categories/android" rel="section">android</a></li>
        <li class="menu-item menu-item-随笔"><a href="/nirvana/categories/informal" rel="section">随笔</a></li>
        <li class="menu-item menu-item-mac"><a href="/nirvana/categories/mac" rel="section">mac</a></li>
        <li class="menu-item menu-item-react-native"><a href="/nirvana/categories/reactnative" rel="section">react-native</a></li>
        <li class="menu-item menu-item-算法"><a href="/nirvana/categories/algorithm" rel="section">算法</a></li>
        <li class="menu-item menu-item-读书笔记"><a href="/nirvana/categories/note" rel="section">读书笔记</a></li>
        <li class="menu-item menu-item-开发工具"><a href="/nirvana/categories/tool" rel="section">开发工具</a></li>
        <li class="menu-item menu-item-设计模式(ts)"><a href="/nirvana/categories/DesignPattern" rel="section">设计模式(TS)</a></li>
        <li class="menu-item menu-item-前端"><a href="/nirvana/categories/javascript" rel="section">前端</a></li>
        <li class="menu-item menu-item-webpack"><a href="/nirvana/categories/webpack" rel="section">webpack</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="nirvana"
      src="/nirvana/images/headphoto.jpeg">
  <p class="site-author-name" itemprop="name">nirvana</p>
  <div class="site-description" itemprop="description">个人学习笔记</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/nirvana/archives">
          <span class="site-state-item-count">249</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">分类</span>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/lzhwWeb" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;lzhwWeb" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
  </div>



        </div>
      </div>
        <div class="back-to-top animated" role="button">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lzhwweb.github.io/nirvana/javascript/%E5%89%8D%E7%AB%AF/%E6%95%B0%E7%BB%84%E9%81%8D%E5%8E%86%E4%B8%8E%E5%B1%9E%E6%80%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/nirvana/images/headphoto.jpeg">
      <meta itemprop="name" content="nirvana">
      <meta itemprop="description" content="个人学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="涅槃快乐是金">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/nirvana/javascript/%E5%89%8D%E7%AB%AF/%E6%95%B0%E7%BB%84%E9%81%8D%E5%8E%86%E4%B8%8E%E5%B1%9E%E6%80%A7/" class="post-title-link" itemprop="url">数组遍历与属性</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-06-10 16:18:55 / 修改时间：17:02:25" itemprop="dateCreated datePublished" datetime="2021-06-10T16:18:55+08:00">2021-06-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/nirvana/categories/javascript/" itemprop="url" rel="index"><span itemprop="name">javascript</span></a>
        </span>
    </span>

  
    <span id="/nirvana/javascript/%E5%89%8D%E7%AB%AF/%E6%95%B0%E7%BB%84%E9%81%8D%E5%8E%86%E4%B8%8E%E5%B1%9E%E6%80%A7/" class="post-meta-item leancloud_visitors" data-flag-title="数组遍历与属性" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>虽然在 JavaScript 中数组是对象，但是没有好的理由去使用 <code>for in</code> 循环遍历数组。 相反，有一些好的理由<strong>不去</strong>使用 <code>for in</code> 遍历数组。</p>
<p><strong>注意:</strong> JavaScript 中数组<strong>不是</strong> <em>关联数组</em>。 JavaScript 中只有<code>对象</code>来管理键值的对应关系。但是关联数组是<strong>保持</strong>顺序的，而对象<strong>不是</strong>。</p>
<p>由于 <code>for in</code> 循环会枚举原型链上的所有属性，唯一过滤这些属性的方式是使用 <a target="_blank" rel="noopener" href="http://bonsaiden.github.io/JavaScript-Garden/zh/#object.hasownproperty"><code>hasOwnProperty</code></a> 函数， 因此会比普通的 <code>for</code> 循环慢上好多倍。</p>
<blockquote>
<p><strong>注意:</strong> JavaScript 中数组<strong>不是</strong> <em>关联数组</em>。 JavaScript 中只有<code>对象</code>来管理键值的对应关系。但是关联数组是<strong>保持</strong>顺序的，而对象<strong>不是</strong>。</p>
</blockquote>
<h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p>为了达到遍历数组的最佳性能，推荐使用经典的 <code>for</code> 循环。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var list &#x3D; [1, 2, 3, 4, 5, ...... 100000000];</span><br><span class="line">for(var i &#x3D; 0, l &#x3D; list.length; i &lt; l; i++) &#123;</span><br><span class="line">    console.log(list[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码有一个处理，就是通过 <code>l = list.length</code> 来缓存数组的长度。</p>
<p>虽然 <code>length</code> 是数组的一个属性，但是在每次循环中访问它还是有性能开销。 <strong>可能</strong>最新的 JavaScript 引擎在这点上做了优化，但是我们没法保证自己的代码是否运行在这些最近的引擎之上。</p>
<p>实际上，不使用缓存数组长度的方式比缓存版本要慢很多。</p>
<h3 id="length-属性"><a href="#length-属性" class="headerlink" title="length 属性"></a><code>length</code> 属性</h3><p><code>length</code> 属性的 <em>getter</em> 方式会简单的返回数组的长度，而 <em>setter</em> 方式会<strong>截断</strong>数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var foo &#x3D; [1, 2, 3, 4, 5, 6];</span><br><span class="line">foo.length &#x3D; 3;</span><br><span class="line">foo; &#x2F;&#x2F; [1, 2, 3]</span><br><span class="line"></span><br><span class="line">foo.length &#x3D; 6;</span><br><span class="line">foo; &#x2F;&#x2F; [1, 2, 3]</span><br></pre></td></tr></table></figure>

<p> 在 Firebug 中查看此时 <code>foo</code> 的值是： <code>[1, 2, 3, undefined, undefined, undefined]</code> 但是这个结果并不准确，如果你在 Chrome 的控制台查看 <code>foo</code> 的结果，你会发现是这样的： <code>[1, 2, 3]</code> 因为在 JavaScript 中 <code>undefined</code> 是一个变量，注意是变量不是关键字，因此上面两个结果的意义是完全不相同的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 为了验证，我们来执行下面代码，看序号 5 是否存在于 foo 中。</span><br><span class="line">5 in foo; &#x2F;&#x2F; 不管在 Firebug 或者 Chrome 都返回 false</span><br><span class="line">foo[5] &#x3D; undefined;</span><br><span class="line">5 in foo; &#x2F;&#x2F; 不管在 Firebug 或者 Chrome 都返回 true</span><br></pre></td></tr></table></figure>

<p>为 <code>length</code> 设置一个更小的值会截断数组，但是增大 <code>length</code> 属性值不会对数组产生影响。</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>为了更好的性能，推荐使用普通的 <code>for</code> 循环并缓存数组的 <code>length</code> 属性。 使用 <code>for in</code> 遍历数组被认为是不好的代码习惯并倾向于产生错误和导致性能问题。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lzhwweb.github.io/nirvana/javascript/%E5%89%8D%E7%AB%AF/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/nirvana/images/headphoto.jpeg">
      <meta itemprop="name" content="nirvana">
      <meta itemprop="description" content="个人学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="涅槃快乐是金">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/nirvana/javascript/%E5%89%8D%E7%AB%AF/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/" class="post-title-link" itemprop="url">类型转换</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-06-10 16:18:16 / 修改时间：17:02:25" itemprop="dateCreated datePublished" datetime="2021-06-10T16:18:16+08:00">2021-06-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/nirvana/categories/javascript/" itemprop="url" rel="index"><span itemprop="name">javascript</span></a>
        </span>
    </span>

  
    <span id="/nirvana/javascript/%E5%89%8D%E7%AB%AF/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/" class="post-meta-item leancloud_visitors" data-flag-title="类型转换" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.6k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>JavaScript 是<em>弱类型</em>语言，所以会在<strong>任何</strong>可能的情况下应用<em>强制类型转换</em>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 下面的比较结果是：true</span><br><span class="line">new Number(10) &#x3D;&#x3D; 10; &#x2F;&#x2F; Number.toString() 返回的字符串被再次转换为数字</span><br><span class="line"></span><br><span class="line">10 &#x3D;&#x3D; &#39;10&#39;;           &#x2F;&#x2F; 字符串被转换为数字</span><br><span class="line">10 &#x3D;&#x3D; &#39;+10 &#39;;         &#x2F;&#x2F; 同上</span><br><span class="line">10 &#x3D;&#x3D; &#39;010&#39;;          &#x2F;&#x2F; 同上 </span><br><span class="line">isNaN(null) &#x3D;&#x3D; false; &#x2F;&#x2F; null 被转换为数字 0</span><br><span class="line">                      &#x2F;&#x2F; 0 当然不是一个 NaN（译者注：否定之否定）</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 下面的比较结果是：false</span><br><span class="line">10 &#x3D;&#x3D; 010;</span><br><span class="line">10 &#x3D;&#x3D; &#39;-10&#39;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>ES5 提示:</strong> 以 <code>0</code> 开头的数字字面值会被作为八进制数字解析。 而在 ECMAScript 5 严格模式下，这个特性被<strong>移除</strong>了。</p>
<p>为了避免上面复杂的强制类型转换，<strong>强烈</strong>推荐使用<code>严格的等于操作符</code>。 虽然这可以避免大部分的问题，但 JavaScript 的弱类型系统仍然会导致一些其它问题。</p>
<h3 id="内置类型的构造函数"><a href="#内置类型的构造函数" class="headerlink" title="内置类型的构造函数"></a>内置类型的构造函数</h3><p>内置类型（比如 <code>Number</code> 和 <code>String</code>）的构造函数在被调用时，使用或者不使用 <code>new</code> 的结果完全不同。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">new Number(10) &#x3D;&#x3D;&#x3D; 10;     &#x2F;&#x2F; False, 对象与数字的比较</span><br><span class="line">Number(10) &#x3D;&#x3D;&#x3D; 10;         &#x2F;&#x2F; True, 数字与数字的比较</span><br><span class="line">new Number(10) + 0 &#x3D;&#x3D;&#x3D; 10; &#x2F;&#x2F; True, 由于隐式的类型转换</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用内置类型 <code>Number</code> 作为构造函数将会创建一个新的 <code>Number</code> 对象， 而在不使用 <code>new</code> 关键字的 <code>Number</code> 函数更像是一个数字转换器。</p>
<p>另外，在比较中引入对象的字面值将会导致更加复杂的强制类型转换。</p>
<p>最好的选择是把要比较的值<strong>显式</strong>的转换为三种可能的类型之一。</p>
<h3 id="转换为字符串"><a href="#转换为字符串" class="headerlink" title="转换为字符串"></a>转换为字符串</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#39;&#39; + 10 &#x3D;&#x3D;&#x3D; &#39;10&#39;; &#x2F;&#x2F; true</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>将一个值加上空字符串可以轻松转换为字符串类型。</p>
<h3 id="转换为数字"><a href="#转换为数字" class="headerlink" title="转换为数字"></a>转换为数字</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+&#39;10&#39; &#x3D;&#x3D;&#x3D; 10; &#x2F;&#x2F; true</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用<strong>一元</strong>的加号操作符，可以把字符串转换为数字。</p>
<p>字符串转换为数字的常用方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+&#39;010&#39; &#x3D;&#x3D;&#x3D; 10</span><br><span class="line">Number(&#39;010&#39;) &#x3D;&#x3D;&#x3D; 10</span><br><span class="line">parseInt(&#39;010&#39;, 10) &#x3D;&#x3D;&#x3D; 10  &#x2F;&#x2F; 用来转换为整数</span><br><span class="line"></span><br><span class="line">+&#39;010.2&#39; &#x3D;&#x3D;&#x3D; 10.2</span><br><span class="line">Number(&#39;010.2&#39;) &#x3D;&#x3D;&#x3D; 10.2</span><br><span class="line">parseInt(&#39;010.2&#39;, 10) &#x3D;&#x3D;&#x3D; 10</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="转换为布尔型"><a href="#转换为布尔型" class="headerlink" title="转换为布尔型"></a>转换为布尔型</h3><p>通过使用 <strong>否</strong> 操作符两次，可以把一个值转换为布尔型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">!!&#39;foo&#39;;   &#x2F;&#x2F; true</span><br><span class="line">!!&#39;&#39;;      &#x2F;&#x2F; false</span><br><span class="line">!!&#39;0&#39;;     &#x2F;&#x2F; true</span><br><span class="line">!!&#39;1&#39;;     &#x2F;&#x2F; true</span><br><span class="line">!!&#39;-1&#39;     &#x2F;&#x2F; true</span><br><span class="line">!!&#123;&#125;;      &#x2F;&#x2F; true</span><br><span class="line">!!true;    &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lzhwweb.github.io/nirvana/javascript/%E5%89%8D%E7%AB%AF/%E5%AF%B9%E8%B1%A1%E4%BD%BF%E7%94%A8%E5%92%8C%E5%B1%9E%E6%80%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/nirvana/images/headphoto.jpeg">
      <meta itemprop="name" content="nirvana">
      <meta itemprop="description" content="个人学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="涅槃快乐是金">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/nirvana/javascript/%E5%89%8D%E7%AB%AF/%E5%AF%B9%E8%B1%A1%E4%BD%BF%E7%94%A8%E5%92%8C%E5%B1%9E%E6%80%A7/" class="post-title-link" itemprop="url">对象使用和属性</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-06-10 16:17:08 / 修改时间：17:02:24" itemprop="dateCreated datePublished" datetime="2021-06-10T16:17:08+08:00">2021-06-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/nirvana/categories/javascript/" itemprop="url" rel="index"><span itemprop="name">javascript</span></a>
        </span>
    </span>

  
    <span id="/nirvana/javascript/%E5%89%8D%E7%AB%AF/%E5%AF%B9%E8%B1%A1%E4%BD%BF%E7%94%A8%E5%92%8C%E5%B1%9E%E6%80%A7/" class="post-meta-item leancloud_visitors" data-flag-title="对象使用和属性" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.7k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>JavaScript 中所有变量都可以当作对象使用，除了两个例外 <code>null</code>和 <code>undefined</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">false.toString(); &#x2F;&#x2F; &#39;false&#39;</span><br><span class="line">[1, 2, 3].toString(); &#x2F;&#x2F; &#39;1,2,3&#39;</span><br><span class="line"></span><br><span class="line">function Foo()&#123;&#125;</span><br><span class="line">Foo.bar &#x3D; 1;</span><br><span class="line">Foo.bar; &#x2F;&#x2F; 1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>一个常见的误解是数字的字面值（literal）不能当作对象使用。这是因为 JavaScript 解析器的一个错误， 它试图将<em>点操作符</em>解析为浮点数字面值的一部分。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2.toString(); &#x2F;&#x2F; 出错：SyntaxError</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>有很多变通方法可以让数字的字面值看起来像对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2..toString(); &#x2F;&#x2F; 第二个点号可以正常解析</span><br><span class="line">2 .toString(); &#x2F;&#x2F; 注意点号前面的空格</span><br><span class="line">(2).toString(); &#x2F;&#x2F; 2先被计算</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="对象作为数据类型"><a href="#对象作为数据类型" class="headerlink" title="对象作为数据类型"></a>对象作为数据类型</h3><p>JavaScript 的对象可以作为<em>哈希表</em>使用，主要用来保存命名的键与值的对应关系。</p>
<p>使用对象的字面语法 - <code>&#123;&#125;</code> - 可以创建一个简单对象。这个新创建的对象从 <code>Object.prototype</code> 继承下面，没有任何<code>自定义属性</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var foo &#x3D; &#123;&#125;; &#x2F;&#x2F; 一个空对象</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 一个新对象，拥有一个值为12的自定义属性&#39;test&#39;</span><br><span class="line">var bar &#x3D; &#123;test: 12&#125;; </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="访问属性"><a href="#访问属性" class="headerlink" title="访问属性"></a>访问属性</h3><p>有两种方式来访问对象的属性，点操作符或者中括号操作符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var foo &#x3D; &#123;name: &#39;kitten&#39;&#125;</span><br><span class="line">foo.name; &#x2F;&#x2F; kitten</span><br><span class="line">foo[&#39;name&#39;]; &#x2F;&#x2F; kitten</span><br><span class="line"></span><br><span class="line">var get &#x3D; &#39;name&#39;;</span><br><span class="line">foo[get]; &#x2F;&#x2F; kitten</span><br><span class="line"></span><br><span class="line">foo.1234; &#x2F;&#x2F; SyntaxError</span><br><span class="line">foo[&#39;1234&#39;]; &#x2F;&#x2F; works</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>两种语法是等价的，但是中括号操作符在下面两种情况下依然有效</p>
<ul>
<li>  动态设置属性</li>
<li>  属性名不是一个有效的变量名：**比如属性名中包含空格，或者属性名是 JS 的关键词）</li>
</ul>
<p>在 <code>JSLint</code>语法检测工具中，点操作符是推荐做法。</p>
<h3 id="删除属性"><a href="#删除属性" class="headerlink" title="删除属性"></a>删除属性</h3><p>删除属性的唯一方法是使用 <code>delete</code> 操作符；设置属性为 <code>undefined</code> 或者 <code>null</code> 并不能真正的删除属性， 而<strong>仅仅</strong>是移除了属性和值的关联。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; &#123;</span><br><span class="line">    bar: 1,</span><br><span class="line">    foo: 2,</span><br><span class="line">    baz: 3</span><br><span class="line">&#125;;</span><br><span class="line">obj.bar &#x3D; undefined;</span><br><span class="line">obj.foo &#x3D; null;</span><br><span class="line">delete obj.baz;</span><br><span class="line"></span><br><span class="line">for(var i in obj) &#123;</span><br><span class="line">    if (obj.hasOwnProperty(i)) &#123;</span><br><span class="line">        console.log(i, &#39;&#39; + obj[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面的输出结果有 <code>bar undefined</code> 和 <code>foo null</code> - 只有 <code>baz</code> 被真正的删除了，所以从输出结果中消失。</p>
<h3 id="属性名的语法"><a href="#属性名的语法" class="headerlink" title="属性名的语法"></a>属性名的语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var test &#x3D; &#123;</span><br><span class="line">    &#39;case&#39;: &#39;I am a keyword so I must be notated as a string&#39;,</span><br><span class="line">    delete: &#39;I am a keyword too so me&#39; &#x2F;&#x2F; 出错：SyntaxError</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对象的属性名可以使用字符串或者普通字符声明。但是由于 JavaScript 解析器的另一个错误设计， 上面的第二种声明方式在 ECMAScript 5 之前会抛出 <code>SyntaxError</code> 的错误。</p>
<p>这个错误的原因是 <code>delete</code> 是 JavaScript 语言的一个<em>关键词</em>；因此为了在更低版本的 JavaScript 引擎下也能正常运行， 必须使用<em>字符串字面值</em>声明方式。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lzhwweb.github.io/nirvana/javascript/%E5%89%8D%E7%AB%AF/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8eval/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/nirvana/images/headphoto.jpeg">
      <meta itemprop="name" content="nirvana">
      <meta itemprop="description" content="个人学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="涅槃快乐是金">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/nirvana/javascript/%E5%89%8D%E7%AB%AF/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8eval/" class="post-title-link" itemprop="url">为什么不要使用 eval</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-06-10 16:16:29 / 修改时间：17:02:24" itemprop="dateCreated datePublished" datetime="2021-06-10T16:16:29+08:00">2021-06-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/nirvana/categories/javascript/" itemprop="url" rel="index"><span itemprop="name">javascript</span></a>
        </span>
    </span>

  
    <span id="/nirvana/javascript/%E5%89%8D%E7%AB%AF/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8eval/" class="post-meta-item leancloud_visitors" data-flag-title="为什么不要使用 eval" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.1k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><code>eval</code> 函数会在当前作用域中执行一段 JavaScript 代码字符串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var foo &#x3D; 1;</span><br><span class="line">function test() &#123;</span><br><span class="line">    var foo &#x3D; 2;</span><br><span class="line">    eval(&#39;foo &#x3D; 3&#39;);</span><br><span class="line">    return foo;</span><br><span class="line">&#125;</span><br><span class="line">test(); &#x2F;&#x2F; 3</span><br><span class="line">foo; &#x2F;&#x2F; 1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>但是 <code>eval</code> 只在被<strong>直接</strong>调用并且调用函数就是 <code>eval</code> 本身时，才在当前作用域中执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var foo &#x3D; 1;</span><br><span class="line">function test() &#123;</span><br><span class="line">    var foo &#x3D; 2;</span><br><span class="line">    var bar &#x3D; eval;</span><br><span class="line">    bar(&#39;foo &#x3D; 3&#39;);</span><br><span class="line">    return foo;</span><br><span class="line">&#125;</span><br><span class="line">test(); &#x2F;&#x2F; 2</span><br><span class="line">foo; &#x2F;&#x2F; 3</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面的代码等价于在全局作用域中调用 <code>eval</code>，和下面两种写法效果一样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 写法一：直接调用全局作用域下的 foo 变量</span><br><span class="line">var foo &#x3D; 1;</span><br><span class="line">function test() &#123;</span><br><span class="line">    var foo &#x3D; 2;</span><br><span class="line">    window.foo &#x3D; 3;</span><br><span class="line">    return foo;</span><br><span class="line">&#125;</span><br><span class="line">test(); &#x2F;&#x2F; 2</span><br><span class="line">foo; &#x2F;&#x2F; 3</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 写法二：使用 call 函数修改 eval 执行的上下文为全局作用域</span><br><span class="line">var foo &#x3D; 1;</span><br><span class="line">function test() &#123;</span><br><span class="line">    var foo &#x3D; 2;</span><br><span class="line">    eval.call(window, &#39;foo &#x3D; 3&#39;);</span><br><span class="line">    return foo;</span><br><span class="line">&#125;</span><br><span class="line">test(); &#x2F;&#x2F; 2</span><br><span class="line">foo; &#x2F;&#x2F; 3</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在<strong>任何情况下</strong>我们都应该避免使用 <code>eval</code> 函数。99.9% 使用 <code>eval</code> 的场景都有<strong>不使用</strong> <code>eval</code> 的解决方案。</p>
<h3 id="伪装的-eval"><a href="#伪装的-eval" class="headerlink" title="伪装的 eval"></a>伪装的 <code>eval</code></h3><p>定时函数 <code>setTimeout</code> 和 <code>setInterval</code> 都可以接受字符串作为它们的第一个参数。 这个字符串<strong>总是</strong>在全局作用域中执行，因此 <code>eval</code> 在这种情况下没有被直接调用。</p>
<h3 id="安全问题"><a href="#安全问题" class="headerlink" title="安全问题"></a>安全问题</h3><p><code>eval</code> 也存在安全问题，因为它会执行<strong>任意</strong>传给它的代码， 在代码字符串未知或者是来自一个不信任的源时，绝对不要使用 <code>eval</code> 函数。</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>绝对不要使用 <code>eval</code>，任何使用它的代码都会在它的工作方式，性能和安全性方面受到质疑。 如果一些情况必须使用到 <code>eval</code> 才能正常工作，首先它的设计会受到质疑，这<strong>不应该</strong>是首选的解决方案， 一个更好的不使用 <code>eval</code> 的解决方案应该得到充分考虑并优先采用。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lzhwweb.github.io/nirvana/javascript/%E5%89%8D%E7%AB%AF/Array%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/nirvana/images/headphoto.jpeg">
      <meta itemprop="name" content="nirvana">
      <meta itemprop="description" content="个人学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="涅槃快乐是金">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/nirvana/javascript/%E5%89%8D%E7%AB%AF/Array%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/" class="post-title-link" itemprop="url">Array 构造函数</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-06-10 16:15:42 / 修改时间：17:02:25" itemprop="dateCreated datePublished" datetime="2021-06-10T16:15:42+08:00">2021-06-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/nirvana/categories/javascript/" itemprop="url" rel="index"><span itemprop="name">javascript</span></a>
        </span>
    </span>

  
    <span id="/nirvana/javascript/%E5%89%8D%E7%AB%AF/Array%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/" class="post-meta-item leancloud_visitors" data-flag-title="Array 构造函数" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>794</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>由于 <code>Array</code> 的构造函数在如何处理参数时有点模棱两可，因此总是推荐使用数组的字面语法 - <code>[]</code> - 来创建数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3]; &#x2F;&#x2F; 结果: [1, 2, 3]</span><br><span class="line">new Array(1, 2, 3); &#x2F;&#x2F; 结果: [1, 2, 3]</span><br><span class="line"></span><br><span class="line">[3]; &#x2F;&#x2F; 结果: [3]</span><br><span class="line">new Array(3); &#x2F;&#x2F; 结果: [] </span><br><span class="line">new Array(&#39;3&#39;) &#x2F;&#x2F; 结果: [&#39;3&#39;]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 因此下面的代码将会使人很迷惑</span><br><span class="line">new Array(3, 4, 5); &#x2F;&#x2F; 结果: [3, 4, 5] </span><br><span class="line">new Array(3) &#x2F;&#x2F; 结果: []，此数组长度为 3</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里的模棱两可指的是数组的<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array">两种构造函数语法</a></p>
<p>由于只有一个参数传递到构造函数中（指的是 <code>new Array(3);</code> 这种调用方式），并且这个参数是数字，构造函数会返回一个 <code>length</code> 属性被设置为此参数的空数组。 需要特别注意的是，此时只有 <code>length</code> 属性被设置，真正的数组并没有生成。</p>
<p>在 Firebug 中，你会看到 <code>[undefined, undefined, undefined]</code>，这其实是不对的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var arr &#x3D; new Array(3);</span><br><span class="line">arr[1]; &#x2F;&#x2F; undefined</span><br><span class="line">1 in arr; &#x2F;&#x2F; false, 数组还没有生成</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这种优先于设置数组长度属性的做法只在少数几种情况下有用，比如需要循环字符串，可以避免 <code>for</code> 循环的麻烦。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">new Array(count + 1).join(stringToRepeat);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>new Array(3).join(&#39;#&#39;)</code> 将会返回 <code>##</code></p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>应该尽量避免使用数组构造函数创建新数组。推荐使用数组的字面语法。它们更加短小和简洁，因此增加了代码的可读性。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lzhwweb.github.io/nirvana/javascript/%E5%89%8D%E7%AB%AF/typeof%E6%93%8D%E4%BD%9C%E7%AC%A6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/nirvana/images/headphoto.jpeg">
      <meta itemprop="name" content="nirvana">
      <meta itemprop="description" content="个人学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="涅槃快乐是金">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/nirvana/javascript/%E5%89%8D%E7%AB%AF/typeof%E6%93%8D%E4%BD%9C%E7%AC%A6/" class="post-title-link" itemprop="url">typeof 操作符</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-06-10 16:14:59 / 修改时间：17:02:24" itemprop="dateCreated datePublished" datetime="2021-06-10T16:14:59+08:00">2021-06-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/nirvana/categories/javascript/" itemprop="url" rel="index"><span itemprop="name">javascript</span></a>
        </span>
    </span>

  
    <span id="/nirvana/javascript/%E5%89%8D%E7%AB%AF/typeof%E6%93%8D%E4%BD%9C%E7%AC%A6/" class="post-meta-item leancloud_visitors" data-flag-title="typeof 操作符" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><code>typeof</code> 操作符（和 <code>instanceof</code>一起）或许是 JavaScript 中最大的设计缺陷， 因为几乎不可能从它们那里得到想要的结果。</p>
<p>尽管 <code>instanceof</code> 还有一些极少数的应用场景，<code>typeof</code> 只有一个实际的应用（这个实际应用是用来检测一个对象是否已经定义或者是否已经赋值）， 而这个应用却<strong>不是</strong>用来检查对象的类型。</p>
<p><strong>注意:</strong> 由于 <code>typeof</code> 也可以像函数的语法被调用，比如 <code>typeof(obj)</code>，但这并不是一个函数调用。 那两个小括号只是用来计算一个表达式的值，这个返回值会作为 <code>typeof</code> 操作符的一个操作数。 实际上<strong>不存在</strong>名为 <code>typeof</code> 的函数。</p>
<h3 id="JavaScript-类型表格"><a href="#JavaScript-类型表格" class="headerlink" title="JavaScript 类型表格"></a>JavaScript 类型表格</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Value               Class      Type</span><br><span class="line">-------------------------------------</span><br><span class="line">&quot;foo&quot;               String     string</span><br><span class="line">new String(&quot;foo&quot;)   String     object</span><br><span class="line">1.2                 Number     number</span><br><span class="line">new Number(1.2)     Number     object</span><br><span class="line">true                Boolean    boolean</span><br><span class="line">new Boolean(true)   Boolean    object</span><br><span class="line">new Date()          Date       object</span><br><span class="line">new Error()         Error      object</span><br><span class="line">[1,2,3]             Array      object</span><br><span class="line">new Array(1, 2, 3)  Array      object</span><br><span class="line">new Function(&quot;&quot;)    Function   function</span><br><span class="line">&#x2F;abc&#x2F;g              RegExp     object (function in Nitro&#x2F;V8)</span><br><span class="line">new RegExp(&quot;meow&quot;)  RegExp     object (function in Nitro&#x2F;V8)</span><br><span class="line">&#123;&#125;                  Object     object</span><br><span class="line">new Object()        Object     object</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面表格中，<em>Type</em> 一列表示 <code>typeof</code> 操作符的运算结果。可以看到，这个值在大多数情况下都返回 “object”。</p>
<p><em>Class</em> 一列表示对象的内部属性 <code>[[Class]]</code> 的值。</p>
<p><strong>JavaScript 标准文档中定义:</strong> <code>[[Class]]</code> 的值只可能是下面字符串中的一个： <code>Arguments</code>, <code>Array</code>, <code>Boolean</code>, <code>Date</code>, <code>Error</code>, <code>Function</code>, <code>JSON</code>, <code>Math</code>, <code>Number</code>, <code>Object</code>, <code>RegExp</code>, <code>String</code>.</p>
<p>为了获取对象的 <code>[[Class]]</code>，我们需要使用定义在 <code>Object.prototype</code> 上的方法 <code>toString</code>。</p>
<h3 id="对象的类定义"><a href="#对象的类定义" class="headerlink" title="对象的类定义"></a>对象的类定义</h3><p>JavaScript 标准文档只给出了一种获取 <code>[[Class]]</code> 值的方法，那就是使用 <code>Object.prototype.toString</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function is(type, obj) &#123;</span><br><span class="line">    var clas &#x3D; Object.prototype.toString.call(obj).slice(8, -1);</span><br><span class="line">    return obj !&#x3D;&#x3D; undefined &amp;&amp; obj !&#x3D;&#x3D; null &amp;&amp; clas &#x3D;&#x3D;&#x3D; type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">is(&#39;String&#39;, &#39;test&#39;); &#x2F;&#x2F; true</span><br><span class="line">is(&#39;String&#39;, new String(&#39;test&#39;)); &#x2F;&#x2F; true</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面例子中，<code>Object.prototype.toString</code> 方法被调用，this 被设置为了需要获取 <code>[[Class]]</code> 值的对象。</p>
<p><code>Object.prototype.toString</code> 返回一种标准格式字符串，所以上例可以通过 <code>slice</code> 截取指定位置的字符串，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype.toString.call([])    &#x2F;&#x2F; &quot;[object Array]&quot;</span><br><span class="line">Object.prototype.toString.call(&#123;&#125;)    &#x2F;&#x2F; &quot;[object Object]&quot;</span><br><span class="line">Object.prototype.toString.call(2)    &#x2F;&#x2F; &quot;[object Number]&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>ES5 提示:</strong> 在 ECMAScript 5 中，为了方便，对 <code>null</code> 和 <code>undefined</code> 调用 <code>Object.prototype.toString</code> 方法， 其返回值由 <code>Object</code> 变成了 <code>Null</code> 和 <code>Undefined</code>。</p>
<h3 id="测试为定义变量"><a href="#测试为定义变量" class="headerlink" title="测试为定义变量"></a>测试为定义变量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">typeof foo !&#x3D;&#x3D; &#39;undefined&#39;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面代码会检测 <code>foo</code> 是否已经定义；如果没有定义而直接使用会导致 <code>ReferenceError</code> 的异常。 这是 <code>typeof</code> 唯一有用的地方。</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>为了检测一个对象的类型，强烈推荐使用 <code>Object.prototype.toString</code> 方法； 因为这是唯一一个可依赖的方式。正如上面表格所示，<code>typeof</code> 的一些返回值在标准文档中并未定义， 因此不同的引擎实现可能不同。</p>
<p>除非为了检测一个变量是否已经定义，我们应尽量避免使用 <code>typeof</code> 操作符。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lzhwweb.github.io/nirvana/javascript/%E5%89%8D%E7%AB%AF/%E5%8E%9F%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/nirvana/images/headphoto.jpeg">
      <meta itemprop="name" content="nirvana">
      <meta itemprop="description" content="个人学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="涅槃快乐是金">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/nirvana/javascript/%E5%89%8D%E7%AB%AF/%E5%8E%9F%E5%9E%8B/" class="post-title-link" itemprop="url">原型</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-06-10 16:14:15 / 修改时间：17:02:24" itemprop="dateCreated datePublished" datetime="2021-06-10T16:14:15+08:00">2021-06-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/nirvana/categories/javascript/" itemprop="url" rel="index"><span itemprop="name">javascript</span></a>
        </span>
    </span>

  
    <span id="/nirvana/javascript/%E5%89%8D%E7%AB%AF/%E5%8E%9F%E5%9E%8B/" class="post-meta-item leancloud_visitors" data-flag-title="原型" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>JavaScript 不包含传统的类继承模型，而是使用 <em>prototype</em> 原型模型。</p>
<p>虽然这经常被当作是 JavaScript 的缺点被提及，其实基于原型的继承模型比传统的类继承还要强大。 实现传统的类继承模型是很简单，但是实现 JavaScript 中的原型继承则要困难的多。 (It is for example fairly trivial to build a classic model on top of it, while the other way around is a far more difficult task.)</p>
<p>由于 JavaScript 是唯一一个被广泛使用的基于原型继承的语言，所以理解两种继承模式的差异是需要一定时间的。</p>
<p>第一个不同之处在于 JavaScript 使用<em>原型链</em>的继承方式。</p>
<p><strong>注意:</strong> 简单的使用 <code>Bar.prototype = Foo.prototype</code> 将会导致两个对象共享<strong>相同</strong>的原型。 因此，改变任意一个对象的原型都会影响到另一个对象的原型，在大多数情况下这不是希望的结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">function Foo() &#123;</span><br><span class="line">    this.value &#x3D; 42;</span><br><span class="line">&#125;</span><br><span class="line">Foo.prototype &#x3D; &#123;</span><br><span class="line">    method: function() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function Bar() &#123;&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 设置Bar的prototype属性为Foo的实例对象</span><br><span class="line">Bar.prototype &#x3D; new Foo();</span><br><span class="line">Bar.prototype.foo &#x3D; &#39;Hello World&#39;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 修正Bar.prototype.constructor为Bar本身</span><br><span class="line">Bar.prototype.constructor &#x3D; Bar;</span><br><span class="line"></span><br><span class="line">var test &#x3D; new Bar() &#x2F;&#x2F; 创建Bar的一个新实例</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 原型链</span><br><span class="line">test [Bar的实例]</span><br><span class="line">    Bar.prototype [Foo的实例] </span><br><span class="line">        &#123; foo: &#39;Hello World&#39; &#125;</span><br><span class="line">        Foo.prototype</span><br><span class="line">            &#123;method: ...&#125;;</span><br><span class="line">            Object.prototype</span><br><span class="line">                &#123;toString: ... &#x2F;* etc. *&#x2F;&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面的例子中，<code>test</code> 对象从 <code>Bar.prototype</code> 和 <code>Foo.prototype</code> 继承下来；因此， 它能访问 <code>Foo</code> 的原型方法 <code>method</code>。同时，它也能够访问<strong>那个</strong>定义在原型上的 <code>Foo</code> 实例属性 <code>value</code>。 需要注意的是 <code>new Bar()</code> <strong>不会</strong>创造出一个新的 <code>Foo</code> 实例，而是 重复使用它原型上的那个实例；因此，所有的 <code>Bar</code> 实例都会共享<strong>相同</strong>的 <code>value</code> 属性。</p>
<p><strong>注意:</strong> <strong>不要</strong>使用 <code>Bar.prototype = Foo</code>，因为这不会执行 <code>Foo</code> 的原型，而是指向函数 <code>Foo</code>。 因此原型链将会回溯到 <code>Function.prototype</code> 而不是 <code>Foo.prototype</code>，因此 <code>method</code> 将不会在 Bar 的原型链上。</p>
<h3 id="属性查找"><a href="#属性查找" class="headerlink" title="属性查找"></a>属性查找</h3><p>当查找一个对象的属性时，JavaScript 会<strong>向上</strong>遍历原型链，直到找到给定名称的属性为止。</p>
<p>到查找到达原型链的顶部 - 也就是 <code>Object.prototype</code> - 但是仍然没有找到指定的属性，就会返回 <a target="_blank" rel="noopener" href="http://bonsaiden.github.io/JavaScript-Garden/zh/#core.undefined">undefined</a>。</p>
<h3 id="原型属性"><a href="#原型属性" class="headerlink" title="原型属性"></a>原型属性</h3><p>当原型属性用来创建原型链时，可以把<strong>任何</strong>类型的值赋给它（prototype）。 然而将原子类型赋给 prototype 的操作将会被忽略。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function Foo() &#123;&#125;</span><br><span class="line">Foo.prototype &#x3D; 1; &#x2F;&#x2F; 无效</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>而将对象赋值给 prototype，正如上面的例子所示，将会动态的创建原型链。</p>
<h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>如果一个属性在原型链的上端，则对于查找时间将带来不利影响。特别的，试图获取一个不存在的属性将会遍历整个原型链。</p>
<p>并且，当使用 <code>for in</code>循环遍历对象的属性时，原型链上的<strong>所有</strong>属性都将被访问。</p>
<h3 id="扩展内置类型的原型"><a href="#扩展内置类型的原型" class="headerlink" title="扩展内置类型的原型"></a>扩展内置类型的原型</h3><p>一个错误特性被经常使用，那就是扩展 <code>Object.prototype</code> 或者其他内置类型的原型对象。</p>
<p>这种技术被称之为 monkey patching 并且会破坏<em>封装</em>。虽然它被广泛的应用到一些 JavaScript 类库中比如 Prototype, 但是我仍然不认为为内置类型添加一些<em>非标准</em>的函数是个好主意。</p>
<p>扩展内置类型的<strong>唯一</strong>理由是为了和新的 JavaScript 保持一致，比如 <code>Array.forEach</code>。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在写复杂的 JavaScript 应用之前，充分理解原型链继承的工作方式是每个 JavaScript 程序员<strong>必修</strong>的功课。 要提防原型链过长带来的性能问题，并知道如何通过缩短原型链来提高性能。 更进一步，绝对<strong>不要</strong>扩展内置类型的原型，除非是为了和新的 JavaScript 引擎兼容。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lzhwweb.github.io/nirvana/javascript/%E5%89%8D%E7%AB%AF/%E9%97%AD%E5%8C%85%E5%92%8C%E5%BC%95%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/nirvana/images/headphoto.jpeg">
      <meta itemprop="name" content="nirvana">
      <meta itemprop="description" content="个人学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="涅槃快乐是金">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/nirvana/javascript/%E5%89%8D%E7%AB%AF/%E9%97%AD%E5%8C%85%E5%92%8C%E5%BC%95%E7%94%A8/" class="post-title-link" itemprop="url">闭包和引用</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-06-10 16:13:30 / 修改时间：17:02:25" itemprop="dateCreated datePublished" datetime="2021-06-10T16:13:30+08:00">2021-06-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/nirvana/categories/javascript/" itemprop="url" rel="index"><span itemprop="name">javascript</span></a>
        </span>
    </span>

  
    <span id="/nirvana/javascript/%E5%89%8D%E7%AB%AF/%E9%97%AD%E5%8C%85%E5%92%8C%E5%BC%95%E7%94%A8/" class="post-meta-item leancloud_visitors" data-flag-title="闭包和引用" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.4k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>闭包是 JavaScript 一个非常重要的特性，这意味着当前作用域<strong>总是</strong>能够访问外部作用域中的变量。 因为 `函 是 JavaScript 中唯一拥有自身作用域的结构，因此闭包的创建依赖于函数。</p>
<h3 id="模拟私有变量"><a href="#模拟私有变量" class="headerlink" title="模拟私有变量"></a>模拟私有变量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function Counter(start) &#123;</span><br><span class="line">    var count &#x3D; start;</span><br><span class="line">    return &#123;</span><br><span class="line">        increment: function() &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        get: function() &#123;</span><br><span class="line">            return count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var foo &#x3D; Counter(4);</span><br><span class="line">foo.increment();</span><br><span class="line">foo.get(); &#x2F;&#x2F; 5</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里，<code>Counter</code> 函数返回两个闭包，函数 <code>increment</code> 和函数 <code>get</code>。 这两个函数都维持着 对外部作用域 <code>Counter</code> 的引用，因此总可以访问此作用域内定义的变量 <code>count</code>.</p>
<h3 id="为什么不可以在外部访问私有变量"><a href="#为什么不可以在外部访问私有变量" class="headerlink" title="为什么不可以在外部访问私有变量"></a>为什么不可以在外部访问私有变量</h3><p>因为 JavaScript 中不可以对作用域进行引用或赋值，因此没有办法在外部访问 <code>count</code> 变量。 唯一的途径就是通过那两个闭包。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var foo &#x3D; new Counter(4);</span><br><span class="line">foo.hack &#x3D; function() &#123;</span><br><span class="line">    count &#x3D; 1337;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面的代码<strong>不会</strong>改变定义在 <code>Counter</code> 作用域中的 <code>count</code> 变量的值，因为 <code>foo.hack</code> 没有 定义在那个<strong>作用域</strong>内。它将会创建或者覆盖<em>全局</em>变量 <code>count</code>。</p>
<h3 id="循环中的闭包"><a href="#循环中的闭包" class="headerlink" title="循环中的闭包"></a>循环中的闭包</h3><p>一个常见的错误出现在循环中使用闭包，假设我们需要在每次循环中调用循环序号</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for(var i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">    setTimeout(function() &#123;</span><br><span class="line">        console.log(i);  </span><br><span class="line">    &#125;, 1000);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面的代码不会输出数字 <code>0</code> 到 <code>9</code>，而是会输出数字 <code>10</code> 十次。</p>
<p>当 <code>console.log</code> 被调用的时候，<em>匿名</em>函数保持对外部变量 <code>i</code> 的引用，此时 <code>for</code>循环已经结束， <code>i</code> 的值被修改成了 <code>10</code>.</p>
<p>为了得到想要的结果，需要在每次循环中创建变量 <code>i</code> 的<strong>拷贝</strong>。</p>
<h3 id="避免引用错误"><a href="#避免引用错误" class="headerlink" title="避免引用错误"></a>避免引用错误</h3><p>为了正确的获得循环序号，最好使用 匿名包装器`其实就是我们通常说的自执行匿名函数）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for(var i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">    (function(e) &#123;</span><br><span class="line">        setTimeout(function() &#123;</span><br><span class="line">            console.log(e);  </span><br><span class="line">        &#125;, 1000);</span><br><span class="line">    &#125;)(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>外部的匿名函数会立即执行，并把 <code>i</code> 作为它的参数，此时函数内 <code>e</code> 变量就拥有了 <code>i</code> 的一个拷贝。</p>
<p>当传递给 <code>setTimeout</code> 的匿名函数执行时，它就拥有了对 <code>e</code> 的引用，而这个值是<strong>不会</strong>被循环改变的。</p>
<p>有另一个方法完成同样的工作，那就是从匿名包装器中返回一个函数。这和上面的代码效果一样。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for(var i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">    setTimeout((function(e) &#123;</span><br><span class="line">        return function() &#123;</span><br><span class="line">            console.log(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)(i), 1000)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lzhwweb.github.io/nirvana/javascript/%E5%89%8D%E7%AB%AF/arguments%E5%AF%B9%E8%B1%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/nirvana/images/headphoto.jpeg">
      <meta itemprop="name" content="nirvana">
      <meta itemprop="description" content="个人学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="涅槃快乐是金">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/nirvana/javascript/%E5%89%8D%E7%AB%AF/arguments%E5%AF%B9%E8%B1%A1/" class="post-title-link" itemprop="url">arguments 对象</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-06-10 16:12:36 / 修改时间：17:02:25" itemprop="dateCreated datePublished" datetime="2021-06-10T16:12:36+08:00">2021-06-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/nirvana/categories/javascript/" itemprop="url" rel="index"><span itemprop="name">javascript</span></a>
        </span>
    </span>

  
    <span id="/nirvana/javascript/%E5%89%8D%E7%AB%AF/arguments%E5%AF%B9%E8%B1%A1/" class="post-meta-item leancloud_visitors" data-flag-title="arguments 对象" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>JavaScript 中每个函数内都能访问一个特别变量 <code>arguments</code>。这个变量维护着所有传递到这个函数中的参数列表。</p>
<p><strong>注意:</strong> 由于 <code>arguments</code> 已经被定义为函数内的一个变量。 因此通过 <code>var</code> 关键字定义 <code>arguments</code> 或者将 <code>arguments</code> 声明为一个形式参数， 都将导致原生的 <code>arguments</code> 不会被创建。</p>
<p><code>arguments</code> 变量<strong>不是</strong>一个数组（<code>Array</code>）。 尽管在语法上它有数组相关的属性 <code>length</code>，但它不从 <code>Array.prototype</code> 继承，实际上它是一个对象（<code>Object</code>）。</p>
<p>因此，无法对 <code>arguments</code> 变量使用标准的数组方法，比如 <code>push</code>, <code>pop</code> 或者 <code>slice</code>。 虽然使用 <code>for</code> 循环遍历也是可以的，但是为了更好的使用数组方法，最好把它转化为一个真正的数组。</p>
<h3 id="转化为数组"><a href="#转化为数组" class="headerlink" title="转化为数组"></a>转化为数组</h3><p>下面的代码将会创建一个新的数组，包含所有 <code>arguments</code> 对象中的元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.slice.call(arguments);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个转化比较<strong>慢</strong>，在性能不好的代码中<strong>不推荐</strong>这种做法。</p>
<h3 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h3><p>下面是将参数从一个函数传递到另一个函数的推荐做法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">    bar.apply(null, arguments);</span><br><span class="line">&#125;</span><br><span class="line">function bar(a, b, c) &#123;</span><br><span class="line">    &#x2F;&#x2F; 干活</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>另一个技巧是同时使用 <code>call</code> 和 <code>apply</code>，创建一个快速的解绑定包装器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function Foo() &#123;&#125;</span><br><span class="line"></span><br><span class="line">Foo.prototype.method &#x3D; function(a, b, c) &#123;</span><br><span class="line">    console.log(this, a, b, c);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 创建一个解绑定的 &quot;method&quot;</span><br><span class="line">&#x2F;&#x2F; 输入参数为: this, arg1, arg2...argN</span><br><span class="line">Foo.method &#x3D; function() &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 结果: Foo.prototype.method.call(this, arg1, arg2... argN)</span><br><span class="line">    Function.call.apply(Foo.prototype.method, arguments);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面的 <code>Foo.method</code> 函数和下面代码的效果是一样的:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Foo.method &#x3D; function() &#123;</span><br><span class="line">    var args &#x3D; Array.prototype.slice.call(arguments);</span><br><span class="line">    Foo.prototype.method.apply(args[0], args.slice(1));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="自动更新"><a href="#自动更新" class="headerlink" title="自动更新"></a>自动更新</h3><p><code>arguments</code> 对象为其内部属性以及函数形式参数创建 <em>getter</em> 和 <em>setter</em> 方法。</p>
<p>因此，改变形参的值会影响到 <code>arguments</code> 对象的值，反之亦然。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function foo(a, b, c) &#123;</span><br><span class="line">    arguments[0] &#x3D; 2;</span><br><span class="line">    a; &#x2F;&#x2F; 2                                                           </span><br><span class="line"></span><br><span class="line">    b &#x3D; 4;</span><br><span class="line">    arguments[1]; &#x2F;&#x2F; 4</span><br><span class="line"></span><br><span class="line">    var d &#x3D; c;</span><br><span class="line">    d &#x3D; 9;</span><br><span class="line">    c; &#x2F;&#x2F; 3</span><br><span class="line">&#125;</span><br><span class="line">foo(1, 2, 3);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="性能真相"><a href="#性能真相" class="headerlink" title="性能真相"></a>性能真相</h3><p>不管它是否有被使用，<code>arguments</code> 对象总会被创建，除了两个特殊情况 - 作为局部变量声明和作为形式参数。</p>
<p><code>arguments</code> 的 <em>getters</em> 和 <em>setters</em> 方法总会被创建；因此使用 <code>arguments</code> 对性能不会有什么影响。 除非是需要对 <code>arguments</code> 对象的属性进行多次访问。</p>
<p><strong>ES5 提示:</strong> 这些 <em>getters</em> 和 <em>setters</em> 在严格模式下（strict mode）不会被创建。</p>
<p>在 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en/JavaScript/Strict_mode">MDC</a> 中对 <code>strict mode</code> 模式下 <code>arguments</code> 的描述有助于我们的理解，请看下面代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 阐述在 ES5 的严格模式下 &#96;arguments&#96; 的特性</span><br><span class="line">function f(a) &#123;</span><br><span class="line">  &quot;use strict&quot;;</span><br><span class="line">  a &#x3D; 42;</span><br><span class="line">  return [a, arguments[0]];</span><br><span class="line">&#125;</span><br><span class="line">var pair &#x3D; f(17);</span><br><span class="line">console.assert(pair[0] &#x3D;&#x3D;&#x3D; 42);</span><br><span class="line">console.assert(pair[1] &#x3D;&#x3D;&#x3D; 17);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然而，的确有一种情况会显著的影响现代 JavaScript 引擎的性能。这就是使用 <code>arguments.callee</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">    arguments.callee; &#x2F;&#x2F; do something with this function object</span><br><span class="line">    arguments.callee.caller; &#x2F;&#x2F; and the calling function object</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function bigLoop() &#123;</span><br><span class="line">    for(var i &#x3D; 0; i &lt; 100000; i++) &#123;</span><br><span class="line">        foo(); &#x2F;&#x2F; Would normally be inlined...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>foo</code> 不再是一个单纯的内联函数 <a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Inlining">inlining</a>（**<a target="_blank" rel="noopener" href="http://cnblogs.com/sanshi/">译者注</a>**：这里指的是解析器可以做内联处理）， 因为它需要知道它自己和它的调用者。 这不仅抵消了内联函数带来的性能提升，而且破坏了封装，因此现在函数可能要依赖于特定的上下文。</p>
<p>因此<strong>强烈</strong>建议大家<strong>不要</strong>使用 <code>arguments.callee</code> 和它的属性。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lzhwweb.github.io/nirvana/javascript/%E5%89%8D%E7%AB%AF/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/nirvana/images/headphoto.jpeg">
      <meta itemprop="name" content="nirvana">
      <meta itemprop="description" content="个人学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="涅槃快乐是金">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/nirvana/javascript/%E5%89%8D%E7%AB%AF/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/" class="post-title-link" itemprop="url">构造函数</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-06-10 11:17:49 / 修改时间：17:02:25" itemprop="dateCreated datePublished" datetime="2021-06-10T11:17:49+08:00">2021-06-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/nirvana/categories/javascript/" itemprop="url" rel="index"><span itemprop="name">javascript</span></a>
        </span>
    </span>

  
    <span id="/nirvana/javascript/%E5%89%8D%E7%AB%AF/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/" class="post-meta-item leancloud_visitors" data-flag-title="构造函数" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.4k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>JavaScript 中的构造函数和其它语言中的构造函数是不同的。 通过 <code>new</code> 关键字方式调用的函数都被认为是构造函数。</p>
<p>在构造函数内部 - 也就是被调用的函数内 - <code>this</code> 指向新创建的对象 <code>Object</code>。 这个<strong>新创建</strong>的对象的 <code>prototype</code>被指向到构造函数的 <code>prototype</code>。</p>
<p>如果被调用的函数没有显式的 <code>return</code> 表达式，则隐式的会返回 <code>this</code> 对象 - 也就是新创建的对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Foo() &#123;</span><br><span class="line">    this.bla &#x3D; 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.prototype.test &#x3D; function() &#123;</span><br><span class="line">    console.log(this.bla);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var test &#x3D; new Foo();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面代码把 <code>Foo</code> 作为构造函数调用，并设置新创建对象的 <code>prototype</code> 为 <code>Foo.prototype</code>。</p>
<p>显式的 <code>return</code> 表达式将会影响返回结果，但<strong>仅限</strong>于返回的是一个对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function Bar() &#123;</span><br><span class="line">    return 2;</span><br><span class="line">&#125;</span><br><span class="line">new Bar(); &#x2F;&#x2F; 返回新创建的对象</span><br><span class="line"></span><br><span class="line">function Test() &#123;</span><br><span class="line">    this.value &#x3D; 2;</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">        foo: 1</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">new Test(); &#x2F;&#x2F; 返回的对象</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>new Bar()</code> 返回的是新创建的对象，而不是数字的字面值 2。 因此 <code>new Bar().constructor === Bar</code>，但是如果返回的是数字对象，结果就不同了，如下所示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function Bar() &#123;</span><br><span class="line">    return new Number(2);</span><br><span class="line">&#125;</span><br><span class="line">new Bar().constructor &#x3D;&#x3D;&#x3D; Number</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>**这里得到的 <code>new Test()</code>是函数返回的对象，而不是通过<code>new</code>关键字新创建的对象，因此：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(new Test()).value &#x3D;&#x3D;&#x3D; undefined</span><br><span class="line">(new Test()).foo &#x3D;&#x3D;&#x3D; 1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果 <code>new</code> 被遗漏了，则函数<strong>不会</strong>返回新创建的对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function Foo() &#123;</span><br><span class="line">    this.bla &#x3D; 1; &#x2F;&#x2F; 获取设置全局参数</span><br><span class="line">&#125;</span><br><span class="line">Foo(); &#x2F;&#x2F; undefined</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>虽然上例在有些情况下也能正常运行，但是由于 JavaScript 中 <code>this</code>的工作原理， 这里的 <code>this</code> 指向<em>全局对象</em>。</p>
<h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>为了不使用 <code>new</code> 关键字，构造函数必须显式的返回一个值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function Bar() &#123;</span><br><span class="line">    var value &#x3D; 1;</span><br><span class="line">    return &#123;</span><br><span class="line">        method: function() &#123;</span><br><span class="line">            return value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Bar.prototype &#x3D; &#123;</span><br><span class="line">    foo: function() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">new Bar();</span><br><span class="line">Bar();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面两种对 <code>Bar</code> 函数的调用返回的值完全相同，一个新创建的拥有 <code>method</code> 属性的对象被返回， 其实这里创建了一个闭包。</p>
<p>还需要注意， <code>new Bar()</code> 并<strong>不会</strong>改变返回对象的原型（也就是返回对象的原型不会指向 <code>Bar.prototype</code>）。 因为构造函数的原型会被指向到刚刚创建的新对象，而这里的 <code>Bar</code> 没有把这个新对象返回：而是返回了一个包含 <code>method</code> 属性的自定义对象）。</p>
<p>在上面的例子中，使用或者不使用 <code>new</code> 关键字没有功能性的区别。</p>
<p>上面两种方式创建的对象不能访问 <code>Bar</code> 原型链上的属性，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var bar1 &#x3D; new Bar();</span><br><span class="line">typeof(bar1.method); &#x2F;&#x2F; &quot;function&quot;</span><br><span class="line">typeof(bar1.foo); &#x2F;&#x2F; &quot;undefined&quot;</span><br><span class="line"></span><br><span class="line">var bar2 &#x3D; Bar();</span><br><span class="line">typeof(bar2.method); &#x2F;&#x2F; &quot;function&quot;</span><br><span class="line">typeof(bar2.foo); &#x2F;&#x2F; &quot;undefined&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="通过工厂模式创建新对象"><a href="#通过工厂模式创建新对象" class="headerlink" title="通过工厂模式创建新对象"></a>通过工厂模式创建新对象</h3><p>我们常听到的一条忠告是<strong>不要</strong>使用 <code>new</code> 关键字来调用函数，因为如果忘记使用它就会导致错误。</p>
<p>为了创建新对象，我们可以创建一个工厂方法，并且在方法内构造一个新对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function Foo() &#123;</span><br><span class="line">    var obj &#x3D; &#123;&#125;;</span><br><span class="line">    obj.value &#x3D; &#39;blub&#39;;</span><br><span class="line"></span><br><span class="line">    var private &#x3D; 2;</span><br><span class="line">    obj.someMethod &#x3D; function(value) &#123;</span><br><span class="line">        this.value &#x3D; value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    obj.getPrivate &#x3D; function() &#123;</span><br><span class="line">        return private;</span><br><span class="line">    &#125;</span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>虽然上面的方式比起 <code>new</code> 的调用方式不容易出错，并且可以充分利用<code>私有变量</code>带来的便利， 但是随之而来的是一些不好的地方。</p>
<ol>
<li> 会占用更多的内存，因为新创建的对象<strong>不能</strong>共享原型上的方法。</li>
<li> 为了实现继承，工厂方法需要从另外一个对象拷贝所有属性，或者把一个对象作为新创建对象的原型。</li>
<li> 放弃原型链仅仅是因为防止遗漏 <code>new</code> 带来的问题，这似乎和语言本身的思想相违背。</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>虽然遗漏 <code>new</code> 关键字可能会导致问题，但这并<strong>不是</strong>放弃使用原型链的借口。 最终使用哪种方式取决于应用程序的需求，选择一种代码书写风格并<strong>坚持</strong>下去才是最重要的。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/nirvana/page/3/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/nirvana/">1</a><span class="space">&hellip;</span><a class="page-number" href="/nirvana/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/nirvana/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/nirvana/page/25/">25</a><a class="extend next" rel="next" href="/nirvana/page/5/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>


<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">nirvana</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">736k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">11:09</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/nirvana/js/utils.js"></script><script src="/nirvana/js/motion.js"></script><script src="/nirvana/js/next-boot.js"></script><script src="/nirvana/js/bookmark.js"></script>

  
<script src="/nirvana/js/local-search.js"></script>






  


<script>
  (function() {
    function leancloudSelector(url) {
      url = encodeURI(url);
      return document.getElementById(url).querySelector('.leancloud-visitors-count');
    }

    function addCount(Counter) {
      const visitors = document.querySelector('.leancloud_visitors');
      const url = decodeURI(visitors.id);
      const title = visitors.dataset.flagTitle;

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url })))
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            const counter = results[0];
            leancloudSelector(url).innerText = counter.time + 1;
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .catch(error => {
                console.error('Failed to save visitor count', error);
              });
          } else {
              leancloudSelector(url).innerText = 'Counter not initialized! More info at console err msg.';
              console.error('ATTENTION! LeanCloud counter has security bug, see how to solve it here: https://github.com/theme-next/hexo-leancloud-counter-security. \n However, you can still use LeanCloud without security, by setting `security` option to `false`.');
            
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    function showTime(Counter) {
      const visitors = document.querySelectorAll('.leancloud_visitors');
      const entries = [...visitors].map(element => {
        return decodeURI(element.id);
      });

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url: { '$in': entries } })))
        .then(response => response.json())
        .then(({ results }) => {
          for (let url of entries) {
            const target = results.find(item => item.url === url);
            leancloudSelector(url).innerText = target ? target.time : 0;
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    const { app_id, app_key, server_url } = {"enable":true,"app_id":"SPsNUvBhME7XmrjzCfHkUu3e-gzGzoHsz","app_key":"4TONafemiIzvJUwqLa7WveoL","server_url":"https://leancloud.cn","security":true,"betterPerformance":false};
    function fetchData(api_server) {
      const Counter = (method, url, data) => {
        return fetch(`${api_server}/1.1${url}`, {
          method,
          headers: {
            'X-LC-Id'     : app_id,
            'X-LC-Key'    : app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        if (CONFIG.hostname !== location.hostname) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    }

    const api_server = app_id.slice(-9) === '-MdYXbMMI' ? `https://${app_id.slice(0, 8).toLowerCase()}.api.lncldglobal.com` : server_url;

    if (api_server) {
      fetchData(api_server);
    } else {
      fetch('https://app-router.leancloud.cn/2/route?appId=' + app_id)
        .then(response => response.json())
        .then(({ api_server }) => {
          fetchData('https://' + api_server);
        });
    }
  })();
</script>



</body>
</html>
