<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
 <meta name="referrer" content="no-referrer"/>

  <link rel="apple-touch-icon" sizes="180x180" href="/nirvana/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/nirvana/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/nirvana/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/nirvana/images/logo.svg" color="#222">

<link rel="stylesheet" href="/nirvana/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.2/css/all.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"lzhwweb.github.io","root":"/nirvana/","images":"/nirvana/images","scheme":"Gemini","version":"8.2.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/nirvana/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}};
  </script>
<meta name="description" content="个人学习笔记">
<meta property="og:type" content="website">
<meta property="og:title" content="涅槃快乐是金">
<meta property="og:url" content="https://lzhwweb.github.io/nirvana/page/2/index.html">
<meta property="og:site_name" content="涅槃快乐是金">
<meta property="og:description" content="个人学习笔记">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="nirvana">
<meta property="article:tag" content="前端,javascript,node,git,webpack,css">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://lzhwweb.github.io/nirvana/page/2/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>
<title>涅槃快乐是金</title>
  




  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/nirvana/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">涅槃快乐是金</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/nirvana/" rel="section">首页</a></li>
        <li class="menu-item menu-item-git"><a href="/nirvana/categories/git" rel="section">git</a></li>
        <li class="menu-item menu-item-linux"><a href="/nirvana/categories/linux" rel="section">linux</a></li>
        <li class="menu-item menu-item-android"><a href="/nirvana/categories/android" rel="section">android</a></li>
        <li class="menu-item menu-item-随笔"><a href="/nirvana/categories/informal" rel="section">随笔</a></li>
        <li class="menu-item menu-item-mac"><a href="/nirvana/categories/mac" rel="section">mac</a></li>
        <li class="menu-item menu-item-react-native"><a href="/nirvana/categories/reactnative" rel="section">react-native</a></li>
        <li class="menu-item menu-item-算法"><a href="/nirvana/categories/algorithm" rel="section">算法</a></li>
        <li class="menu-item menu-item-读书笔记"><a href="/nirvana/categories/note" rel="section">读书笔记</a></li>
        <li class="menu-item menu-item-开发工具"><a href="/nirvana/categories/tool" rel="section">开发工具</a></li>
        <li class="menu-item menu-item-设计模式(ts)"><a href="/nirvana/categories/DesignPattern" rel="section">设计模式(TS)</a></li>
        <li class="menu-item menu-item-前端"><a href="/nirvana/categories/javascript" rel="section">前端</a></li>
        <li class="menu-item menu-item-webpack"><a href="/nirvana/categories/webpack" rel="section">webpack</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="nirvana"
      src="/nirvana/images/headphoto.jpeg">
  <p class="site-author-name" itemprop="name">nirvana</p>
  <div class="site-description" itemprop="description">个人学习笔记</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/nirvana/archives">
          <span class="site-state-item-count">249</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">分类</span>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/lzhwWeb" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;lzhwWeb" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
  </div>



        </div>
      </div>
        <div class="back-to-top animated" role="button">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lzhwweb.github.io/nirvana/javascript/%E5%89%8D%E7%AB%AF/%E4%B8%80%E6%96%87%E5%90%83%E9%80%8FReactSSR%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%90%8C%E6%9E%84%E6%B8%B2%E6%9F%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/nirvana/images/headphoto.jpeg">
      <meta itemprop="name" content="nirvana">
      <meta itemprop="description" content="个人学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="涅槃快乐是金">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/nirvana/javascript/%E5%89%8D%E7%AB%AF/%E4%B8%80%E6%96%87%E5%90%83%E9%80%8FReactSSR%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%90%8C%E6%9E%84%E6%B8%B2%E6%9F%93/" class="post-title-link" itemprop="url">一文吃透React SSR服务端同构渲染</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-06-10 16:41:24 / 修改时间：17:02:24" itemprop="dateCreated datePublished" datetime="2021-06-10T16:41:24+08:00">2021-06-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/nirvana/categories/javascript/" itemprop="url" rel="index"><span itemprop="name">javascript</span></a>
        </span>
    </span>

  
    <span id="/nirvana/javascript/%E5%89%8D%E7%AB%AF/%E4%B8%80%E6%96%87%E5%90%83%E9%80%8FReactSSR%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%90%8C%E6%9E%84%E6%B8%B2%E6%9F%93/" class="post-meta-item leancloud_visitors" data-flag-title="一文吃透React SSR服务端同构渲染" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>24k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>22 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="为什么要服务端渲染-ssr"><a href="#为什么要服务端渲染-ssr" class="headerlink" title="为什么要服务端渲染(ssr)"></a>为什么要服务端渲染(ssr)</h1><p>至于为什么要服务端渲染，我相信大家都有所闻，而且每个人都能说出几点来。</p>
<h2 id="首屏等待"><a href="#首屏等待" class="headerlink" title="首屏等待"></a>首屏等待</h2><p>在 SPA 模式下，所有的数据请求和 Dom 渲染都在浏览器端完成，所以当我们第一次访问页面的时候很可能会存在“白屏”等待，而服务端渲染所有数据请求和 html内容已在服务端处理完成，浏览器收到的是完整的 html 内容，可以更快的看到渲染内容，在服务端完成数据请求肯定是要比在浏览器端效率要高的多。</p>
<h2 id="没考虑seo的感受"><a href="#没考虑seo的感受" class="headerlink" title="没考虑seo的感受"></a>没考虑seo的感受</h2><p>有些网站的流量来源主要还是靠搜索引擎，所以网站的 seo 还是很重要的，而 SPA 模式对搜索引擎不够友好，要想彻底解决这个问题只能采用服务端直出。改变不了别人（搜索yinqing），只能改变自己。</p>
<h2 id="SSR-SPA-体验升级"><a href="#SSR-SPA-体验升级" class="headerlink" title="SSR + SPA 体验升级"></a>SSR + SPA 体验升级</h2><p>只实现 SSR 其实没啥意义，技术上没有任何发展和进步，否则 SPA 技术就不会出现。但是单纯的 SPA又不够完美，所以最好的方案就是这两种体验和技术的结合，第一次访问页面是服务端渲染，基于第一次访问后续的交互就是 SPA 的效果和体验，还不影响SEO 效果，这就有点完美了。单纯实现 ssr 很简单，毕竟这是传统技术，也不分语言，随便用 php 、jsp、asp、node 等都可以实现。但是要实现两种技术的结合，同时可以最大限度的重用代码（同构），减少开发维护成本，那就需要采用 react 或者 vue等前端框架相结合 node (ssr) 来实现。</p>
<p>本文主要说 React SSR 技术 ,当然 vue 也一样，只是技术栈不同而已。</p>
<h1 id="核心原理"><a href="#核心原理" class="headerlink" title="核心原理"></a>核心原理</h1><p>整体来说 react 服务端渲染原理不复杂，其中最核心的内容就是同构。</p>
<p>node server 接收客户端请求，得到当前的req url path,然后在已有的路由表内查找到对应的组件，拿到需要请求的数据，将数据作为 props、context或者store 形式传入组件，然后基于 react 内置的服务端渲染api renderToString() or renderToNodeStream() 把组件渲染为 html字符串或者 stream 流, 在把最终的 html 进行输出前需要将数据注入到浏览器端(注水)，server 输出(response)后浏览器端可以得到数据(脱水)，浏览器开始进行渲染和节点对比，然后执行组件的componentDidMount 完成组件内事件绑定和一些交互，浏览器重用了服务端输出的 html 节点，整个流程结束。</p>
<p>技术点确实不少，但更多的是架构和工程层面的，需要把各个知识点进行链接和整合。这里放一个架构图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-ba28fc3e201b3ca0.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<h1 id="react-ssr"><a href="#react-ssr" class="headerlink" title="react ssr"></a>react ssr</h1><h2 id="从-ejs-开始"><a href="#从-ejs-开始" class="headerlink" title="从 ejs 开始"></a>从 ejs 开始</h2><p>实现 ssr 很简单，先看一个 node ejs的栗子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; index.html</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">   &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">   &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;</span><br><span class="line">   &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;ie&#x3D;edge&quot;&gt;</span><br><span class="line">   &lt;title&gt;react ssr &lt;%&#x3D; title %&gt;&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">   &lt;%&#x3D;  data %&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> &#x2F;&#x2F;node ssr</span><br><span class="line"> const ejs &#x3D; require(&#39;ejs&#39;);</span><br><span class="line"> const http &#x3D; require(&#39;http&#39;);</span><br><span class="line"></span><br><span class="line">http.createServer((req, res) &#x3D;&gt; &#123;</span><br><span class="line">    if (req.url &#x3D;&#x3D;&#x3D; &#39;&#x2F;&#39;) &#123;</span><br><span class="line">        res.writeHead(200, &#123;</span><br><span class="line">            &#39;Content-Type&#39;: &#39;text&#x2F;html&#39; </span><br><span class="line">        &#125;);</span><br><span class="line">        &#x2F;&#x2F; 渲染文件 index.ejs</span><br><span class="line">        ejs.renderFile(&#39;.&#x2F;views&#x2F;index.ejs&#39;, &#123;</span><br><span class="line">            title: &#39;react ssr&#39;, </span><br><span class="line">            data: &#39;首页&#39;&#125;, </span><br><span class="line">            (err, data) &#x3D;&gt; &#123;</span><br><span class="line">            if (err ) &#123;</span><br><span class="line">                console.log(err);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                res.end(data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).listen(8080);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="jsx-到字符串"><a href="#jsx-到字符串" class="headerlink" title="jsx 到字符串"></a>jsx 到字符串</h2><p>上面我们结合 ejs模板引擎 ，实现了一个服务端渲染的输出，html 和 数据直接输出到客户端。参考以上，我们结合 react组件 来实现服务端渲染直出，使用 jsx 来代替 ejs，之前是在 html 里使用 ejs 来绑定数据，现在改写成使用jsx 来绑定数据,使用 react 内置 api 来把组件渲染为 html 字符串，其他没有差别。</p>
<p>为什么react 组件可以被转换为 html字符串呢？简单的说我们写的 jsx 看上去就像在写 html（其实写的是对象） 标签，其实经过编译后都会转换成React.createElement方法，最终会被转换成一个对象(虚拟DOM)，而且和平台无关，有了这个对象，想转换成什么那就看心情了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">const  React  &#x3D; require(&#39;react&#39;);</span><br><span class="line"></span><br><span class="line">const &#123; renderToString&#125;  &#x3D; require( &#39;react-dom&#x2F;server&#39;);</span><br><span class="line"></span><br><span class="line">const http &#x3D; require(&#39;http&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;组件</span><br><span class="line">class Index extends React.Component&#123;</span><br><span class="line">    constructor(props)&#123;</span><br><span class="line">        super(props);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render()&#123;</span><br><span class="line">        return &lt;h1&gt;&#123;this.props.data.title&#125;&lt;&#x2F;h1&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;模拟数据的获取</span><br><span class="line">const fetch &#x3D; function () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        title:&#39;react ssr&#39;,</span><br><span class="line">        data:[]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;服务</span><br><span class="line">http.createServer((req, res) &#x3D;&gt; &#123;</span><br><span class="line">    if (req.url &#x3D;&#x3D;&#x3D; &#39;&#x2F;&#39;) &#123;</span><br><span class="line">        res.writeHead(200, &#123;</span><br><span class="line">            &#39;Content-Type&#39;: &#39;text&#x2F;html&#39;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        const data &#x3D; fetch();</span><br><span class="line"></span><br><span class="line">        const html &#x3D; renderToString(&lt;Index data&#x3D;&#123;data&#125;&#x2F;&gt;);</span><br><span class="line">        res.end(html);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).listen(8080);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>ps</strong>:以上代码不能直接运行，需要结合babel 使用 @babel/preset-react 进行转换</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx babel script.js --out-file script-compiled.js --presets&#x3D;@babel&#x2F;preset-react</span><br></pre></td></tr></table></figure>

<h1 id="引出问题"><a href="#引出问题" class="headerlink" title="引出问题"></a>引出问题</h1><p>在上面非常简单的就是实现了 react ssr ,把jsx作为模板引擎，不要小看上面的一小段代码，他可以帮我们引出一系列的问题，这也是完整实现 react ssr 的基石。</p>
<ul>
<li>  双端路由如何维护？</li>
</ul>
<p>首先我们会发现我在 server 端定义了路由 ‘/‘，但是在 react SPA 模式下我们需要使用react-router来定义路由。那是不是就需要维护两套路由呢？</p>
<ul>
<li>  获取数据的方法和逻辑写在哪里？</li>
</ul>
<p>发现数据获取的fetch 写的独立的方法，和组件没有任何关联，我们更希望的是每个路由都有自己的 fetch 方法。</p>
<ul>
<li>  服务端 html 节点无法重用</li>
</ul>
<p>虽然组件在服务端得到了数据，也能渲染到浏览器内，但是当浏览器端进行组件渲染的时候直出的内容会一闪而过消失。</p>
<p>好了，问题有了，接下来我们就一步一步的来解决这些问题。</p>
<h1 id="同构才是核心"><a href="#同构才是核心" class="headerlink" title="同构才是核心"></a>同构才是核心</h1><p>react ssr 的核心就是同构，没有同构的 ssr 是没有意义的。</p>
<p>所谓同构就是采用一套代码，构建双端（server 和 client）逻辑，最大限度的重用代码，不用维护两套代码。而传统的服务端渲染是无法做到的，react 的出现打破了这个瓶颈，并且现在已经得到了比较广泛的应用。</p>
<h2 id="路由同构"><a href="#路由同构" class="headerlink" title="路由同构"></a>路由同构</h2><p>双端使用同一套路由规则，node server 通过req url path 进行组件的查找，得到需要渲染的组件。</p>
<p>//组件和路由配置 ，供双端使用 routes-config.js</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Detail extends React.Component&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return &lt;div&gt;detail&lt;&#x2F;div&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Index extends React.Component &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return &lt;div&gt;index&lt;&#x2F;div&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const routes &#x3D; [</span><br><span class="line">            &#123;</span><br><span class="line">                path: &quot;&#x2F;&quot;,</span><br><span class="line">                exact: true,</span><br><span class="line">                component: Home</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                path: &#39;&#x2F;detail&#39;, exact: true,</span><br><span class="line">                component:Detail,</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                path: &#39;&#x2F;detail&#x2F;:a&#x2F;:b&#39;, exact: true,</span><br><span class="line">                component: Detail</span><br><span class="line">            &#125; </span><br><span class="line">];</span><br><span class="line">&#x2F;&#x2F;导出路由表</span><br><span class="line">export default routes;</span><br></pre></td></tr></table></figure>

<p>//客户端 路由组件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import routes from &#39;.&#x2F;routes-config.js&#39;;</span><br><span class="line">function App()&#123;</span><br><span class="line">    return (</span><br><span class="line">        &lt;Layout&gt;</span><br><span class="line">            &lt;Switch&gt;</span><br><span class="line">                        &#123;</span><br><span class="line">                            routes.map((item,index)&#x3D;&gt;&#123;</span><br><span class="line">                                return &lt;Route path&#x3D;&#123;item.path&#125; key&#x3D;&#123;index&#125; exact&#x3D;&#123;item.exact&#125; render&#x3D;&#123;item.component&#125;&gt;&lt;&#x2F;Route&gt;</span><br><span class="line">                            &#125;)</span><br><span class="line">                        &#125;</span><br><span class="line">            &lt;&#x2F;Switch&gt;</span><br><span class="line">        &lt;&#x2F;Layout&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line">export default App;</span><br></pre></td></tr></table></figure>

<p><strong>node server 进行组件查找</strong></p>
<p>路由匹配其实就是对 组件path 规则的匹配，如果规则不复杂可以自己写，如果情况很多种还是使用官方提供的库来完成。</p>
<p><strong>matchRoutes(routes, pathname)</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;引入官方库</span><br><span class="line">import &#123; matchRoutes &#125; from &quot;react-router-config&quot;;</span><br><span class="line">import routes from &#39;.&#x2F;routes-config.js&#39;;</span><br><span class="line"></span><br><span class="line">const path &#x3D; req.path;</span><br><span class="line"></span><br><span class="line">const branch &#x3D; matchRoutes(routes, path);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;得到要渲染的组件</span><br><span class="line">const Component &#x3D; branch[0].route.component;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;node server </span><br><span class="line">http.createServer((req, res) &#x3D;&gt; &#123;</span><br><span class="line"></span><br><span class="line">        const url &#x3D; req.url;</span><br><span class="line">        &#x2F;&#x2F;简单容错，排除图片等资源文件的请求</span><br><span class="line">        if(url.indexOf(&#39;.&#39;)&gt;-1) &#123; res.end(&#39;&#39;); return false;&#125;</span><br><span class="line"></span><br><span class="line">        res.writeHead(200, &#123;</span><br><span class="line">            &#39;Content-Type&#39;: &#39;text&#x2F;html&#39;</span><br><span class="line">        &#125;);</span><br><span class="line">        const data &#x3D; fetch();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;查找组件</span><br><span class="line">        const branch &#x3D;  matchRoutes(routes,url);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;得到组件</span><br><span class="line">        const Component &#x3D; branch[0].route.component;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;将组件渲染为 html 字符串</span><br><span class="line">        const html &#x3D; renderToString(&lt;Component data&#x3D;&#123;data&#125;&#x2F;&gt;);</span><br><span class="line"></span><br><span class="line">        res.end(html);</span><br><span class="line"></span><br><span class="line"> &#125;).listen(8080);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看下matchRoutes方法的返回值,其中route.component 就是 要渲染的组件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123; </span><br><span class="line"></span><br><span class="line">    route:</span><br><span class="line">        &#123; path: &#39;&#x2F;detail&#39;, exact: true, component: [Function: Detail] &#125;,</span><br><span class="line">    match:</span><br><span class="line">        &#123; path: &#39;&#x2F;detail&#39;, url: &#39;&#x2F;detail&#39;, isExact: true, params: &#123;&#125; &#125; </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>react-router-config 这个库由react 官方维护，功能是实现嵌套路由的查找，代码没有多少，有兴趣可以看看。</p>
<p><strong>文章走到这里，相信你已经知道了路由同构，所以上面的第一个问题 ： 【双端路由如何维护？】 解决了。</strong></p>
<h2 id="数据同构（预取同构）"><a href="#数据同构（预取同构）" class="headerlink" title="数据同构（预取同构）"></a>数据同构（预取同构）</h2><p>这里开始解决我们最开始发现的第二个问题 - 【获取数据的方法和逻辑写在哪里？】</p>
<p>数据预取同构，解决双端如何使用同一套数据请求方法来进行数据请求。</p>
<p>先说下流程，在查找到要渲染的组件后，需要预先得到此组件所需要的数据，然后将数据传递给组件后，再进行组件的渲染。</p>
<p>我们可以通过给组件定义静态方法来处理，组件内定义异步数据请求的方法也合情合理，同时声明为静态（static），在 server 端和组件内都也可以直接通过组件（function） 来进行访问。</p>
<p>比如 Index.getInitialProps</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;组件</span><br><span class="line">class Index extends React.Component&#123;</span><br><span class="line">    constructor(props)&#123;</span><br><span class="line">        super(props);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;数据预取方法  静态 异步 方法</span><br><span class="line">    static async  getInitialProps(opt) &#123;</span><br><span class="line">        const fetch1 &#x3D;await fetch(&#39;&#x2F;xxx.com&#x2F;a&#39;);</span><br><span class="line">        const fetch2 &#x3D; await fetch(&#39;&#x2F;xxx.com&#x2F;b&#39;);</span><br><span class="line"></span><br><span class="line">        return &#123;</span><br><span class="line">            res:[fetch1,fetch2]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render()&#123;</span><br><span class="line">        return &lt;h1&gt;&#123;this.props.data.title&#125;&lt;&#x2F;h1&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;node server </span><br><span class="line">http.createServer((req, res) &#x3D;&gt; &#123;</span><br><span class="line"></span><br><span class="line">        const url &#x3D; req.url;</span><br><span class="line">        if(url.indexOf(&#39;.&#39;)&gt;-1) &#123; res.end(&#39;&#39;); return false;&#125;</span><br><span class="line"></span><br><span class="line">        res.writeHead(200, &#123;</span><br><span class="line">            &#39;Content-Type&#39;: &#39;text&#x2F;html&#39;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;组件查找</span><br><span class="line">        const branch &#x3D;  matchRoutes(routes,url);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;得到组件</span><br><span class="line">        const Component &#x3D; branch[0].route.component;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;数据预取</span><br><span class="line">        const data &#x3D; Component.getInitialProps(branch[0].match.params);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;传入数据，渲染组件为 html 字符串</span><br><span class="line">        const html &#x3D; renderToString(&lt;Component data&#x3D;&#123;data&#125;&#x2F;&gt;);</span><br><span class="line"></span><br><span class="line">        res.end(html);</span><br><span class="line"></span><br><span class="line"> &#125;).listen(8080);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>另外还有在声明路由的时候把数据请求方法关联到路由中，比如定一个 loadData 方法，然后在查找到路由后就可以判断是否存在loadData这个方法。</p>
<p>看下参考代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const loadBranchData &#x3D; (location) &#x3D;&gt; &#123;</span><br><span class="line">  const branch &#x3D; matchRoutes(routes, location.pathname)</span><br><span class="line"></span><br><span class="line">  const promises &#x3D; branch.map((&#123; route, match &#125;) &#x3D;&gt; &#123;</span><br><span class="line">    return route.loadData</span><br><span class="line">      ? route.loadData(match)</span><br><span class="line">      : Promise.resolve(null)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  return Promise.all(promises)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面这种方式实现上没什么问题，但从职责划分的角度来说有些不够清晰，我还是比较喜欢直接通过组件来得到异步方法。</p>
<p>好了，到这里我们的第二个问题 - 【获取数据的方法和逻辑写在哪里？】 解决了。</p>
<h2 id="渲染同构"><a href="#渲染同构" class="headerlink" title="渲染同构"></a>渲染同构</h2><p>假设我们现在基于上面已经实现的代码，同时我们也使用 webpack 进行了配置，对代码进行了转换和打包，整个服务可以跑起来。</p>
<p>路由能够正确匹配，数据预取正常，服务端可以直出组件的 html ，浏览器加载 js 代码正常，查看网页源代码能看到 html 内容，好像我们的整个流程已经走完。</p>
<p>但是当浏览器端的 js 执行完成后，发现数据重新请求了，组件的重新渲染导致页面看上去有些闪烁。</p>
<p>这是因为在浏览器端，双端节点对比失败，导致组件重新渲染，也就是只有当服务端和浏览器端渲染的组件具有相同的props 和 DOM 结构的时候，组件才能只渲染一次。</p>
<p>刚刚我们实现了双端的数据预取同构，但是数据也仅仅是服务端有，浏览器端是没有这个数据，当客户端进行首次组件渲染的时候没有初始化的数据，渲染出的节点肯定和服务端直出的节点不同，导致组件重新渲染。</p>
<h3 id="数据注水"><a href="#数据注水" class="headerlink" title="数据注水"></a>数据注水</h3><p>在服务端将预取的数据注入到浏览器，使浏览器端可以访问到，客户端进行渲染前将数据传入对应的组件即可，这样就保证了props的一致。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F;node server  参考代码</span><br><span class="line">http.createServer((req, res) &#x3D;&gt; &#123;</span><br><span class="line"></span><br><span class="line">        const url &#x3D; req.url;</span><br><span class="line">        if(url.indexOf(&#39;.&#39;)&gt;-1) &#123; res.end(&#39;&#39;); return false;&#125;</span><br><span class="line"></span><br><span class="line">        res.writeHead(200, &#123;</span><br><span class="line">            &#39;Content-Type&#39;: &#39;text&#x2F;html&#39;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        console.log(url);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;查找组件</span><br><span class="line">        const branch &#x3D;  matchRoutes(routes,url);</span><br><span class="line">        &#x2F;&#x2F;得到组件</span><br><span class="line">        const Component &#x3D; branch[0].route.component;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;数据预取</span><br><span class="line">        const data &#x3D; Component.getInitialProps(branch[0].match.params);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;组件渲染为 html</span><br><span class="line">        const html &#x3D; renderToString(&lt;Component data&#x3D;&#123;data&#125;&#x2F;&gt;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;数据注水</span><br><span class="line">        const propsData &#x3D; &#96;&lt;textarea id&#x3D;&quot;krs-server-render-data-BOX&quot;&gt;$&#123;JSON.stringify(data)&#125;&lt;&#x2F;textarea&gt;&#96;;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 通过 ejs 模板引擎将数据注入到页面</span><br><span class="line">        ejs.renderFile(&#39;.&#x2F;index.html&#39;, &#123;</span><br><span class="line">            htmlContent: html,  </span><br><span class="line">            propsData</span><br><span class="line">        &#125;,  &#x2F;&#x2F; 渲染的数据key: 对应到了ejs中的index</span><br><span class="line">            (err, data) &#x3D;&gt; &#123;</span><br><span class="line">                if (err) &#123;</span><br><span class="line">                    console.log(err);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    console.log(data);</span><br><span class="line">                    res.end(data);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line"></span><br><span class="line"> &#125;).listen(8080);</span><br><span class="line"></span><br><span class="line"> &#x2F;&#x2F;node ejs html</span><br><span class="line"></span><br><span class="line"> &lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;ie&#x3D;edge&quot;&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;rootEle&quot;&gt;</span><br><span class="line">        &lt;%- htmlContent %&gt; &#x2F;&#x2F;组件 html内容</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;%- propsData %&gt; &#x2F;&#x2F;组件 init  state ，现在是个字符串</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;html&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>需要借助 ejs 模板，将数据绑定到页面上，为了防止 XSS攻击，这里我把数据写到了 textarea 标签里。</p>
<p>下图中，我看着明文数据难受，对数据做了base64编码 ，用之前需要转码，看个人需要。<br><img src="https://upload-images.jianshu.io/upload_images/10024246-4ea344d1832c1cca.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<h3 id="数据脱水"><a href="#数据脱水" class="headerlink" title="数据脱水"></a>数据脱水</h3><p>上一步数据已经注入到了浏览器端，这一步要在客户端组件渲染前先拿到数据，并且传入组件就可以了。</p>
<p>客户端可以直接使用id=krs-server-render-data-BOX 进行数据获取。</p>
<p>第一个方法简单粗暴，可直接在组件内的constructor 构造函数 内进行获取，如果怕代码重复，可以写一个高阶组件。</p>
<p>第二个方法可以通过 context 传递，只需要在入口处传入，在组件中声明 static contextType 即可。</p>
<p>我是采用context 传递，为了后面方便集成 redux 状态管理 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F; 定义 context 生产者 组件</span><br><span class="line"></span><br><span class="line">import React,&#123;createContext&#125; from &#39;react&#39;;</span><br><span class="line">import RootContext from &#39;.&#x2F;route-context&#39;;</span><br><span class="line"></span><br><span class="line">export default class Index extends React.Component &#123;</span><br><span class="line">    constructor(props,context) &#123;</span><br><span class="line">        super(props);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        return &lt;RootContext.Provider value&#x3D;&#123;this.props.initialData||&#123;&#125;&#125;&gt;</span><br><span class="line">            &#123;this.props.children&#125;</span><br><span class="line">        &lt;&#x2F;RootContext.Provider&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;入口  app.js</span><br><span class="line">import React from &#39;react&#39;;</span><br><span class="line">import ReactDOM from &#39;react-dom&#39;;</span><br><span class="line">import &#123; BrowserRouter &#125; from &#39;react-router-dom&#39;;</span><br><span class="line">import Routes from &#39;..&#x2F;&#39;;</span><br><span class="line">import Provider from &#39;.&#x2F;provider&#39;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;渲染入口  接收脱水数据</span><br><span class="line">function renderUI(initialData) &#123;</span><br><span class="line">    ReactDOM.hydrate(&lt;BrowserRouter&gt;&lt;Provider initialData&#x3D;&#123;initialData&#125;&gt;</span><br><span class="line">        &lt;Routes &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;Provider&gt;</span><br><span class="line">    &lt;&#x2F;BrowserRouter&gt;, document.getElementById(&#39;rootEle&#39;), (e) &#x3D;&gt; &#123;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;函数执行入口</span><br><span class="line">function entryIndex() &#123;</span><br><span class="line">    let APP_INIT_DATA &#x3D; &#123;&#125;;</span><br><span class="line">    let state &#x3D; true;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;取得数据</span><br><span class="line">    let stateText &#x3D; document.getElementById(&#39;krs-server-render-data-BOX&#39;);</span><br><span class="line"></span><br><span class="line">    if (stateText) &#123;</span><br><span class="line">        APP_INIT_DATA &#x3D; JSON.parse(stateText.value || &#39;&#123;&#125;&#39;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (APP_INIT_DATA) &#123;&#x2F;&#x2F;客户端渲染</span><br><span class="line"></span><br><span class="line">        renderUI(APP_INIT_DATA);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;入口执行</span><br><span class="line">entryIndex();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>行文至此，核心的内容已经基本说完，剩下的就是组件内如何使用脱水的数据。</p>
<p>下面通过 context 拿到数据 , 代码仅供参考，可根据自己的需求来进行封装和调整。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">import React from &#39;react&#39;;</span><br><span class="line">import &#39;.&#x2F;css&#x2F;index.scss&#39;;</span><br><span class="line"></span><br><span class="line">export default class Index extends React.Component &#123;</span><br><span class="line"></span><br><span class="line">    constructor(props, context) &#123;</span><br><span class="line">        super(props, context);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;将context 存储到 state </span><br><span class="line">        this.state &#x3D; &#123;</span><br><span class="line">            ... context</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;设置此参数 才能拿到 context 数据</span><br><span class="line">    static contextType &#x3D; RootContext;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;数据预取方法</span><br><span class="line">    static async getInitialProps(krsOpt) &#123;</span><br><span class="line"></span><br><span class="line">        if (__SERVER__) &#123;</span><br><span class="line">            &#x2F;&#x2F;如果是服务端渲染的话  可以做的处理,node 端设置的全局变量</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        const fetch1 &#x3D; fetch.postForm(&#39;&#x2F;fe_api&#x2F;filed-manager&#x2F;get-detail-of-type&#39;, &#123;</span><br><span class="line">            data: &#123; ofTypeId: 4000 &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        const fecth2 &#x3D; fetch.postForm(&#39;&#x2F;fe_api&#x2F;filed-manager&#x2F;get-detail-of-type&#39;, &#123;</span><br><span class="line">            data: &#123; ofTypeId: 2000 &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        const resArr &#x3D; await fetch.multipleFetch(fetch1, fecth2);</span><br><span class="line">        &#x2F;&#x2F;返回所有数据</span><br><span class="line">        return &#123;</span><br><span class="line">            page: &#123;&#125;,</span><br><span class="line">            fetchData: resArr</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    componentDidMount() &#123;</span><br><span class="line">        if (!this.isSSR) &#123; &#x2F;&#x2F;非服务端渲染需要自身进行数据获取</span><br><span class="line">            Index.getInitialProps(this.props.krsOpt).then(data &#x3D;&gt; &#123;</span><br><span class="line">                this.setState(&#123;</span><br><span class="line">                    ...data</span><br><span class="line">                &#125;, () &#x3D;&gt; &#123;</span><br><span class="line">                   &#x2F;&#x2F;可有的一些操作</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;得到 state 内的数据，进行逻辑判断和容错，然后渲染</span><br><span class="line">        const &#123; page, fetchData &#125; &#x3D; this.state;</span><br><span class="line">        const [res] &#x3D; fetchData || [];</span><br><span class="line"></span><br><span class="line">        return &lt;div className&#x3D;&quot;detailBox&quot;&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                res &amp;&amp; res.data.map(item &#x3D;&gt; &#123;</span><br><span class="line">                    return &lt;div key&#x3D;&#123;item.id&#125;&gt;&#123;item.keyId&#125;:&#123;item.keyName&#125;---&#123;item.setContent&#125;&lt;&#x2F;div&gt;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>到此我们的第三个问题：【服务端 html 节点无法重用 】已经解决,但人不够完美，请继续看。</p>
<h1 id="css-过滤"><a href="#css-过滤" class="headerlink" title="css 过滤"></a>css 过滤</h1><p>我们在写组件的时候大部分都会导入相关的 css 文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import &#39;.&#x2F;css&#x2F;index.scss&#39;;&#x2F;&#x2F;导入css</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;组件</span><br><span class="line">class Index extends React.Component&#123;</span><br><span class="line">    constructor(props)&#123;</span><br><span class="line">        super(props);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static async  getInitialProps() &#123;</span><br><span class="line">        const fetch1 &#x3D;await fetch(&#39;&#x2F;xxx.com&#x2F;a&#39;);</span><br><span class="line">        const fetch2 &#x3D; await fetch(&#39;&#x2F;xxx.com&#x2F;b&#39;);</span><br><span class="line"></span><br><span class="line">        return &#123;</span><br><span class="line">            res:[fetch1,fetch2]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render()&#123;</span><br><span class="line">        return &lt;h1&gt;&#123;this.props.data.title&#125;&lt;&#x2F;h1&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这个 css 文件在服务端无法执行，其实想想在服务端本来就不需要渲染 css 。为什么不直接干掉？ 所以为了方便，我这里写了一个babel 插件，在编译的时候干掉 css 的导入代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 删除 css 的引入</span><br><span class="line"> * 可能社区已经有现成的插件但是不想费劲儿找了，还是自己写一个吧。 </span><br><span class="line"> *&#x2F;</span><br><span class="line">module.exports &#x3D; function (&#123; types: babelTypes &#125;) &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        name: &quot;no-require-css&quot;,</span><br><span class="line">        visitor: &#123;</span><br><span class="line">            ImportDeclaration(path, state) &#123;</span><br><span class="line">                let importFile &#x3D; path.node.source.value;</span><br><span class="line">                if(importFile.indexOf(&#39;.scss&#39;)&gt;-1)&#123;</span><br><span class="line">                    &#x2F;&#x2F; 干掉css 导入</span><br><span class="line">                    path.remove();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;.babelrc 中使用</span><br><span class="line"></span><br><span class="line"> &quot;plugins&quot;: [</span><br><span class="line">                &quot;.&#x2F;webpack&#x2F;babel&#x2F;plugin&#x2F;no-require-css&quot;  &#x2F;&#x2F;引入        </span><br><span class="line">            ]</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://www.renrenfan.com.cn/">资源搜索网站大全</a> <a target="_blank" rel="noopener" href="https://www.renrenfan.com.cn/">https://www.renrenfan.com.cn</a> <a target="_blank" rel="noopener" href="https://www.houdianzi.com/">广州VI设计公司</a><a target="_blank" rel="noopener" href="https://www.houdianzi.com/">https://www.houdianzi.com</a></p>
<h1 id="动态路由的-SSR"><a href="#动态路由的-SSR" class="headerlink" title="动态路由的 SSR"></a>动态路由的 SSR</h1><p>现在要说一个更加核心的内容，也是本文的一个压轴亮点，可以说是<strong>全网唯一</strong>,我之前也看过很多文章和资料都没有细说这一块儿的实现。</p>
<p>不知道你有没有发现，上面我们已经一步一步的实现了 React SSR 同构 的完整流程，但是总感觉少点什么东西。</p>
<p>SPA模式下大部分都会实现组件分包和按需加载，防止所有代码打包在一个文件过大影响页面的加载和渲染，影响用户体验。</p>
<p>那么基于 SSR 的组件按需加载如何实现呢？</p>
<p>当然我们所限定按需的粒度是路由级别的，请求不同的路由动态加载对应的组件。</p>
<h2 id="如何实现组件的按需加载？"><a href="#如何实现组件的按需加载？" class="headerlink" title="如何实现组件的按需加载？"></a>如何实现组件的按需加载？</h2><p>在 webpack2 时期主要使用require.ensure方法来实现按需加载，他会单独打包指定的文件，在当下 webpack4，有了更加规范的的方式实现按需加载，那就是动态导入 import(‘./xx.js’),当然实现的效果和 require.ensure是相同的。</p>
<p>咱们这里只说如何借助这个规范实现按需加载的路由，关于动态导入的实现原理先按下不表。</p>
<p>我们都知道 import 方法传入一个js文件地址，返回值是一个 promise 对象，然后在 then 方法内回调得到按需的组件。他的原理其实就是通过 jsonp 的方式，动态请求脚本，然后在回调内得到组件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import(&#39;..&#x2F;index&#39;).then(res&#x3D;&gt;&#123;</span><br><span class="line">    &#x2F;&#x2F;xxxx</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>那现在我们已经得到了几个比较有用的信息。</p>
<ul>
<li>  如何加载脚本 - import 结合 webpack 自动完成</li>
<li>  脚本是否加载完成 - 通过在 then 方法回调进行处理</li>
<li>  获取异步按组件 - 通过在 then 方法回调内获取</li>
</ul>
<p>我们可以试着把上面的逻辑抽象成为一个组件，然后在路由配置的地方进行导入后，那么是不是就完成了组件的按需加载呢？</p>
<p>先看下按需加载组件, 目的是在 import 完成的时候得到按需的组件，然后更改容器组件的 state，将这个异步组件进行渲染。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 按需加载的容器组件</span><br><span class="line"> * @class Bundle</span><br><span class="line"> * @extends &#123;Component&#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">export default class Async extends React.Component &#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">        super(props);</span><br><span class="line">        this.state &#x3D; &#123;</span><br><span class="line">            COMPT: null</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    UNSAFE_componentWillMount() &#123;</span><br><span class="line">        &#x2F;&#x2F;执行组件加载</span><br><span class="line">        if (!this.state.COMPT) &#123;</span><br><span class="line">            this.load(this.props);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    load(props) &#123;</span><br><span class="line">        this.setState(&#123;</span><br><span class="line">            COMPT: null</span><br><span class="line">        &#125;);</span><br><span class="line">        &#x2F;&#x2F;注意这里，返回Promise对象; C.default 指向按需组件</span><br><span class="line">        props.load().then((C) &#x3D;&gt; &#123;</span><br><span class="line">            this.setState(&#123;</span><br><span class="line">                COMPT: C.default ? C.default : COMPT</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        return this.state.COMPT ? this.props.children(this.state.COMPT) : &lt;span&gt;正在加载......&lt;&#x2F;span&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Async 容器组件接收一个 props 传过来的 load 方法，返回值是 Promise类型，用来动态导入组件。</p>
<p>在生命周期 UNSAFE_componentWillMount 得到按需的组件，并将组件存储到 state.COMPT内,同时在 render 方法中判断这个状态的可用性，然后调用this.props.children 方法进行渲染。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;调用</span><br><span class="line">const LazyPageCom &#x3D; (props) &#x3D;&gt; (</span><br><span class="line">    &lt;Async load&#x3D;&#123;() &#x3D;&gt; import(&#39;..&#x2F;index&#39;)&#125;&gt;</span><br><span class="line">        &#123;(C) &#x3D;&gt; &lt;C &#123;...props&#125; &#x2F;&gt;&#125;&#x2F;&#x2F;返回函数组件</span><br><span class="line">    &lt;&#x2F;Async&gt;</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当然这只是其中一种方法，也有很多是通过 react-loadable 库来进行实现，但是实现思路基本相同,有兴趣的可以看下源码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;参考代码</span><br><span class="line">import React from &#39;react&#39;;</span><br><span class="line">import Loadable from &#39;react-loadable&#39;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;loading 组件</span><br><span class="line">const Loading &#x3D;()&#x3D;&gt;&#123;</span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;loading&lt;&#x2F;div&gt;</span><br><span class="line">    ) </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;导出组件</span><br><span class="line">export default Loadable(&#123;</span><br><span class="line">    loader:import(&#39;..&#x2F;index&#39;),</span><br><span class="line">    loading:Loading</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>到这里我们已经实现了组件的按需加载，剩下就是配置到路由。</p>
<p>看下伪代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F;index.js</span><br><span class="line"></span><br><span class="line">class Index extends React.Component &#123;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        return &lt;div&gt;detail&lt;&#x2F;div&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;detail.js</span><br><span class="line"></span><br><span class="line">class Detail extends React.Component &#123;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        return &lt;div&gt;detail&lt;&#x2F;div&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;routes.js</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;按需加载 index 组件</span><br><span class="line">const AyncIndex &#x3D; (props) &#x3D;&gt; (</span><br><span class="line">    &lt;Async load&#x3D;&#123;() &#x3D;&gt; import(&#39;..&#x2F;index&#39;)&#125;&gt;</span><br><span class="line">        &#123;(C) &#x3D;&gt; &lt;C &#123;...props&#125; &#x2F;&gt;&#125;</span><br><span class="line">    &lt;&#x2F;Async&gt;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;按需加载 detai 组件</span><br><span class="line">const AyncDetail &#x3D; (props) &#x3D;&gt; (</span><br><span class="line">    &lt;Async load&#x3D;&#123;() &#x3D;&gt; import(&#39;..&#x2F;index&#39;)&#125;&gt;</span><br><span class="line">        &#123;(C) &#x3D;&gt; &lt;C &#123;...props&#125; &#x2F;&gt;&#125;</span><br><span class="line">    &lt;&#x2F;Async&gt;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">const routes &#x3D; [</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        path: &quot;&#x2F;&quot;,</span><br><span class="line">        exact: true,</span><br><span class="line">        component: AyncIndex</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        path: &#39;&#x2F;detail&#39;, exact: true,</span><br><span class="line">        component: AyncDetail,</span><br><span class="line">    &#125;</span><br><span class="line">];</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>结合路由的按需加载已经配置完成，先不管 server端 是否需要进行调整，此时的代码是可以运行的，按需也是 ok 的。</p>
<p>但是ssr无效了，查看网页源代码无内容。</p>
<h2 id="动态路由-SSR-双端配置"><a href="#动态路由-SSR-双端配置" class="headerlink" title="动态路由 SSR 双端配置"></a>动态路由 SSR 双端配置</h2><p>ssr无效了,这是什么原因呢？</p>
<p>上面我们在做路由同构的时候，双端使用的是同一个 route配置文件routes-config.js,现在组件改成了按需加载，所以在路由查找后得到的组件发生改变了 - AyncDetail,AyncIndex，根本无法转换出组件内容。</p>
<h3 id="ssr-模式下-server-端如何处理路由按需加载"><a href="#ssr-模式下-server-端如何处理路由按需加载" class="headerlink" title="ssr 模式下 server 端如何处理路由按需加载"></a>ssr 模式下 server 端如何处理路由按需加载</h3><p>其实很简单，也是参考客户端的处理方式，对路由配置进行二次处理。server 端在进行组件查找前，强制执行 import 方法，得到一个全新的静态路由表，再去进行组件的查找。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F;获得静态路由</span><br><span class="line"></span><br><span class="line">import routes from &#39;routes-config.js&#39;;&#x2F;&#x2F;得到动态路由的配置</span><br><span class="line"></span><br><span class="line">export async function getStaticRoutes() &#123;</span><br><span class="line"></span><br><span class="line">    const staticRoutes &#x3D; [];&#x2F;&#x2F;存放新路由</span><br><span class="line"></span><br><span class="line">    for (; i &lt; len; i++) &#123;</span><br><span class="line">        let item &#x3D; routes[i];</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;存放静态路由</span><br><span class="line">        staticRoutes.push(&#123;</span><br><span class="line">            ...item,</span><br><span class="line">            ...&#123;</span><br><span class="line">                component: (await item.component().props.load()).default</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    return staticRoutes; &#x2F;&#x2F;返回静态路由</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如今我们离目标更近了一步，server端已兼容了按需路由的查找。但是还没完！</p>
<p>我们这个时候访问页面的话，ssr 生效了，查看网页源代码可以看到对应的 html 内容。</p>
<p>但是页面上会显示直出的内容，然后显示<span>正在加载……</span> ,瞬间又变成直出的内容。</p>
<h3 id="ssr-模式下-client-端如何处理路由按需加载"><a href="#ssr-模式下-client-端如何处理路由按需加载" class="headerlink" title="ssr 模式下 client 端如何处理路由按需加载"></a>ssr 模式下 client 端如何处理路由按需加载</h3><p>这个是为什么呢？</p>
<p>是不是看的有点累了，再坚持一下就成功了。</p>
<p>其实有问题才是最好的学习方式，问题解决了，路就通了。</p>
<p>首先我们知道浏览器端会对已有的节点进行双端对比，如果对比失败就会重新渲染，这很明显就是个问题。</p>
<p>咱分析一下，首先服务端直出了 html 内容，而此时浏览器端js执行完后需要做按需加载，在按需加载前的组件默认的内容就是<span>正在加载……</span> 这个缺省内容和服务端直出的 html 内容完全不同，所以对比失败，页面会渲染成 <span>正在加载……</span>,然后按需加载完成后组件再次渲染，此时渲染的就是真正的组件了。</p>
<p><strong>如何解决呢？</strong></p>
<p>其实也并不复杂，只是不确定是否可行，试过就知道。</p>
<p>既然客户端需要处理按需，那么我们等这个按需组件加载完后再进行渲染是不是就可以了呢？</p>
<p>答案是：可以的！</p>
<p><strong>如何按需呢？</strong></p>
<p>向“服务端同学”学习，找到对应的组件并强制 执行import按需，只是这里不是转换为静态路由，只找到按需的组件完成动态加载即可。</p>
<p>既然有了思路，那就撸起代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import React,&#123;createContext&#125; from &#39;react&#39;;</span><br><span class="line">import RootContext from &#39;.&#x2F;route-context&#39;;</span><br><span class="line"></span><br><span class="line">export default class Index extends React.Component &#123;</span><br><span class="line">    constructor(props,context) &#123;</span><br><span class="line">        super(props);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        return &lt;RootContext.Provider value&#x3D;&#123;this.props.initialData||&#123;&#125;&#125;&gt;</span><br><span class="line">            &#123;this.props.children&#125;</span><br><span class="line">        &lt;&#x2F;RootContext.Provider&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;入口  app.js</span><br><span class="line">import React from &#39;react&#39;;</span><br><span class="line">import ReactDOM from &#39;react-dom&#39;;</span><br><span class="line">import &#123; BrowserRouter &#125; from &#39;react-router-dom&#39;;</span><br><span class="line">import Routes from &#39;..&#x2F;&#39;;</span><br><span class="line">import Provider from &#39;.&#x2F;provider&#39;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;渲染入口</span><br><span class="line">function renderUI(initialData) &#123;</span><br><span class="line">    ReactDOM.hydrate(&lt;BrowserRouter&gt;&lt;Provider initialData&#x3D;&#123;initialData&#125;&gt;</span><br><span class="line">        &lt;Routes &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;Provider&gt;</span><br><span class="line">    &lt;&#x2F;BrowserRouter&gt;, document.getElementById(&#39;rootEle&#39;), (e) &#x3D;&gt; &#123;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function entryIndex() &#123;</span><br><span class="line">    let APP_INIT_DATA &#x3D; &#123;&#125;;</span><br><span class="line">    let state &#x3D; true;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;取得数据</span><br><span class="line">    let stateText &#x3D; document.getElementById(&#39;krs-server-render-data-BOX&#39;);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;数据脱水</span><br><span class="line">    if (stateText) &#123;</span><br><span class="line">        APP_INIT_DATA &#x3D; JSON.parse(stateText.value || &#39;&#123;&#125;&#39;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (APP_INIT_DATA) &#123;&#x2F;&#x2F;客户端渲染</span><br><span class="line"></span><br><span class="line">        - renderUI(true, APP_INIT_DATA);</span><br><span class="line">        &#x2F;&#x2F;查找组件</span><br><span class="line">        + matchComponent(document.location.pathname, routesConfig()).then(res &#x3D;&gt; &#123;</span><br><span class="line">            renderUI(true, APP_INIT_DATA);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;执行入口</span><br><span class="line">entryIndex();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>matchComponent 是我封装的一个组件查找的方法，在文章开始已经介绍过类似的实现，代码就不贴了。</p>
<p><strong>核心亮点说完，整个流程基本结束，剩下的都是些有的没的了，我打算要收工了。</strong></p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="SEO-支持"><a href="#SEO-支持" class="headerlink" title="SEO 支持"></a>SEO 支持</h2><p>页面的 SEO 效果取决于页面的主体内容和页面的 TDK（标题 title,描述 description,关键词 keyword）以及关键词的分布和密度，现在我们实现了 ssr所以页面的主体内容有了，那如何设置页面的标题并且让每个页面（路由）的标题都不同呢？</p>
<p>只要我们每请求一个路由的时候返回不同的 tdk 就可以了。</p>
<p>这里我在所对应组件数据预取的方法内加了约定，返回的数据为固定格式，必须包含 page 对象，page 对象内包含 tdk 的信息。</p>
<p>看代码瞬间就明白。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import &#39;.&#x2F;css&#x2F;index.scss&#39;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;组件</span><br><span class="line">class Index extends React.Component&#123;</span><br><span class="line">    constructor(props)&#123;</span><br><span class="line">        super(props);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static async  getInitialProps() &#123;</span><br><span class="line">        const fetch1 &#x3D;await fetch(&#39;&#x2F;xxx.com&#x2F;a&#39;);</span><br><span class="line">        const fetch2 &#x3D; await fetch(&#39;&#x2F;xxx.com&#x2F;b&#39;);</span><br><span class="line"></span><br><span class="line">        return &#123;</span><br><span class="line">            page:&#123;</span><br><span class="line">                tdk:&#123;</span><br><span class="line">                    title:&#39;标题&#39;,</span><br><span class="line">                    keyword:&#39;关键词&#39;,</span><br><span class="line">                    description:&#39;描述&#39;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res:[fetch1,fetch2]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render()&#123;</span><br><span class="line">        return &lt;h1&gt;&#123;this.props.data.title&#125;&lt;&#x2F;h1&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样你的 tdk 可以根据你的需要设置成静态还是从接口拿到的。然后可以在 esj 模板里进行绑定，也可以在 componentDidMount通过 js<br>document.title=this.state.page.tdk.title设置页面的标题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">   &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">   &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;</span><br><span class="line">   &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;ie&#x3D;edge&quot;&gt;</span><br><span class="line">   &lt;meta name&#x3D;&quot;keywords&quot; content&#x3D;&quot;&lt;%&#x3D;page.tdk.keyword%&gt;&quot; &#x2F;&gt;</span><br><span class="line">   &lt;meta name&#x3D;&quot;description&quot; content&#x3D;&quot;content&#x3D;&quot;&lt;%&#x3D;page.tdk.description%&gt;&quot; &#x2F;&gt;</span><br><span class="line">   &lt;title&gt;&lt;%&#x3D;page.tdk.title%&gt;&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">   &lt;div id&#x3D;&quot;rootEle&quot;&gt;</span><br><span class="line">       &lt;%- htmlContent %&gt;</span><br><span class="line">   &lt;&#x2F;div&gt;</span><br><span class="line">   &lt;%- propsData %&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;%page.staticSource.js.forEach(function(item)&#123;%&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="fetch-同构"><a href="#fetch-同构" class="headerlink" title="fetch 同构"></a>fetch 同构</h2><p>可以使用isomorphic-fetch、axios或者whatwg-fetch + node-fetch 等库来实现支持双端的 fetch 数据请求，这里推荐使用axios 主要是比较方便。</p>
<h1 id="TODO-和-思考"><a href="#TODO-和-思考" class="headerlink" title="TODO 和 思考"></a>TODO 和 思考</h1><p>没有介绍结合 redux 状态管理的 ssr 实现，其实也不复杂，关键还是看业务中是否需要使用redux，因为文中已经实现了使用 context 传递数据，直接改成按store 传递也很容易,但是更多的还是对 react-redux 的应用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F;渲染入口 代码仅供参考 </span><br><span class="line">function renderUI(initialData) &#123;</span><br><span class="line">   ReactDOM.hydrate(&lt;BrowserRouter&gt;&lt;Provider store&#x3D;&#123;initialData&#125;&gt;</span><br><span class="line">       &lt;Routes &#x2F;&gt;</span><br><span class="line">   &lt;&#x2F;Provider&gt;</span><br><span class="line">   &lt;&#x2F;BrowserRouter&gt;, document.getElementById(&#39;rootEle&#39;), (e) &#x3D;&gt; &#123;</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>服务端同构渲染虽然可以提升首屏的出现时间，利于 SEO，对低端用户友好，但是开发复杂度有所提高，代码需要兼容双端运行（runtime）,还有一些库只能在浏览器端运行，在服务端加载会直接报错，这种情况就需要进行做一些特殊处理。</p>
<p>同时也会大大的增加服务端负载，当然这都容易解决，可以改用renderToNodeStream() 方法通过流式输出来提升服务端渲染性能，可以进行监控和扩容，所以是否需要 ssr 模式，还要看具体的产品线和用户定位。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lzhwweb.github.io/nirvana/javascript/%E5%89%8D%E7%AB%AF/CSS%E6%96%B0%E7%89%B9%E6%80%A7contain%EF%BC%8C%E6%8E%A7%E5%88%B6%E9%A1%B5%E9%9D%A2%E7%9A%84%E9%87%8D%E7%BB%98%E4%B8%8E%E9%87%8D%E6%8E%92/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/nirvana/images/headphoto.jpeg">
      <meta itemprop="name" content="nirvana">
      <meta itemprop="description" content="个人学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="涅槃快乐是金">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/nirvana/javascript/%E5%89%8D%E7%AB%AF/CSS%E6%96%B0%E7%89%B9%E6%80%A7contain%EF%BC%8C%E6%8E%A7%E5%88%B6%E9%A1%B5%E9%9D%A2%E7%9A%84%E9%87%8D%E7%BB%98%E4%B8%8E%E9%87%8D%E6%8E%92/" class="post-title-link" itemprop="url">CSS新特性contain，控制页面的重绘与重排</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-06-10 16:40:29 / 修改时间：17:02:25" itemprop="dateCreated datePublished" datetime="2021-06-10T16:40:29+08:00">2021-06-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/nirvana/categories/javascript/" itemprop="url" rel="index"><span itemprop="name">javascript</span></a>
        </span>
    </span>

  
    <span id="/nirvana/javascript/%E5%89%8D%E7%AB%AF/CSS%E6%96%B0%E7%89%B9%E6%80%A7contain%EF%BC%8C%E6%8E%A7%E5%88%B6%E9%A1%B5%E9%9D%A2%E7%9A%84%E9%87%8D%E7%BB%98%E4%B8%8E%E9%87%8D%E6%8E%92/" class="post-meta-item leancloud_visitors" data-flag-title="CSS新特性contain，控制页面的重绘与重排" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4.7k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="contain-为何？"><a href="#contain-为何？" class="headerlink" title="contain 为何？"></a><code>contain</code> 为何？</h2><p><code>contain</code> 属性允许我们指定特定的 DOM 元素和它的子元素，让它们能够独立于整个 DOM 树结构之外。目的是能够让浏览器有能力只对部分元素进行重绘、重排，而不必每次都针对整个页面。</p>
<blockquote>
<p>The contain property allows an author to indicate that an element and its contents are, as much as possible, independent of the rest of the document tree. This allows the browser to recalculate layout, style, paint, size, or any combination of them for a limited area of the DOM and not the entire page.</p>
</blockquote>
<h2 id="contain-语法"><a href="#contain-语法" class="headerlink" title="contain 语法"></a><code>contain</code> 语法</h2><p>看看它的语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &#x2F;* No layout containment. *&#x2F;</span><br><span class="line">  contain: none;</span><br><span class="line">  &#x2F;* Turn on size containment for an element. *&#x2F;</span><br><span class="line">  contain: size;</span><br><span class="line">  &#x2F;* Turn on layout containment for an element. *&#x2F;</span><br><span class="line">  contain: layout;</span><br><span class="line">  &#x2F;* Turn on style containment for an element. *&#x2F;</span><br><span class="line">  contain: style;</span><br><span class="line">  &#x2F;* Turn on paint containment for an element. *&#x2F;</span><br><span class="line">  contain: paint;</span><br><span class="line"></span><br><span class="line">  &#x2F;* Turn on containment for layout, paint, and size. *&#x2F;</span><br><span class="line">  contain: strict;</span><br><span class="line">  &#x2F;* Turn on containment for layout, and paint. *&#x2F;</span><br><span class="line">  contain: content;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除去 <code>none</code>，取值还有 6 个，我们一个一个来看看。</p>
<h2 id="contain-size"><a href="#contain-size" class="headerlink" title="contain: size"></a>contain: size</h2><p>contain: size: 设定了 <code>contain: size</code> 的元素的渲染不会受到其子元素内容的影响。</p>
<blockquote>
<p>The value turns on size containment for the element. This ensures that the containing box can be laid out without needing to examine its descendants.</p>
</blockquote>
<p>我开始看到这个定义也是一头雾水，光看定义很难明白到底是什么意思。还需实践一番：</p>
<p>假设我们有如下简单结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;container&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">    width: 300px;</span><br><span class="line">    padding: 10px;</span><br><span class="line">    border: 1px solid red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p &#123;</span><br><span class="line">    border: 1px solid #333;</span><br><span class="line">    margin: 5px;</span><br><span class="line">    font-size: 14px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并且，借助 jQuery 实现每次点击容器添加一个 <code>&lt;p&gt;Coco&lt;/p&gt;</code> 结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(&#39;.container&#39;).on(&#39;click&#39;, e &#x3D;&gt; &#123;</span><br><span class="line">    $(&#39;.container&#39;).append(&#39;&lt;p&gt;Coco&lt;&#x2F;p&gt;&#39;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>那么会得到如下结果：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-0e816a00adab35e5.gif?imageMogr2/auto-orient/strip"></p>
<p>可以看到，容器 <code>.container</code> 的高度是会随着元素的增加而增加的，这是正常的现象。</p>
<p>此刻，我们给容器 <code>.container</code> 添加一个 <code>contain: size</code>，也就会出现上述说的：<strong>设定了 <code>contain: size</code> 的元素的渲染不会受到其子元素内容的影响</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">    width: 300px;</span><br><span class="line">    padding: 10px;</span><br><span class="line">    border: 1px solid red;</span><br><span class="line">+   contain: size</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再看看会发生什么：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-4eafd75af8365e03.gif?imageMogr2/auto-orient/strip"></p>
<p>正常而言，父元素的高度会因为子元素的增多而被撑高，而现在，子元素的变化不再影响父元素的样式布局，这就是 <code>contain: size</code> 的作用。</p>
<h2 id="contain-style"><a href="#contain-style" class="headerlink" title="contain: style"></a>contain: style</h2><p>接下来再说说 <code>contain: style</code>、<code>contain: layout</code> 、<code>contain: paint</code>。先看看 contain: style。</p>
<p>截止至本文书写的过程中，<code>contain: style</code> 暂时被移除了。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.w3.org/TR/css-contain-1/">CSS Containment Module Level 1</a>: Drop the at-risk “style containment” feature from this specification, move it Level 2。</p>
</blockquote>
<p>嗯，官方说辞是因为存在某些风险，暂时被移除，可能在规范的第二版会重新定义吧，那这个属性也暂且放一放。</p>
<h2 id="contain-paint"><a href="#contain-paint" class="headerlink" title="contain: paint"></a>contain: paint</h2><p>contain: paint：设定了 <code>contain: paint</code> 的元素即是设定了布局限制，也就是说告知 User Agent，此元素的子元素不会在此元素的边界之外被展示，因此，如果元素不在屏幕上或以其他方式设定为不可见，则还可以保证其后代不可见不被渲染。</p>
<blockquote>
<p>This value turns on paint containment for the element. This ensures that the descendants of the containing box don’t display outside its bounds, so if an element is off-screen or otherwise not visible, its descendants are also guaranteed to be not visible.</p>
</blockquote>
<p>这个稍微好理解一点，先来看第一个特性：</p>
<h3 id="设定了-contain-paint-的元素的子元素不会在此元素的边界之外被展示"><a href="#设定了-contain-paint-的元素的子元素不会在此元素的边界之外被展示" class="headerlink" title="设定了 contain: paint 的元素的子元素不会在此元素的边界之外被展示"></a>设定了 <code>contain: paint</code> 的元素的子元素不会在此元素的边界之外被展示</h3><ul>
<li>  设定了 <code>contain: paint</code> 的元素的子元素不会在此元素的边界之外被展示</li>
</ul>
<p>这个特点有点类似与 <code>overflow: hidden</code>，也就是明确告知用户代理，子元素的内容不会超出元素的边界，所以超出部分无需渲染。</p>
<p>简单示例，假设元素结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;container&quot;&gt;</span><br><span class="line">    &lt;p&gt;Coco&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">    contain: paint;</span><br><span class="line">    border: 1px solid red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p&#123;</span><br><span class="line">    left: -100px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来看看，设定了 <code>contain: paint</code> 与没设定时会发生什么：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-40d071c4e009dc68.gif?imageMogr2/auto-orient/strip"></p>
<p><a target="_blank" rel="noopener" href="https://codepen.io/Chokcoco/pen/KKwmgmN">CodePen Demo – contain: paint Demo</a>点击预览 </p>
<h3 id="设定了-contain-paint-的元素在屏幕之外时不会渲染绘制"><a href="#设定了-contain-paint-的元素在屏幕之外时不会渲染绘制" class="headerlink" title="设定了 contain: paint 的元素在屏幕之外时不会渲染绘制"></a>设定了 <code>contain: paint</code> 的元素在屏幕之外时不会渲染绘制</h3><p>通过使用 <code>contain: paint</code>， 如果元素处于屏幕外，那么用户代理就会忽略渲染这些元素，从而能更快的渲染其它内容。</p>
<h2 id="contain-layout"><a href="#contain-layout" class="headerlink" title="contain: layout"></a>contain: layout</h2><p>contain: layout：设定了 <code>contain: layout</code> 的元素即是设定了布局限制，也就是说告知 User Agent，此元素内部的样式变化不会引起元素外部的样式变化，反之亦然。</p>
<blockquote>
<p>This value turns on layout containment for the element. This ensures that the containing box is totally opaque for layout purposes; nothing outside can affect its internal layout, and vice versa.</p>
</blockquote>
<p>启用 <code>contain: layout</code> 可以潜在地将每一帧需要渲染的元素数量减少到少数，而不是重新渲染整个文档，从而为浏览器节省了大量不必要的工作，并显着提高了性能。</p>
<p>使用 <code>contain：layout</code>，开发人员可以指定对该元素任何后代的任何更改都不会影响任何外部元素的布局，反之亦然。</p>
<p>因此，浏览器仅计算内部元素的位置（如果对其进行了修改），而其余DOM保持不变。因此，这意味着帧渲染管道中的布局过程将加快。</p>
<h3 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h3><p>描述很美好，但是在实际 Demo 测试的过程中（截止至2021/04/27，Chrome 90.0.4430.85），仅仅单独使用 <code>contain：layout</code> 并没有验证得到上述那么美好的结果。</p>
<p><strong>设定了 <code>contain: layout</code> 的指定元素，改元素的任何后代的任何更改还是会影响任何外部元素的布局</strong>，点击红框会增加一条 <code>&lt;p&gt;Coco&lt;p&gt;</code> 元素插入到 <code>container</code> 中：</p>
<p>简单的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;container&quot;&gt;</span><br><span class="line">    &lt;p&gt;Coco&lt;&#x2F;p&gt;</span><br><span class="line">    ...</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div class&#x3D;&quot;g-test&quot;&gt;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">html,</span><br><span class="line">body &#123;</span><br><span class="line">    width: 100%;</span><br><span class="line">    height: 100%;</span><br><span class="line">    display: flex;</span><br><span class="line">    justify-content: center;</span><br><span class="line">    align-items: center;</span><br><span class="line">    flex-direction: column;</span><br><span class="line">    gap: 10px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.container &#123;</span><br><span class="line">    width: 150px;</span><br><span class="line">    padding: 10px;</span><br><span class="line">    contain: layout;</span><br><span class="line">    border: 1px solid red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.g-test &#123;</span><br><span class="line">    width: 150px;</span><br><span class="line">    height: 150px;</span><br><span class="line">    border: 1px solid green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/10024246-9205beded9aa0db4.gif?imageMogr2/auto-orient/strip"></p>
<p><a target="_blank" rel="noopener" href="https://codepen.io/Chokcoco/pen/rNjRELL">CodePen Demo – contain: layout Demo</a>点击预览 </p>
<p>目前看来，<code>contain: layout</code> 的实际作用不那么明显，更多的关于它的用法，你可以再看看这篇文章：<a target="_blank" rel="noopener" href="https://css-tricks.com/almanac/properties/c/contain/">CSS-tricks - contain</a></p>
<h2 id="contain-strict-contain-content"><a href="#contain-strict-contain-content" class="headerlink" title="contain: strict | contain: content"></a>contain: strict | contain: content</h2><p>这两个属性稍微有点特殊，效果是上述介绍的几个属性的聚合效果：</p>
<ul>
<li>  <code>contain: strict</code>：同时开启 layout、style、paint 以及 size 的功能，它相当于 <code>contain: size layout paint</code></li>
<li>  <code>contain: content</code>：同时开启 layout、style 以及 paint 的功能，它相当于 <code>contain: layout paint</code></li>
</ul>
<p>所以，这里也提一下，contain 属性是可以同时定义几个的。</p>
<h2 id="Can-i-Use-–-CSS-Contain"><a href="#Can-i-Use-–-CSS-Contain" class="headerlink" title="Can i Use – CSS Contain"></a>Can i Use – CSS Contain</h2><p>截止至 2021-04-27，Can i Use 上的 CSS Contain 兼容性，已经可以开始使用起来：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-316f1e66fa903213.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li>  <a target="_blank" rel="noopener" href="https://www.w3.org/TR/css-contain-1/">CSS Containment Module Level 1</a></li>
<li>  <a target="_blank" rel="noopener" href="https://justmarkup.com/articles/2016-04-05-css-containment/">CSS containment</a></li>
<li>  <a target="_blank" rel="noopener" href="https://developers.google.com/web/updates/2016/06/css-containment">CSS Containment in Chrome 52</a></li>
</ul>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>好了，本文到此结束，希望对你有帮助 :)</p>
<p>更多精彩 CSS 技术文章汇总在我的 <a target="_blank" rel="noopener" href="https://github.com/chokcoco/iCSS">Github – iCSS</a> ，持续更新，欢迎点个 star 订阅收藏。</p>
<p>如果还有什么疑问或者建议，可以多多交流，原创文章，文笔有限，才疏学浅，文中若有不正之处，万望告知。</p>
<blockquote>
<p>原文：<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000039950464?utm_source=tag-newest">https://segmentfault.com/a/1190000039950464?utm_source=tag-newest</a></p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lzhwweb.github.io/nirvana/javascript/%E5%89%8D%E7%AB%AF/%E5%A4%A7%E5%89%8D%E7%AB%AF%E9%A2%86%E5%9F%9F%EF%BC%8C%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E4%BA%BA%E6%9C%80%E5%90%83%E9%A6%99%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/nirvana/images/headphoto.jpeg">
      <meta itemprop="name" content="nirvana">
      <meta itemprop="description" content="个人学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="涅槃快乐是金">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/nirvana/javascript/%E5%89%8D%E7%AB%AF/%E5%A4%A7%E5%89%8D%E7%AB%AF%E9%A2%86%E5%9F%9F%EF%BC%8C%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E4%BA%BA%E6%9C%80%E5%90%83%E9%A6%99%EF%BC%9F/" class="post-title-link" itemprop="url">大前端领域，什么样的人最吃香？｜InfoQ 编程语言 4 月排行榜</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-06-10 16:39:20 / 修改时间：17:02:25" itemprop="dateCreated datePublished" datetime="2021-06-10T16:39:20+08:00">2021-06-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/nirvana/categories/javascript/" itemprop="url" rel="index"><span itemprop="name">javascript</span></a>
        </span>
    </span>

  
    <span id="/nirvana/javascript/%E5%89%8D%E7%AB%AF/%E5%A4%A7%E5%89%8D%E7%AB%AF%E9%A2%86%E5%9F%9F%EF%BC%8C%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E4%BA%BA%E6%9C%80%E5%90%83%E9%A6%99%EF%BC%9F/" class="post-meta-item leancloud_visitors" data-flag-title="大前端领域，什么样的人最吃香？｜InfoQ 编程语言 4 月排行榜" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.4k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>提起大前端，总会有人抱怨“学不动了”，因为技术更新太快。那大前端的风会吹向何方？是跨端、Flutter、Serverless，还是小程序？为回答上述问题，结合 InfoQ 编程语言 4 月排行榜的调查结果，我们采访了大前端领域的三名程序员，试图了解这个领域的程序员们。</p>
<h5 id="发现-1：Web-开发依然是大前端领域的主流"><a href="#发现-1：Web-开发依然是大前端领域的主流" class="headerlink" title="发现 1：Web 开发依然是大前端领域的主流"></a>发现 1：Web 开发依然是大前端领域的主流</h5><p><img src="https://upload-images.jianshu.io/upload_images/10024246-7433f22baa7e4ec4?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>基于投票数据，我们发现 Web 开发得票率为 68%，由此可见它依然是大前端领域的主流。iOS 开发得票率为 16%，排名第二，而 Android 开发则以 5% 的得票率排名第四。同时，我们注意到，小程序开发以 6% 的得票率超过 Android 开发的 5%。</p>
<p>在采访中，网名叫月熊的程序员表示，自己在大前端领域最关心的技术方向是跨端开发、微前端和数据可视化 / 交互。而他所在公司的业务是面向小批量制造领域的数字化工厂和智能制造行业，主要工作涉及基于 Web 的跨端应用开发，包括 Web 端、移动端、桌面端、小程序端，以及部分 3D 数据展示和模型处理。</p>
<p>而在某银行信息科技部基础技术板块担任前端负责人的英楠同样也在关注跨端框架，他说：“最想学习和实战 Flutter。“</p>
<h5 id="发现-2：JavaScript-在大前端领域“独霸天下”"><a href="#发现-2：JavaScript-在大前端领域“独霸天下”" class="headerlink" title="发现 2：JavaScript 在大前端领域“独霸天下”"></a>发现 2：JavaScript 在大前端领域“独霸天下”</h5><p><img src="https://upload-images.jianshu.io/upload_images/10024246-1d0bc3a412be6e10?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>基于投票数据，我们发现在大前端领域编程语言使用情况上，JavaScript 以 78.5% 的得票率，排名第一。而 TypeScript 得票率为 42.9%，排名第二。</p>
<p>考虑到这两门编程语言都属于 JavaScript 生态，JavaScript 在大前端堪称“独霸天下”。前端程序员英楠在采访中称，使用最多的编程语言还是 JavaScript，因为工作主要还是面向 B 端，几乎全部项目都是用 JavaScript，公共组件则是用 TypeScript 开发。</p>
<p>另一位前端程序员月熊则表示，自己在工作中使用最多的编程语言是 TypeScript，“相比 JavaScript，它有静态语法特性，更符合大规模、跨端协作项目的开发”。</p>
<p>前端程序员小吴说：“使用最多的编程语言是 JavaScript。自从有了 node.js 后，JavaScript 几乎可以处理任何业务逻辑，包含后端的数据增删查改、前端页面渲染和用户交互操作等。阿特伍德定律说，任何可以用 JavaScript 来写的应用，最终都将用 JavaScript 来写。”</p>
<h5 id="发现-3：选择编程语言最看重的是语言生态"><a href="#发现-3：选择编程语言最看重的是语言生态" class="headerlink" title="发现 3：选择编程语言最看重的是语言生态"></a>发现 3：选择编程语言最看重的是语言生态</h5><p><img src="https://upload-images.jianshu.io/upload_images/10024246-cf88ef49d29728ed?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>在选择编程语言时，最看重的因素是什么？答案是语言生态。语言生态得票率为 63.4%，排名第一。对前端开发者来说，语言生态是最看重的，它包括工具链的完备程度，库、框架等完善程度。生产效率得票率为 22.2%，排名第二，而语言的功能特性则排名第三。</p>
<p>发现 4：Vue 和 React 是最流行的前端开发框架</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-8b837ea731ef04b9?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>基于投票数据，我们发现 Vue.js 以 46.5% 的得票率排名第一，被视为最流行的前端开发框架。而 React 紧随其后，以 31.5% 的得票率排名第二。Flutter 排名第三，得票率为 8.5%。</p>
<p>月熊在采访中表示，最常用的前端开发框架是 React，其生态圈较为完善，“编程习惯上更易于贴合工程化的需求”。</p>
<p>英楠同样是 React 的忠实用户，他说：“最常用的是 React。React 生态非常完善，满足了我们项目的一切需求，市面上能与抗衡的就只有 Vue 了。”</p>
<p>对前端程序员来说，编程语言或框架对他们的工作非常重要。月熊认为，不同编程语言或框架几乎决定了不同的生态圈，这会极大地影响到项目组织、团队组织以及第三方库的使用。他自述，他们团队早年间选用过 Angular 1，但后面在性能和升级上都碰到较大的困难。</p>
<p>英楠称，在 React 这类数据驱动试图的前端框架前，一个项目使用的是 JSP 渲染前端页面，前后端完全耦合，连开发一个简单的需求都非常痛苦，”后来，2018 年使用 Vue 将老项目进行了渐进式迁移，开发效率提升至少 5 倍“。</p>
<p>小吴说：“React 和 Vue 各占一半。比较严谨的业务逻辑，使用 React 和 TypeScript。要快速开发的小项目则使用 Vue 2。此前还重度使用过 Angular.js。”</p>
<h5 id="大前端的未来与前端程序员的核心能力"><a href="#大前端的未来与前端程序员的核心能力" class="headerlink" title="大前端的未来与前端程序员的核心能力"></a>大前端的未来与前端程序员的核心能力</h5><p>由国内业界发明的技术名词“大前端”如今逐渐成为前端领域的大趋势。而前端未来会如何发展？在月熊看来，随着前端项目的不断增大，前端在未来应具备更强大的运行能力，可以提供更复杂的交互，也期待 VR/AR 时代的到来。英楠则表示，近些年，前端井喷式增长得到缓和，但人才缺口仍然巨大，希望在 AI+ 前端领域有更多突破，解决绝大多数的重复劳动，解放前端人员的生产力。</p>
<p>当然，大前端的变化反过来也会影响前端程序员。现在的大前端有点“全栈”的味道，并且以前的胶水代码越来越行不通，前端程序员也会强化自己的工程思维，具备体系化知识，并且能熟练使用各种框架。</p>
<p>英楠表示，未来最看重的前端程序员核心能力就是工程师能力。“我认为前端程序员未来的核心能力，除了前端专业技能外，工程化思维、分析问题和解决问题的能力以及学习能力都非常关键。“他说。</p>
<p>而月熊认为，前端程序员未来要具备的核心能力分三部分：</p>
<ul>
<li>第一，编程基本素养，包括但不限于编程范式、设计模式、数据结构与算法等；</li>
<li>第二，工程化能力，能从编写简单的页面到 Hold 住大型项目；</li>
<li>第三，产品 / 交互的感知能力，能理解产品设计，能自觉践行某些交互优化的原则 / 范式，为用户提供更好的交互体验。<blockquote>
<p>原文：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUxMzcxMzE5Ng==&amp;mid=2247509000&amp;idx=1&amp;sn=6058104917c06b0c4fa47fa54ceb549a&amp;chksm=f952114bce25985d2ff774bac1e952f56dca4b149bdc811505983cb0a1460615e9100ef50520&amp;scene=27#wechat_redirect">https://mp.weixin.qq.com/s?__biz=MzUxMzcxMzE5Ng==&amp;mid=2247509000&amp;idx=1&amp;sn=6058104917c06b0c4fa47fa54ceb549a&amp;chksm=f952114bce25985d2ff774bac1e952f56dca4b149bdc811505983cb0a1460615e9100ef50520&amp;scene=27#wechat_redirect</a></p>
</blockquote>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lzhwweb.github.io/nirvana/javascript/%E5%89%8D%E7%AB%AF/H5%E9%A1%B9%E7%9B%AE%E9%80%82%E9%85%8D%E7%B3%BB%E7%BB%9F%E6%B7%B1%E8%89%B2%E6%A8%A1%E5%BC%8F%E6%96%B9%E6%A1%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/nirvana/images/headphoto.jpeg">
      <meta itemprop="name" content="nirvana">
      <meta itemprop="description" content="个人学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="涅槃快乐是金">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/nirvana/javascript/%E5%89%8D%E7%AB%AF/H5%E9%A1%B9%E7%9B%AE%E9%80%82%E9%85%8D%E7%B3%BB%E7%BB%9F%E6%B7%B1%E8%89%B2%E6%A8%A1%E5%BC%8F%E6%96%B9%E6%A1%88/" class="post-title-link" itemprop="url">H5项目适配系统深色模式方案</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-06-10 16:37:36 / 修改时间：17:02:24" itemprop="dateCreated datePublished" datetime="2021-06-10T16:37:36+08:00">2021-06-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/nirvana/categories/javascript/" itemprop="url" rel="index"><span itemprop="name">javascript</span></a>
        </span>
    </span>

  
    <span id="/nirvana/javascript/%E5%89%8D%E7%AB%AF/H5%E9%A1%B9%E7%9B%AE%E9%80%82%E9%85%8D%E7%B3%BB%E7%BB%9F%E6%B7%B1%E8%89%B2%E6%A8%A1%E5%BC%8F%E6%96%B9%E6%A1%88/" class="post-meta-item leancloud_visitors" data-flag-title="H5项目适配系统深色模式方案" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.1k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h2><blockquote>
<p>随着 iOS 13 的发布，深色模式（Dark Mode）越来越多地出现在大众的视野中，支持深色模式已经成为现代移动应用和网站的一个潮流，前段时间更是因为微信的适配再度引起热议。深色模式不仅可以大幅减少电量的消耗，减弱强光对比,还能 提供更好的可视性和沉浸感。</p>
</blockquote>
<p><code>如何切换深色模式</code></p>
<ul>
<li>iOS：“设置”–“显示与亮度”–“外观”，选择“深色”</li>
<li>Android：“系统设置”–“显示”–“深色模式”。</li>
</ul>
<h2 id="二、问题"><a href="#二、问题" class="headerlink" title="二、问题"></a>二、问题</h2><p>如果系统设置了深色模式，H5页面不做相应的处理，会出现背景色冲突、深色文字显示异常，深色图标显示异常等一些显示上的问题。</p>
<p>所以，需要对深色模式进行一些适配。</p>
<h2 id="三、H5项目适配深色模式方案"><a href="#三、H5项目适配深色模式方案" class="headerlink" title="三、H5项目适配深色模式方案"></a>三、H5项目适配深色模式方案</h2><h3 id="1-声明-color-scheme"><a href="#1-声明-color-scheme" class="headerlink" title="1.声明 color-scheme"></a>1.声明 color-scheme</h3><p><code>color-scheme</code>有两种方式。</p>
<h5 id="1-1-meta"><a href="#1-1-meta" class="headerlink" title="1.1 meta"></a>1.1 meta</h5><p>在head中声明<code>&lt;meta name=&quot;color-scheme&quot; content=&quot;light dark&quot;&gt;</code>，声明当前页面支持 light 和 dark 两种模式，系统切换到深色模式时，浏览器默认样式也会切换到深色；</p>
<h5 id="1-2-CSS"><a href="#1-2-CSS" class="headerlink" title="1.2 CSS"></a>1.2 CSS</h5><p>下面的 css 同样可以实现上面 meta 声明的效果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">:root &#123;</span><br><span class="line">    color-scheme: light dark;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：此声明并非为页面做自动适配，只影响浏览器默认样式<br>更多信息可查阅 W3C 文档 《CSS Color Adjustment Module Level 1》</p>
<h3 id="2-通过-CSS-媒体查询"><a href="#2-通过-CSS-媒体查询" class="headerlink" title="2.通过 CSS 媒体查询"></a>2.通过 CSS 媒体查询</h3><p><code>prefers-color-scheme</code> CSS 媒体特性用于检测用户是否有将系统的主题色设置为亮色或者暗色。</p>
<ul>
<li><code>no-preference</code><br>表示系统未得知用户在这方面的选项。在布尔值上下文中，其执行结果为 false。</li>
<li><code>light</code><br>表示用户已告知系统他们选择使用浅色主题的界面。</li>
<li><code>dark</code><br>表示用户已告知系统他们选择使用暗色主题的界面。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">:root &#123;</span><br><span class="line">    color-scheme: light dark;</span><br><span class="line">    background: white;</span><br><span class="line">    color: black;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@media (prefers-color-scheme: dark) &#123;</span><br><span class="line">    :root &#123;</span><br><span class="line">        background: black;</span><br><span class="line">        color: white;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;颜色较多的情况，建议使用CSS变量对颜色值进行管理</span><br></pre></td></tr></table></figure>
<h3 id="3-图片适配"><a href="#3-图片适配" class="headerlink" title="3.图片适配"></a>3.图片适配</h3>利用<code>picture+source</code>标签，设置不同模式下的图片 url。</li>
</ul>
<p>HTML <code>&lt;picture&gt;</code>元素通过包含零或多个 <code>&lt;source&gt; </code>元素和一个<code>&lt;img&gt;</code>元素来为不同的显示/设备场景提供图像版本。浏览器会选择最匹配的子 <code>&lt;source&gt;</code> 元素，如果没有匹配的，就选择 <code>&lt;img&gt;</code> 元素的 src 属性中的URL。然后，所选图像呈现在<code>&lt;img&gt;</code>元素占据的空间中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;picture&gt;</span><br><span class="line">    &lt;!-- 深色模式下的图片 --&gt;</span><br><span class="line">    &lt;source srcset&#x3D;&quot;dark.jpg&quot; media&#x3D;&quot;(prefers-color-scheme: dark)&quot; &#x2F;&gt;</span><br><span class="line">    &lt;!-- 默认模式下的图片 --&gt;</span><br><span class="line">    &lt;img src&#x3D;&quot;light.jpg&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;picture&gt;</span><br></pre></td></tr></table></figure>
<h3 id="4-JavaScript中判断当前模式-amp-监听模式变化"><a href="#4-JavaScript中判断当前模式-amp-监听模式变化" class="headerlink" title="4. JavaScript中判断当前模式&amp;监听模式变化"></a>4. JavaScript中判断当前模式&amp;监听模式变化</h3><h5 id="4-1-matchMedia"><a href="#4-1-matchMedia" class="headerlink" title="4.1 matchMedia"></a>4.1 matchMedia</h5><p>Window 的<code>matchMedia() </code>方法返回一个新的<code>MediaQueryList </code>对象，表示指定的媒体查询 (en-US)字符串解析后的结果。返回的<code>MediaQueryList </code>可被用于判定Document是否匹配媒体查询，或者监控一个<code>document</code> 来判定它匹配了或者停止匹配了此媒体查询。</p>
<h5 id="4-2-addListener"><a href="#4-2-addListener" class="headerlink" title="4.2 addListener()"></a>4.2 addListener()</h5><p><code>MediaQueryList</code>接口的<code>addListener()</code>方法向<code>MediaQueryListener</code>添加一个侦听器，该侦听器将运行自定义回调函数以响应媒体查询状态的更改。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#JavaScript监听判断</span><br><span class="line">const mediaQuery &#x3D; window.matchMedia(&#39;(prefers-color-scheme: dark)&#39;)</span><br><span class="line"></span><br><span class="line">function darkModeHandler() &#123;</span><br><span class="line">    if (mediaQuery.matches) &#123;</span><br><span class="line">        console.log(&#39;现在是深色模式&#39;)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        console.log(&#39;现在是浅色模式&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 判断当前模式</span><br><span class="line">darkModeHandler()</span><br><span class="line">&#x2F;&#x2F; 监听模式变化</span><br><span class="line">mediaQuery.addListener(darkModeHandler)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>原文：<a target="_blank" rel="noopener" href="https://jishuin.proginn.com/p/763bfbd567d0">https://jishuin.proginn.com/p/763bfbd567d0</a></p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lzhwweb.github.io/nirvana/javascript/%E5%89%8D%E7%AB%AF/%E4%BD%BF%E7%94%A8Whistle%E8%B0%83%E8%AF%95Web/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/nirvana/images/headphoto.jpeg">
      <meta itemprop="name" content="nirvana">
      <meta itemprop="description" content="个人学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="涅槃快乐是金">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/nirvana/javascript/%E5%89%8D%E7%AB%AF/%E4%BD%BF%E7%94%A8Whistle%E8%B0%83%E8%AF%95Web/" class="post-title-link" itemprop="url">使用Whistle调试Web</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-06-10 16:36:28 / 修改时间：17:02:24" itemprop="dateCreated datePublished" datetime="2021-06-10T16:36:28+08:00">2021-06-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/nirvana/categories/javascript/" itemprop="url" rel="index"><span itemprop="name">javascript</span></a>
        </span>
    </span>

  
    <span id="/nirvana/javascript/%E5%89%8D%E7%AB%AF/%E4%BD%BF%E7%94%A8Whistle%E8%B0%83%E8%AF%95Web/" class="post-meta-item leancloud_visitors" data-flag-title="使用Whistle调试Web" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>3.2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><a href="https://link.zhihu.com/?target=https://github.com/avwo/whistle">Whistle</a> 是一款 Web 调试工具，使用 Whistle，可以修改一个 HTTP/HTTPS 请求的方方面面，我们可以通过它 Mock 数据、修改请求延迟时间、修改静态文件等等。市面上有许多 Web 调试工具，比如在 Windows 上比较有名的 Fiddler，比如说 Charles 等等。而 Whistle 具有开源免费、配置简单、以及跨平台等特点，在使用它一段时间之后，我认为在前端开发中它完全能够代替上述的工具。下面让我们结合实际场景来看看 Whistle 能帮助我们做什么吧。</p>
<h2 id="快速起步"><a href="#快速起步" class="headerlink" title="快速起步"></a>快速起步</h2><p>在开始使用 Whistle 之前，需要安装以及进行一些配置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 1\. 下载</span><br><span class="line">npm i -g whistle</span><br><span class="line"># 2\. 启动 whistle 默认监听在 8899 端口</span><br><span class="line">w2 start</span><br></pre></td></tr></table></figure>

<p>启动 Whistle 之后，我们访问 <code>localhost:8899</code> 就可以看到 Whistle 的配置界面了，如图，界面左侧有 4 个菜单项，Network 可以查看请求响应的详情。Rules 是规则配置的地方，关于规则是什么，我们放到后面讲。在 Values 中我们可以配置 key-value 数据，之后可以在 Rules 使用对应的键值进行引用。Plugins 里展示了我们额外安装的 Whistle 插件，并且可以对这些插件进行配置。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-3b8f23d096a03b1c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>Whistle 的规则主要由两部分组成，pattern 和 operatorURI，Whistle 使用 pattern 对请求进行匹配，并对匹配上的请求上应用 operatorURI 定义的操作，通过不同的 operatorURI，可以做到替换请求体、响应体、响应码等等事情。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-692ec2b174912915.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>为了让我们的请求被 Whistle 代理，还需配置 HTTP 代理或者 HTTPS 代理到 Whistle，如果使用 Chrome 浏览器，推荐 <a href="https://link.zhihu.com/?target=https://chrome.google.com/webstore/detail/proxy-switchyomega/padekgcemlokbadohgkifijomclgjgif?hl=zh-CN">SwitchyOmega</a> 配置代理，这样更加灵活。另外，为了能够抓取 HTTPS 协议的包，我们还需要下载<a href="https://link.zhihu.com/?target=https://wproxy.org/whistle/webui/https.html">安装并信任 Whistle 的 HTTPS 证书</a>，其中，关于 iOS 的证书配置，我之前写了一篇</p>
<p>关于 Whistle 更加详细的配置方法，请参考 Whistle 的<a href="https://link.zhihu.com/?target=https://wproxy.org/whistle/">官方文档</a>。</p>
<p>下面，让我们看看 Whistle 的一些功能。</p>
<h2 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">example.com localhost:8000</span><br></pre></td></tr></table></figure>

<p>通过配置这样的规则，当我们访问 <code>example.com</code> 的时候，实际请求会打到 <code>localhost:8000</code>。</p>
<p>如果我们的 API 是同源的，并且我们只想将静态资源的请求替换为本地开发中的，还可以这样配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 假设所有 API 路径为 &#x2F;api，仍然走实际地址</span><br><span class="line">example.com&#x2F;api example.com&#x2F;api</span><br><span class="line"># 其他请求到本地</span><br><span class="line">example.com localhost:8000</span><br></pre></td></tr></table></figure>

<h2 id="Mock-数据"><a href="#Mock-数据" class="headerlink" title="Mock 数据"></a>Mock 数据</h2><p>日常开发中，我们经常需要对后端接口进行 Mock，这样就不需要依赖后端实际部署情况了，或者我们需要测试一些边缘情况，Mock 这些边缘情况就可以免除为测试这样的边缘链路需要做的许多麻烦事情。最简单的 Mock 可以针对一个 pattern 替换响应体和响应码等等。如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Rules</span><br><span class="line"># 将 example.com&#x2F;api&#x2F;user 接口的响应内容替换为 user.json 中的内容，并将响应码替换成 200</span><br><span class="line"># 其中，user.json 在 Values 面板中保存</span><br><span class="line">example.com&#x2F;api&#x2F;user resBody:&#x2F;&#x2F;&#123;user.json&#125; replaceStatus:&#x2F;&#x2F;200</span><br></pre></td></tr></table></figure>

<p>我们甚至可以设定请求的响应延时，只需要再加一个 <code>resDelay</code> 的 operatorURI：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 10s 后返回</span><br><span class="line">example.com&#x2F;api&#x2F;user resBody:&#x2F;&#x2F;&#123;user.json&#125; replaceStatus:&#x2F;&#x2F;200 resDelay:&#x2F;&#x2F;10000</span><br></pre></td></tr></table></figure>

<p>可能有时候会有更加复杂的 Mock 需求，比如几个接口之间互相有关联，需要跑通一个完整的链路可能需要一些定制的逻辑。Whistle 提供了很多插件，其中有一个能够提供非常强大 Mock 能力的插件——<a href="https://link.zhihu.com/?target=https://github.com/whistle-plugins/whistle.vase">whistle.vase</a>。使用这个插件，我们甚至可以直接写 JS 代码，根据我们的具体请求参数作出各种具体逻辑。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -g whistle.vase</span><br></pre></td></tr></table></figure>

<p>在安装完之后，就可以在 Plugins 中对其进行配置了。</p>
<h2 id="移动端调试"><a href="#移动端调试" class="headerlink" title="移动端调试"></a>移动端调试</h2><p>移动端最佳的调试方案应该是直接连接到桌面浏览器的调试工具，比如说移动端的 Safari 可以直接连接到 Safari 上，安卓的 Chrome 可以直接连接到 Chrome 的 DevTools 上，这种调试方法所得到的调试功能最多最强大。但是，并不是所有情况下我们都可以使用这种方式进行调试的，此时就可以使用更加通用的方法，下面介绍两种借助 Whistle 进行移动端调试的方案。</p>
<p>Whistle 自带了 <a href="https://link.zhihu.com/?target=https://github.com/nupthale/weinre">Weinre</a>，可以进行移动端远程调试，开启该功能很简单，只需在需要调试的 pattern 后面加上如下operatorURI：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">www.zhihu.com weinre:&#x2F;&#x2F;debug</span><br></pre></td></tr></table></figure>

<p>其中 <code>debug</code> 为类别（可以自由指定名称），方便我们对各个页面进行分类，这样一来，我们在 Whislte 的应用界面的 Weinre 菜单中就可以看到 <code>debug</code> 了，点击 <code>debug</code>，在手机上打开对应的页面，就可以愉快地进行调试了。</p>
<p>另一种方案是使用移动端的调试面板（引入特定的包），目前有许多移动端的调试面板工具可以满足轻量级的调试需求，比如 <a href="https://link.zhihu.com/?target=https://github.com/Tencent/vConsole">vConsole</a>、<a href="https://link.zhihu.com/?target=https://github.com/liriliri/eruda">Eruda</a> 等等。不过，我们的代码中不一定有加载这些调试包（比如我们生产环境代码），我们可以借助 Whistle 在 HTML 响应体后面增加一段加载移动端调试面板的代码。比如说我们使用 Eruda，那么我们可以在 Values 中增加下面一段代码，取名为 load_eruda.js：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(function() &#123;</span><br><span class="line">  var script &#x3D; document.createElement(&#39;script&#39;);</span><br><span class="line">  script.onload &#x3D; function() &#123;</span><br><span class="line">    eruda.init();</span><br><span class="line">  &#125;;</span><br><span class="line">  script.src &#x3D; &#39;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;eruda&#39;;</span><br><span class="line">  document.body.appendChild(script);</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>假设我们要调试知乎（<a target="_blank" rel="noopener" href="http://www.zhihu.com/">http://www.zhihu.com</a>），利用 <code>jsAppend</code> 将这段自定义脚本加到 HTML 后方，像这样增加规则：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">www.zhihu.com jsAppend:&#x2F;&#x2F;&#123;load_eruda.js&#125;</span><br></pre></td></tr></table></figure>

<p>打开 <code>www.zhihu.com</code>，就可以看到 Eruda 的调试按钮了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是对 Whistle 的介绍，Whistle 提供了超过 60+ 个协议（operatorURI），可以满足我们平时在 Web 调试过程中各式各样的需求，可以查看 Whistle 的文档进一步探索。当然，目前 Whistle 也存在一些不足，比如现在还不支持 HTTP/2 的抓包（作者有计划支持），比如 Mock 数据如何与团队共享的问题。不过，作为一款在积极开发且功能在我看来已经比较完善的应用，非常推荐大家一试。</p>
<h2 id="附：其他类似工具"><a href="#附：其他类似工具" class="headerlink" title="附：其他类似工具"></a>附：其他类似工具</h2><ol>
<li> <a href="https://link.zhihu.com/?target=https://www.wireshark.org/">Wireshark</a> - 网络数据包分析软件，网络协议栈的各个层的数据都可以很方便地查看。</li>
<li> <a href="https://link.zhihu.com/?target=https://termshark.io/">Termshark</a> - 「终端版」的 Wireshark</li>
<li> <a href="https://link.zhihu.com/?target=https://www.charlesproxy.com/">Charles</a> - 一款老牌 HTTP/HTTPS 抓包调试工具</li>
<li> <a href="https://link.zhihu.com/?target=https://www.telerik.com/fiddler">Fiddler</a> - 又一款免费的 Web 调试工具</li>
<li> <a href="https://link.zhihu.com/?target=https://mitmproxy.org/">mitmproxy</a> - 一款开源免费的交互式的 HTTPS 代理</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lzhwweb.github.io/nirvana/javascript/%E5%89%8D%E7%AB%AF/%E6%A6%82%E8%A6%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E7%89%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/nirvana/images/headphoto.jpeg">
      <meta itemprop="name" content="nirvana">
      <meta itemprop="description" content="个人学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="涅槃快乐是金">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/nirvana/javascript/%E5%89%8D%E7%AB%AF/%E6%A6%82%E8%A6%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E7%89%88/" class="post-title-link" itemprop="url">概要设计 - 模版</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-06-10 16:35:18 / 修改时间：17:02:24" itemprop="dateCreated datePublished" datetime="2021-06-10T16:35:18+08:00">2021-06-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/nirvana/categories/javascript/" itemprop="url" rel="index"><span itemprop="name">javascript</span></a>
        </span>
    </span>

  
    <span id="/nirvana/javascript/%E5%89%8D%E7%AB%AF/%E6%A6%82%E8%A6%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E7%89%88/" class="post-meta-item leancloud_visitors" data-flag-title="概要设计 - 模版" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>858</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="概要设计"><a href="#概要设计" class="headerlink" title="概要设计 -"></a>概要设计 -</h1><p>系统名称：*****<br>文档修订历史<br>|版本号 | 作者 |备注    |修订日期|<br> |  —-  | —-  |  —-  | —-  |<br>|v1.0|****|创建模版    |2020-7-29|</p>
<p> </p>
<h2 id="1-需求背景"><a href="#1-需求背景" class="headerlink" title="1. 需求背景"></a>1. 需求背景</h2><p>【【描述需求背景或者开发重构的目的/出发点】<br>原先大家写文档都是本机写文档，然后评审时统一交给主持人进行投影，文档版本管理也比较混乱</p>
<h2 id="2-需求分析"><a href="#2-需求分析" class="headerlink" title="2. 需求分析"></a>2. 需求分析</h2><h5 id="2-1-产品需求分析【产品需求适用】"><a href="#2-1-产品需求分析【产品需求适用】" class="headerlink" title="2.1. 产品需求分析【产品需求适用】"></a>2.1. 产品需求分析【产品需求适用】</h5><p>【用于描述对产品提出的需求的理解和分析：产品定位、新增功能、业务目标等，避免对需求的理解和产品不一致，导致做无用功】<br>XXXX。。。</p>
<h5 id="2-2-技术技术需求分析【技术优化适用】"><a href="#2-2-技术技术需求分析【技术优化适用】" class="headerlink" title="2.2. 技术技术需求分析【技术优化适用】"></a>2.2. 技术技术需求分析【技术优化适用】</h5><p>【用于描述对技术团队提出的技术需求的理解和分析：技术债务清理、市场反馈问题改善、性能体验优化、技术指标达成、技术方案更新等。此处应包含技术改善项目和大致的实现策略】<br>XXXX。。。</p>
<h2 id="3-整体实现方案"><a href="#3-整体实现方案" class="headerlink" title="3. 整体实现方案"></a>3. 整体实现方案</h2><h5 id="3-1-整体框架图"><a href="#3-1-整体框架图" class="headerlink" title="3.1. 整体框架图"></a>3.1. 整体框架图</h5><p>【展示应用整体的框架图，包括整体结构、应用分层、模块解耦】<br>XXXX。。。
 </p>
<h5 id="3-2-核心功能流程图"><a href="#3-2-核心功能流程图" class="headerlink" title="3.2. 核心功能流程图"></a>3.2. 核心功能流程图</h5><p>【展示新增核心功能的流程图，帮助梳理整个功能的逻辑，减少编码过程中由于前期考虑不周导致的不稳定性和随机bug】<br>XXXX。。。
 </p>
<h2 id="4-模块设计"><a href="#4-模块设计" class="headerlink" title="4. 模块设计"></a>4. 模块设计</h2><p>【根据原型或者UX稿识别需要新增或修改的页面、模块、组件，尽量解耦】<br>XXXX。。。
 </p>
<h2 id="5-接口设计"><a href="#5-接口设计" class="headerlink" title="5. 接口设计"></a>5. 接口设计</h2><p>【列出所有关联接口及功能描述，详细参数交互后续补充，标注新增或修改】<br>XXXX。。。</p>
<h2 id="6-异常流程设计"><a href="#6-异常流程设计" class="headerlink" title="6.异常流程设计"></a>6.异常流程设计</h2><p>【列出所有交互异常流程处理方案，接口异常处理方案】</p>
<h2 id="7-风险及应对方案"><a href="#7-风险及应对方案" class="headerlink" title="7. 风险及应对方案"></a>7. 风险及应对方案</h2><p>【列出开发相关的风险项：资损风险、安全风险、指标达成风险、进度风险等，以及针对各项风险的应对方案。如设计中包含，需详细说明；如不包含，请写明【确认无此风险】</p>
<h5 id="7-1-资损风险分析"><a href="#7-1-资损风险分析" class="headerlink" title="7.1. 资损风险分析"></a>7.1. 资损风险分析</h5><p>XXXX。。。
 </p>
<h5 id="7-2-安全风险分析"><a href="#7-2-安全风险分析" class="headerlink" title="7.2. 安全风险分析"></a>7.2. 安全风险分析</h5><p>XXXX。。。
 </p>
<h5 id="7-3-接口改动是否兼容老版本"><a href="#7-3-接口改动是否兼容老版本" class="headerlink" title="7.3. 接口改动是否兼容老版本"></a>7.3. 接口改动是否兼容老版本</h5><p>XXXX。。。
 </p>
<h5 id="7-4-代码改动是否兼容老版"><a href="#7-4-代码改动是否兼容老版" class="headerlink" title="7.4. 代码改动是否兼容老版"></a>7.4. 代码改动是否兼容老版</h5><p>XXXX。。。
 </p>
<h5 id="7-5-路由修改删除是否已检查页面投放情况"><a href="#7-5-路由修改删除是否已检查页面投放情况" class="headerlink" title="7.5. 路由修改删除是否已检查页面投放情况"></a>7.5. 路由修改删除是否已检查页面投放情况</h5><p>XXXX。。。
 </p>
<h5 id="7-6-其它风险说明"><a href="#7-6-其它风险说明" class="headerlink" title="7.6. 其它风险说明"></a>7.6. 其它风险说明</h5><p>XXXX。。。
 </p>
<h2 id="8-各节点里程碑"><a href="#8-各节点里程碑" class="headerlink" title="8. 各节点里程碑"></a>8. 各节点里程碑</h2><p>【列出各领域的关键事项及时间节点，以便各领域协同、项目透明、进度可预知】<br>XXXX。。。
 </p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lzhwweb.github.io/nirvana/javascript/%E5%89%8D%E7%AB%AF/canvas%E5%89%8D%E7%AB%AF%E5%9B%BE%E7%89%87%E5%90%88%E6%88%90-Fabric/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/nirvana/images/headphoto.jpeg">
      <meta itemprop="name" content="nirvana">
      <meta itemprop="description" content="个人学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="涅槃快乐是金">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/nirvana/javascript/%E5%89%8D%E7%AB%AF/canvas%E5%89%8D%E7%AB%AF%E5%9B%BE%E7%89%87%E5%90%88%E6%88%90-Fabric/" class="post-title-link" itemprop="url">canvas前端图片合成-Fabric.js</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-06-10 16:33:52 / 修改时间：17:02:24" itemprop="dateCreated datePublished" datetime="2021-06-10T16:33:52+08:00">2021-06-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/nirvana/categories/javascript/" itemprop="url" rel="index"><span itemprop="name">javascript</span></a>
        </span>
    </span>

  
    <span id="/nirvana/javascript/%E5%89%8D%E7%AB%AF/canvas%E5%89%8D%E7%AB%AF%E5%9B%BE%E7%89%87%E5%90%88%E6%88%90-Fabric/" class="post-meta-item leancloud_visitors" data-flag-title="canvas前端图片合成-Fabric.js" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>757</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Fabric.js是一个可以简化Canvas程序编写的库,官方文档地址<a target="_blank" rel="noopener" href="http://fabricjs.com/docs/">http://fabricjs.com/docs/</a></p>
<p>暂时只支持纯图片的编辑合成</p>
<h6 id="支持设置画布的大小"><a href="#支持设置画布的大小" class="headerlink" title="支持设置画布的大小"></a>支持设置画布的大小</h6><p><img src="https://upload-images.jianshu.io/upload_images/10024246-e7ecd000a4d55435.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>点击上传背景图片按钮 上传背景图</p>
<p>使用new FileReader()方法，把本地图片转换成base64图片，并且push到data数据中</p>
<p>点击添加画布按钮，push一条新的画布数据，数据是一个对象，包含canvas字段，用来储存Fabric实例，支持图片拖拽的形式把图片添加到画布中</p>
<p>拖动图片的时候使用dragend监听拖拽结束后的事件，在画布中使用dragenter监听鼠标是否进入，如果进入并且拖拽动作结束，获取图片的base64地址并且通过new fabric.Image.fromURL方法添加图片，并且捕获鼠标的坐标减去鼠标距离图片顶部和左边的距离，就得到图片在canvas中具体的位置，通过设置top和left</p>
<p>通过.on()方法监听图片旋转，缩放，方法接受2个参数，第一个为事件名，第二个为回调函数</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>“mouse:down”</td>
<td>鼠标按下时</td>
</tr>
<tr>
<td>“mouse:up”</td>
<td>鼠标抬起时</td>
</tr>
<tr>
<td>“mouse:move”</td>
<td>鼠标移动时</td>
</tr>
<tr>
<td>“object:modified”</td>
<td>对象修改后</td>
</tr>
<tr>
<td>“object:moving”</td>
<td>对象移动</td>
</tr>
<tr>
<td>“object:added”</td>
<td>对象被加入</td>
</tr>
<tr>
<td>“object:selected”</td>
<td>对象被选中</td>
</tr>
<tr>
<td>“object:rotating”</td>
<td>对象被旋转</td>
</tr>
<tr>
<td>“object:scaling”</td>
<td>对象缩放</td>
</tr>
</tbody></table>
<h4 id="判断是否选中对象，使用以下方法调整图片层级"><a href="#判断是否选中对象，使用以下方法调整图片层级" class="headerlink" title="判断是否选中对象，使用以下方法调整图片层级"></a>判断是否选中对象，使用以下方法调整图片层级</h4><table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>bringForward()</td>
<td>图层上移</td>
</tr>
<tr>
<td>sendBackwards()</td>
<td>图层下移</td>
</tr>
<tr>
<td>bringToFront()</td>
<td>图层置顶</td>
</tr>
<tr>
<td>sendToBack()</td>
<td>图层置底</td>
</tr>
</tbody></table>
<h4 id="编辑图片，下面小画布列表也会同时等比例变化"><a href="#编辑图片，下面小画布列表也会同时等比例变化" class="headerlink" title="编辑图片，下面小画布列表也会同时等比例变化"></a>编辑图片，下面小画布列表也会同时等比例变化</h4><p>先获取大画布和小画布的比例，按照画布比例缩放移动小画布图片</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lzhwweb.github.io/nirvana/javascript/%E5%89%8D%E7%AB%AF/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%99%BB%E5%BD%95%E3%80%81%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF%E7%9B%B8%E5%85%B3%E6%8E%A5%E5%8F%A3%E8%B0%83%E6%95%B4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/nirvana/images/headphoto.jpeg">
      <meta itemprop="name" content="nirvana">
      <meta itemprop="description" content="个人学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="涅槃快乐是金">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/nirvana/javascript/%E5%89%8D%E7%AB%AF/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%99%BB%E5%BD%95%E3%80%81%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF%E7%9B%B8%E5%85%B3%E6%8E%A5%E5%8F%A3%E8%B0%83%E6%95%B4/" class="post-title-link" itemprop="url">小程序登录、用户信息相关接口调整</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-06-10 16:33:08 / 修改时间：17:02:24" itemprop="dateCreated datePublished" datetime="2021-06-10T16:33:08+08:00">2021-06-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/nirvana/categories/javascript/" itemprop="url" rel="index"><span itemprop="name">javascript</span></a>
        </span>
    </span>

  
    <span id="/nirvana/javascript/%E5%89%8D%E7%AB%AF/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%99%BB%E5%BD%95%E3%80%81%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF%E7%9B%B8%E5%85%B3%E6%8E%A5%E5%8F%A3%E8%B0%83%E6%95%B4/" class="post-meta-item leancloud_visitors" data-flag-title="小程序登录、用户信息相关接口调整" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>216</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>微信小程序都无法显示用户头像了，昵称还都变成了【微信用户】，后来查找微信的官方文档发现，以前用的getuserinfo的接口更新了。现在这个接口只能获取匿名的一些信息，而不再像以前一样，能获取到用户的基本信息了。<br>既然找到了问题的原因，那么就好解决了。<br>在授权的页面，将之前的getuserinfo 更换成getUserProfile这个接口就可以了，然后将信息重新对接到以前的逻辑里面。<br>详细信息参考：<a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/community/develop/doc/000cacfa20ce88df04cb468bc52801">小程序登录、用户信息相关接口调整说明</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lzhwweb.github.io/nirvana/javascript/%E5%89%8D%E7%AB%AF/%E5%B0%8F%E7%B1%B3Web%E5%89%8D%E7%AB%AFJavaScript%E9%9D%A2%E8%AF%95%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/nirvana/images/headphoto.jpeg">
      <meta itemprop="name" content="nirvana">
      <meta itemprop="description" content="个人学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="涅槃快乐是金">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/nirvana/javascript/%E5%89%8D%E7%AB%AF/%E5%B0%8F%E7%B1%B3Web%E5%89%8D%E7%AB%AFJavaScript%E9%9D%A2%E8%AF%95%E9%A2%98/" class="post-title-link" itemprop="url">小米Web前端JavaScript面试题</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-06-10 16:32:11 / 修改时间：17:02:25" itemprop="dateCreated datePublished" datetime="2021-06-10T16:32:11+08:00">2021-06-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/nirvana/categories/javascript/" itemprop="url" rel="index"><span itemprop="name">javascript</span></a>
        </span>
    </span>

  
    <span id="/nirvana/javascript/%E5%89%8D%E7%AB%AF/%E5%B0%8F%E7%B1%B3Web%E5%89%8D%E7%AB%AFJavaScript%E9%9D%A2%E8%AF%95%E9%A2%98/" class="post-meta-item leancloud_visitors" data-flag-title="小米Web前端JavaScript面试题" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.8k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>一、<br>请定义这样一个函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function repeat (func, times, wait) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数能返回一个新函数，比如这样用<br>var repeatedFun = repeat(alert, 10, 5000)<br>调用这个 repeatedFun (“hellworld”)<br>会alert十次 helloworld, 每次间隔5秒<br>二、<br>写一个函数stringconcat， 要求能</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var result1 &#x3D; stringconcat(&quot;a&quot;, &quot;b&quot;)  result1 &#x3D; &quot;a+b&quot;</span><br><span class="line">var stringconcatWithPrefix &#x3D; stringconcat.prefix(&quot;hellworld&quot;);</span><br><span class="line">var result2 &#x3D; stringconcatWithPrefix(&quot;a&quot;, &quot;b&quot;)  result2 &#x3D; &quot;hellworld+a+b&quot;</span><br></pre></td></tr></table></figure>

<p>/**</p>
<ul>
<li><p>第一题</p>
</li>
<li><p>@param func</p>
</li>
<li><p>@param times</p>
</li>
<li><p>@param wait</p>
</li>
<li><p>@returns {repeatImpl}</p>
</li>
<li><p>/<br>function repeat (func, times, wait) {<br>  //不用匿名函数是为了方便调试<br>  function repeatImpl(){</p>
<pre><code>  var handle,
      _arguments = arguments,
      i = 0;
  handle = setInterval(function()&#123;
      i = i + 1;
      //到达指定次数取消定时器
      if(i === times)&#123;
          clearInterval(handle);
          return;
      &#125;
      func.apply(null, _arguments);
  &#125;,wait);
</code></pre>
<p>  }</p>
<p>  return repeatImpl;<br>}</p>
</li>
</ul>
<p>//测试用例<br>var repeatFun = repeat(alert, 4, 3000);</p>
<p>repeatFun(“hellworld”);</p>
<p>/**</p>
<ul>
<li><p>第二题</p>
</li>
<li><p>@returns {string}</p>
</li>
<li><p>/<br>function stringconcat(){<br>  var result = [];</p>
<p>  stringconcat.merge.call(null, result, arguments);<br>  return result.join(“+”);<br>}</p>
</li>
</ul>
<p>stringconcat.prefix = function(){<br>    var _arguments = [],<br>        _this = this;</p>
<pre><code>_this.merge.call(null, _arguments, arguments);

return function()&#123;
    var _args = _arguments.slice(0);

    _this.merge.call(null, _args, arguments);
    return _this.apply(null, _args);
&#125;;
</code></pre>
<p>};</p>
<p>stringconcat.merge = function(array, arrayLike){<br>    var i = 0;</p>
<pre><code>for(i = 0; i &lt; arrayLike.length; i++)&#123;
    array.push(arrayLike[i]);
&#125;
</code></pre>
<p>}</p>
<p>//测试用例<br>var result1 = stringconcat(“a”, “b”); //result1 = “a+b”<br>var result3 = stringconcat(“c”, “d”); //result1 = “a+b”</p>
<p>var stringconcatWithPrefix = stringconcat.prefix(“hellworld”);<br>var stringconcatWithPrefix1 = stringconcat.prefix(“hellworld1”);</p>
<p>var result2 = stringconcatWithPrefix(“a”, “b”); //result2 = “hellworld+a+b”<br>var result4 = stringconcatWithPrefix1(“c”, “d”); //result2 = “hellworld+a+b”</p>
<p>alert(result1);<br>alert(result2);<br>alert(result3);<br>alert(result4);</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lzhwweb.github.io/nirvana/javascript/%E5%89%8D%E7%AB%AF/%E6%88%91%E6%9B%BE%E7%9B%AE%E7%9D%B9%E7%9A%84%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%81%BE%E9%9A%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/nirvana/images/headphoto.jpeg">
      <meta itemprop="name" content="nirvana">
      <meta itemprop="description" content="个人学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="涅槃快乐是金">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/nirvana/javascript/%E5%89%8D%E7%AB%AF/%E6%88%91%E6%9B%BE%E7%9B%AE%E7%9D%B9%E7%9A%84%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%81%BE%E9%9A%BE/" class="post-title-link" itemprop="url">我曾目睹的微服务灾难</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-06-10 16:31:16 / 修改时间：17:02:25" itemprop="dateCreated datePublished" datetime="2021-06-10T16:31:16+08:00">2021-06-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/nirvana/categories/javascript/" itemprop="url" rel="index"><span itemprop="name">javascript</span></a>
        </span>
    </span>

  
    <span id="/nirvana/javascript/%E5%89%8D%E7%AB%AF/%E6%88%91%E6%9B%BE%E7%9B%AE%E7%9D%B9%E7%9A%84%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%81%BE%E9%9A%BE/" class="post-meta-item leancloud_visitors" data-flag-title="我曾目睹的微服务灾难" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>2014 年 Martin Fowler 发表了一篇关于微服务的文章，当时，我所在的团队正在构建面向服务的架构。这篇文章以及随后的炒作几乎影响了世界上所有的软件团队。那时，“Netflix OSS 栈”是世界上最酷的东西，它可以让世界各地的工程师在分布式系统中使用 Netflix 的经验。六年多过去了，如果我们现在来看看软件工程的工作，就会发现，其中大部分都是关于微服务的架构的。</p>
<p>炒作驱动开发</p>
<p>在 2010 年代的早期，很多组织都面临着软件开发周期的挑战。与其他 50、100 或 200 名工程师一起工作的人，他们在开发环境、QA 过程和程序部署方面都很困难。Martin Fowler 的《Continuous Delivery》（译注：尚无中译本）一书给许多团队带来了曙光，他们开始意识到，他们那“雄伟”的单体应用正给他们带来组织问题。所以，微服务对软件工程师很有吸引力。在一个大项目中引入持续交付或部署，而不是一开始就引入，更具有挑战性。</p>
<p>于是，团队开始拆分三个、十个、一百个微服务。其中大部分都使用“JSON over HTTP”（其他人可能会称之为 RESTful）API 来在这些组件之间实现远程调用。人们对 HTTP 协议非常熟悉，这看起来是一种将单体应用转换成小程序块的简单方法。这时，团队在 15 分钟之内就开始将代码部署到生产环境中。再也没有“哦，团队 A 破坏了 CI 管道，我不能部署我的代码”这样的情况了，这种感觉棒极了！</p>
<p>但是，大多数工程师都忘了，在解决软件架构层面的组织问题的同时，他们也引入了许多复杂性。分布式系统的谬误变得越来越明显，并很快让这些团队感到头疼。甚至那些已经在做客户机 / 服务器架构的公司，当他们的系统中有超过 10 个移动部分时，也会出现这种情况。</p>
<p>现实的反击</p>
<p>做出重大的架构改变并非没有成本。团队开始认识到，共享数据库是一种单点故障。后来他们意识到，他们各自的领域创造了一个全新的世界：最终的一致性就是一件事。在你提取数据的服务失败后该怎么办？很多问题开始堆积如山。高速开发速度的承诺被寻找错误、事件和数据一致性问题等压得喘不过气。另外一个问题是，工程师需要一种集中的日志和可观察性解决方案，在几十个服务中发现并纠正这些缺陷。</p>
<p>灾难 1：服务规模过小</p>
<p>随着开发人员创造力的爆发，每天都能创造出新的服务。一项新功能？咣当，让我们开始服务吧！突然之间，20 名工程师组成了维护 50 项服务的小组。一人负责一项服务还不够！一般而言，代码的问题在于它会“腐烂”。维护每一项服务都是要付出代价的。想象一下，在你的服务团队中传播一个库的升级。再想象一下，这些服务开始于不同的时间点，具有不同的架构、业务逻辑和所使用的框架之间的纠葛。那是多么可怕啊！解决这些问题的方法当然是有的。其中大部分都不能使用，而其他一些则需要花费很多 FTE 工作。</p>
<p>另外一种感觉是，我被告知，在服务 A 中部署新功能，并且在服务 B 中同时部署，或者当人们开始编写服务以生成 CSV 时。为什么会有人引入网络跳转，以产生世界上已知的文件格式？这东西谁来维护？有些团队正在受服务之苦。更糟的是，它在开发过程中会产生许多摩擦。与仅仅在 IDE 中查看一个项目不同，人们需要一次打开多个项目才能了解所有这些混乱的情况。</p>
<p>灾难 2：开发环境</p>
<p>我已经记不清有多少次有人走近我说：</p>
<p>“嘿，João。你有时间吗？我们需要改善开发环境了！大家都在抱怨这些事，可是都没用！”</p>
<p>这一问题涉及各个层面。移动开发者不需要在开发环境中开发功能就可以实现，或者后端开发者想要尝试他们的服务而不会破坏任何业务流程。如果有人想在生产之前在移动应用中测试整个过程，这也是一个问题。</p>
<p>跨分布式系统的开发环境存在一些问题，尤其是规模方面：</p>
<p>在云供应商中启动 200 个服务需要花费多少钱？你能做到吗？你是否能够启动运行他们所需的基础设施呢？</p>
<p>这需要多长时间呢？加入一个移动工程师开始开发一项功能，在给定的版本中有一组服务，当这些服务完成之后，有 10 个新版本被部署到生产中，那会怎样？</p>
<p>测试数据怎么样？你是否拥有所有服务的测试数据？在整个 Fleet 中都保持一致，所以用户和其他实体相匹配？</p>
<p>当你开发一个多租户、多区域的应用时，如何配置和功能标志？怎样跟上生产进度？若同时更改缺省值呢？</p>
<p>这些只是冰山一角而已。你可能会考虑将工程技术应用于这个问题。那也许行得通。但是，我怀疑大多数组织是否有足够大的规模来完成这项工作。这样做既麻烦又费钱。</p>
<p>灾难 3：端到端测试</p>
<p>不难想象，端到端测试和开发环境有相似的问题。在此之前，使用虚拟机或容器创建新的开发环境相对简单。同样，使用 Selenium 创建测试套件非常简单，它可以在部署新版本之前通过业务流并判断它们是否在工作。有了微服务，即使我们能够解决以上关于构建环境的所有问题，我们也不能再次宣布系统正在运行。我们至多可以这样说，运行特定版本的服务和特定配置的系统可以在特定的时间点上正常工作。真是大不相同啊！</p>
<p>要让人们相信我们只能进行几次这样的测试是非常困难的。而且在持续集成（Continuous Integration）流程中运行这些测试并不够。它们应该持续运行。它们应该针对生产运行情况发出相应的警报。我已经分享了无数次 Cindy Sridharan 的文章《在生产中测试，安全的方法》（Testing in production, the safe way），试图让人们理解我的观点。</p>
<p>灾难 4：巨大的共享数据库</p>
<p>一种简单的方法就是继续使用共享数据库，这样就可以避免单体应用，同时保证数据的一致性。这种方法不会增加操作负荷，而且可以轻松地一步一步地切割单体应用。但它也有相当大的缺点。这不仅是一个明显的单点故障，而且违背了面向服务架构的一些原则。你是否为每项服务创建一个用户？你是否具有细粒度的权限，以便服务 A 只能读写特定的表？假如某人不小心删除了索引怎么办？怎样知道有多少服务使用了不同的表？那扩容呢？</p>
<p>解决这些问题本身就变成了一个全新的难题。在技术上，这可能不是一个无关紧要的小问题，因为数据库经常比软件寿命长。用数据复制来解决问题——不管是 Kafaka、AWS DMS 还是其他什么——都需要你的工程团队理解数据库的细节，以及如何处理重复时间等等。</p>
<p>灾难 5：API 网关</p>
<p>在面向服务的架构中，API 网关是一种典型模式。它们帮助解耦后端与前端消费者。在实施端点聚合、速率限制或跨系统认证方面，它们也有用。近来，业界倾向于 backend-for-frontend（BFF，服务于前端的后端）的架构，将网关部署到前端的每个消费者群体（iOS、Android、Web 或桌面应用），从而解耦它们的进化。</p>
<p>和世界上的任何东西一样，人们开始有了新的创造性用例。有时这只是一个小技巧，使移动应用能够向后兼容。突然间，你的 API 网关变成了一个单点故障，因为人们发现在一个地方进行认证更加容易，其中还包含一些出乎意料的业务逻辑。现在，你不再有一个获得所有流量的单体应用，而是有一个自己开发的 Spring Boot 服务来或许所有的流量！会出什么问题呢？工程人员很快意识到这是个错误，但是由于存在大量的定制，有时候他们不能用它来取代无状态的、可扩展的定制。</p>
<p>当使用未分页的端点或返回大量响应时，就会导致 API 网关灾难。又或者，如果你在没有后备机制的情况下进行聚合，仅仅调用一次 API 就会“烧毁”你的网关。</p>
<p>灾难 6：超时、重试和弹性</p>
<p>分布式系统经常处于局部故障模式。如果服务 A 不能与服务 B 取得联系，会发生什么？咱们可以再试一次，对吗？但是这很快让我们陷入了困惑之中。我见过有些团队使用断路器，然后对下游服务进行 HTTP 调用时会超时。尽管这可能是一种正常的反应，为我们争取了一些时间来解决问题，但是它会产生二阶效应。所有这些请求都将被断路器取消，因为它们太长，在断路器上的时间太长。随着流量的增加，会有越来越多的请求进入队列，结果会比你希望修复的更糟。工程师们都在努力理解队列理论，理解为什么会出现超时现象。同样的事情发生在团队开始讨论 HTTP 客户端的线程池等问题时。尽管对这些东西进行配置本身就是一种艺术，但基于直觉来设置数值会使你陷入严重的停机状态。</p>
<p>在从失败中恢复的过程中，一个棘手的问题是并非所有的失败都一样。有些情况下，我们会希望我们的消费者是等幂的。但是这意味着我们应该积极的决定每一种失败情况下该怎么做。消费者是否等幂？能否重试这个调用？在认识到存在巨大的数据完整性问题之前，我已经看到许多工程师忽视了这些，因为它们只是“边缘情况”。</p>
<p>即使你设置了后备机制，重试也比所有这些更加复杂。假设你的移动应用有 500 万用户，而更新用户首选项的消息总线暂时无法运行。你创建了一个支持这种情况的后备机制，该机制通过 HTTP API 调用用户的首选项服务。你应该知道我在说什么吧。如今，该服务突然出现了巨大的流量尖峰，可能无法应付所有的流量。更糟糕的是：你的服务可能接收到所有这些新请求，但是如果重试机制不能实现指数退避和抖动，那么你就可能遇到来自移动应用的分布式拒绝服务。</p>
<p>看到所有这些灾难，你还喜欢分布式系统吗？</p>
<p>要是我告诉你，我只是写下了我所看到的灾难中的一小部分呢？分布式系统很难掌握，而且大多数软件工程师只是在最近才持续接触到它们。</p>
<p>好消息是，对于我所说的很多灾难，我们都能找到解决方案，行业已经创造除了更好的工具，使得除了美国五大科技巨头（Facebook、苹果、亚马逊、Netflix、谷歌）之外的其他组织都能解决这些问题。</p>
<p>我还是喜欢分布式系统，而且我还是觉得微服务是一个解决组织问题的好方法。但是，当我们把失败看作“边缘案例”或者我们认为不可能发生的事时，问题就出现了。在一定范围内，这些边缘案例成为新常态，我们应该加以应对。</p>
<p>原文链接：</p>
<p><a target="_blank" rel="noopener" href="https://world.hey.com/joaoqalves/disasters-i-ve-seen-in-a-microservices-world-a9137a51">https://world.hey.com/joaoqalves/disasters-i-ve-seen-in-a-microservices-world-a9137a51</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/nirvana/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/nirvana/">1</a><span class="page-number current">2</span><a class="page-number" href="/nirvana/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/nirvana/page/25/">25</a><a class="extend next" rel="next" href="/nirvana/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>


<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">nirvana</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">736k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">11:09</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/nirvana/js/utils.js"></script><script src="/nirvana/js/motion.js"></script><script src="/nirvana/js/next-boot.js"></script><script src="/nirvana/js/bookmark.js"></script>

  
<script src="/nirvana/js/local-search.js"></script>






  


<script>
  (function() {
    function leancloudSelector(url) {
      url = encodeURI(url);
      return document.getElementById(url).querySelector('.leancloud-visitors-count');
    }

    function addCount(Counter) {
      const visitors = document.querySelector('.leancloud_visitors');
      const url = decodeURI(visitors.id);
      const title = visitors.dataset.flagTitle;

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url })))
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            const counter = results[0];
            leancloudSelector(url).innerText = counter.time + 1;
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .catch(error => {
                console.error('Failed to save visitor count', error);
              });
          } else {
              leancloudSelector(url).innerText = 'Counter not initialized! More info at console err msg.';
              console.error('ATTENTION! LeanCloud counter has security bug, see how to solve it here: https://github.com/theme-next/hexo-leancloud-counter-security. \n However, you can still use LeanCloud without security, by setting `security` option to `false`.');
            
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    function showTime(Counter) {
      const visitors = document.querySelectorAll('.leancloud_visitors');
      const entries = [...visitors].map(element => {
        return decodeURI(element.id);
      });

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url: { '$in': entries } })))
        .then(response => response.json())
        .then(({ results }) => {
          for (let url of entries) {
            const target = results.find(item => item.url === url);
            leancloudSelector(url).innerText = target ? target.time : 0;
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    const { app_id, app_key, server_url } = {"enable":true,"app_id":"SPsNUvBhME7XmrjzCfHkUu3e-gzGzoHsz","app_key":"4TONafemiIzvJUwqLa7WveoL","server_url":"https://leancloud.cn","security":true,"betterPerformance":false};
    function fetchData(api_server) {
      const Counter = (method, url, data) => {
        return fetch(`${api_server}/1.1${url}`, {
          method,
          headers: {
            'X-LC-Id'     : app_id,
            'X-LC-Key'    : app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        if (CONFIG.hostname !== location.hostname) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    }

    const api_server = app_id.slice(-9) === '-MdYXbMMI' ? `https://${app_id.slice(0, 8).toLowerCase()}.api.lncldglobal.com` : server_url;

    if (api_server) {
      fetchData(api_server);
    } else {
      fetch('https://app-router.leancloud.cn/2/route?appId=' + app_id)
        .then(response => response.json())
        .then(({ api_server }) => {
          fetchData('https://' + api_server);
        });
    }
  })();
</script>



</body>
</html>
