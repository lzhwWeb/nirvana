<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
 <meta name="referrer" content="no-referrer"/>

  <link rel="apple-touch-icon" sizes="180x180" href="/nirvana/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/nirvana/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/nirvana/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/nirvana/images/logo.svg" color="#222">

<link rel="stylesheet" href="/nirvana/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.2/css/all.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"lzhwweb.github.io","root":"/nirvana/","images":"/nirvana/images","scheme":"Gemini","version":"8.2.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/nirvana/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}};
  </script>
<meta name="description" content="个人学习笔记">
<meta property="og:type" content="website">
<meta property="og:title" content="涅槃快乐是金">
<meta property="og:url" content="https://lzhwweb.github.io/nirvana/page/3/index.html">
<meta property="og:site_name" content="涅槃快乐是金">
<meta property="og:description" content="个人学习笔记">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="nirvana">
<meta property="article:tag" content="前端,javascript,node,git,webpack,css">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://lzhwweb.github.io/nirvana/page/3/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>
<title>涅槃快乐是金</title>
  




  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/nirvana/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">涅槃快乐是金</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/nirvana/" rel="section">首页</a></li>
        <li class="menu-item menu-item-git"><a href="/nirvana/categories/git" rel="section">git</a></li>
        <li class="menu-item menu-item-linux"><a href="/nirvana/categories/linux" rel="section">linux</a></li>
        <li class="menu-item menu-item-android"><a href="/nirvana/categories/android" rel="section">android</a></li>
        <li class="menu-item menu-item-随笔"><a href="/nirvana/categories/informal" rel="section">随笔</a></li>
        <li class="menu-item menu-item-mac"><a href="/nirvana/categories/mac" rel="section">mac</a></li>
        <li class="menu-item menu-item-react-native"><a href="/nirvana/categories/reactnative" rel="section">react-native</a></li>
        <li class="menu-item menu-item-算法"><a href="/nirvana/categories/algorithm" rel="section">算法</a></li>
        <li class="menu-item menu-item-读书笔记"><a href="/nirvana/categories/note" rel="section">读书笔记</a></li>
        <li class="menu-item menu-item-开发工具"><a href="/nirvana/categories/tool" rel="section">开发工具</a></li>
        <li class="menu-item menu-item-设计模式(ts)"><a href="/nirvana/categories/DesignPattern" rel="section">设计模式(TS)</a></li>
        <li class="menu-item menu-item-前端"><a href="/nirvana/categories/javascript" rel="section">前端</a></li>
        <li class="menu-item menu-item-webpack"><a href="/nirvana/categories/webpack" rel="section">webpack</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="nirvana"
      src="/nirvana/images/headphoto.jpeg">
  <p class="site-author-name" itemprop="name">nirvana</p>
  <div class="site-description" itemprop="description">个人学习笔记</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/nirvana/archives">
          <span class="site-state-item-count">249</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">分类</span>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/lzhwWeb" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;lzhwWeb" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
  </div>



        </div>
      </div>
        <div class="back-to-top animated" role="button">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lzhwweb.github.io/nirvana/javascript/%E5%89%8D%E7%AB%AF/%E4%BD%BF%E7%94%A8IOC%E8%A7%A3%E8%80%A6React%E7%BB%84%E4%BB%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/nirvana/images/headphoto.jpeg">
      <meta itemprop="name" content="nirvana">
      <meta itemprop="description" content="个人学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="涅槃快乐是金">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/nirvana/javascript/%E5%89%8D%E7%AB%AF/%E4%BD%BF%E7%94%A8IOC%E8%A7%A3%E8%80%A6React%E7%BB%84%E4%BB%B6/" class="post-title-link" itemprop="url">使用IOC解耦React组件</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-06-10 16:29:48 / 修改时间：17:02:25" itemprop="dateCreated datePublished" datetime="2021-06-10T16:29:48+08:00">2021-06-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/nirvana/categories/javascript/" itemprop="url" rel="index"><span itemprop="name">javascript</span></a>
        </span>
    </span>

  
    <span id="/nirvana/javascript/%E5%89%8D%E7%AB%AF/%E4%BD%BF%E7%94%A8IOC%E8%A7%A3%E8%80%A6React%E7%BB%84%E4%BB%B6/" class="post-meta-item leancloud_visitors" data-flag-title="使用IOC解耦React组件" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>3.1k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><code>IOC</code>（控制反转）是一种编程思想，可以解耦组件，提高组件复用性。</p>
<p>本文包括两部分：</p>
<ol>
<li> 介绍<code>IOC</code>概念</li>
<li> <code>IOC</code>在<code>React</code>中的应用</li>
</ol>
<h2 id="IOC是什么"><a href="#IOC是什么" class="headerlink" title="IOC是什么"></a><strong>IOC是什么</strong></h2><p>让我们来看个例子：</p>
<p>我们有个士兵的类，在类内部会实例化一种武器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Soldier &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    &#x2F;&#x2F; 这里我们实例化一把步枪</span><br><span class="line">    this.weapon &#x3D; new Rifle();</span><br><span class="line">  &#125;</span><br><span class="line">  attack() &#123;</span><br><span class="line">    this.weapon.attack();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>士兵的武器应该是多种多样的，但是在<code>Soldier</code>类内部依赖了<code>Rifle</code>。</p>
<p>所以当我们想将武器从步枪换为手榴弹时，只能这样改写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; ...</span><br><span class="line">constructor() &#123;</span><br><span class="line">  &#x2F;&#x2F; 这里我们实例化一把步枪</span><br><span class="line">  &#x2F;&#x2F; this.weapon &#x3D; new Rifle();</span><br><span class="line">  &#x2F;&#x2F; 这里我们实例化一个手榴弹</span><br><span class="line">  this.weapon &#x3D; new Grenade();</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; ...</span><br></pre></td></tr></table></figure>

<p>理想的状态是：士兵不依赖具体的武器，弹药库里有什么武器，就用什么武器。</p>
<p>在这种情况下，<code>IOC</code>作为弹药库，就派上了用场。</p>
<p>让我们来改写代码：</p>
<h3 id="第一步：DI（Dependency-Injection）"><a href="#第一步：DI（Dependency-Injection）" class="headerlink" title="第一步：DI（Dependency Injection）"></a><strong>第一步：DI（Dependency Injection）</strong></h3><p>改写的第一步是使士兵不依赖具体的武器，而是将武器作为依赖注入给士兵：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Soldier &#123;</span><br><span class="line">  &#x2F;&#x2F; 将武器作为依赖注入</span><br><span class="line">  constructor(weapon) &#123;</span><br><span class="line">    this.weapon &#x3D; weapon;</span><br><span class="line">  &#125;</span><br><span class="line">  attack() &#123;</span><br><span class="line">    this.weapon.attack();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们将武器的实例作为<code>Soldier</code>的参数传入，于是可以如下调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const s1 &#x3D; new Soldier(new Rifle());</span><br><span class="line">const s2 &#x3D; new Soldier(new Grenade());</span><br></pre></td></tr></table></figure>

<p>这一步被称为<code>DI</code>（依赖注入）。</p>
<h3 id="第二步：IOC容器"><a href="#第二步：IOC容器" class="headerlink" title="第二步：IOC容器"></a><strong>第二步：IOC容器</strong></h3><p>那么武器从哪儿来呢？接下来来打造我们的武器库：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Armory &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this.weapon &#x3D; null;</span><br><span class="line">  &#125;</span><br><span class="line">  setWeapon(weapon) &#123;</span><br><span class="line">    this.weapon &#x3D; weapon;</span><br><span class="line">  &#125;</span><br><span class="line">  getWeapon() &#123;</span><br><span class="line">    return this.weapon;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>武器库支持存武器(<code>setWeapon</code>)和取武器（<code>getWeapon</code>）。</p>
<p>现在，士兵不依赖具体武器，只需要去武器库取武器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const armory1 &#x3D; new Armory();</span><br><span class="line"></span><br><span class="line">class Soldier &#123;</span><br><span class="line">  &#x2F;&#x2F; 将武器作为依赖注入</span><br><span class="line">  constructor(armory) &#123;</span><br><span class="line">    this.weapon &#x3D; armory.getWeapon();</span><br><span class="line">  &#125;</span><br><span class="line">  attack() &#123;</span><br><span class="line">    this.weapon.attack();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>改造前的依赖关系：</p>
<p><code>士兵 --&gt; 武器</code></p>
<p>改造前原先应用（士兵）拥有依赖的完全控制权。</p>
<p>改造后的依赖关系：</p>
<p><code>士兵 --&gt; 武器库 &lt;-- 武器</code></p>
<p>改造后应用（士兵）与服务提供方（武器）解耦，他们通过<code>IOC</code>容器（武器库）联系。</p>
<p>从<code>Demo</code>也能看出<code>IOC</code>与<code>DI</code>的关系：<code>DI</code>是实现<code>IOC</code>编程思想的一种方式。</p>
<p>除了<code>DI</code>外，另一种实现方式是<code>Dependency Lookup</code>（依赖查找），简称<code>DL</code>。</p>
<h2 id="IOC与React"><a href="#IOC与React" class="headerlink" title="IOC与React"></a><strong>IOC与React</strong></h2><p>在<code>React</code>中，为组件传递的<code>props</code>就是一种<code>DI</code>实现。</p>
<p>为了跨层级传递数据，我们常使用<code>Context API</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function Name() &#123;</span><br><span class="line">  const &#123;name&#125; &#x3D; useContext(nameContext);</span><br><span class="line">  reutrn &lt;h1&gt;&#123;name&#125;&lt;&#x2F;h1&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>context</code>将依赖提供方（<code>name</code>）与依赖使用方（<code>Name</code>）隔离，可以看作是一种<code>IOC</code>实现。<br>所以说，合理使用<code>React</code>可以充分利用<code>IOC</code>的思想解耦代码逻辑。<br>接下来我们看看专业的<code>DI</code>库如何与<code>React</code>结合：</p>
<h2 id="InversifyJS"><a href="#InversifyJS" class="headerlink" title="InversifyJS"></a><strong>InversifyJS</strong></h2><p><strong>InversifyJS</strong>[1]是一个强大、轻量的<code>DI</code>库。<br><img src="https://upload-images.jianshu.io/upload_images/10024246-062089aa62c329c8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br>首先我们实现依赖（武器的实现）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; armory.ts</span><br><span class="line">import &#123; injectable &#125; from &quot;inversify&quot;;</span><br><span class="line"></span><br><span class="line">export interface IArmory&lt;T&gt; &#123;</span><br><span class="line">  attack(): T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@injectable()</span><br><span class="line">export class Armory implements IArmory&lt;string&gt; &#123;</span><br><span class="line">  attack() &#123;</span><br><span class="line">    return &quot;Rifle biubiubiu～&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过<code>inversify</code>提供的<code>injectable decorator</code>标记该<code>class</code>是可被注入的。</p>
<p>接下来实现需求方（士兵的实现）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import React from &quot;react&quot;;</span><br><span class="line">import &#123; IArmory &#125; from &quot;.&#x2F;armory&quot;;</span><br><span class="line"></span><br><span class="line">export class Soldier extends React.Component &#123;</span><br><span class="line">  private readonly Armory: IArmory&lt;string&gt;;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;h1 onClick&#x3D;&#123;() &#x3D;&gt; this.armory.attack()&#125;&gt;I am a soldier&lt;&#x2F;h1&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后实例化<code>IOC</code>容器，连接需求方与依赖：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Container &#125; from &quot;inversify&quot;;</span><br><span class="line">import &#123; IArmory, Armory &#125; from &quot;.&#x2F;armory&quot;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 实例化IOC容器</span><br><span class="line">export const container &#x3D; new Container();</span><br><span class="line">&#x2F;&#x2F; 将依赖方注入容器，其中armory为该依赖的ID</span><br><span class="line">container.bind&lt;IArmory&lt;string&gt;&gt;(&quot;armory&quot;).to(Armory);</span><br></pre></td></tr></table></figure>

<p>至此，完成一个<code>React</code>组件的简单<code>IOC</code>。</p>
<p>业务逻辑的更多依赖都可以通过注入IOC容器来实现解耦。</p>
<p><code>Hooks</code>同样可以通过<code>inversify</code>完成<code>IOC</code>，参考<strong>Dependency injection in React using InversifyJS. Now with React Hooks</strong>[2]</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><strong>参考资料</strong></h3><p>[1]<strong><a target="_blank" rel="noopener" href="https://github.com/inversify/InversifyJS">InversifyJS</a></strong><br>[2]<strong><a target="_blank" rel="noopener" href="https://itnext.io/dependency-injection-in-react-using-inversifyjs-now-with-react-hooks-64f7f077cde6">Dependency injection in React using InversifyJS. Now with React Hooks:</a></strong></p>
<blockquote>
<p>本文分享自微信公众号 - 魔术师卡颂（gh_bc4b6cbdf9ad），作者：卡颂</p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lzhwweb.github.io/nirvana/javascript/%E5%89%8D%E7%AB%AF/%E7%9C%8B%E6%BC%AB%E7%94%BB%EF%BC%8C%E5%AD%A6Redux/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/nirvana/images/headphoto.jpeg">
      <meta itemprop="name" content="nirvana">
      <meta itemprop="description" content="个人学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="涅槃快乐是金">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/nirvana/javascript/%E5%89%8D%E7%AB%AF/%E7%9C%8B%E6%BC%AB%E7%94%BB%EF%BC%8C%E5%AD%A6Redux/" class="post-title-link" itemprop="url">看漫画，学 Redux</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-06-10 16:29:02 / 修改时间：17:02:25" itemprop="dateCreated datePublished" datetime="2021-06-10T16:29:02+08:00">2021-06-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/nirvana/categories/javascript/" itemprop="url" rel="index"><span itemprop="name">javascript</span></a>
        </span>
    </span>

  
    <span id="/nirvana/javascript/%E5%89%8D%E7%AB%AF/%E7%9C%8B%E6%BC%AB%E7%94%BB%EF%BC%8C%E5%AD%A6Redux/" class="post-meta-item leancloud_visitors" data-flag-title="看漫画，学 Redux" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>6k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>5 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>前言</p>
<p>经常看react文章的时候会看到这两个词Redux和Flux。今天就先来看看由@jasonslyvia带来的这篇Redux的文章。</p>
<p>正文从这开始～</p>
<p>Flux 架构已然让人觉得有些迷惑，而比 Flux 更让人摸不着头脑的是 Flux 与 Redux 的区别。Redux 是一个基于 Flux 思想的新架构方式，本文将探讨它们的区别。</p>
<p><strong>为什么要改变 Flux？</strong></p>
<p>Redux 解决的问题和 Flux 一样，但 Redux 能做的还有更多。</p>
<p>和 Flux 一样，Redux 让应用的状态变化变得更加可预测。如果你想改变应用的状态，就必须 dispatch 一个 action。你没有办法直接改变应用的状态，因为保存这些状态的东西（称为 store）只有 getter 而没有 setter。对于 Flux 和 Redux 来说，这些概念都是相似的。</p>
<p>那么为什么要新设计一种架构呢？Redux 的创造者 Dan Abramov 发现了改进 Flux 架构的可能。他想要一个更好的开发者工具来调试 Flux 应用。他发现如果稍微对 Flux 架构进行一些调整，就可以开发出一款更好用的开发者工具，同时依然能享受 Flux 架构带给你的可预测性。</p>
<p>确切的说，他想要的开发者工具包含了代码热替换（hot reload）和时间旅行（time travel）功能。然而要想在 Flux 架构上实现这些功能，确实有些麻烦。</p>
<p><strong>问题1：store 的代码无法被热替换，除非清空当前的状态</strong></p>
<p>在 Flux 中，store 包含了两样东西：</p>
<ul>
<li><p>  改变状态的逻辑</p>
</li>
<li><p>  当前的状态</p>
</li>
</ul>
<p>在一个 store 中同时保存这两样东西将会导致代码热替换功能出现问题。当你热替换掉 store 的代码想要看看新的状态改变逻辑是否生效时，你就丢失了 store 中保存的当前状态。此外，你还把 store 与 Flux 架构中其它组件产生关系的事件系统搞乱了。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-5aad1c497e0386b0?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>解决方案</p>
<p>将这两样东西分开处理。让一个对象来保存状态，这个对象在热替换代码的时候不会受到影响。让另一个对象包含所有改变状态的逻辑，这个对象可以被热替换因为它不用关心任何保存状态相关的事情。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-e408496161ee7ef5?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p><strong>问题2：每次触发 action 时状态对象都被直接改写了</strong></p>
<p>时间旅行调试法的特性是：你能掌握状态对象的每一次变化，这样的话，你就能轻松的跳回到这个对象之前的某个状态（想象一个撤销功能）。</p>
<p>要实现这样的功能，每次状态改变之后，你都需要把旧的状态保存在一个数组中。但是由于 JavaScript 的对象引用特性，简单的把一个对象放进数组中并不能实现我们需要的功能。这样做不能创建一个快照（snapshot），而只是创建了一个新的指针指向同一个对象。</p>
<p>所以要想实现时间旅行特性，每一个状态改变的版本都需要保存在不同的 JavaScript 对象中，这样你才不会不小心改变了某个历史版本的状态。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-4299f3d05bba1a15?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>解决方案</p>
<p>当一个 action 需要 store 响应时，不要直接修改 store 中的状态，而是将状态拷贝一份并在这份拷贝的状态上做出修改。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-f358578e4feb2fb1?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p><strong>问题3：没有合适的位置引入第三方插件</strong></p>
<p>当你在写一些调试性工具时，你希望它们能够更加通用。一个使用该工具的用户应该可以直接引入这个工具而不需要做额外的包装或桥接。</p>
<p>要实现这样的特性，Flux 架构需要一个扩展点。</p>
<p>一个简单的例子就是日志。比如说你希望console.log() 每一个触发的 action 同时 console.log() 这个 action 被响应完成后的状态。在 Flux 中，你只能订阅（subscribe） dispatcher 的更新和每一个 store 的变动。但是这样就侵入了业务代码，这样的日志功能不是一个第三方插件能够轻易实现的。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-1144bdb327d2829e?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>解决方案</p>
<p>将这个架构的部分功能包装进其他的对象中将使得我们的需求变得更容易实现。这些「其他对象」在架构原有的功能基础之上添加了自己的功能。你可以把这种扩展点看做是一个增强器（enhancers）或者高阶对象（higher order objects），亦或者中间件（middleware）。</p>
<p>此外，使用一个树形结构来组织所有改变状态的逻辑，这样当状态发生改变的时候 store 只会触发一个事件来通知视图层（view），而这一个事件会被整棵树中的所有逻辑处理（译者注：「处理」不代表一定会改变状态，这些改变状态的逻辑本质上是函数，函数内部会根据 action 的类型等来确定是否对状态进行改变）。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-4d59819f9b748ce0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>*注意：就上述这些问题和解决方案来说，我主要在关注开发者工具这一使用场景。实际上，对 Flux 做出的这些改变在其他场景中也非常有帮助。在上述三点之外，Flux 和 Redux 还有更多的不同点。比如，相比于 Flux，Redux 精简了整个架构的冗余代码，并且复用 store 的逻辑变得更加简单。这里有一个 Redux 优点的列表可供参考。</p>
<p>那么让我们来看看 Redux 是怎么让这些特性变为现实的。</p>
<p><strong>新的角色</strong></p>
<p>从 Flux 演进到 Redux，整个架构中的角色发生了些许的变化。</p>
<p>Action creators</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-e673e016fe178b98?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片"></p>
<p>Redux 保留了 Flux 中 action creator 的概念。每当你想要改变应用中的状态时，你就要 dispatch 一个 action，这也是唯一改变状态的方法。</p>
<p>就像我在这篇关于 Flux 的文章中提到的一样，我把 action creator 看做是一个报务员（负责发电报的人，telegraph operator），你找到 action creator 告诉他你大致上想要传达什么信息，action creator 则会把这些信息格式化为一种标准的格式，以便系统中的其他部分能够理解。</p>
<p>与 Flux 不同的是，Redux 中的 action creator 不会直接把 action 发送给 dispatcher，而是返回一个格式化好的 JavaScript 对象。</p>
<p>The store</p>
<p>我把 Flux 中的 store 描述为一种过度控制的官僚机制。不能简单直接的修改状态，而是要求所有的状态改变都必须由store 亲自产生，还必须要经历 action 分发那种套路。在 Redux 中，store 依然是这么的充满控制欲和官僚主义，但是又有些不一样。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-88aac50cd3b2ba18?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>在 Flux 中，你可以拥有多个 store，每一个 store 都有自己的统治权。每个 store 都保存着自己对应的那部分状态，以及所有修改这些状态的逻辑。</p>
<p>而 Redux 中的 store 更喜欢将权力下放，而且不得不这么做。因为在 Redux 中，你只能有一个 store……所以如果你打算像 Flux 那样 store 完全独立处理自己的事情，那么 Redux 中的 store 将变得工作量巨大。</p>
<p>因此，Redux 中的 store 首先会保存整个应用的所有状态，然后将判断哪一部分状态需要改变的任务分配下去。而以根reducer（root reducer）为首的 reducer 们将会承担这个任务。</p>
<p>你可能发现这里好像没有dispatcher 什么事，看起来有点越权，但 store 已经完全接管了 dispatch 相关的工作。</p>
<p>The reducers</p>
<p>当 store 需要知道一个 action 触发后状态需要怎么改变时，他会去询问 reducer。根 reducer 会根据状态对象的键（key）将整个状态树进行拆分，然后将拆分后的每一块子状态传到知道该怎么响应的子 reducer 那里进行处理。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-af7350b35b25cf72.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>我把 reducers 看做是有点格外热衷复印的白领。他们不希望把任何事搞砸，因此他们不会修改任何传递给他们的文件。取而代之的是，他们会对这些文件进行复印，然后在复印件上进行修改。（译者注：当然，当这些修改后的复印件定稿后，他们也不会再去修改这些复印件。）</p>
<p>这是 Redux 的核心思想之一。不直接修改整个应用的状态树，而是将状态树的每一部分进行拷贝并修改拷贝后的部分，然后将这些部分重新组合成一颗新的状态树。</p>
<p>子 reducers 会把他们创建的副本传回给根 reducer，而根 reducer 会把这些副本组合起来形成一颗新的状态树。最后根 reducer 将新的状态树传回给 store，store 再将新的状态树设为最终的状态。</p>
<p>如果你有一个小型应用，你可能只有一个reducer 对整个状态树进行拷贝并作出修改。又或者你有一个超大的应用，你可能会有若干个 reducers 对整个状态树进行修改。这也是 Flux 和 Redux 的另一处区别。在 Flux 中，store 并不需要与其他 store 产生关联，而且 store 的结构是扁平的。而在 Redux 中，reducers 是有层级结构的。这种层级结构可以有若干层，就像组件的层级结构那样。</p>
<p>The views: 智能组件（smart components）和木偶组件(dumb components)</p>
<p>Flux 拥有控制型视图（controller views） 和常规型视图（regular views）。控制型视图就像是一个经理一样，管理着 store 和子视图（child views）之间的通信。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-b3a89829aa350800?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>在 Redux 中，也有一个类似的概念：智能组件和木偶组件。（译者注：在最新的 Redux 文档中，它们分别叫做容器型组件 Container component 和展示型组件 Presentational component）智能组件的职责就像经理一样，但是比起Flux 中的角色，Redux 对经理的职责有更多的定义：</p>
<ul>
<li><p>  智能组件负责所有的 action。如果智能组件里包含的一个木偶组件需要触发一个 action，智能组件会通过 props 传给一个 function 给木偶组件，而木偶组件可以把这个 function 当做一个回调。</p>
</li>
<li><p>  智能组件不能定义 CSS 样式。</p>
</li>
<li><p>  智能组件几乎不会产生自己的 DOM 节点，他的工作是组织若干的木偶组件，由木偶组件来生成最终的 DOM 节点。</p>
</li>
</ul>
<p>木偶组件不会直接依赖 action 的触发，因为所有的 action 都会当做 props 传下来。这意味着木偶组件可以被任何一个逻辑不同的 App 拿去使用。同时木偶组件也需要有一定的样式来让自己变得好看一些（当然你可以让木偶组件接受某些 props 作为设置样式的变量）。</p>
<p><strong>视图层绑定</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-a3584facccad4b62?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片"></p>
<p>要把 store 绑定到视图上，Redux 需要一点帮助。如果你在使用 React，那么你需要使用 react-redux。</p>
<p>视图绑定工作有点像为组件树服务的 IT 部门。IT 部门确保所有的组件都正确的绑定到 store 上，并处理各种技术上的细节，以确保余下层级的组件对绑定相关的操作毫无感知。</p>
<p>视图层绑定引入了三个概念：</p>
<ul>
<li><p>  <Provider> 组件： 这个组件需要包裹在整个组件树的最外层。这个组件让根组件的所有子孙组件能够轻松的使用 connect() 方法绑定 store。</p>
</li>
<li><p>  connect()：这是 react-redux 提供的一个方法。如果一个组件想要响应状态的变化，就把自己作为参数传给 connect() 的结果（译者注：connect() 返回的依然是一个函数），connect() 方法会处理与 store 绑定的细节，并通过 selector 确定该绑定 store 中哪一部分的数据。</p>
</li>
<li><p>  selector：这是你自己编写的一个函数。这个函数声明了你的组件需要整个 store 中的哪一部分数据作为自己的 props。</p>
</li>
</ul>
<p><strong>根组件</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-4fc845e2d3d245ec?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>所有的 React 应用都存在一个根组件（root component）。他其实就是整个组件树最外层的那个组件，但是在 Redux 中，根组件还要承担额外的任务。</p>
<p>根组件承担的角色有点像企业中的高管，他将整个团队整合到一起来完成某项任务。他会创建 store，并告诉 store 使用哪些 reducers，并最终完成视图层的绑定。</p>
<p>当完成整个应用的初始化工作后，根组件的就不再插手整个应用的运行过程了。每一次重新渲染（re-render）都没有根组件什么事，这些活儿都由根组件下面的子组件完成，当然也少不了视图层绑定的功劳。</p>
<p><strong>Redux 完成的运行流程</strong></p>
<p>让我们看看上述各个部分是怎样组合成一个可以运行的应用的。</p>
<p>配置环节</p>
<p>应用中的不同部分需要在配置环节中整合到一起。</p>
<p>(1) <em>准备好 store。</em>根组件会创建 store，并通过 createStore(reducer) 方法告诉 store 该使用哪个根 reducer。与此同时，根 reducer 也通过 combineReducers() 方法组建了一只向自己汇报的 reducer 团队。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-d832b0601951193b?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片"></p>
<p>(2) 设置 store 和组件之间的通信。根组件将它所有的子组件包裹在 <Provider> 组件中，并建立了 Provider 与 store 之间的联系。</p>
<p>Provider 本质上创建了一个用于更新视图组件的网络。那些智能组件通过 connect() 方法连入这个网络，以此确保他们能够获取到状态的更新。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-2e61200b7ac1ff04?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片"></p>
<p>(3) 准备好 action callback。为了让木偶组件更好的处理 action，智能组件可以用 bindActionCreators() 方法来创建 action callback。这样做之后，智能组件就能给木偶组件传入一个回调（callback）。对应的 action 会在木偶组件调用这个回调时被自动 dispatch。（译者注：使用 bindActionCreators() 使得木偶组件无需关心 action 的 type 等信息，只用调用 props 中的某个方法传入需要的参数作为 action 的 payload 即可）</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-7828e3bec86d30b1?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片"></p>
<p>数据流</p>
<p>现在我们的应用已经配置完成，用户可以开始操作了。让我们触发一个 action，看看数据是怎样流动的。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-8c1cdc1cf3fe7bc5?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片"></p>
<p>(1) 视图发出了一个 action，action creator 将这个 action 格式化并返回。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-bb9e6ab545305bf2?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片"></p>
<p>(2) 这个 action 要么被自动 dispatch（如果我们在配置阶段使用了 bindActionCreators()），要么由视图层手动 dispatch。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-ab9825b546237dbb?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片"></p>
<p>(3) store 接受到这个 action 后，将当前的状态树和这个 action 传给根 reducer。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-38ee22f1100d5ea1?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片"></p>
<p>(4) 根 reducer 将整个状态树切分成一个个小块，然后将某一个小块分发给知道怎么处理这部分内容的子reducer。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-4e631ac8c3fc1aa3?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片"></p>
<p>(5) 子 reducer 将传入的一小块状态树进行拷贝，然后在副本上进行修改，并最终将修改后的副本返回根reducer。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-d38dc2f1f3e9a481?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片"></p>
<p>(6) 当所有的子 reducer 返回他们修改的副本之后，根 reducer 将这些部分再次组合起来形成一颗新的状态树。然后根 reducer 将这个新的状态树交还给 store，store 再把自己的状态置为这个最新的状态树。 </p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-5248c07e0a0acebd?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片"></p>
<p>(7) store 告诉视图层绑定：「状态更新啦」</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-8ce27928c4bfb166?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片"></p>
<p>(8) 视图层绑定让 store 把更新的状态传过来</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-eaa10bbd70692251?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片"></p>
<p>(9) 视图层绑定触发了一个重新渲染的操作（re-render）</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-93fd1b32145e7df1?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片"></p>
<p>这就是我所理解的 Redux，希望对你有所帮助。</p>
<p><strong>更多资源</strong></p>
<ul>
<li><p>  Redux 官方文档</p>
</li>
<li><p>  Redux 官方文档中文版</p>
</li>
<li><p>  The Evolutionof Flux Frameworks</p>
</li>
<li><p>  Smart andDumb Components</p>
</li>
<li><p>  The upsides of using Redux</p>
</li>
<li><p>  The downsides of using Redux</p>
</li>
<li><p>  如何评价数据流管理架构 Redux?</p>
</li>
</ul>
<p>关于本文</p>
<blockquote>
<p>译者：@ jasonslyvia<br>原文连接：<a target="_blank" rel="noopener" href="http://jasonslyvia.github.io/a-cartoon-intro-to-redux-cn/">http://jasonslyvia.github.io/a-cartoon-intro-to-redux-cn/</a></p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lzhwweb.github.io/nirvana/javascript/%E5%89%8D%E7%AB%AF/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E4%B8%BB%E5%AF%BC%E7%9A%84Weex%E5%9B%A0%E6%B4%BB%E8%B7%83%E5%BA%A6%E4%B8%8D%E5%A4%9F%E4%BB%8EApacheIncubator%E9%80%80%E4%BC%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/nirvana/images/headphoto.jpeg">
      <meta itemprop="name" content="nirvana">
      <meta itemprop="description" content="个人学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="涅槃快乐是金">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/nirvana/javascript/%E5%89%8D%E7%AB%AF/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E4%B8%BB%E5%AF%BC%E7%9A%84Weex%E5%9B%A0%E6%B4%BB%E8%B7%83%E5%BA%A6%E4%B8%8D%E5%A4%9F%E4%BB%8EApacheIncubator%E9%80%80%E4%BC%91/" class="post-title-link" itemprop="url">阿里巴巴主导的 Weex 因活跃度不够从 Apache Incubator 退休</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-06-10 16:28:03 / 修改时间：17:02:25" itemprop="dateCreated datePublished" datetime="2021-06-10T16:28:03+08:00">2021-06-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/nirvana/categories/javascript/" itemprop="url" rel="index"><span itemprop="name">javascript</span></a>
        </span>
    </span>

  
    <span id="/nirvana/javascript/%E5%89%8D%E7%AB%AF/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E4%B8%BB%E5%AF%BC%E7%9A%84Weex%E5%9B%A0%E6%B4%BB%E8%B7%83%E5%BA%A6%E4%B8%8D%E5%A4%9F%E4%BB%8EApacheIncubator%E9%80%80%E4%BC%91/" class="post-meta-item leancloud_visitors" data-flag-title="阿里巴巴主导的 Weex 因活跃度不够从 Apache Incubator 退休" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>877</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><a target="_blank" rel="noopener" href="https://www.oschina.net/action/GoToLink?url=https://lists.apache.org/thread.html/reb2523a568b5ce5cfc1b8017c20106221f0ab689ebcf3cb42feb8a54%2540%253Cgeneral.incubator.apache.org%253E">根据 Apache Incubator 邮件列表的信息</a>，上周发起的关于 Weex 是否从 Apache Incubator 退休的投票已结束。投票结果显示，由于没有[-1]否决票，所以 Weex 从 Apache Incubator 退休的投票获得了 IPMC 的一致通过。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-af70e8e94120a0b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>Weex 从 Apache Incubator 退休并不意味着停止维护，仅表示它不再在 Apache Incubator 中开发（与 TLP 项目移动至 <a target="_blank" rel="noopener" href="https://www.oschina.net/news/112808/apache-moved-to-the-attic">Attic</a> 类似），详情查看 <a target="_blank" rel="noopener" href="https://www.oschina.net/action/GoToLink?url=https://incubator.apache.org/guides/retirement.html">Guide to Retirement</a>。</p>
<p>此外，从之前邮件列表中的<a target="_blank" rel="noopener" href="https://www.oschina.net/action/GoToLink?url=https://lists.apache.org/thread.html/rcaf67836a77ad3bebcafffc9e853bcd043a844e123e06ac8e71c9f4d%2540%253Cdev.weex.apache.org%253E">讨论</a>可以看到，Weex 在阿里巴巴（尤其是淘宝）中仍被广泛使用，许多开发者仍在开发 Weex，并有长期计划来对其进行改进。所以 Weex 从 Apache Incubator 退休后也会继续开发。</p>
<p>此次投票的发起人，同时也是 Weex 项目的导师姜宁 (<a target="_blank" rel="noopener" href="https://my.oschina.net/u/3569919">@WillemJiang</a>) <a target="_blank" rel="noopener" href="https://www.oschina.net/action/GoToLink?url=https://www.zhihu.com/question/459369570/answer/1886114582">表示</a>，Weex 从 Apache Incubator 退休的主要原因是项目活跃度不够。这里的活跃度指的是 Weex 在 Apache 社区中的活跃情况，姜宁提到 Weex 的很多 PPMC 成员都不活跃，例如没有提交 IPMC Chair 需要的社区报告。不活跃的氛围导致项目发布新版本时也没有足够的人来进行投票（官网和 GitHub 上显示的最新版本是2019年发布的 <a target="_blank" rel="noopener" href="https://www.oschina.net/action/GoToLink?url=https://github.com/apache/incubator-weex/releases/tag/0.28.0">0.28</a>）。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-eac2fdc67fb7bf4e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>根据 ASF 董事吴晟 (<a target="_blank" rel="noopener" href="https://my.oschina.net/wusheng">@wu-sheng</a>) 的<a target="_blank" rel="noopener" href="https://www.oschina.net/action/GoToLink?url=https://twitter.com/wusheng1108/status/1393011558289051651">说法</a>，Weex 似乎也是中国首个从 Apache Incubator 退休的项目。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-7e4ed45f7d5166fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p><a target="_blank" rel="noopener" href="https://www.oschina.net/action/GoToLink?url=https://weex.apache.org/zh/">Weex</a> 于2016年<a target="_blank" rel="noopener" href="https://www.oschina.net/news/72703/weex-web-native">正式开源</a>，定位是使用 Web 来开发高性能原生应用的框架。Weex 致力于使开发者能基于通用跨平台的 Web 开发语言和开发经验，来构建 Android、iOS 和 Web 应用。简单来说，在集成 WeexSDK 之后，开发者可以使用 JavaScript 语言和前端开发经验来开发移动应用。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-43dc96bc94d25aba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>现在再回去看 Vue.js 作者尤雨溪当时对 Weex 的<a target="_blank" rel="noopener" href="https://www.oschina.net/action/GoToLink?url=https://www.zhihu.com/question/37636296/answer/72881168">评价</a>，似乎一切早已注定……</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-01a451e251c17421.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<blockquote>
<p>**PS:**16年团队在做多端时，在选择weex还是react-native，考虑了很多，最终选择了，react-native作为主要研究方向，现在回顾下，有庆幸，有惋惜。希望以后国内的开源项目越来越好！</p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lzhwweb.github.io/nirvana/javascript/%E5%89%8D%E7%AB%AF/%E6%AF%8F%E4%B8%AA%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E7%9F%A5%E4%B9%8BSEO/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/nirvana/images/headphoto.jpeg">
      <meta itemprop="name" content="nirvana">
      <meta itemprop="description" content="个人学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="涅槃快乐是金">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/nirvana/javascript/%E5%89%8D%E7%AB%AF/%E6%AF%8F%E4%B8%AA%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E7%9F%A5%E4%B9%8BSEO/" class="post-title-link" itemprop="url">每个程序员必知之SEO</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-06-10 16:26:11 / 修改时间：17:02:24" itemprop="dateCreated datePublished" datetime="2021-06-10T16:26:11+08:00">2021-06-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/nirvana/categories/javascript/" itemprop="url" rel="index"><span itemprop="name">javascript</span></a>
        </span>
    </span>

  
    <span id="/nirvana/javascript/%E5%89%8D%E7%AB%AF/%E6%AF%8F%E4%B8%AA%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E7%9F%A5%E4%B9%8BSEO/" class="post-meta-item leancloud_visitors" data-flag-title="每个程序员必知之SEO" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>3.3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="搜索引擎是如何工作的"><a href="#搜索引擎是如何工作的" class="headerlink" title="搜索引擎是如何工作的"></a>搜索引擎是如何工作的</h1><blockquote>
<p>如果你有时间，可以读一下谷歌的框架：</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="http://infolab.stanford.edu/~backrub/google.html">http://infolab.stanford.edu/~backrub/google.html</a></p>
<blockquote>
<p>这是一个老的，有些过时纸，但非常平易近人，甚至在我们中间的非白皮书的读者图标微笑什么每个程序员都应该知道的关于搜索引擎优化和他们绝对概念的解释更详细，我只提一笔带过。</p>
</blockquote>
<h2 id="搜索时发生什么了"><a href="#搜索时发生什么了" class="headerlink" title="搜索时发生什么了"></a>搜索时发生什么了</h2><ul>
<li>  用户输入查询内容</li>
<li>  查询处理以及分词技术</li>
<li>  确定搜索意图及返回相关、新鲜的内容</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-baf593c80e1a6181.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<h1 id="为什么需要SEO"><a href="#为什么需要SEO" class="headerlink" title="为什么需要SEO"></a>为什么需要SEO</h1><p>这是一个有趣的问题，答案总会来源于<code>为网站带来更多的流量</code>。</p>
<h2 id="爬虫与索引"><a href="#爬虫与索引" class="headerlink" title="爬虫与索引"></a>爬虫与索引</h2><p>我们先看看来自谷歌的爬虫工作的一点内容</p>
<blockquote>
<p>抓取是 Googlebot 发现新网页并更新这些网页以将网页添加到 Google 索引中的过程。</p>
<p>我们使用许多计算机来获取（或”抓取”）网站上的大量网页。执行获取任务的程序叫做 Googlebot（也被称为漫游器或信息采集软件）。Googlebot 使用算法来进行抓取：计算机程序会确定要抓取的网站、抓取频率以及从每个网站中获取的网页数量。</p>
<p>Google 的抓取过程是根据网页网址的列表进行的，该列表是在之前进行的抓取过程中形成的，且随着网站管理员所提供的站点地图数据不断进行扩充。Googlebot 在访问每个网站时，会检测每个网页上的链接，并将这些链接添加到它要抓取的网页列表中。新建立的网站、对现有网站所进行的更改以及无效链接都会被记录下 来，并用于更新 Google 索引。</p>
</blockquote>
<p>也就是如原文所说:</p>
<blockquote>
<p>谷歌的爬虫(又或者说蛛蛛)能够抓取你整个网站索引的所有页。</p>
</blockquote>
<p><strong>为什么谷歌上可以搜索整个互联网的内容</strong>？因为，他解析并存储了。而更有意思的是，他会为同样的内容建立一个索引或者说分类，按照一定的相关性，针对于某个关键词的内容。</p>
<p>PageRank对于一个网站来说是相当重要的，只是这个相比也比较复杂。包括其他网站链接向你的网站，以及流量，当然还有域名等等。</p>
<h3 id="什么样的网站需要SEO？"><a href="#什么样的网站需要SEO？" class="headerlink" title="什么样的网站需要SEO？"></a>什么样的网站需要SEO？</h3><p>下图是我的博客的流量来源</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-246afc710a7a5bef.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="What Site Need SEO"></p>
<figcaption style="box-sizing: border-box;">What Site Need SEO</figcaption>

<p>正常情况下除了像<code>腾讯</code>这类的<code>QQ空间</code>自我封闭的网站外都需要SEO，或者不希望泄露一些用户隐私如<code>Facebook</code>、<code>人人</code>等等</p>
<ul>
<li>  如果你和我的网站一样需要靠搜索带来流量</li>
<li>  如果你只有很少的用户访问，却有很多的内容。</li>
<li>  如果你是为一个公司、企业工作为以带来业务。</li>
<li>  。。。</li>
</ul>
<h2 id="SEO与编程的不同之处"><a href="#SEO与编程的不同之处" class="headerlink" title="SEO与编程的不同之处"></a>SEO与编程的不同之处</h2><p>SEO与编程的最大不同之处在于</p>
<h3 id="编程的核心是技术，SEO的核心是内容。"><a href="#编程的核心是技术，SEO的核心是内容。" class="headerlink" title="编程的核心是技术，SEO的核心是内容。"></a>编程的核心是技术，SEO的核心是内容。</h3><p>内容才是SEO最重要的组成部分，这也就是腾讯复制不了的东西。</p>
<h1 id="SEO基础知识"><a href="#SEO基础知识" class="headerlink" title="SEO基础知识"></a>SEO基础知识</h1><h2 id="确保网站是可以被索引的"><a href="#确保网站是可以被索引的" class="headerlink" title="确保网站是可以被索引的"></a>确保网站是可以被索引的</h2><p>一些常见的页面不能被访问的原因</p>
<ul>
<li>  隐藏在需要提交的表格中的链接</li>
<li>  不能解析的JavaScript脚本中的链接</li>
<li>  Flash、Java和其他插件中的链接</li>
<li>  PowerPoint和PDF文件中的链接</li>
<li>  指向被meta Robtots标签、rel=”NoFollow”和robots.txt屏蔽的页面的链接</li>
<li>  页面上有上几百个链接</li>
<li>  frame(框架结构)和iframe里的链接</li>
</ul>
<p>对于现在的网站来还有下面的原因，通过来说是因为内容是动态生成的，而不是静态的</p>
<ul>
<li>  网站通过WebSocket的方法渲染内容</li>
<li>  使用诸如Mustache之类的JS模板引擎</li>
</ul>
<h2 id="什么样的网页可以被索引"><a href="#什么样的网页可以被索引" class="headerlink" title="什么样的网页可以被索引"></a>什么样的网页可以被索引</h2><ul>
<li>  确保页面可以在没有JavaScript下能被渲染。对于现在JavaScript语言的使用越来越多的情况下，在使用JS模板引擎的时候也应该注意这样的问题。</li>
<li>  在用户禁用了JavaScript的情况下，保证所有的链接和页面是可以访问的。</li>
<li>  确保爬虫可以看到所有的内容。那些用JS动态加载出来的对于爬虫来说是不友好的</li>
<li>  使用描述性的锚文本的网页</li>
<li>  限制的页面上的链接数量。除去一些分类网站、导航网站之类有固定流量，要不容易被认为垃圾网站。</li>
<li>  确保页面能被索引。有一指向它的URL</li>
<li>  URL应该遵循最佳实践。如blog/how-to-driver有更好的可读性</li>
</ul>
<h2 id="在正确的地方使用正确的关键词"><a href="#在正确的地方使用正确的关键词" class="headerlink" title="在正确的地方使用正确的关键词"></a>在正确的地方使用正确的关键词</h2><ul>
<li>  把关键词放URL中</li>
<li>  关键词应该是页面的标签</li>
<li>  带有H1标签</li>
<li>  图片文件名、ALT属性带有关键词。</li>
<li>  页面文字</li>
<li>  加粗文字</li>
<li>  Descripiton标签</li>
</ul>
<h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><p>对于技术博客而言，内容才是最需要考虑的因素。</p>
<p>可以考虑一下这篇文章，虽然其主题是以SEO为主 <a target="_blank" rel="noopener" href="http://www.phodal.com/blog/user-experience-writing-web-content/">用户体验与网站内容</a></p>
<p>不可忽略的一些因素是内容才是最优质的部分，没有内容一切SEO都是无意义的。</p>
<h2 id="复制内容问题"><a href="#复制内容问题" class="headerlink" title="复制内容问题"></a>复制内容问题</h2><p>一个以用户角度考虑的问题</p>
<h3 id="用户需要看到多元化的搜索结果"><a href="#用户需要看到多元化的搜索结果" class="headerlink" title="用户需要看到多元化的搜索结果"></a>用户需要看到多元化的搜索结果</h3><p>所以对于搜索引擎来说，复制带来的结果：</p>
<ul>
<li>  搜索引擎爬虫对每个网站都有设定的爬行预算，每一次爬行都只能爬行trpgr页面数</li>
<li>  连向复制内容页面的链接也浪费了它们的链接权重。</li>
<li>  没有一个搜索引擎详细解释他们的算法怎样选择显示页面的哪个版本。</li>
</ul>
<p>于是上文说到的作者给了下面的这些建议:</p>
<blockquote>
<p>避免从网上复制的内容（除非你有很多其他的内容汇总，以使它看起来不同 - 我们做头条，对我们的产品页面的新闻片段的方式） 。这当然强烈适用于在自己的网站页面以及。内容重复可以混淆搜索引擎哪些页面是权威（它也可能会导致罚款，如果你只是复制粘贴别人的内容也行） ，然后你可以有你自己的网页互相竞争排名！</p>
<p>如果你必须有重复的内容，利用相对=规范，让搜索引擎知道哪个URL是一个他们应该被视为权威。但是，如果你的页面是另一个在网络上找到一个副本？那么开始想出一些策略来增加更多的文字和信息来区分你的网页，因为这样重复的内容是决不可能得到好的排名。</p>
</blockquote>
<p>——待续。</p>
<h1 id="保持更新"><a href="#保持更新" class="headerlink" title="保持更新"></a>保持更新</h1><p>谷歌对于一个一直在更新的博客来说会有一个好的排名，当然只是相对的。</p>
<p>对于一个技术博客作者来说，一直更新的好处不仅可以让我们不断地学习更多的内容。也可以保持一个良好的习惯，而对于企业来说更是如此。如果我们每天去更新我们的博客，那么搜索引擎对于我们网站的收录也会变得越来越加频繁。那么，对于我们的排名及点击量来说也算是一个好事，当我们可以获得足够的排名靠前时，我们的PR值也在不断地提高。</p>
<p>更多内容可以参考:<a target="_blank" rel="noopener" href="http://www.seomoz.org/blog/google-fresh-factor">Google Fresh Factor</a></p>
<h1 id="网站速度"><a href="#网站速度" class="headerlink" title="网站速度"></a>网站速度</h1><blockquote>
<p>谷歌曾表示在他们的算法页面加载速度问题，所以一定要确保你已经调整您的网站，都服从最佳做法，以使事情迅速</p>
</blockquote>
<p>过去的一个月里，我试着提高自己的网站的速度，有一个相对好的速度，但是受限于<code>域名解析速度</code>以及<code>VPS</code>。</p>
<p><a target="_blank" rel="noopener" href="http://www.phodal.com/blog/use-traceroute-analyse-person-homepage-speed/">网站速度分析与traceroute</a></p>
<p><a target="_blank" rel="noopener" href="http://www.phodal.com/blog/ux-and-improve-website-load-speed/">UX与网站速度优化——博客速度优化小记</a></p>
<p><a target="_blank" rel="noopener" href="http://www.phodal.com/blog/nginx-with-ngx-pagespeed-module-improve-website-cache/">Nginx ngx_pagespeed nginx前端优化模块编译</a></p>
<h1 id="保持耐心"><a href="#保持耐心" class="headerlink" title="保持耐心"></a>保持耐心</h1><blockquote>
<p>这是有道理的，如果你在需要的谷歌机器人抓取更新的页面，然后处理每一个页面，并更新与新内容对应的索引的时间因素。</p>
<p>而这可能是相当长一段时间，当你正在处理的内容PB级。</p>
</blockquote>
<p>SEO是一个长期的过程，很少有网站可以在短期内有一个很好的位置，除非是一个热门的网站，然而在它被发现之前也会一个过程。</p>
<h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><p>在某种意义上，这个是提高PR值，及网站流量的另外一个核心，除了内容以外的核心。</p>
<ul>
<li>  链接建设是SEO的基础部分。除非你有一个异常强大的品牌，不需要干什么就能吸引到链接。</li>
<li>  链接建设永不停止。这是不间断营销网站的过程</li>
</ul>
<p>关于链接的内容有太多，而且当前没有一个好的方法获取链接虽然在我的网站已经有了</p>
<p>Links to Your Site</p>
<p>Total links</p>
<p><code>5,880</code></p>
<blockquote>
<p>同时寻求更多的链接是更有利更相关的链接可以帮助一样多。如果你有你的内容的分销合作伙伴，或者你建立一个小工具，或其他任何人都会把链接回你的网站在网络上 - 你可以通过确保各个环节都有最佳的关键字锚文本大大提高链路的相关性。您还应该确保所有链接到您的网站指向你的主域（ <a target="_blank" rel="noopener" href="http://www.yourdomain.com/">http://www.yourdomain.com</a> ，像<a target="_blank" rel="noopener" href="http://widget.yourdomain.com不是一个子域)/">http://widget.yourdomain.com不是一个子域）</a> 。另外，你要尽可能多的联系，以包含适当的替代文字。你的想法。</p>
<p>另外，也许不太明显的方式，建立链接（或者至少流量）是使用社交媒体 - 所以设置你的Facebook ，Twitter和谷歌，每当你有新的链接一定要分享。这些通道也可以作为一个有效的渠道，推动更多的流量到您的网站。</p>
</blockquote>
<p>由社交渠道带来的流量在现在已经越来越重要了，对于一些以内容为主导的网站，而且处于发展初期，可以迅速带来流量，可以参考一下这篇文章</p>
<p><a target="_blank" rel="noopener" href="http://www.phodal.com/blog/xunta-analytics-and-website-content/">寻ta分析与网站内容</a></p>
<p>一些更简单的办法就是交换链接，总之这个话题有些沉重，可能会带来一些负面的影响，如黑帽SEO。。。。</p>
<p><strong>参考来源</strong>:</p>
<p>《SEO艺术》(The Art of SEO)</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lzhwweb.github.io/nirvana/javascript/%E5%89%8D%E7%AB%AF/meta%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/nirvana/images/headphoto.jpeg">
      <meta itemprop="name" content="nirvana">
      <meta itemprop="description" content="个人学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="涅槃快乐是金">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/nirvana/javascript/%E5%89%8D%E7%AB%AF/meta%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" class="post-title-link" itemprop="url">meta基础知识</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-06-10 16:24:50 / 修改时间：17:02:24" itemprop="dateCreated datePublished" datetime="2021-06-10T16:24:50+08:00">2021-06-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/nirvana/categories/javascript/" itemprop="url" rel="index"><span itemprop="name">javascript</span></a>
        </span>
    </span>

  
    <span id="/nirvana/javascript/%E5%89%8D%E7%AB%AF/meta%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" class="post-meta-item leancloud_visitors" data-flag-title="meta基础知识" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>681</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><strong>H5页面窗口自动调整到设备宽度，并禁止用户缩放页面</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width,initial-scale&#x3D;1.0,minimum-scale&#x3D;1.0,maximum-scale&#x3D;1.0,user-scalable&#x3D;no&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>忽略将页面中的数字识别为电话号码</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name&#x3D;&quot;format-detection&quot; content&#x3D;&quot;telephone&#x3D;no&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>忽略<code>Android</code>平台中对邮箱地址的识别</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name&#x3D;&quot;format-detection&quot; content&#x3D;&quot;email&#x3D;no&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>当网站添加到主屏幕快速启动方式，可隐藏地址栏，仅针对<code>ios</code>的safari</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name&#x3D;&quot;apple-mobile-web-app-capable&quot; content&#x3D;&quot;yes&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>将网站添加到主屏幕快速启动方式，仅针对ios的safari顶端状态条的样式</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name&#x3D;&quot;apple-mobile-web-app-status-bar-style&quot; content&#x3D;&quot;black&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lzhwweb.github.io/nirvana/javascript/%E5%89%8D%E7%AB%AF/%E5%89%8D%E5%90%8E%E7%AB%AF%E4%B8%80%E4%BD%93%E5%8C%96:%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E5%B0%86%E6%AD%BB%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/nirvana/images/headphoto.jpeg">
      <meta itemprop="name" content="nirvana">
      <meta itemprop="description" content="个人学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="涅槃快乐是金">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/nirvana/javascript/%E5%89%8D%E7%AB%AF/%E5%89%8D%E5%90%8E%E7%AB%AF%E4%B8%80%E4%BD%93%E5%8C%96:%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E5%B0%86%E6%AD%BB%EF%BC%9F/" class="post-title-link" itemprop="url">前后端一体化：前后端分离将死？</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-06-10 16:23:39 / 修改时间：17:02:25" itemprop="dateCreated datePublished" datetime="2021-06-10T16:23:39+08:00">2021-06-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/nirvana/categories/javascript/" itemprop="url" rel="index"><span itemprop="name">javascript</span></a>
        </span>
    </span>

  
    <span id="/nirvana/javascript/%E5%89%8D%E7%AB%AF/%E5%89%8D%E5%90%8E%E7%AB%AF%E4%B8%80%E4%BD%93%E5%8C%96:%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E5%B0%86%E6%AD%BB%EF%BC%9F/" class="post-meta-item leancloud_visitors" data-flag-title="前后端一体化：前后端分离将死？" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4.1k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>PS：本文所针对的场景，都是复杂业务场景下的 Web 应用。简单的 Web 应用不适合复杂的架构模式，它为带来巨大的成本。</p>
<p>在接触了领域驱动设计的概念，其中关于核心域的想法让人颇为激动。而在微服务架构中，核心域是一个或者多个服务的域，而位于核心域的核心则是领域模型。简单地来说，对于一个系统来说，它的核心的核心的 ”核心“ 就是：领域模型。</p>
<p>过去，当我们谈及领域模型的时候，我们往往将其置于 Web 后端的领域。当我 GET 了一些基本的理念之后，便尝试整合到前端架构中。去年，我开始了 在项目上的第一次尝试，并在 GitHub 上创建了 <a target="_blank" rel="noopener" href="https://github.com/phodal/clean-frontend">clean-frontend</a> 项目，它以 Angular 作为示例，介绍了如何开发一个整洁前端架构的前端应用。</p>
<h2 id="引子-1：模型一致化"><a href="#引子-1：模型一致化" class="headerlink" title="引子 1：模型一致化"></a>引子 1：模型一致化</h2><p>我习惯于在公司的项目中引入成熟的框架，从几年前的 Angular.js 到近几年的 Angular，完整的框架能为企业带来更少的维护成本，从而降低软件开发成本。几年前，我们引入了 Angular 之后，便开始大量地 TypeScript 项目实践。作为一个支持静态类型的语言，它非常适合于开发大型应用、企业应用，在这一点上你可以从 React、Vue 等框架建议使用 TypeScript 看到一种趋势。</p>
<p>采纳了 TypeScript 之后，当前端从后端获取到数据之后，那么它需要将 JSON 数据映射到对应的 interface。如此一来，前端的模型也就有了对应的领域模型。而这个数据模型和后端的数据模型应该是完成一致的，但是实际上，它往往是落后的。后端的 API 发生的变更之后，才需要前端同步去修改模型。</p>
<p>而当我作为一个前端的 Tech Lead 来考虑这个问题的时候，我首先想到的是：读取后端的 Java 代码，然后生成对应的前端模型。在没有造 Chapi 的轮子之前，通过 TypeScript Compiler 转换获得对应的类型，是我觉得比较靠谱的方案。在有了 Chapi 之后，我觉得它们都是小问题了。</p>
<p>不过，然后我一想这样做的意义并不大，还不如：套用后端的契约测试，造一个前端的自动化契约测试，即：<a target="_blank" rel="noopener" href="http://github.com/phodal/mest">mest</a>。它通过 API 返回数据和 TypeScript 的 Interface 来完成对于契约的测试。一个简单的测试数据如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">url,interface</span><br><span class="line">https:&#x2F;&#x2F;phodal.github.io&#x2F;mest-test&#x2F;error.json,mock&#x2F;IError.ts</span><br></pre></td></tr></table></figure>

<p>通过 HTTP 请求获取对应的测试数据，再将其与本地的模型进行比较。</p>
<p>不过呢，我们还要使用 JavaScript 语言重写部分 Java 代码，那么我们为什么不要 JavaScript / TypeScript 重写一切呢？</p>
<h2 id="引子-2：JavaScript-TypeScript-重写一切"><a href="#引子-2：JavaScript-TypeScript-重写一切" class="headerlink" title="引子 2：JavaScript / TypeScript 重写一切"></a>引子 2：JavaScript / TypeScript 重写一切</h2><p>遗憾的是，使用 JavaScript 编写后端应用（BFF、胶水层除外），在大部分的大公司是比较难的。内部的生态链和运维影响了技术决策，使用 C++ 不香吗，使用 JavaScript 会存在无人在背后支持。</p>
<h3 id="纯-Node-js-后端应用"><a href="#纯-Node-js-后端应用" class="headerlink" title="纯 Node.js 后端应用"></a>纯 Node.js 后端应用</h3><p>在过去的几年里，我建议：小公司的后端应用<strong>不要</strong>使用 JavaScript / TypeScript 编写，因为运维、监控、APM 等生态尚不够完善。小公司应该优先投资于业务领域，在基础设施的投入见效比较短，除非能控制好开发人员的流动性。</p>
<p>不过，不管怎样，已经有大量的小公司因为人力成本的原因，已经使用上了 Node.js 来开发后端应用。</p>
<h3 id="Serverless-应用"><a href="#Serverless-应用" class="headerlink" title="Serverless 应用"></a>Serverless 应用</h3><p>而随着 JavaScript 系生态的完善，基础设施已经不是会成为小公司的负担，我便觉得这是一个好的时机。不过，我指的是采用 Serverlesss 架构，而非自建 JavaScript 系生态。Serverless 不仅帮助小企业解决了基础设施的问题，还能为小企业降低软件运维成本。一旦企业做大之后，也可以自建采用 OpenFaas 等开源方案解决 Serverless 的供应商锁定问题。</p>
<p>不论是 Node.js 后端应用还是 Serverless 应用，因为使用的是同一种语言，我们可以轻松地在前后端之间共享代码，可以是 Git submodule、NPM 包、远程等等的方式。</p>
<h2 id="引子-3：纯编译到-JavaScript"><a href="#引子-3：纯编译到-JavaScript" class="headerlink" title="引子 3：纯编译到 JavaScript"></a>引子 3：纯编译到 JavaScript</h2><p>市面上有各种各样支持 compile to js 的语言、框架，诸如于 Kotlin.js、Scala.js、Python.js 等等。</p>
<p>对于小前端的应用来说，这种架构非常的不错。它相当于是渐进式的系统架构方案，当前采用了主流的前端框架，而非传统的后端渲染机制，并统一了技术栈，降低了组织内部的学习成本。不过，它带来额外的调试因素，毕竟每多一层封装，系统的复杂度就需要 * 2。</p>
<p>而为了让框架的使用者支持不同的框架 React、Angular、Vue，这个框架还需要提供这些框架的 bind 或者是 wrapper，以提升框架使用者的幸福感。</p>
<p>但是，我们的挑战依然是复杂的前端应用，以及它难以消除交互的复杂度。</p>
<h2 id="引子-4：共享领域模型-模式库"><a href="#引子-4：共享领域模型-模式库" class="headerlink" title="引子 4：共享领域模型/模式库"></a>引子 4：共享领域模型/模式库</h2><p>开始之前，我不得不强调一，领域模型是一种包含数据和行为的抽血模型。</p>
<p>编译到 JavaScript 是一种轻前端的方案，而对于重前端的项目来说，它们完成可以采用一种新的模式：共享领域模型。即将领域模型作为模式库，提供给前后端一起使用。即，我们只需要编译所需要的部分。</p>
<p>这在我使用了 Kotlin 的多平台技术（multiplatform）重写了 Chapi 的 domain 层之后，我意识到了这是一个非常迷人的方案。我即使用在前端代码中使用 Chapi 的领域模型，我还需要在后端的代码中使用这套模型。原先，我需要手动翻译一行行代码，现在我并不需要这样的一个步骤。只需要在 pom.xml、build.gradle 或者是 package.json 中引入依赖及其对应的版本即可。</p>
<p>在引入了这部分的代码之后，我们再关注于 UI 交互部分即可。</p>
<h2 id="引子-5：领域模型编译到-WASM"><a href="#引子-5：领域模型编译到-WASM" class="headerlink" title="引子 5：领域模型编译到 WASM"></a>引子 5：领域模型编译到 WASM</h2><p>考虑到并非所有的语言都能支持 compile to JavaScript，一种颇为有效的方式就是使用 WASM。</p>
<blockquote>
<p>WebAssembly 或称 wasm 是一个实验性的低端编程语言，应用于浏览器内的客户端。WebAssembly 将让开发者能运用自己熟悉的编程语言编译，再藉虚拟机引擎在浏览器内运行。 —— <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/zh-cn/WebAssembly">维基百科</a></p>
</blockquote>
<p>我尝试将使用 Go 编写的 Coca 编译成 WASM，但是遇到一系列的问题（我已经忘了），体积似乎是个问题，所以我尝试使用 Rust 去构建另外一种可能性。Rust 官方提供了 Rust Webpack Template，因此我可以将其集成到我现有的前端应用中。只是呢，似乎还没有人会使用 Rust 去编写后端应用。</p>
<p>但是 WASM 提供了一种更友好的方式，即我们不需要重写现有的代码，而是只需要添加一些代码，便可以将现有的后端模型代码提到给前端使用。并且，与混淆后的 JavaScript 相比，它看上去更加安全 —— 学习成本更高一些。</p>
<h2 id="引子-6：ComponentLess"><a href="#引子-6：ComponentLess" class="headerlink" title="引子 6：ComponentLess"></a>引子 6：ComponentLess</h2><p>在研究 Serverless 和微前端的期间，我突然有了一点想法，我对于客户端领域的 Serverless 式架构有了一些基本的构想，叫：ComponentLess。尽管有了一些基础的理念，但是还缺乏一个真实可用的 Demo，所以我并没有定义出什么是 ComponentLess。</p>
<p>起先，我以为无代码编程是一个 ComponentLess 方向，但是一研究发现并不是。无代码编程倾向于可视化编程，而 ComponentLess 倾向于使用 DSL 编程。就这一点来说，我便偏向于使用 Web Components + WAM 技术来构建新的前端架构。</p>
<h3 id="ComponentLess"><a href="#ComponentLess" class="headerlink" title="ComponentLess"></a>ComponentLess</h3><p>从单体应用转向微服务架构的一大特质是，组件（非单指 UI 组件，可以视为服务）由函数调用转向了 HTTP 调用。而 Serverless 进一步地将微服务的服务级别 HTTP 调用，细化为函数级别的 HTTP 调用。</p>
<p>对于前端领域来说，也是如此。微前端将单体应用拆分一个个的独立运行前端应用，我们可以随意地组合这些应用。进一步地，结合诸如于 Web Component 这样的组件级方案，便可以将拆分细分为到 UI 组件的粒度。我们可以使用 （HTML Imports 已遗弃）script 标签从远程导入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;module&quot; src&#x3D;&quot;my-element.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;my-element&gt;&lt;&#x2F;my-element&gt;</span><br></pre></td></tr></table></figure>

<p>因此，在未来，不论是前端开发人员，还是开发人员，都可以通过集成组件的方式来开发应用。也就是说，我们只需要关注于编写核心业务代码即可，剩下的部分可以通过一些特殊的方式来实现。</p>
<h3 id="DSL-抽象化代码"><a href="#DSL-抽象化代码" class="headerlink" title="DSL 抽象化代码"></a>DSL 抽象化代码</h3><p>ComponentLess + Serverless 是<strong>代码即基础设施</strong>开始的一个标志。当代码开始作为基础设施的一部分时，代码便需要以某种方式才能组合到一起。在 Serverless Framework 中，开发人员通过配置接入服务端所使用的基础信息。而 YAML 配置本身也是 DSL 的一种，缺乏灵活度，但是使用非常简单。</p>
<p>事实上，这是两个选择：</p>
<ul>
<li>  配置 + 编程语言。 上手容易，迁移难</li>
<li>  DSL。 上手复杂，易于迁移</li>
</ul>
<p>但是，无论如何我还是如何 DSL，它听上去有着更丰富的 KPI。至于如何抽象化基础设计代码，可以参考《<a target="_blank" rel="noopener" href="https://github.com/phodal/cloud-dev">云研发：研发即代码</a>》一文。</p>
<h3 id="模型复用"><a href="#模型复用" class="headerlink" title="模型复用"></a>模型复用</h3><p>不论是 ComponentLess 还是 Serverless，它们都是由函数、UI 组件变为一个独立可运行的单元。为了与别人交互，它需要包含输入和输出。而输入和输出本身是需要一个数据模型作为支撑的，以此才能完成整个系统的稳定性。</p>
<p>而这个话题已经回到我们开头所讨论的内容里。</p>
<h2 id="前后端分离将死？"><a href="#前后端分离将死？" class="headerlink" title="前后端分离将死？"></a>前后端分离将死？</h2><p>在所有的引子里， 我们已经准备了所有的论据，所以只需要：</p>
<ul>
<li>  使用可以跨前后端的语言，构建领域模型</li>
<li>  将后端服务、前端设施细化为更小的组件</li>
<li>  设计 DSL 将领域模型转换到特定平台的代码</li>
</ul>
<p>你就可以杀死前后端分离，就是这么简单。</p>
<p>前后端分离将死，不是现在，但是可能在五年后开始。</p>
<p>你说呢？</p>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>架构，没有终点。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lzhwweb.github.io/nirvana/javascript/%E5%89%8D%E7%AB%AF/undefined%E5%92%8Cnull/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/nirvana/images/headphoto.jpeg">
      <meta itemprop="name" content="nirvana">
      <meta itemprop="description" content="个人学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="涅槃快乐是金">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/nirvana/javascript/%E5%89%8D%E7%AB%AF/undefined%E5%92%8Cnull/" class="post-title-link" itemprop="url">undefined 和 null</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-06-10 16:22:32 / 修改时间：17:02:24" itemprop="dateCreated datePublished" datetime="2021-06-10T16:22:32+08:00">2021-06-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/nirvana/categories/javascript/" itemprop="url" rel="index"><span itemprop="name">javascript</span></a>
        </span>
    </span>

  
    <span id="/nirvana/javascript/%E5%89%8D%E7%AB%AF/undefined%E5%92%8Cnull/" class="post-meta-item leancloud_visitors" data-flag-title="undefined 和 null" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>969</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>JavaScript 有两个表示‘空’的值，其中比较有用的是 <code>undefined</code>。</p>
<h3 id="undefined-的值"><a href="#undefined-的值" class="headerlink" title="undefined 的值"></a><code>undefined</code> 的值</h3><p><code>undefined</code> 是一个值为 <code>undefined</code> 的类型。</p>
<p>这个语言也定义了一个全局变量，它的值是 <code>undefined</code>，这个变量也被称为 <code>undefined</code>。 但是这个变量<strong>不是</strong>一个常量，也不是一个关键字。这意味着它的<em>值</em>可以轻易被覆盖。<br>下面的情况会返回 <code>undefined</code> 值：</p>
<ul>
<li>  访问未修改的全局变量 <code>undefined</code>。</li>
<li>  由于没有定义 <code>return</code> 表达式的函数隐式返回。</li>
<li>  <code>return</code> 表达式没有显式的返回任何内容。</li>
<li>  访问不存在的属性。</li>
<li>  函数参数没有被显式的传递值。</li>
<li>  任何被设置为 <code>undefined</code> 值的变量。</li>
</ul>
<h3 id="处理-undefined-值的改变"><a href="#处理-undefined-值的改变" class="headerlink" title="处理 undefined 值的改变"></a>处理 <code>undefined</code> 值的改变</h3><p>由于全局变量 <code>undefined</code> 只是保存了 <code>undefined</code> 类型实际<em>值</em>的副本， 因此对它赋新值<strong>不会</strong>改变类型 <code>undefined</code> 的值。</p>
<p>然而，为了方便其它变量和 <code>undefined</code> 做比较，我们需要事先获取类型 <code>undefined</code> 的值。</p>
<p>为了避免可能对 <code>undefined</code> 值的改变，一个常用的技巧是使用一个传递到<a target="_blank" rel="noopener" href="http://bonsaiden.github.io/JavaScript-Garden/zh/#function.scopes">匿名包装器</a>的额外参数。 在调用时，这个参数不会获取任何值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var undefined &#x3D; 123;</span><br><span class="line">(function(something, foo, undefined) &#123;    </span><br><span class="line">&#x2F;&#x2F; 局部作用域里的 undefined 变量重新获得了 &#96;undefined&#96; 值</span><br><span class="line">&#125;)(&#39;Hello World&#39;, 42);</span><br></pre></td></tr></table></figure>

<p>另外一种达到相同目的方法是在函数内使用变量声明。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var undefined &#x3D; 123;</span><br><span class="line">(function(something, foo) &#123;</span><br><span class="line">    var undefined;    ...</span><br><span class="line">&#125;)(&#39;Hello World&#39;, 42);</span><br></pre></td></tr></table></figure>

<p>这里唯一的区别是，在压缩后并且函数内没有其它需要使用 <code>var</code> 声明变量的情况下，这个版本的代码会多出 4 个字节的代码。</p>
<h3 id="null-的用处"><a href="#null-的用处" class="headerlink" title="null 的用处"></a><code>null</code> 的用处</h3><p>JavaScript 中的 <code>undefined</code> 的使用场景类似于其它语言中的 <em>null</em>，实际上 JavaScript 中的 <code>null</code> 是另外一种数据类型。</p>
<p>它在 JavaScript 内部有一些使用场景（比如声明原型链的终结 <code>Foo.prototype = null</code>），但是大多数情况下都可以使用 <code>undefined</code> 来代替。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lzhwweb.github.io/nirvana/javascript/%E5%89%8D%E7%AB%AF/instanceof%E6%93%8D%E4%BD%9C%E7%AC%A6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/nirvana/images/headphoto.jpeg">
      <meta itemprop="name" content="nirvana">
      <meta itemprop="description" content="个人学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="涅槃快乐是金">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/nirvana/javascript/%E5%89%8D%E7%AB%AF/instanceof%E6%93%8D%E4%BD%9C%E7%AC%A6/" class="post-title-link" itemprop="url">instanceof 操作符</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-06-10 16:21:13 / 修改时间：17:02:24" itemprop="dateCreated datePublished" datetime="2021-06-10T16:21:13+08:00">2021-06-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/nirvana/categories/javascript/" itemprop="url" rel="index"><span itemprop="name">javascript</span></a>
        </span>
    </span>

  
    <span id="/nirvana/javascript/%E5%89%8D%E7%AB%AF/instanceof%E6%93%8D%E4%BD%9C%E7%AC%A6/" class="post-meta-item leancloud_visitors" data-flag-title="instanceof 操作符" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>752</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><code>instanceof</code> 操作符用来比较两个操作数的构造函数。只有在比较自定义的对象时才有意义。 如果用来比较内置类型，将会和 <a target="_blank" rel="noopener" href="http://bonsaiden.github.io/JavaScript-Garden/zh/#types.typeof"><code>typeof</code> 操作符</a> 一样用处不大。</p>
<h3 id="比较自定义对象"><a href="#比较自定义对象" class="headerlink" title="比较自定义对象"></a>比较自定义对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Foo() &#123;&#125;</span><br><span class="line">function Bar() &#123;&#125;</span><br><span class="line">Bar.prototype &#x3D; new Foo();</span><br><span class="line"></span><br><span class="line">new Bar() instanceof Bar; &#x2F;&#x2F; true</span><br><span class="line">new Bar() instanceof Foo; &#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 如果仅仅设置 Bar.prototype 为函数 Foo 本身，而不是 Foo 构造函数的一个实例</span><br><span class="line">Bar.prototype &#x3D; Foo;</span><br><span class="line">new Bar() instanceof Foo; &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>

<h3 id="instanceof-比较内置类型"><a href="#instanceof-比较内置类型" class="headerlink" title="instanceof 比较内置类型"></a><code>instanceof</code> 比较内置类型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">new String(&#39;foo&#39;) instanceof String; &#x2F;&#x2F; true</span><br><span class="line">new String(&#39;foo&#39;) instanceof Object; &#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">&#39;foo&#39; instanceof String; &#x2F;&#x2F; false</span><br><span class="line">&#39;foo&#39; instanceof Object; &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>

<p>有一点需要注意，<code>instanceof</code> 用来比较属于不同 JavaScript 上下文的对象（比如，浏览器中不同的文档结构）时将会出错， 因为它们的构造函数不会是同一个对象。</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p><code>instanceof</code> 操作符应该<strong>仅仅</strong>用来比较来自同一个 JavaScript 上下文的自定义对象。 正如 <a target="_blank" rel="noopener" href="http://bonsaiden.github.io/JavaScript-Garden/zh/#types.typeof"><code>typeof</code></a> 操作符一样，任何其它的用法都应该是避免的。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lzhwweb.github.io/nirvana/javascript/%E5%89%8D%E7%AB%AF/hasOwnProperty%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/nirvana/images/headphoto.jpeg">
      <meta itemprop="name" content="nirvana">
      <meta itemprop="description" content="个人学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="涅槃快乐是金">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/nirvana/javascript/%E5%89%8D%E7%AB%AF/hasOwnProperty%E5%87%BD%E6%95%B0/" class="post-title-link" itemprop="url">hasOwnProperty 函数</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-06-10 16:20:16 / 修改时间：17:02:25" itemprop="dateCreated datePublished" datetime="2021-06-10T16:20:16+08:00">2021-06-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/nirvana/categories/javascript/" itemprop="url" rel="index"><span itemprop="name">javascript</span></a>
        </span>
    </span>

  
    <span id="/nirvana/javascript/%E5%89%8D%E7%AB%AF/hasOwnProperty%E5%87%BD%E6%95%B0/" class="post-meta-item leancloud_visitors" data-flag-title="hasOwnProperty 函数" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>为了判断一个对象是否包含<em>自定义</em>属性而<em>不是</em>原型链上的属性， 我们需要使用继承自 <code>Object.prototype</code> 的 <code>hasOwnProperty</code> 方法。</p>
<p><strong>注意:</strong> 通过判断一个属性是否 <code>undefined</code> 是<strong>不够</strong>的。 因为一个属性可能确实存在，只不过它的值被设置为 <code>undefined</code>。</p>
<p><code>hasOwnProperty</code> 是 JavaScript 中唯一一个处理属性但是<strong>不</strong>查找原型链的函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 修改Object.prototype</span><br><span class="line">Object.prototype.bar &#x3D; 1; </span><br><span class="line">var foo &#x3D; &#123;goo: undefined&#125;;</span><br><span class="line"></span><br><span class="line">foo.bar; &#x2F;&#x2F; 1</span><br><span class="line">&#39;bar&#39; in foo; &#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">foo.hasOwnProperty(&#39;bar&#39;); &#x2F;&#x2F; false</span><br><span class="line">foo.hasOwnProperty(&#39;goo&#39;); &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<p>只有 <code>hasOwnProperty</code> 可以给出正确和期望的结果，这在遍历对象的属性时会很有用。 <strong>没有</strong>其它方法可以用来排除原型链上的属性，而不是定义在对象<em>自身</em>上的属性。</p>
<h3 id="hasOwnProperty-作为属性"><a href="#hasOwnProperty-作为属性" class="headerlink" title="hasOwnProperty 作为属性"></a><code>hasOwnProperty</code> 作为属性</h3><p>JavaScript <strong>不会</strong>保护 <code>hasOwnProperty</code> 被非法占用，因此如果一个对象碰巧存在这个属性， 就需要使用<em>外部</em>的 <code>hasOwnProperty</code> 函数来获取正确的结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var foo &#x3D; &#123;</span><br><span class="line">    hasOwnProperty: function() &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;,</span><br><span class="line">    bar: &#39;Here be dragons&#39;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">foo.hasOwnProperty(&#39;bar&#39;); &#x2F;&#x2F; 总是返回 false</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用其它对象的 hasOwnProperty，并将其上下文设置为foo</span><br><span class="line">(&#123;&#125;).hasOwnProperty.call(foo, &#39;bar&#39;); &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>当检查对象上某个属性是否存在时，<code>hasOwnProperty</code> 是<strong>唯一</strong>可用的方法。 同时在使用 <code>for in</code> loop遍历对象时，推荐<strong>总是</strong>使用 <code>hasOwnProperty</code> 方法， 这将会避免<code>原型</code>对象扩展带来的干扰。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lzhwweb.github.io/nirvana/javascript/%E5%89%8D%E7%AB%AF/%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%E4%B8%8E%E8%A1%A8%E8%BE%BE%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/nirvana/images/headphoto.jpeg">
      <meta itemprop="name" content="nirvana">
      <meta itemprop="description" content="个人学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="涅槃快乐是金">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/nirvana/javascript/%E5%89%8D%E7%AB%AF/%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%E4%B8%8E%E8%A1%A8%E8%BE%BE%E5%BC%8F/" class="post-title-link" itemprop="url">函数声明与表达式</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-06-10 16:19:36 / 修改时间：17:02:25" itemprop="dateCreated datePublished" datetime="2021-06-10T16:19:36+08:00">2021-06-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/nirvana/categories/javascript/" itemprop="url" rel="index"><span itemprop="name">javascript</span></a>
        </span>
    </span>

  
    <span id="/nirvana/javascript/%E5%89%8D%E7%AB%AF/%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%E4%B8%8E%E8%A1%A8%E8%BE%BE%E5%BC%8F/" class="post-meta-item leancloud_visitors" data-flag-title="函数声明与表达式" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>702</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>函数是JavaScript中的一等对象，这意味着可以把函数像其它值一样传递。 一个常见的用法是把<em>匿名函数</em>作为回调函数传递到异步函数中。</p>
<h3 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>上面的方法会在执行前被 <code>解析(hoisted)</code>，因此它存在于当前上下文的<em>任意</em>一个地方， 即使在函数定义体的上面被调用也是对的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo(); &#x2F;&#x2F; 正常运行，因为foo在代码运行前已经被创建</span><br><span class="line">function foo() &#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="函数赋值表达式"><a href="#函数赋值表达式" class="headerlink" title="函数赋值表达式"></a>函数赋值表达式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var foo &#x3D; function() &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>这个例子把一个<em>匿名</em>的函数赋值给变量 <code>foo</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">foo; &#x2F;&#x2F; &#39;undefined&#39;</span><br><span class="line">foo(); &#x2F;&#x2F; 出错：TypeError</span><br><span class="line">var foo &#x3D; function() &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>由于 <code>var</code> 定义了一个声明语句，对变量 <code>foo</code> 的解析是在代码运行之前，因此 <code>foo</code> 变量在代码运行时已经被定义过了。</p>
<p>但是由于赋值语句只在运行时执行，因此在相应代码执行之前， <code>foo</code> 的值缺省为 <code>undefined</code>。</p>
<h3 id="命名函数的赋值表达式"><a href="#命名函数的赋值表达式" class="headerlink" title="命名函数的赋值表达式"></a>命名函数的赋值表达式</h3><p>另外一个特殊的情况是将命名函数赋值给一个变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var foo &#x3D; function bar() &#123;    </span><br><span class="line">        bar(); &#x2F;&#x2F; 正常运行</span><br><span class="line">&#125;</span><br><span class="line">bar(); &#x2F;&#x2F; 出错：ReferenceError</span><br></pre></td></tr></table></figure>

<p><code>bar</code> 函数声明外是不可见的，这是因为我们已经把函数赋值给了 <code>foo</code>； 然而在 <code>bar</code> 内部依然可见。这是由于 JavaScript 的  <code>命名处理</code>所致， 函数名在函数内<em>总是</em>可见的。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/nirvana/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/nirvana/">1</a><a class="page-number" href="/nirvana/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/nirvana/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/nirvana/page/25/">25</a><a class="extend next" rel="next" href="/nirvana/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>


<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">nirvana</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">736k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">11:09</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/nirvana/js/utils.js"></script><script src="/nirvana/js/motion.js"></script><script src="/nirvana/js/next-boot.js"></script><script src="/nirvana/js/bookmark.js"></script>

  
<script src="/nirvana/js/local-search.js"></script>






  


<script>
  (function() {
    function leancloudSelector(url) {
      url = encodeURI(url);
      return document.getElementById(url).querySelector('.leancloud-visitors-count');
    }

    function addCount(Counter) {
      const visitors = document.querySelector('.leancloud_visitors');
      const url = decodeURI(visitors.id);
      const title = visitors.dataset.flagTitle;

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url })))
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            const counter = results[0];
            leancloudSelector(url).innerText = counter.time + 1;
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .catch(error => {
                console.error('Failed to save visitor count', error);
              });
          } else {
              leancloudSelector(url).innerText = 'Counter not initialized! More info at console err msg.';
              console.error('ATTENTION! LeanCloud counter has security bug, see how to solve it here: https://github.com/theme-next/hexo-leancloud-counter-security. \n However, you can still use LeanCloud without security, by setting `security` option to `false`.');
            
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    function showTime(Counter) {
      const visitors = document.querySelectorAll('.leancloud_visitors');
      const entries = [...visitors].map(element => {
        return decodeURI(element.id);
      });

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url: { '$in': entries } })))
        .then(response => response.json())
        .then(({ results }) => {
          for (let url of entries) {
            const target = results.find(item => item.url === url);
            leancloudSelector(url).innerText = target ? target.time : 0;
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    const { app_id, app_key, server_url } = {"enable":true,"app_id":"SPsNUvBhME7XmrjzCfHkUu3e-gzGzoHsz","app_key":"4TONafemiIzvJUwqLa7WveoL","server_url":"https://leancloud.cn","security":true,"betterPerformance":false};
    function fetchData(api_server) {
      const Counter = (method, url, data) => {
        return fetch(`${api_server}/1.1${url}`, {
          method,
          headers: {
            'X-LC-Id'     : app_id,
            'X-LC-Key'    : app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        if (CONFIG.hostname !== location.hostname) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    }

    const api_server = app_id.slice(-9) === '-MdYXbMMI' ? `https://${app_id.slice(0, 8).toLowerCase()}.api.lncldglobal.com` : server_url;

    if (api_server) {
      fetchData(api_server);
    } else {
      fetch('https://app-router.leancloud.cn/2/route?appId=' + app_id)
        .then(response => response.json())
        .then(({ api_server }) => {
          fetchData('https://' + api_server);
        });
    }
  })();
</script>



</body>
</html>
