<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
 <meta name="referrer" content="no-referrer"/>

  <link rel="apple-touch-icon" sizes="180x180" href="/nirvana/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/nirvana/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/nirvana/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/nirvana/images/logo.svg" color="#222">

<link rel="stylesheet" href="/nirvana/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.2/css/all.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"lzhwweb.github.io","root":"/nirvana/","images":"/nirvana/images","scheme":"Gemini","version":"8.2.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}};
  </script>
<meta name="description" content="个人学习笔记">
<meta property="og:type" content="website">
<meta property="og:title" content="涅槃快乐是金">
<meta property="og:url" content="https://lzhwweb.github.io/nirvana/page/3/index.html">
<meta property="og:site_name" content="涅槃快乐是金">
<meta property="og:description" content="个人学习笔记">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="nirvana">
<meta property="article:tag" content="前端,javascript,node,git">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://lzhwweb.github.io/nirvana/page/3/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>
<title>涅槃快乐是金</title>
  




  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/nirvana/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">涅槃快乐是金</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/nirvana/" rel="section">首页</a></li>
        <li class="menu-item menu-item-git"><a href="/nirvana/categories/git" rel="section">git</a></li>
        <li class="menu-item menu-item-linux"><a href="/nirvana/categories/linux" rel="section">linux</a></li>
        <li class="menu-item menu-item-android"><a href="/nirvana/categories/android" rel="section">android</a></li>
        <li class="menu-item menu-item-随笔"><a href="/nirvana/categories/informal" rel="section">随笔</a></li>
        <li class="menu-item menu-item-mac"><a href="/nirvana/categories/mac" rel="section">mac</a></li>
        <li class="menu-item menu-item-react-native"><a href="/nirvana/categories/reactnative" rel="section">react-native</a></li>
        <li class="menu-item menu-item-算法"><a href="/nirvana/categories/algorithm" rel="section">算法</a></li>
        <li class="menu-item menu-item-读书笔记"><a href="/nirvana/categories/note" rel="section">读书笔记</a></li>
        <li class="menu-item menu-item-开发工具"><a href="/nirvana/categories/tool" rel="section">开发工具</a></li>
        <li class="menu-item menu-item-设计模式(ts)"><a href="/nirvana/categories/DesignPattern" rel="section">设计模式(TS)</a></li>
        <li class="menu-item menu-item-前端"><a href="/nirvana/categories/javascript" rel="section">前端</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">nirvana</p>
  <div class="site-description" itemprop="description">个人学习笔记</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/nirvana/archives">
          <span class="site-state-item-count">178</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lzhwweb.github.io/nirvana/javascript/%E5%89%8D%E7%AB%AF/JavaScript%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E6%96%B9%E6%B3%95-%EF%BC%888%EF%BC%89Other-%E5%85%B6%E5%AE%83%E6%93%8D%E4%BD%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/nirvana/images/avatar.gif">
      <meta itemprop="name" content="nirvana">
      <meta itemprop="description" content="个人学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="涅槃快乐是金">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/nirvana/javascript/%E5%89%8D%E7%AB%AF/JavaScript%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E6%96%B9%E6%B3%95-%EF%BC%888%EF%BC%89Other-%E5%85%B6%E5%AE%83%E6%93%8D%E4%BD%9C/" class="post-title-link" itemprop="url">JavaScript常用工具方法-（8）Other-其它操作</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-03-11 21:12:40" itemprop="dateCreated datePublished" datetime="2021-03-11T21:12:40+08:00">2021-03-11</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-03-10 13:07:19" itemprop="dateModified" datetime="2021-03-10T13:07:19+08:00">2021-03-10</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/nirvana/categories/javascript/" itemprop="url" rel="index"><span itemprop="name">javascript</span></a>
        </span>
    </span>

  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>3.7k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="8-Other-其它操作"><a href="#8-Other-其它操作" class="headerlink" title="8. Other 其它操作"></a>8. Other 其它操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*获取网址参数*&#x2F;</span><br><span class="line">getURL(name)&#123;</span><br><span class="line">    var reg &#x3D; new RegExp(&quot;(^|&amp;)&quot;+ name +&quot;&#x3D;([^&amp;]*)(&amp;|$)&quot;);</span><br><span class="line">    var r &#x3D; decodeURI(window.location.search).substr(1).match(reg);</span><br><span class="line">    if(r!&#x3D;null) return  r[2]; return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*获取全部url参数,并转换成json对象*&#x2F;</span><br><span class="line">getUrlAllParams (url) &#123;</span><br><span class="line">    var url &#x3D; url ? url : window.location.href;</span><br><span class="line">    var _pa &#x3D; url.substring(url.indexOf(&#39;?&#39;) + 1),</span><br><span class="line">        _arrS &#x3D; _pa.split(&#39;&amp;&#39;),</span><br><span class="line">        _rs &#x3D; &#123;&#125;;</span><br><span class="line">    for (var i &#x3D; 0, _len &#x3D; _arrS.length; i &lt; _len; i++) &#123;</span><br><span class="line">        var pos &#x3D; _arrS[i].indexOf(&#39;&#x3D;&#39;);</span><br><span class="line">        if (pos &#x3D;&#x3D; -1) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        var name &#x3D; _arrS[i].substring(0, pos),</span><br><span class="line">            value &#x3D; window.decodeURIComponent(_arrS[i].substring(pos + 1));</span><br><span class="line">        _rs[name] &#x3D; value;</span><br><span class="line">    &#125;</span><br><span class="line">    return _rs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*删除url指定参数，返回url*&#x2F;</span><br><span class="line">delParamsUrl(url, name)&#123;</span><br><span class="line">    var baseUrl &#x3D; url.split(&#39;?&#39;)[0] + &#39;?&#39;;</span><br><span class="line">    var query &#x3D; url.split(&#39;?&#39;)[1];</span><br><span class="line">    if (query.indexOf(name)&gt;-1) &#123;</span><br><span class="line">        var obj &#x3D; &#123;&#125;</span><br><span class="line">        var arr &#x3D; query.split(&quot;&amp;&quot;);</span><br><span class="line">        for (var i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">            arr[i] &#x3D; arr[i].split(&quot;&#x3D;&quot;);</span><br><span class="line">            obj[arr[i][0]] &#x3D; arr[i][1];</span><br><span class="line">        &#125;;</span><br><span class="line">        delete obj[name];</span><br><span class="line">        var url &#x3D; baseUrl + JSON.stringify(obj).replace(&#x2F;[\&quot;\&#123;\&#125;]&#x2F;g,&quot;&quot;).replace(&#x2F;\:&#x2F;g,&quot;&#x3D;&quot;).replace(&#x2F;\,&#x2F;g,&quot;&amp;&quot;);</span><br><span class="line">        return url</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return url;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*获取十六进制随机颜色*&#x2F;</span><br><span class="line">getRandomColor () &#123;</span><br><span class="line">    return &#39;#&#39; + (function(h) &#123;</span><br><span class="line">        return new Array(7 - h.length).join(&quot;0&quot;) + h;</span><br><span class="line">    &#125;)((Math.random() * 0x1000000 &lt;&lt; 0).toString(16));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*图片加载*&#x2F;</span><br><span class="line">imgLoadAll(arr,callback)&#123;</span><br><span class="line">    var arrImg &#x3D; []; </span><br><span class="line">    for (var i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">        var img &#x3D; new Image();</span><br><span class="line">        img.src &#x3D; arr[i];</span><br><span class="line">        img.onload &#x3D; function()&#123;</span><br><span class="line">            arrImg.push(this);</span><br><span class="line">            if (arrImg.length &#x3D;&#x3D; arr.length) &#123;</span><br><span class="line">                callback &amp;&amp; callback();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*音频加载*&#x2F;</span><br><span class="line">loadAudio(src, callback) &#123;</span><br><span class="line">    var audio &#x3D; new Audio(src);</span><br><span class="line">    audio.onloadedmetadata &#x3D; callback;</span><br><span class="line">    audio.src &#x3D; src;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*DOM转字符串*&#x2F;</span><br><span class="line">domToStirng(htmlDOM)&#123;</span><br><span class="line">    var div&#x3D; document.createElement(&quot;div&quot;);</span><br><span class="line">    div.appendChild(htmlDOM);</span><br><span class="line">    return div.innerHTML</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*字符串转DOM*&#x2F;</span><br><span class="line">stringToDom(htmlString)&#123;</span><br><span class="line">    var div&#x3D; document.createElement(&quot;div&quot;);</span><br><span class="line">    div.innerHTML&#x3D;htmlString;</span><br><span class="line">    return div.children[0];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 光标所在位置插入字符，并设置光标位置</span><br><span class="line"> * </span><br><span class="line"> * @param &#123;dom&#125; 输入框</span><br><span class="line"> * @param &#123;val&#125; 插入的值</span><br><span class="line"> * @param &#123;posLen&#125; 光标位置处在 插入的值的哪个位置</span><br><span class="line"> *&#x2F;</span><br><span class="line">setCursorPosition (dom,val,posLen) &#123;</span><br><span class="line">    var cursorPosition &#x3D; 0;</span><br><span class="line">    if(dom.selectionStart)&#123;</span><br><span class="line">        cursorPosition &#x3D; dom.selectionStart;</span><br><span class="line">    &#125;</span><br><span class="line">    this.insertAtCursor(dom,val);</span><br><span class="line">    dom.focus();</span><br><span class="line">    console.log(posLen)</span><br><span class="line">    dom.setSelectionRange(dom.value.length,cursorPosition + (posLen || val.length));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*光标所在位置插入字符*&#x2F;</span><br><span class="line">insertAtCursor(dom, val) &#123;</span><br><span class="line">    if (document.selection)&#123;</span><br><span class="line">        dom.focus();</span><br><span class="line">        sel &#x3D; document.selection.createRange();</span><br><span class="line">        sel.text &#x3D; val;</span><br><span class="line">        sel.select();</span><br><span class="line">    &#125;else if (dom.selectionStart || dom.selectionStart &#x3D;&#x3D; &#39;0&#39;)&#123;</span><br><span class="line">        let startPos &#x3D; dom.selectionStart;</span><br><span class="line">        let endPos &#x3D; dom.selectionEnd;</span><br><span class="line">        let restoreTop &#x3D; dom.scrollTop;</span><br><span class="line">        dom.value &#x3D; dom.value.substring(0, startPos) + val + dom.value.substring(endPos, dom.value.length);</span><br><span class="line">        if (restoreTop &gt; 0)&#123;</span><br><span class="line">            dom.scrollTop &#x3D; restoreTop;</span><br><span class="line">        &#125;</span><br><span class="line">        dom.focus();</span><br><span class="line">        dom.selectionStart &#x3D; startPos + val.length;</span><br><span class="line">        dom.selectionEnd &#x3D; startPos + val.length;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        dom.value +&#x3D; val;</span><br><span class="line">        dom.focus();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lzhwweb.github.io/nirvana/javascript/%E5%89%8D%E7%AB%AF/JavaScript%E7%9A%84%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/nirvana/images/avatar.gif">
      <meta itemprop="name" content="nirvana">
      <meta itemprop="description" content="个人学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="涅槃快乐是金">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/nirvana/javascript/%E5%89%8D%E7%AB%AF/JavaScript%E7%9A%84%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/" class="post-title-link" itemprop="url">JavaScript的值传递和引用传递</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-03-11 21:12:40" itemprop="dateCreated datePublished" datetime="2021-03-11T21:12:40+08:00">2021-03-11</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-03-10 13:14:04" itemprop="dateModified" datetime="2021-03-10T13:14:04+08:00">2021-03-10</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/nirvana/categories/javascript/" itemprop="url" rel="index"><span itemprop="name">javascript</span></a>
        </span>
    </span>

  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li>  原文: <a target="_blank" rel="noopener" href="https://codeburst.io/explaining-value-vs-reference-in-javascript-647a975e12a0">Explaining Value vs. Reference in Javascript</a></li>
</ul>
<p><strong>为了保证可读性，本文采用意译而非直译。另外，本文版权归原作者所有，翻译仅用于学习。</strong></p>
<p>JavaScript有5种基本的数据类型，分别是：布尔、null、undefined、String和Number。这些基本类型在赋值的时候是通过值传递的方式。值得注意的是还有另外三种类型: Array、Function和Object，它们通过引用来传递。从底层技术上看，它们三都是对象。</p>
<h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p>如果一个基本的数据类型绑定到某个变量，我们可以认为该变量包含这个基本数据类型的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var x &#x3D; 10;</span><br><span class="line">var y &#x3D; &#39;abc&#39;;</span><br><span class="line">var z &#x3D; null;</span><br></pre></td></tr></table></figure>
<p>当我们使用<code>=</code>将这些变量赋值到另外的变量，实际上是将对应的值拷贝了一份，然后赋值给新的变量。我们把它称作<code>值传递</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var x &#x3D; 10;</span><br><span class="line">var y &#x3D; &#39;abc&#39;;</span><br><span class="line"></span><br><span class="line">var a &#x3D; x;</span><br><span class="line">var b &#x3D; y;</span><br><span class="line"></span><br><span class="line">console.log(x, y, a, b) &#x2F;&#x2F; 10, &#39;abc&#39;, 10, &#39;abc&#39;</span><br></pre></td></tr></table></figure>
<p><code>a</code>和<code>x</code>都包含10，<code>b</code>和<code>y</code>都包含<code>&#39;abc&#39;</code>，并且它们是完全独立的拷贝，互不干涉。如果我们将<code>a</code>的值改变，<code>x</code>不会受到影响。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var x &#x3D; 10;</span><br><span class="line">var y &#x3D; &#39;abc&#39;;</span><br><span class="line">var a &#x3D; x;</span><br><span class="line">var b &#x3D; y;</span><br><span class="line">a &#x3D; 5;</span><br><span class="line">b &#x3D; &#39;def&#39;;</span><br><span class="line">console.log(x, y, a, b); &#x2F;&#x2F; 10, &#39;abc&#39;, 5, &#39;def&#39;</span><br></pre></td></tr></table></figure>
<p>###对象</p>
<p>如果一个变量绑定到一个非基本数据类型(Array, Function, Object)，那么它只记录了一个内存地址，该地址存放了具体的数据。注意之前提到指向基本数据类型的变量相当于包含了数据，而现在指向非基本数据类型的变量本身是不包含数据的。</p>
<p>对象在内存中被创建，当我们声明<code>arr = []</code>，我们在内存中创建了一个数组。<code>arr</code>记录的是该内存的地址。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var arr &#x3D; []; &#x2F;&#x2F; (a)</span><br><span class="line">arr.push(1); &#x2F;&#x2F; (b)</span><br></pre></td></tr></table></figure>

<p>当执行完(a)之后，内存中创建了一个空的数组对象，其内存地址为<code>#001</code>，<code>arr</code>指向该地址。</p>
<table>
<thead>
<tr>
<th>变量</th>
<th>地址</th>
<th>对象</th>
</tr>
</thead>
<tbody><tr>
<td>arr</td>
<td>#001</td>
<td>[]</td>
</tr>
</tbody></table>
<p>当执行完(b)之后，数组对象中多了一个元素，但是数组的地址依然没有变，<code>arr</code>也没有变。</p>
<table>
<thead>
<tr>
<th>变量</th>
<th>地址</th>
<th>对象</th>
</tr>
</thead>
<tbody><tr>
<td>arr</td>
<td>#001</td>
<td>[1]</td>
</tr>
</tbody></table>
<h3 id="引用传递"><a href="#引用传递" class="headerlink" title="引用传递"></a>引用传递</h3><p>对象是通过引用传递，而不是值传递。也就是说，变量赋值只会将地址传递过去。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var reference &#x3D; [1];</span><br><span class="line">var refCopy &#x3D; reference;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>变量</th>
<th>地址</th>
<th>对象</th>
</tr>
</thead>
<tbody><tr>
<td>reference</td>
<td>#001</td>
<td>[1]</td>
</tr>
<tr>
<td>refCopy</td>
<td>#001</td>
<td></td>
</tr>
</tbody></table>
<p><code>reference</code>和<code>refCopy</code>指向同一个数组。 如果我们更新<code>reference</code>，<code>refCopy</code>也会受到影响。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reference.push(2);</span><br><span class="line">console.log(reference, refCopy); &#x2F;&#x2F; [1, 2], [1, 2]</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>变量</th>
<th>地址</th>
<th>对象</th>
</tr>
</thead>
<tbody><tr>
<td>reference</td>
<td>#001</td>
<td>[1, 2]</td>
</tr>
<tr>
<td>refCopy</td>
<td>#001</td>
<td></td>
</tr>
</tbody></table>
<p>###引用重新赋值</p>
<p>如果我们将一个已经赋值的变量重新赋值，那么它将包含新的数据或则引用地址。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; &#123; first: &#39;fundebug.com&#39;&#125;;</span><br><span class="line">obj &#x3D; &#123; second: &#39;fundebug.cn&#39;&#125;;</span><br></pre></td></tr></table></figure>

<p><code>obj</code>从指向第一个对象变为指向第二个对象。</p>
<table>
<thead>
<tr>
<th>变量</th>
<th>地址</th>
<th>对象</th>
</tr>
</thead>
<tbody><tr>
<td>obj</td>
<td>#001</td>
<td>{first: ‘fundebug.com’}</td>
</tr>
<tr>
<td></td>
<td>#002</td>
<td>{second: ‘fundebug.cn’}</td>
</tr>
</tbody></table>
<p>如果一个对象没有被任何变量指向，就如第一个对象(地址为<code>#001</code>)，JavaScript引擎的垃圾回收机制会将该对象销毁并释放内存。</p>
<p>###== 和 ===</p>
<p>对于引用类型的变量，<code>==</code>和<code>===</code>只会判断引用的地址是否相同，而不会判断对象具体里属性以及值是否相同。因此，如果两个变量指向相同的对象，则返回<code>true</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var arrRef &#x3D; [&#39;Hi!&#39;];</span><br><span class="line">var arrRef2 &#x3D; arrRef;</span><br><span class="line"></span><br><span class="line">console.log(arrRef &#x3D;&#x3D;&#x3D; arrRef2); &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>
<p>如果是不同的对象，即使包含相同的属性和值，也会返回<code>false</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var arr1 &#x3D; [&quot;Hi!&quot;];</span><br><span class="line">var arr2 &#x3D; [&quot;Hi!&quot;];</span><br><span class="line"></span><br><span class="line">console.log(arr1 &#x3D;&#x3D;&#x3D; arr2); &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>
<p>如果想判断两个不同的对象是否真的相同，一个简单的方法就是将它们转换为字符串然后判断。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var arr1str &#x3D; JSON.stringify(arr1);</span><br><span class="line">var arr2str &#x3D; JSON.stringify(arr2);</span><br><span class="line"></span><br><span class="line">console.log(arr1str &#x3D;&#x3D;&#x3D; arr2str); &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<p>另一个方法就是递归地判断每一个属性的值，直到基本类型位置，然后判断是否相同。</p>
<p>###函数参数</p>
<p>当我们将基本类型数据传入函数，函数会将这些数据拷贝赋值给函数的参数变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var hundred &#x3D; 100;</span><br><span class="line">var two &#x3D; 2;</span><br><span class="line">function multiply(x, y) &#123;</span><br><span class="line"> return x * y;</span><br><span class="line">&#125;</span><br><span class="line">var twoHundred &#x3D; multiply(hundred, two);</span><br></pre></td></tr></table></figure>

<p><code>hundred</code>的值拷贝给变量<code>x</code>，<code>two</code>的值拷贝给变量<code>y</code>。</p>
<h3 id="纯函数"><a href="#纯函数" class="headerlink" title="纯函数"></a>纯函数</h3><p>对于一个函数，给定一个输入，返回一个唯一的输出。除此之外，不会对外部环境产生任何附带影响。我们机会称该函数为纯函数。所有函数内部定义的变量在函数返回之后都被垃圾回收掉。</p>
<p>但是，如果函数的输入是对象(Array, Function, Object)，那么传入的是一个引用。对该变量的操作将会影响到原本的对象。这样的编程手法将产生附带影响，是的代码的逻辑复杂和可读性变低。</p>
<p>因此，很多数组函数，比如<code>Array.map</code>和<code>Array.filter</code>是以纯函数的形式实现。虽然它们的参数是一个数组变量，但是通过深度拷贝并赋值给一个新的变量，然后在新的数组上操作，来防止原始数组被更改。</p>
<p>我们来看一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function changeAgeImpure(person) &#123;</span><br><span class="line"> person.age &#x3D; 25;</span><br><span class="line"> return person;</span><br><span class="line">&#125;</span><br><span class="line">var alex &#x3D; &#123;</span><br><span class="line"> name: &#39;Alex&#39;,</span><br><span class="line"> age: 30</span><br><span class="line">&#125;;</span><br><span class="line">var changedAlex &#x3D; changeAgeImpure(alex);</span><br><span class="line">console.log(alex); &#x2F;&#x2F; &#123; name: &#39;Alex&#39;, age: 25 &#125;</span><br><span class="line">console.log(changedAlex); &#x2F;&#x2F; &#123; name: &#39;Alex&#39;, age: 25 &#125;</span><br></pre></td></tr></table></figure>

<p>在非纯函数<code>changeAgeImpure</code>中，将对象<code>person</code>的<code>age</code>更新并返回。原始的<code>alex</code>对象也被影响，<code>age</code>更新为25。</p>
<p>让我们来看如何实现一个纯函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function changeAgePure(person) &#123;</span><br><span class="line"> var newPersonObj &#x3D; JSON.parse(JSON.stringify(person));</span><br><span class="line"> newPersonObj.age &#x3D; 25;</span><br><span class="line"> return newPersonObj;</span><br><span class="line">&#125;</span><br><span class="line">var alex &#x3D; &#123;</span><br><span class="line"> name: &#39;Alex&#39;,</span><br><span class="line"> age: 30</span><br><span class="line">&#125;;</span><br><span class="line">var alexChanged &#x3D; changeAgePure(alex);</span><br><span class="line">console.log(alex); &#x2F;&#x2F; &#123; name: &#39;Alex&#39;, age: 30 &#125;</span><br><span class="line">console.log(alexChanged); &#x2F;&#x2F; &#123; name: &#39;Alex&#39;, age: 25 &#125;</span><br></pre></td></tr></table></figure>
<p>我们通过<code>JSON.sringify</code>将对象变为一个字符串，然后再通过<code>JSON.parse</code>将字符串变回对象。通过该操作会生成一个新的对象。</p>
<p>###一道简单的面试题</p>
<p>值传递和引用传递经常在面试中被问到，来尝试回答一下如下代码如何输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function changeAgeAndReference(person) &#123;</span><br><span class="line"> person.age &#x3D; 25;</span><br><span class="line"> person &#x3D; &#123;</span><br><span class="line"> name: &#39;John&#39;,</span><br><span class="line"> age: 50</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"> return person;</span><br><span class="line">&#125;</span><br><span class="line">var personObj1 &#x3D; &#123;</span><br><span class="line"> name: &#39;Alex&#39;,</span><br><span class="line"> age: 30</span><br><span class="line">&#125;;</span><br><span class="line">var personObj2 &#x3D; changeAgeAndReference(personObj1);</span><br><span class="line">console.log(personObj1); &#x2F;&#x2F; -&gt; ?</span><br><span class="line">console.log(personObj2); &#x2F;&#x2F; -&gt; ?</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lzhwweb.github.io/nirvana/javascript/%E5%89%8D%E7%AB%AF/JavaScript%E9%9D%A2%E8%AF%95%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/nirvana/images/avatar.gif">
      <meta itemprop="name" content="nirvana">
      <meta itemprop="description" content="个人学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="涅槃快乐是金">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/nirvana/javascript/%E5%89%8D%E7%AB%AF/JavaScript%E9%9D%A2%E8%AF%95%E9%A2%98/" class="post-title-link" itemprop="url">JavaScript面试题</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-03-11 21:12:40" itemprop="dateCreated datePublished" datetime="2021-03-11T21:12:40+08:00">2021-03-11</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-03-10 13:14:04" itemprop="dateModified" datetime="2021-03-10T13:14:04+08:00">2021-03-10</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/nirvana/categories/javascript/" itemprop="url" rel="index"><span itemprop="name">javascript</span></a>
        </span>
    </span>

  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.4k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> (function()&#123; </span><br><span class="line">        var a &#x3D; b &#x3D;5;</span><br><span class="line">    &#125;)();</span><br><span class="line">console.log(b);</span><br></pre></td></tr></table></figure>

<p><strong>答案：</strong><code>5</code></p>
<blockquote>
<p>这个问题考查的要点是两个不同的作用域，’a’被var声明成了一个局部变量，但是’b’实际上没有被定义，所以它是一个全局变量。<br>这个问题还牵扯到另个一个比较重要的问题，就是strict mode，如果你选择了strict mode，上面的代码就会报Uncaught ReferenceError，因为b没有被定义，它可以帮你检查出代码的一些问题：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> (function()&#123; </span><br><span class="line">      &#39;use strict&#39;; </span><br><span class="line">      var a &#x3D; window.b &#x3D;5;</span><br><span class="line">    &#125;)();</span><br><span class="line">console.log(b);</span><br></pre></td></tr></table></figure>
<h2 id="创建“native”方法"><a href="#创建“native”方法" class="headerlink" title="创建“native”方法"></a>创建“native”方法</h2><p>写一个重复打印字符串对象的方法，输入一个整数，这个整数代表重复打印的字数，比如：</p>
<p> console.log(‘hello’.repeatify(3));</p>
<p>这样会打印出hellohellohello。</p>
<h3 id="答案："><a href="#答案：" class="headerlink" title="答案："></a>答案：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String.prototype.repeatify &#x3D;String.prototype.repeatify ||function(times)&#123;</span><br><span class="line">    var str &#x3D;&#39;&#39;;</span><br><span class="line">    for(var i &#x3D;0; i &lt; times; i++)&#123;</span><br><span class="line">    str +&#x3D;this;</span><br><span class="line">    &#125;</span><br><span class="line">    return str;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<p>这个问题考查的是开发者对JavaScript继承和prototype属性的了解程度。</p>
<h2 id="Hoisting"><a href="#Hoisting" class="headerlink" title="Hoisting"></a>Hoisting</h2><p>下面这段代码的输出结果是什么？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function test()&#123;</span><br><span class="line">   console.log(a);</span><br><span class="line">   console.log(foo()); var a &#x3D;1; function foo()&#123;</span><br><span class="line">   return2;</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   test();</span><br></pre></td></tr></table></figure>
<p><strong>答案:</strong><code>undefined和2</code></p>
<p>上面的代码和下面这段是等效的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function test()&#123; var a; function foo()&#123;</span><br><span class="line">    return2;</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(a);</span><br><span class="line">    console.log(foo());</span><br><span class="line">    a &#x3D;1;</span><br><span class="line">    &#125;</span><br><span class="line">    test();</span><br></pre></td></tr></table></figure>
<h2 id="在JavaScript中如何执行"><a href="#在JavaScript中如何执行" class="headerlink" title="在JavaScript中如何执行"></a>在JavaScript中如何执行</h2><p>通过下面的代码给出结果，解释一下你的答案：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D;&#123;</span><br><span class="line">    fullname:&#39;Colin Ihrig&#39;,</span><br><span class="line">    prop:&#123;</span><br><span class="line">          fullname:&#39;Aurelio De Rosa&#39;,</span><br><span class="line">          getFullname:function()&#123;</span><br><span class="line">                  return this.fullname;</span><br><span class="line">           &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">console.log(obj.prop.getFullname()); var test &#x3D; obj.prop.getFullname;</span><br><span class="line">console.log(test());</span><br></pre></td></tr></table></figure>

<p><strong>答案：</strong><code>Aurelio De Rosa 和John Doe</code></p>
<h2 id="call-和-apply"><a href="#call-和-apply" class="headerlink" title="call() 和 apply()"></a>call() 和 apply()</h2><p>解决前面的问题之后让最后一个console.log()输出Aurelio De Rosa.</p>
<p><strong>答案：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(test.call(obj.prop));</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这个问题在于call()还是apply()。 </p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lzhwweb.github.io/nirvana/javascript/%E5%89%8D%E7%AB%AF/Javascript%E8%87%AA%E8%BA%AB%E6%89%A7%E8%A1%8C%E6%95%88%E7%8E%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/nirvana/images/avatar.gif">
      <meta itemprop="name" content="nirvana">
      <meta itemprop="description" content="个人学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="涅槃快乐是金">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/nirvana/javascript/%E5%89%8D%E7%AB%AF/Javascript%E8%87%AA%E8%BA%AB%E6%89%A7%E8%A1%8C%E6%95%88%E7%8E%87/" class="post-title-link" itemprop="url">Javascript自身执行效率</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-03-11 21:12:40" itemprop="dateCreated datePublished" datetime="2021-03-11T21:12:40+08:00">2021-03-11</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-03-10 13:08:29" itemprop="dateModified" datetime="2021-03-10T13:08:29+08:00">2021-03-10</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/nirvana/categories/javascript/" itemprop="url" rel="index"><span itemprop="name">javascript</span></a>
        </span>
    </span>

  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.9k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Javascript中的作用域链、闭包、原型继承、eval等特性，在提供各种神奇功能的同时也带来了各种效率问题，用之不慎就会导致执行效率低下。</p>
<h2 id="1、全局导入"><a href="#1、全局导入" class="headerlink" title="1、全局导入"></a>1、全局导入</h2><p>我们在编码过程中多多少少会使用到一些全局变量（window,document,自定义全局变量等等），了解javascript作用域链的人都知道，在局部作用域中访问全局变量需要一层一层遍历整个作用域链直至顶级作用域，而局部变量的访问效率则会更快更高，因此在局部作用域中高频率使用一些全局对象时可以将其导入到局部作用域中，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> &#x2F;&#x2F;1、作为参数传入模块</span><br><span class="line">  (function(window,$)&#123;</span><br><span class="line">      var xxx &#x3D; window.xxx;</span><br><span class="line">      $(&quot;#xxx1&quot;).xxx();</span><br><span class="line">      $(&quot;#xxx2&quot;).xxx();</span><br><span class="line">  &#125;)(window,jQuery);</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F;2、暂存到局部变量</span><br><span class="line">  function()&#123;</span><br><span class="line">     var doc &#x3D; document;</span><br><span class="line">     var global &#x3D; window.global;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2、eval以及类eval问题"><a href="#2、eval以及类eval问题" class="headerlink" title="2、eval以及类eval问题"></a>2、eval以及类eval问题</h2><p>我们都知道eval可以将一段字符串当做js代码来执行处理，据说使用eval执行的代码比不使用eval的代码慢100倍以上（具体效率我没有测试，有兴趣同学可以测试一下）</p>
<p>JavaScript 代码在执行前会进行类似“预编译”的操作：首先会创建一个当前执行环境下的活动对象，并将那些用 var 申明的变量设置为活动对象的属性，但是此时这些变量的赋值都是 undefined，并将那些以 function 定义的函数也添加为活动对象的属性，而且它们的值正是函数的定义。但是，如果你使用了“eval”，则“eval”中的代码（实际上为字符串）无法预先识别其上下文，无法被提前解析和优化，即无法进行预编译的操作。所以，其性能也会大幅度降低</p>
<p>其实现在大家一般都很少会用eval了，这里我想说的是两个类eval的场景</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(new Function&#123;&#125;,setTimeout,setInterver)</span><br><span class="line"></span><br><span class="line">setTimtout(&quot;alert(1)&quot;,1000);</span><br><span class="line"></span><br><span class="line">setInterver(&quot;alert(1)&quot;,1000);</span><br><span class="line"></span><br><span class="line">(new Function(&quot;alert(1)&quot;))();</span><br></pre></td></tr></table></figure>
<p>上述几种类型代码执行效率都会比较低，因此建议直接传入匿名方法、或者方法的引用给setTimeout方法</p>
<h2 id="3、闭包结束后释放掉不再被引用的变量"><a href="#3、闭包结束后释放掉不再被引用的变量" class="headerlink" title="3、闭包结束后释放掉不再被引用的变量"></a>3、闭包结束后释放掉不再被引用的变量</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var f &#x3D; (function()&#123;</span><br><span class="line">    var a &#x3D; &#123;name:&quot;var3&quot;&#125;;</span><br><span class="line">    var b &#x3D; [&quot;var1&quot;,&quot;var2&quot;];</span><br><span class="line">    var c &#x3D; document.getElementByTagName(&quot;li&quot;);</span><br><span class="line">    &#x2F;&#x2F;****其它变量</span><br><span class="line">    &#x2F;&#x2F;***一些运算</span><br><span class="line">    var res &#x3D; function()&#123;</span><br><span class="line">        alert(a.name);</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<p>上述代码中变量f的返回值是由一个立即执行函数构成的闭包中返回的方法res，该变量保留了对于这个闭包中所有变量（a,b,c等）的引用，因此这两个变量会一直驻留在内存空间中,尤其是对于dom元素的引用对内存的消耗会很大，而我们在res中只使用到了a变量的值，因此，在闭包返回前我们可以将其它变量释放</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var f &#x3D; (function()&#123;</span><br><span class="line">    var a &#x3D; &#123;name:&quot;var3&quot;&#125;;</span><br><span class="line">    var b &#x3D; [&quot;var1&quot;,&quot;var2&quot;];</span><br><span class="line">    var c &#x3D; document.getElementByTagName(&quot;li&quot;);</span><br><span class="line">    &#x2F;&#x2F;****其它变量</span><br><span class="line">    &#x2F;&#x2F;***一些运算</span><br><span class="line">    &#x2F;&#x2F;闭包返回前释放掉不再使用的变量</span><br><span class="line">    b &#x3D; c &#x3D; null;</span><br><span class="line">    var res &#x3D; function()&#123;</span><br><span class="line">        alert(a.name);</span><br><span class="line">        &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lzhwweb.github.io/nirvana/javascript/%E5%89%8D%E7%AB%AF/Js%E6%93%8D%E4%BD%9Cdom%E7%9A%84%E6%95%88%E7%8E%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/nirvana/images/avatar.gif">
      <meta itemprop="name" content="nirvana">
      <meta itemprop="description" content="个人学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="涅槃快乐是金">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/nirvana/javascript/%E5%89%8D%E7%AB%AF/Js%E6%93%8D%E4%BD%9Cdom%E7%9A%84%E6%95%88%E7%8E%87/" class="post-title-link" itemprop="url">Js操作dom的效率</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-03-11 21:12:40" itemprop="dateCreated datePublished" datetime="2021-03-11T21:12:40+08:00">2021-03-11</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-03-10 12:58:00" itemprop="dateModified" datetime="2021-03-10T12:58:00+08:00">2021-03-10</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/nirvana/categories/javascript/" itemprop="url" rel="index"><span itemprop="name">javascript</span></a>
        </span>
    </span>

  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.7k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>在web开发过程中，前端执行效率的瓶颈往往都是在dom操作上面，dom操作是一件很耗性能的事情，如何才能在dom操作过程中尽量节约性能呢？</p>
<p><strong>1、减少reflow</strong></p>
<p><strong>什么是reflow？</strong></p>
<p>当 DOM 元素的属性发生变化 (如 color) 时, 浏览器会通知 render 重新描绘相应的元素, 此过程称为 repaint。</p>
<p>如果该次变化涉及元素布局 (如 width), 浏览器则抛弃原有属性, 重新计算并把结果传递给 render 以重新描绘页面元素, 此过程称为 reflow。</p>
<p><strong>减少reflow的方法</strong></p>
<ol>
<li> 先将元素从document中删除，完成修改后再把元素放回原来的位置（当对某元素及其子元素进行大量reflow操作时，1,2两种方法效果才会比较明显）</li>
<li> 将元素的display设置为”none”，完成修改后再把display修改为原来的值</li>
<li> 修改多个样式属性时定义class类代替多次修改style属性（for certain同学推荐）</li>
<li> 大量添加元素到页面时使用documentFragment</li>
</ol>
<p>例如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for(var i&#x3D;0;i&lt;100:i++)&#123;</span><br><span class="line">    var child &#x3D; docuemnt.createElement(&quot;li&quot;);</span><br><span class="line">    child.innerHtml &#x3D; &quot;child&quot;;</span><br><span class="line">    document.getElementById(&quot;parent&quot;).appendChild(child);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码会多次操作dom，效率比较低，可以改为下面的形式 创建documentFragment，将所有元素加入到docuemntFragment不会改变dom结构，最后将其添加到页面，只进行了一次reflow</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var frag &#x3D; document.createDocumentFragment();</span><br><span class="line">for(var i&#x3D;0;i&lt;100:i++)&#123;</span><br><span class="line">        var child &#x3D; docuemnt.createElement(&quot;li&quot;);</span><br><span class="line">        child.innerHtml &#x3D; &quot;child&quot;;</span><br><span class="line">    frag.appendChild(child);</span><br><span class="line">&#125;</span><br><span class="line">document.getElementById(&quot;parent&quot;).appendChild(frag);</span><br></pre></td></tr></table></figure>

<p><strong>2、暂存dom状态信息</strong></p>
<p>当代码中需要多次访问元素的状态信息，在状态不变的情况下我们可以将其暂存到变量中，这样可以避免多次访问dom带来内存的开销，典型的例子就是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ar lis &#x3D; document.getElementByTagName(&quot;li&quot;);</span><br><span class="line">for(var i&#x3D;1;i&lt;lis.length;i++)&#123;</span><br><span class="line">    &#x2F;&#x2F;***</span><br><span class="line">&#125;</span><br><span class="line">上述方式会在每一次循环都去访问dom元素，我们可以简单将代码优化如下</span><br><span class="line">var lis &#x3D; document.getElementByTagName(&quot;li&quot;);</span><br><span class="line">for(var i&#x3D;1,j&#x3D;lis.length ;i&lt;j;i++)&#123;</span><br><span class="line">    &#x2F;&#x2F;***</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3、缩小选择器的查找范围</strong></p>
<p>查找dom元素时尽量避免大面积遍历页面元素，尽量使用精准选择器，或者指定上下文以缩小查找范围，以jquery为例</p>
<ul>
<li>  少用模糊匹配的选择器：例如$(“[name*=’_fix’]”)，多用诸如id以及逐步缩小范围的复合选择器$(“li.active”)等</li>
<li>  指定上下文：例如$(“#parent .class”)，$(“.class”,$el)等</li>
</ul>
<p><strong>4、使用事件委托</strong></p>
<p><strong>使用场景：</strong>一个有大量记录的列表，每条记录都需要绑定点击事件，在鼠标点击后实现某些功能，我们通常的做法是给每条记录都绑定监听事件，这种做法会导致页面会有大量的事件监听器，效率比较低下。</p>
<p><strong>基本原理</strong>：我们都知道dom规范中事件是会冒泡的，也就是说在不主动阻止事件冒泡的情况下任何一个元素的事件都会按照dom树的结构逐级冒泡至顶端。而event对象中也提供了event.target（IE下是srcElement）指向事件源，因此我们即使在父级元素上监听该事件也可以找到触发该事件的最原始的元素，这就是委托的基本原理。废话不多说，上示例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;ul li&quot;).bind(&quot;click&quot;,function()&#123;</span><br><span class="line">    alert($(this).attr(&quot;data&quot;));</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>上述写法其实是给所有的li元素都绑定了click事件来监听鼠标点击每一个元素的事件，这样页面上会有大量的事件监听器。</p>
<p>根据上面介绍的监听事件的原理我们来改写一下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;ul&quot;).bind(&quot;click&quot;,function(e)&#123;</span><br><span class="line">    if(e.target.nodeName.toLowerCase() &#x3D;&#x3D;&#x3D;&quot;li&quot;)&#123;</span><br><span class="line">        alert($(e.target).attr(&quot;data&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这样一来，我们就可以只添加一个事件监听器去捕获所有li上触发的事件，并做出相应的操作。</p>
<p>当然，我们不必每次都做事件源的判断工作，可以将其抽象一下交给工具类来完成。jquery中的delegate()方法就实现了该功能</p>
<p>语法是这样的$(selector).delegate(childSelector,event,data,function)，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;div&quot;).delegate(&quot;button&quot;,&quot;click&quot;,function()&#123;</span><br><span class="line">  $(&quot;p&quot;).slideToggle();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>参数说明（引自w3school）</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-d8f6aee706ebe272.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" title="Javascript执行效率小结_"></p>
<p>**Tips:**事件委托还有一个好处就是，即使在事件绑定之后动态添加的元素上触发的事件同样可以监听到哦，这样就不用在每次动态加入元素到页面后都为其绑定事件了</p>
<p>暂时先总结到这。</p>
<hr>
<p>原文来自：<a target="_blank" rel="noopener" href="http://www.cnblogs.com/gewei/archive/2013/03/29/2988180.html">www.cnblogs.com/gewei/archive/2013/03/29/2988180.html</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lzhwweb.github.io/nirvana/javascript/%E5%89%8D%E7%AB%AF/Mac%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%97%A0%E6%B3%95%E6%89%93%E5%BC%80%E6%88%96%E6%96%87%E4%BB%B6%E6%8D%9F%E5%9D%8F%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/nirvana/images/avatar.gif">
      <meta itemprop="name" content="nirvana">
      <meta itemprop="description" content="个人学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="涅槃快乐是金">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/nirvana/javascript/%E5%89%8D%E7%AB%AF/Mac%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%97%A0%E6%B3%95%E6%89%93%E5%BC%80%E6%88%96%E6%96%87%E4%BB%B6%E6%8D%9F%E5%9D%8F%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95/" class="post-title-link" itemprop="url">Mac应用程序无法打开或文件损坏的处理方法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-03-11 21:12:40" itemprop="dateCreated datePublished" datetime="2021-03-11T21:12:40+08:00">2021-03-11</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-03-10 13:17:22" itemprop="dateModified" datetime="2021-03-10T13:17:22+08:00">2021-03-10</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/nirvana/categories/javascript/" itemprop="url" rel="index"><span itemprop="name">javascript</span></a>
        </span>
    </span>

  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>465</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Mac应用程序无法打开或文件损坏的处理方法</p>
<h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p>大多数用户在安装 Mac 应用时，经常会遇到提示 “ XXX.app 已损坏，打不开。您应该将它移到废纸篓 ” 或 “ 打不开 XXX.app，因为它来自身份不明的开发者 ” ，如下图所示：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/10024246-acb847a54e1d04dc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" title="1516261454857950.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/10024246-6dc056c4a2b86b69.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" title="1516261464940638.png"></p>
<p>  遇到这种情况，解决的方法很简单，步骤如下：</p>
<p><strong>1. 打开系统偏好设置界面，进入安全性与隐私</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/10024246-11dc656bdb44769d.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2018-01-18 下午2.54.11.jpg" title="1516261331253960.jpeg"></p>
<p><strong>2. 点按左下角的锁头图标，解锁更改权限</strong></p>
<p><strong>3. 将允许从以下位置下载的应用，更改为 “ 任何来源 ” ，然后再打开应用即可</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/10024246-d9101881c093b84a.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" title="1516261394740817.jpeg"></p>
<p>若没有“任何来源”这个选项（macOS Sierra 10.12及以上的用户可能会遇到），按以下步骤执行：</p>
<p>打开终端（Terminal.app）</p>
<p>拷贝粘贴 sudo spctl –master-disable，按回车键</p>
<p>输入你的账户密码，按回车键确认执行（该密码不会显示，直接输入即可）</p>
<p><img src="http://upload-images.jianshu.io/upload_images/10024246-0b13724e32c58228.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p>如安装应用时，出现 “ 打不开 XXX.app，因为它来自身份不明的开发者 ” ，并提示你的软件在什么位置什么时间下载了磁盘影像。如图所示：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/10024246-f6ffe536b22e1916.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" title="1522042275384344.png"></p>
<p>  遇到这种情况，方法如下：</p>
<p><strong>1、将软件放入“应用程序”后，点击软件 右键-打开 ，如图所示：</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/10024246-8a9f9c4ab31e0aeb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" title="1522044010422080.png"></p>
<p><strong>2、弹出以下对话框后，你打开即可。</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/10024246-1f7894dba90e9353.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" title="1522043712276473.png"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lzhwweb.github.io/nirvana/javascript/%E5%89%8D%E7%AB%AF/Node%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%E5%99%A8PM2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/nirvana/images/avatar.gif">
      <meta itemprop="name" content="nirvana">
      <meta itemprop="description" content="个人学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="涅槃快乐是金">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/nirvana/javascript/%E5%89%8D%E7%AB%AF/Node%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%E5%99%A8PM2/" class="post-title-link" itemprop="url">Node进程管理器PM2</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-03-11 21:12:40" itemprop="dateCreated datePublished" datetime="2021-03-11T21:12:40+08:00">2021-03-11</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-03-10 13:17:22" itemprop="dateModified" datetime="2021-03-10T13:17:22+08:00">2021-03-10</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/nirvana/categories/javascript/" itemprop="url" rel="index"><span itemprop="name">javascript</span></a>
        </span>
    </span>

  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4.5k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><code>PM2</code>是一个带有<strong>负载均衡</strong>功能的<code>Node</code>应用的进程管理器。<code>PM2</code>可以利用服务器上的<strong>所有CPU</strong>，并保证进程永远都活着，<strong>0秒的重载</strong>，部署管理<strong>多个</strong>Node项目。<code>PM2</code>是<code>Node</code>线上部署完美的管理工具。</p>
<h4 id="1、基本指令"><a href="#1、基本指令" class="headerlink" title="1、基本指令"></a>1、基本指令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">npm install pm2 -g ： 全局安装。</span><br><span class="line"></span><br><span class="line">pm2 start app.js ： 启动服务，入口文件是app.js。</span><br><span class="line"></span><br><span class="line">pm2 start app.js -i [n] --name [name] ： 启动n个进程，名字命名为name。</span><br><span class="line"></span><br><span class="line">npm restart  [name or id] ： 重启服务。</span><br><span class="line"></span><br><span class="line">npm reload  [name or id] ： 和rastart功能相同，但是可以实现0s的无缝衔接；如果有nginx的使用经验，可以</span><br><span class="line">对比nginx reload指令。</span><br><span class="line"></span><br><span class="line">pm2 start app.js --max_memory_restart 1024M ： 当内存超过1024M时自动重启。 如果工程中有比较棘手的内</span><br><span class="line">存泄露问题，这个算是一个折中方案。</span><br><span class="line"></span><br><span class="line">pm2 monit ： 对服务进行监控。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2、查看服务进程数"><a href="#2、查看服务进程数" class="headerlink" title="2、查看服务进程数"></a>2、查看服务进程数</h4><p>至于要启动几个进程，可以通过服务器的内核数进行确定，几个内核就启动几个服务。指令如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 查看物理CPU个数</span><br><span class="line"> cat &#x2F;proc&#x2F;cpuinfo| grep &quot;physical id&quot; | sort| uniq | wc -l</span><br><span class="line"></span><br><span class="line"> # 查看每个物理CPU中core的个数(即核数)</span><br><span class="line"> cat &#x2F;proc&#x2F;cpuinfo| grep &quot;cpu cores&quot;| uniq</span><br><span class="line"></span><br><span class="line"> # 查看逻辑CPU的个数</span><br><span class="line"> cat &#x2F;proc&#x2F;cpuinfo| grep &quot;processor&quot;| wc -l</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当然可以启动多个端口，一个端口号对应一个服务，这样的话就需要nignx来做负载均衡了。</p>
<h4 id="3、-是否需要nginx"><a href="#3、-是否需要nginx" class="headerlink" title="3、 是否需要nginx"></a>3、 是否需要nginx</h4><p>nginx可以做的事情主要有两个：</p>
<blockquote>
<ol>
<li> 反向代理，实现简单的负载均衡： 如果有多台服务器或者一台服务器多个端口，可以考虑用nginx。</li>
<li> 静态资源缓存：把一些静态资源（如静态页面，js等资源文件）放到nginx里，可以极大的提高服务的性能。</li>
</ol>
</blockquote>
<h4 id="4、fork与cluster启动模式"><a href="#4、fork与cluster启动模式" class="headerlink" title="4、fork与cluster启动模式"></a>4、fork与cluster启动模式</h4><p>开发环境中多以fork的方式启动，生产环境中多用cluster方式启动</p>
<p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/73722a2868ba4cfad76e1e57a6ae2dd06e512e04/687474703a2f2f7777312e73696e61696d672e636e2f6c617267652f616534396261353767793166646f7a7134333167616a32316630303963373730"><img src="http://upload-images.jianshu.io/upload_images/10024246-dbf8192d633005bd?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a> </p>
<p>上面的示例图中可以看一“watching”一项，这个项默认是disabled，可以通过如下命令开启</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pm2 start app.js --name m --watch</span><br></pre></td></tr></table></figure>

<p><strong>建议：这个适合在开发时用，可以省不少时间，生产环境下最好不要用</strong></p>
<ol>
<li><p> cluster是fork的派生，cluster支持所有cluster拥有的特性；</p>
</li>
<li><p> fork不支持socket地址端口复用，cluster支持地址端口复用。因为只有node的cluster模块支持socket选项SO_REUSEADDR；</p>
</li>
</ol>
<p><code>fork不可以启动多个实例进程，cluster可以启动多个实例。但node的child_process.fork是可以实现启动多个进程的，但是为什么没有实现呢？就个人理解，node多为提供网络服务，启动多个实例需要地址端口复用，此时便可使用cluster模式实现，但fork模式并不支持地址端口复用，多实例进程启动会产生异常错误。但对于常驻任务脚本而言，不需要提供网络服务，此时多进程启动可以实现，同时也提高了任务处理效率。对于上述需求，可以两种方式实现，一是配置app0,app1,app2方式启动多个进程，二是通过应用实例自身调用child_process.fork多进程编程实现；</code></p>
<p>fork模式可以应用于其他语言，如php，python，perl，ruby，bash，coffee， 而cluster只能应用于node;</p>
<p>fork不支持定时重启，cluster支持定时重启。定时重启也就是配置中的cron_restart配置项。</p>
<h4 id="5、pm2的监控"><a href="#5、pm2的监控" class="headerlink" title="5、pm2的监控"></a>5、pm2的监控</h4><p>pm2的监控有两种方式：</p>
<h5 id="①cli方式监控"><a href="#①cli方式监控" class="headerlink" title="①cli方式监控"></a>①cli方式监控</h5><p>pm2 monit是专门用来监控的命令，监控项包括cpu与内存</p>
<p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/26aaca8e82f519f00ecf5800ac232430364d3736/687474703a2f2f7777312e73696e61696d672e636e2f6c617267652f616534396261353767793166646f7a7876773475356a32316b77306470343161"><img src="http://upload-images.jianshu.io/upload_images/10024246-f1ba4e586096426d?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a> </p>
<p>缺点monit展示内容太过粗糙，不够详细</p>
<h5 id="②pm2-list展示当前所有pm2的管理项目"><a href="#②pm2-list展示当前所有pm2的管理项目" class="headerlink" title="②pm2 list展示当前所有pm2的管理项目"></a>②pm2 list展示当前所有pm2的管理项目</h5><p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/ced3e54eb50b8cdfad838f6114d1661f292ae735/687474703a2f2f7777312e73696e61696d672e636e2f6c617267652f6165343962613537677931666470303061377177306a32316663306361677035"><img src="http://upload-images.jianshu.io/upload_images/10024246-15f8e419621a2c5b?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a> </p>
<p>可以查看出每个进程的运行状态。</p>
<p>如果需要更详细的监控内容，对于cli而言一般都是可以实现的。</p>
<p>这种监控方式的缺点：</p>
<blockquote>
<p>a. 不够直观，需要自己去执行命令并分析结果；</p>
</blockquote>
<blockquote>
<p>b. 不便于多台服务器的应用监控管理；</p>
</blockquote>
<h4 id="6、日志问题"><a href="#6、日志问题" class="headerlink" title="6、日志问题"></a>6、日志问题</h4><p>日志系统对于任意应用而言，通常都是必不可少的一个辅助功能。pm2的相关文件默认存放于$HOME/.pm2/目录下，其日志主要有两类：</p>
<p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/7b9ac5eb511f8f93e60ed37bd9dbfeb03d43c63d/687474703a2f2f7777312e73696e61696d672e636e2f6c617267652f61653439626135376779316664703067317a356a626a32316b32303673713564"><img src="http://upload-images.jianshu.io/upload_images/10024246-999dcbf8be916146?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a> </p>
<p>a. pm2自身的日志，存放于$HOME/.pm2/pm2.log；</p>
<p>b. pm2所管理的应用的日志，存放于$HOME/.pm2/logs/目录下，标准谁出日志存放于${APP_NAME}_out.log，标准错误日志存放于${APP_NAME}_error.log；</p>
<p>这里之所以把日志单独说明一下是因为，如果程序开发不严谨，为了调试程序，导致应用产生大量标准输出，使服务器本身记录大量的日志，导致服务磁盘满载问题。一般而言，pm2管理的应用本身都有自己日志系统，所以对于这种不必要的输出内容需禁用日志，重定向到/dev/null。</p>
<p>与crontab比较，也有类似情况，crontab自身日志，与其管理的应用本身的输出。应用脚本输出一定需要重定向到/dev/null，因为该输出内容会以邮件的形式发送给用户，内容存储在邮件文件，会产生意向不到的结果，或会导致脚本压根不被执行；</p>
<h4 id="7、高级用法"><a href="#7、高级用法" class="headerlink" title="7、高级用法"></a>7、高级用法</h4><p>pm2支持配置文件启动：<br>pm2 ecosystem： 生成配置文件ecosystem.json<br>pm2 startOrRestart /file/path/ecosystem.json : 通过配置文件启动服务</p>
<p>如下是开发时ecosystem.json的内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">    * Application configuration section</span><br><span class="line">    * http:&#x2F;&#x2F;pm2.keymetrics.io&#x2F;docs&#x2F;usage&#x2F;application-declaration&#x2F;</span><br><span class="line">    * 多个服务，依次放到apps对应的数组里</span><br><span class="line">    *&#x2F;</span><br><span class="line">    apps : [</span><br><span class="line">    &#x2F;&#x2F; First application</span><br><span class="line">        &#123;</span><br><span class="line">            name      : &quot;nova&quot;,</span><br><span class="line">            max_memory_restart: &quot;300M&quot;,</span><br><span class="line">            script    : &quot;&#x2F;root&#x2F;nova&#x2F;app.js&quot;,</span><br><span class="line">            out_file : &quot;&#x2F;logs&#x2F;nova_out.log&quot;,</span><br><span class="line">            error_file : &quot;&#x2F;logs&#x2F;nova_error.log&quot;,</span><br><span class="line">            instances  : 4,</span><br><span class="line">            exec_mode  : &quot;cluster&quot;,</span><br><span class="line">            env: &#123;</span><br><span class="line">                NODE_ENV: &quot;production&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上述采用cluster模式启动了4个服务进程；如果服务占用的内存超过300M，会自动进行重启。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"> 配置项</span><br><span class="line"></span><br><span class="line">name  应用进程名称；</span><br><span class="line"></span><br><span class="line">script  启动脚本路径；</span><br><span class="line"></span><br><span class="line">cwd  应用启动的路径，关于script与cwd的区别举例说明：在&#x2F;home&#x2F;polo&#x2F;目录下运行&#x2F;data&#x2F;release&#x2F;node&#x2F;</span><br><span class="line">index.js，此处script为&#x2F;data&#x2F;release&#x2F;node&#x2F;index.js，cwd为&#x2F;home&#x2F;polo&#x2F;；</span><br><span class="line"></span><br><span class="line">args  传递给脚本的参数；</span><br><span class="line"></span><br><span class="line">interpreter  指定的脚本解释器；</span><br><span class="line"></span><br><span class="line">interpreter_args  传递给解释器的参数；</span><br><span class="line"></span><br><span class="line">instances  应用启动实例个数，仅在cluster模式有效，默认为fork；</span><br><span class="line"></span><br><span class="line">exec_mode  应用启动模式，支持fork和cluster模式；</span><br><span class="line"></span><br><span class="line">watch  监听重启，启用情况下，文件夹或子文件夹下变化应用自动重启；</span><br><span class="line"></span><br><span class="line">ignore_watch  忽略监听的文件夹，支持正则表达式；</span><br><span class="line"></span><br><span class="line">max_memory_restart  最大内存限制数，超出自动重启；</span><br><span class="line"></span><br><span class="line">env  环境变量，object类型，如&#123;&quot;NODE_ENV&quot;:&quot;production&quot;, &quot;ID&quot;: &quot;42&quot;&#125;；</span><br><span class="line"></span><br><span class="line">log_date_format  指定日志日期格式，如YYYY-MM-DD HH:mm:ss；</span><br><span class="line"></span><br><span class="line">error_file  记录标准错误流，$HOME&#x2F;.pm2&#x2F;logs&#x2F;XXXerr.log)，代码错误可在此文件查找；</span><br><span class="line"></span><br><span class="line">out_file  记录标准输出流，$HOME&#x2F;.pm2&#x2F;logs&#x2F;XXXout.log)，如应用打印大量的标准输出，会导致pm2日志过大；</span><br><span class="line"></span><br><span class="line">min_uptime  应用运行少于时间被认为是异常启动；</span><br><span class="line"></span><br><span class="line">max_restarts  最大异常重启次数，即小于min_uptime运行时间重启次数；</span><br><span class="line"></span><br><span class="line">autorestart  默认为true, 发生异常的情况下自动重启；</span><br><span class="line"></span><br><span class="line">cron_restart  crontab时间格式重启应用，目前只支持cluster模式；</span><br><span class="line"></span><br><span class="line">force  默认false，如果true，可以重复启动一个脚本。pm2不建议这么做；</span><br><span class="line"></span><br><span class="line">restart_delay  异常重启情况下，延时重启时间；</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="8、稳定运行建议"><a href="#8、稳定运行建议" class="headerlink" title="8、稳定运行建议"></a>8、稳定运行建议</h4><p>PM2是一款非常优秀的Node进程管理工具，它有着丰富的特性：能够充分利用多核CPU且能够负载均衡、能够帮助应用在崩溃后、指定时间(cluster model)和超出最大内存限制等情况下实现自动重启。</p>
<p>个人几点看法保证常驻应用进程稳定运行：</p>
<ol>
<li><p> 定时重启，应用进程运行时间久了或许总会产生一些意料之外的问题，定时可以规避一些不可测的情况；</p>
</li>
<li><p> 最大内存限制，根据观察设定合理内存限制，保证应用异常运行；</p>
</li>
<li><p> 合理min_uptime，min_uptime是应用正常启动的最小持续运行时长，超出此时间则被判定为异常启动；</p>
</li>
<li><p> 设定异常重启延时restart_delay，对于异常情况导致应用停止，设定异常重启延迟可防止应用在不可测情况下不断重启的导致重启次数过多等问题；</p>
</li>
<li><p> 设置异常重启次数，如果应用不断异常重启，并超过一定的限制次数，说明此时的环境长时间处于不可控状态，服务器异常。此时便可停止尝试，发出错误警告通知等。</p>
</li>
</ol>
<p>关于pm2的使用，主要还是运用于常驻脚本。</p>
<h4 id="9、自动化部署"><a href="#9、自动化部署" class="headerlink" title="9、自动化部署"></a>9、自动化部署</h4><p>通过shell脚本实现资源拉取、服务重启、nginx缓存更新等操作，再配合pm2的监控功能，就初步达到了一个后端工程部署的标配了。</p>
<h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><p><a target="_blank" rel="noopener" href="http://pm2.keymetrics.io/">1.pm2官网</a><br><a target="_blank" rel="noopener" href="https://github.com/Unitech/pm2">2.pm2 github</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lzhwweb.github.io/nirvana/javascript/%E5%89%8D%E7%AB%AF/TypeScript%E6%B3%9B%E5%9E%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%92%8C%E7%90%86%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/nirvana/images/avatar.gif">
      <meta itemprop="name" content="nirvana">
      <meta itemprop="description" content="个人学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="涅槃快乐是金">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/nirvana/javascript/%E5%89%8D%E7%AB%AF/TypeScript%E6%B3%9B%E5%9E%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%92%8C%E7%90%86%E8%A7%A3/" class="post-title-link" itemprop="url">TypeScript泛型的基本使用和理解</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-03-11 21:12:40" itemprop="dateCreated datePublished" datetime="2021-03-11T21:12:40+08:00">2021-03-11</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-03-10 13:09:57" itemprop="dateModified" datetime="2021-03-10T13:09:57+08:00">2021-03-10</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/nirvana/categories/javascript/" itemprop="url" rel="index"><span itemprop="name">javascript</span></a>
        </span>
    </span>

  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.5k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>许多时候，标注的具体类型并不能确定，比如一个函数的参数类型</p>
<p>在像C#和Java这样的语言中，可以使用<code>泛型</code>来创建可重用的组件，一个组件可以支持多种类型的数据。 这样用户就可以以自己的数据类型来使用组件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function getVal(obj, k) &#123;    return obj[k];&#125;</span><br></pre></td></tr></table></figure>

<p>上面的函数，我们想实现的是获取一个对象指定的 k 所对应的值</p>
<p>那么实际使用的时候，obj 的类型是 不确定的 自然 k 的取值范围也是不确定的</p>
<p>它需要我们在具体调用的时候才能确定</p>
<p>这个时候这种定义过程不确定类型的需求就可以通过泛型来解决</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function getVal&lt;T&gt;(obj: T, k: keyof T) &#123;    return obj[k];&#125;</span><br></pre></td></tr></table></figure>
<p>所谓的泛型，就是给可变(不定)的类型定义变量(参数)， &lt;&gt; 类似 ()</p>
<h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><p>在面向对象章节中，我们曾经给大家讲过一个基于泛型使用的例子:模拟组件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">abstract class Component&lt;T1, T2&gt; &#123;</span><br><span class="line">    props: T1;</span><br><span class="line">		state: T2;</span><br><span class="line">    constructor(props: T1) &#123; </span><br><span class="line">        this.props &#x3D; props;</span><br><span class="line">    &#125;</span><br><span class="line">   	abstract render(): string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface IMyComponentProps &#123;</span><br><span class="line">    val: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface IMyComponentState &#123;</span><br><span class="line">		x: number; </span><br><span class="line">&#125;</span><br><span class="line">class MyComponent extends Component&lt;IMyComponentProps, IMyComponentState&gt; &#123;</span><br><span class="line">    constructor(props: IMyComponentProps) &#123;</span><br><span class="line">        super(props);</span><br><span class="line">				this.state &#x3D; &#123; </span><br><span class="line">						x: 1</span><br><span class="line">				&#125; </span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">    render() &#123; </span><br><span class="line">        this.props.val;</span><br><span class="line">        this.state.x;</span><br><span class="line">        return &#39;&lt;myComponent &#x2F;&gt;&#39;;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line">let myComponent &#x3D; new MyComponent(&#123;val: 1&#125;); </span><br><span class="line">myComponent.render();</span><br></pre></td></tr></table></figure>

<h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><p>我们还可以在接口中使用泛型 后端提供了一些接口 用以返回一些数据</p>
<p>依据返回的数据格式定义如下接口:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface IResponseData &#123;</span><br><span class="line">    code: number;</span><br><span class="line">    message?: string;</span><br><span class="line">		data: any; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据接口，我们封装对应的一些方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function getData(url: string) &#123; </span><br><span class="line">	return fetch(url).then(res &#x3D;&gt; &#123;</span><br><span class="line">		return res.json();</span><br><span class="line">	&#125;).then( (data: IResponseData) &#x3D;&gt; &#123;</span><br><span class="line">        return data;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是，我们会发现该接口的 data 项的具体格式不确定，不同的接口会返回的数据是不一样的，当我们 想根据具体当前请求的接口返回具体 data 格式的时候，就比较麻烦了，因为 getData 并不清楚你调 用的具体接口是什么，对应的数据又会是什么样的</p>
<p>这个时候我们可以对 IResponseData 使用泛型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface IResponseData&lt;T&gt; &#123;</span><br><span class="line">    code: number;</span><br><span class="line">    message?: string;</span><br><span class="line">		data: T; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function getData&lt;U&gt;(url: string) &#123; </span><br><span class="line">	return fetch(url).then(res &#x3D;&gt; &#123;</span><br><span class="line">  			return res.json();</span><br><span class="line">  &#125;).then( (data: IResponseData&lt;U&gt;) &#x3D;&gt; &#123;</span><br><span class="line">       return data;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义不同的数据接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 用户接口</span><br><span class="line">interface IResponseUserData &#123;</span><br><span class="line">    id: number;</span><br><span class="line">    username: string;</span><br><span class="line">    email: string;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 文章接口</span><br><span class="line">interface IResponseArticleData &#123;</span><br><span class="line">    id: number;</span><br><span class="line">    title: string;</span><br><span class="line">    author: IResponseUserData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用具体代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">~(async function()&#123;</span><br><span class="line">    let user &#x3D; await getData&lt;IResponseUserData&gt;(&#39;&#39;); </span><br><span class="line">    if (user.code &#x3D;&#x3D;&#x3D; 1) &#123;</span><br><span class="line">    		console.log(user.message); </span><br><span class="line">    &#125; else &#123;</span><br><span class="line">    		console.log(user.data.username); </span><br><span class="line">    &#125;</span><br><span class="line">    let articles &#x3D; await getData&lt;IResponseArticleData&gt;(&#39;&#39;); </span><br><span class="line">    if (articles.code &#x3D;&#x3D;&#x3D; 1) &#123;</span><br><span class="line">        console.log(articles.message); </span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        console.log(articles.data.id);</span><br><span class="line">        console.log(articles.data.author.username); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lzhwweb.github.io/nirvana/javascript/%E5%89%8D%E7%AB%AF/TypeScript%E8%A3%85%E9%A5%B0%E5%99%A8%EF%BC%88decorators%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/nirvana/images/avatar.gif">
      <meta itemprop="name" content="nirvana">
      <meta itemprop="description" content="个人学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="涅槃快乐是金">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/nirvana/javascript/%E5%89%8D%E7%AB%AF/TypeScript%E8%A3%85%E9%A5%B0%E5%99%A8%EF%BC%88decorators%EF%BC%89/" class="post-title-link" itemprop="url">TypeScript装饰器（decorators）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-03-11 21:12:40" itemprop="dateCreated datePublished" datetime="2021-03-11T21:12:40+08:00">2021-03-11</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-03-10 13:10:34" itemprop="dateModified" datetime="2021-03-10T13:10:34+08:00">2021-03-10</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/nirvana/categories/javascript/" itemprop="url" rel="index"><span itemprop="name">javascript</span></a>
        </span>
    </span>

  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>7.7k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>7 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="什么是装饰器"><a href="#什么是装饰器" class="headerlink" title="什么是装饰器"></a>什么是装饰器</h2><p>装饰器是一种特殊类型的声明，它能够被附加到类声明，方法， 访问符，属性或参数上。  装饰器使用 @expression这种形式，expression求值后必须为一个函数，它会在运行时被调用，被装饰的声明信息做为参数传入。</p>
<p>通俗的理解可以认为就是在原有代码外层包装了一层处理逻辑。<br>个人认为装饰器是一种解决方案，而并非是狭义的***@Decorator***，后者仅仅是一个语法糖罢了。</p>
<p>装饰器在身边的例子随处可见，一个简单的例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">水龙头上边的起泡器就是一个装饰器，在装上以后就会把空气混入水流中，掺杂很多泡泡在水里。</span><br><span class="line">但是起泡器安装与否对水龙头本身并没有什么影响，即使拆掉起泡器，也会照样工作，水龙头的作用在于阀门的控制，至于水中掺不掺杂气泡则不是水龙头需要关心的。</span><br></pre></td></tr></table></figure>

<p>在TypeScript中装饰器还属于实验性语法，你必须在命令行或<code>tsconfig.json</code>里启用<code>experimentalDecorators</code>编译器选项：</p>
<p>命令行:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc --target ES5 --experimentalDecorators</span><br></pre></td></tr></table></figure>

<p>tsconfig.json:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;compilerOptions&quot;: &#123;</span><br><span class="line">        &quot;target&quot;: &quot;ES5&quot;,</span><br><span class="line">        &quot;experimentalDecorators&quot;: true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="为什么要用装饰器"><a href="#为什么要用装饰器" class="headerlink" title="为什么要用装饰器"></a>为什么要用装饰器</h3><p>可能有些时候，我们会对传入参数的类型判断、对返回值的排序、过滤，对函数添加节流、防抖或其他的功能性代码，基于多个类的继承，各种各样的与函数逻辑本身无关的、重复性的代码。<br>所以，对于装饰器，可以简单地理解为是非侵入式的行为修改。</p>
<h3 id="如何定义装饰器"><a href="#如何定义装饰器" class="headerlink" title="如何定义装饰器"></a>如何定义装饰器</h3><p>装饰器本身其实就是一个函数，理论上忽略参数的话，任何函数都可以当做装饰器使用。<br>helloword.ts</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function helloWord(target: any) &#123;</span><br><span class="line">    console.log(&#39;hello Word!&#39;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@helloWord</span><br><span class="line">class HelloWordClass &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>tsc</code>编译后,执行命令<code>node helloword.js</code>，输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello Word!</span><br></pre></td></tr></table></figure>

<p>装饰器组合<br>多个装饰器可以同时应用到一个声明上，就像下面的示例：</p>
<p>书写在同一行上：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@f @g x</span><br></pre></td></tr></table></figure>
<p>书写在多行上：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@f</span><br><span class="line">@g</span><br><span class="line">x</span><br></pre></td></tr></table></figure>

<h3 id="装饰器执行时机"><a href="#装饰器执行时机" class="headerlink" title="装饰器执行时机"></a>装饰器执行时机</h3><p>修饰器对类的行为的改变，是代码编译时发生的（不是TypeScript编译，而是js在执行机中编译阶段），而不是在运行时。这意味着，修饰器能在编译阶段运行代码。也就是说，修饰器本质就是编译时执行的函数。<br>在Node.js环境中模块一加载时就会执行</p>
<p>但是实际场景中，有时希望向装饰器传入一些参数, 如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Path(&quot;&#x2F;hello&quot;, &quot;world&quot;)</span><br><span class="line">class HelloService &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>此时上面装饰器方法就不满足了（VSCode编译报错），这是我们可以借助<em><strong>JavaScript中函数柯里化特性</strong></em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function Path(p1: string, p2: string) &#123;</span><br><span class="line">    return function (target) &#123; &#x2F;&#x2F;  这才是真正装饰器</span><br><span class="line">        &#x2F;&#x2F; do something </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="装饰器类型"><a href="#装饰器类型" class="headerlink" title="装饰器类型"></a>装饰器类型</h3><p>装饰器的类型有：类装饰器、访问器装饰器、属性装饰器、方法装饰器、参数装饰器，但是没有函数装饰器(function)。</p>
<h4 id="1-类装饰器"><a href="#1-类装饰器" class="headerlink" title="1.类装饰器"></a>1.类装饰器</h4><p>应用于类构造函数，其参数是类的构造函数。<br><em><strong>注意class并不是像Java那种强类型语言中的类，而是JavaScript构造函数的语法糖。</strong></em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function addAge(args: number) &#123;</span><br><span class="line">    return function (target: Function) &#123;</span><br><span class="line">        target.prototype.age &#x3D; args;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@addAge(18)</span><br><span class="line">class Hello &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age: number;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        console.log(&#39;hello&#39;);</span><br><span class="line">        this.name &#x3D; &#39;yugo&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(Hello.prototype.age);&#x2F;&#x2F;18</span><br><span class="line">let hello &#x3D; new Hello();</span><br><span class="line"></span><br><span class="line">console.log(hello.age);&#x2F;&#x2F;18</span><br></pre></td></tr></table></figure>
<h4 id="2-方法装饰器"><a href="#2-方法装饰器" class="headerlink" title="2.方法装饰器"></a>2.方法装饰器</h4><p>它会被应用到方法的 属性描述符上，可以用来监视，修改或者替换方法定义。<br>方法装饰会在运行时传入下列3个参数：</p>
<ul>
<li>1、对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。</li>
<li>2、成员的名字。</li>
<li>3、成员的属性描述符{value: any, writable: boolean, enumerable: boolean, configurable: boolean}。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">function addAge(constructor: Function) &#123;</span><br><span class="line">  constructor.prototype.age &#x3D; 18;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function method(target: any, propertyKey: string, descriptor: PropertyDescriptor) &#123;</span><br><span class="line">   console.log(target);</span><br><span class="line">   console.log(&quot;prop &quot; + propertyKey);</span><br><span class="line">   console.log(&quot;desc &quot; + JSON.stringify(descriptor) + &quot;\n\n&quot;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">@addAge</span><br><span class="line">class Hello&#123;</span><br><span class="line">  name: string;</span><br><span class="line">  age: number;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    console.log(&#39;hello&#39;);</span><br><span class="line">    this.name &#x3D; &#39;yugo&#39;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @method</span><br><span class="line">  hello()&#123;</span><br><span class="line">    return &#39;instance method&#39;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @method</span><br><span class="line">  static shello()&#123;</span><br><span class="line">    return &#39;static method&#39;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们得到的结果是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Hello &#123; hello: [Function] &#125;</span><br><span class="line">prop hello</span><br><span class="line">desc &#123;&quot;writable&quot;:true,&quot;enumerable&quot;:true,&quot;configurable&quot;:true&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123; [Function: Hello] shello: [Function] &#125;</span><br><span class="line">prop shello</span><br><span class="line">desc &#123;&quot;writable&quot;:true,&quot;enumerable&quot;:true,&quot;configurable&quot;:true&#125;</span><br></pre></td></tr></table></figure>

<p>假如我们修饰的是 hello 这个实例方法，第一个参数将是原型对象，也就是 Hello.prototype。</p>
<p>假如是 shello 这个静态方法，则第一个参数是构造器 constructor。</p>
<p>第二个参数分别是属性名，第三个参数是属性修饰对象。</p>
<p><strong>注意：</strong>在vscode编辑时有时会报作为表达式调用时，无法解析方法修饰器的签名。错误，此时需要在<code>tsconfig.json</code>中增加<code>target</code>配置项：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;compilerOptions&quot;: &#123;</span><br><span class="line">        &quot;target&quot;: &quot;es6&quot;,</span><br><span class="line">        &quot;experimentalDecorators&quot;: true,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-访问器装饰器"><a href="#3-访问器装饰器" class="headerlink" title="3. 访问器装饰器"></a>3. 访问器装饰器</h4><p>访问器装饰器应用于访问器的属性描述符，可用于观察，修改或替换访问者的定义。 访问器装饰器不能在声明文件中使用，也不能在任何其他环境上下文中使用（例如在声明类中）。</p>
<blockquote>
<p>注意: TypeScript不允许为单个成员装饰get和set访问器。相反，该成员的所有装饰器必须应用于按文档顺序指定的第一个访问器。这是因为装饰器适用于属性描述符，它结合了get和set访问器，而不是单独的每个声明。</p>
</blockquote>
<p>访问器装饰器表达式会在运行时当作函数被调用，传入下列3个参数：</p>
<ul>
<li>对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。</li>
<li>成员的名字。</li>
<li>成员的属性描述符。<blockquote>
<p>注意  如果代码输出目标版本小于ES5，Property Descriptor将会是undefined。</p>
</blockquote>
</li>
</ul>
<p>如果访问器装饰器返回一个值，它会被用作方法的<em>属性描述符</em>。</p>
<blockquote>
<p>注意  如果代码输出目标版本小于<code>ES5</code>返回值会被忽略。</p>
</blockquote>
<p>下面是使用了访问器装饰器（<code>@configurable</code>）的例子，应用于<code>Point</code>类的成员上：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> class Point &#123;</span><br><span class="line">    private _x: number;</span><br><span class="line">    private _y: number;</span><br><span class="line">    constructor(x: number, y: number) &#123;</span><br><span class="line">        this._x &#x3D; x;</span><br><span class="line">        this._y &#x3D; y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @configurable(false)</span><br><span class="line">    get x() &#123; return this._x; &#125;</span><br><span class="line"></span><br><span class="line">    @configurable(false)</span><br><span class="line">    get y() &#123; return this._y; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以通过如下函数声明来定义<code>@configurable</code>装饰器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function configurable(value: boolean) &#123;</span><br><span class="line">    return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) &#123;</span><br><span class="line">        descriptor.configurable &#x3D; value;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="4-方法参数装饰器"><a href="#4-方法参数装饰器" class="headerlink" title="4. 方法参数装饰器"></a>4. 方法参数装饰器</h4><p>参数装饰器表达式会在运行时当作函数被调用，传入下列3个参数：</p>
<ul>
<li>1、对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。</li>
<li>2、参数的名字。</li>
<li>3、参数在函数参数列表中的索引。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">const parseConf &#x3D; [];</span><br><span class="line">class Modal &#123;</span><br><span class="line">    @parseFunc</span><br><span class="line">    public addOne(@parse(&#39;number&#39;) num) &#123;</span><br><span class="line">        console.log(&#39;num:&#39;, num);</span><br><span class="line">        return num + 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 在函数调用前执行格式化操作</span><br><span class="line">function parseFunc(target, name, descriptor) &#123;</span><br><span class="line">    const originalMethod &#x3D; descriptor.value;</span><br><span class="line">    descriptor.value &#x3D; function (...args: any[]) &#123;</span><br><span class="line">        for (let index &#x3D; 0; index &lt; parseConf.length; index++) &#123;</span><br><span class="line">            const type &#x3D; parseConf[index];</span><br><span class="line">            console.log(type);</span><br><span class="line">            switch (type) &#123;</span><br><span class="line">                case &#39;number&#39;:</span><br><span class="line">                    args[index] &#x3D; Number(args[index]);</span><br><span class="line">                    break;</span><br><span class="line">                case &#39;string&#39;:</span><br><span class="line">                    args[index] &#x3D; String(args[index]);</span><br><span class="line">                    break;</span><br><span class="line">                case &#39;boolean&#39;:</span><br><span class="line">                    args[index] &#x3D; String(args[index]) &#x3D;&#x3D;&#x3D; &#39;true&#39;;</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">            return originalMethod.apply(this, args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    return descriptor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 向全局对象中添加对应的格式化信息</span><br><span class="line">function parse(type) &#123;</span><br><span class="line">    return function (target, name, index) &#123;</span><br><span class="line">        parseConf[index] &#x3D; type;</span><br><span class="line">        console.log(&#39;parseConf[index]:&#39;, type);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">let modal &#x3D; new Modal();</span><br><span class="line">console.log(modal.addOne(&#39;10&#39;)); &#x2F;&#x2F; 11</span><br></pre></td></tr></table></figure>

<h4 id="5-属性装饰器"><a href="#5-属性装饰器" class="headerlink" title="5. 属性装饰器"></a>5. 属性装饰器</h4><p>属性装饰器表达式会在运行时当作函数被调用，传入下列2个参数：</p>
<ul>
<li>1、对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。</li>
<li>2、成员的名字。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">function log(target: any, propertyKey: string) &#123;</span><br><span class="line">    let value &#x3D; target[propertyKey];</span><br><span class="line">    &#x2F;&#x2F; 用来替换的getter</span><br><span class="line">    const getter &#x3D; function () &#123;</span><br><span class="line">        console.log(&#96;Getter for $&#123;propertyKey&#125; returned $&#123;value&#125;&#96;);</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 用来替换的setter</span><br><span class="line">    const setter &#x3D; function (newVal) &#123;</span><br><span class="line">        console.log(&#96;Set $&#123;propertyKey&#125; to $&#123;newVal&#125;&#96;);</span><br><span class="line">        value &#x3D; newVal;</span><br><span class="line">    &#125;;</span><br><span class="line">    &#x2F;&#x2F; 替换属性，先删除原先的属性，再重新定义属性</span><br><span class="line">    if (delete this[propertyKey]) &#123;</span><br><span class="line">        Object.defineProperty(target, propertyKey, &#123;</span><br><span class="line">            get: getter,</span><br><span class="line">            set: setter,</span><br><span class="line">            enumerable: true,</span><br><span class="line">            configurable: true</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Calculator &#123;</span><br><span class="line">    @log</span><br><span class="line">    public num: number;</span><br><span class="line">    square() &#123;</span><br><span class="line">        return this.num * this.num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let cal &#x3D; new Calculator();</span><br><span class="line">cal.num &#x3D; 2;</span><br><span class="line">console.log(cal.square());</span><br><span class="line">&#x2F;&#x2F; Set num to 2</span><br><span class="line">&#x2F;&#x2F; Getter for num returned 2</span><br><span class="line">&#x2F;&#x2F; Getter for num returned 2</span><br><span class="line">&#x2F;&#x2F; 4</span><br></pre></td></tr></table></figure>
<h3 id="装饰器加载顺序"><a href="#装饰器加载顺序" class="headerlink" title="装饰器加载顺序"></a>装饰器加载顺序</h3><p><img src="https://upload-images.jianshu.io/upload_images/10024246-9464275773b2a9c2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">function ClassDecorator() &#123;</span><br><span class="line">    return function (target) &#123;</span><br><span class="line">        console.log(&quot;I am class decorator&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">function MethodDecorator() &#123;</span><br><span class="line">    return function (target, methodName: string, descriptor: PropertyDescriptor) &#123;</span><br><span class="line">        console.log(&quot;I am method decorator&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">function Param1Decorator() &#123;</span><br><span class="line">    return function (target, methodName: string, paramIndex: number) &#123;</span><br><span class="line">        console.log(&quot;I am parameter1 decorator&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">function Param2Decorator() &#123;</span><br><span class="line">    return function (target, methodName: string, paramIndex: number) &#123;</span><br><span class="line">        console.log(&quot;I am parameter2 decorator&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">function PropertyDecorator() &#123;</span><br><span class="line">    return function (target, propertyName: string) &#123;</span><br><span class="line">        console.log(&quot;I am property decorator&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@ClassDecorator()</span><br><span class="line">class Hello &#123;</span><br><span class="line">    @PropertyDecorator()</span><br><span class="line">    greeting: string;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @MethodDecorator()</span><br><span class="line">    greet( @Param1Decorator() p1: string, @Param2Decorator() p2: string) &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">I am property decorator</span><br><span class="line">I am parameter2 decorator</span><br><span class="line">I am parameter1 decorator</span><br><span class="line">I am method decorator</span><br><span class="line">I am class decorator</span><br></pre></td></tr></table></figure>
<p>从上述例子得出如下结论：</p>
<ol>
<li><p>有多个参数装饰器时：从最后一个参数依次向前执行</p>
</li>
<li><p>方法和方法参数中参数装饰器先执行。</p>
</li>
<li><p>类装饰器总是最后执行。</p>
</li>
<li><p>方法和属性装饰器，谁在前面谁先执行。因为参数属于方法一部分，所以参数会一直紧紧挨着方法执行。</p>
</li>
</ol>
<p>上述例子中属性和方法调换位置，输出如下结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">I am parameter2 decorator</span><br><span class="line">I am parameter1 decorator</span><br><span class="line">I am method decorator</span><br><span class="line">I am property decorator</span><br><span class="line">I am class decorator</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lzhwweb.github.io/nirvana/javascript/%E5%89%8D%E7%AB%AF/URL%E7%BC%96%E7%A0%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/nirvana/images/avatar.gif">
      <meta itemprop="name" content="nirvana">
      <meta itemprop="description" content="个人学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="涅槃快乐是金">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/nirvana/javascript/%E5%89%8D%E7%AB%AF/URL%E7%BC%96%E7%A0%81/" class="post-title-link" itemprop="url">URL编码</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-03-11 21:12:40" itemprop="dateCreated datePublished" datetime="2021-03-11T21:12:40+08:00">2021-03-11</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-03-10 13:14:04" itemprop="dateModified" datetime="2021-03-10T13:14:04+08:00">2021-03-10</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/nirvana/categories/javascript/" itemprop="url" rel="index"><span itemprop="name">javascript</span></a>
        </span>
    </span>

  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>URL的架构——————-<br><scheme>://<username>:<password>@<host>:<port>/<parameters>?<query>#<fragment><br>&lt;模式&gt; ://&lt;用户名&gt;:&lt;密码&gt;@&lt;主机地址&gt;:&lt;端口&gt;/&lt;路径&gt;;&lt;参数&gt;?&lt;查询&gt;#&lt;信息片断&gt;</p>
<p>模式——-<br>通常是指用来访问URL所标明地址的资源的协议.<br>如果一个模式向IANA注册过,那么它就是官方的(如HTTP,FTP)<br>但也有非官方的(未注册)的模式在普遍使用,(如SFTP,svn)<br>scheme: 为一部分,//不属于分隔符的一部分,是URL下一部分的开始.</p>
<p>{ …..//&lt;用户名&gt;:&lt;密码&gt;@&lt;主机地址&gt;:&lt;端口&gt;…}—————————————————————<br>构成了URL的权限控制部分</p>
<p>只提供用户名<br><a href="ftp://some_user@code.google.com/">ftp://some_user@code.google.com/</a><br>提供用户名和密码<br><a href="ftp://some_user:password@code.google.com/">ftp://some_user:password@code.google.com/</a><br>如果你不提供用户名和密码,而你试图访问的URL要求你提供,那么应用程序(如:浏览器)将提供一些默认值.</p>
<p>主机———<br>主机地址可以是域名或IP地址,正如我们所知,域名会解析成IP地址(通过DNS查找)以确定我们正在尝试访问<br>的机器的地址.</p>
<p>端口——–<br>它告诉我们,我们连接到机器上的指定应用正在监听什么网络端口,如果省略,则使用默认值 ,HTTP的默认为80</p>
<p>路径——–<br>以 / 作为前缀从URL组成部分中分离.一个路径由一系列的 / 字符分隔的片断组成.<br>告诉我们资源在服务器上的位置,每个路径片断都可以包含参数,以 ;  号与路径片断隔开,如:<br><a target="_blank" rel="noopener" href="http://www.soon.com/aaa;para1=xxx/bbb;para2=yyy/my.html">http://www.soon.com/aaa;para1=xxx/bbb;para2=yyy/my.html</a><br>这样的URL是完全有效的.</p>
<p>参数———<br>它们可以出现在路径之后,查询字符串之前,以 ; 号与URL的其它部分和其它参数隔开,如:<br><a target="_blank" rel="noopener" href="http://www.soon.com/aaa/bbb/ccc/my.html;para1=xyz;para2=abc">http://www.soon.com/aaa/bbb/ccc/my.html;para1=xyz;para2=abc</a><br>它们不是很常见.</p>
<p>查询———<br>它们十分常见.<br>这是发送一些参数到服务器资源上的首选方式.<br>这些以  关键字=值  的查询对以?号与URL的其它部分隔开,并且以&amp;符号与其它的 [查询对] 分开.使用 ; 号将 [查询对] 分开也是合法的. </p>
<blockquote>
<p><a target="_blank" rel="noopener" href="http://www.soon.com/bbs/about.html?para1=ok&amp;para2=yes">http://www.soon.com/bbs/about.html?para1=ok&amp;para2=yes</a>    等价于<br><a target="_blank" rel="noopener" href="http://www.soon.com/bbs/about.html?para1=ok;para2=yes">http://www.soon.com/bbs/about.html?para1=ok;para2=yes</a></p>
</blockquote>
<p>信息片断—————<br>这是一个URL的可选部分,用于描述资源的一个特定部分.我们通常看到它们用于链接到HTML文档中的特定部分.信息片断以#号与URL的其它部分隔开.当从服务器请求一个以URL寻址的资源时,客户端通常不会发送信息片断到服务器(至少HTTP协议不会).一旦客户端获取资源,它将使用信息片断处理有关部分.————————– 上面是URL的九大部分 —————————–</p>
<p> URL该如何进行正确的编码?哪些字符可以在URL中安全的使用?<br> 哪些字符不能使用?</p>
<h2 id="URL的特殊字符"><a href="#URL的特殊字符" class="headerlink" title=" URL的特殊字符"></a> URL的特殊字符</h2><p> 当几种特定的字符集合出现在URL中时,你必须特别注意:</p>
<p>首先,在URL中有特殊意义的字符,也就是保留字符:<br> ;    /    ?   :     @     &amp;     =     +    $     ,        {10个}<br> 这意味着,这些字符通常在URL中使用时,是有特殊含义的(如 “:”把每一个部分分隔开来),如果一个URL的某一部分(如查询参数的一部分)可能包含这些字符之一,则应该在放入URL之前对其进行转义处理.<br>  第二组需要注意的字符集是非保留字符集.如下:<br>  -  _   .   !   ~   *   ‘   (   )             {9个}<br> 这些字符可以被用于URL的任何位置(有些地方,不允许它们出现.使用它们作为URL的一部分时,你不需要进行编码/转义处理.你可以对它们进行转义操作且不影响URL的语义,但不建议这么做.<br>第三组  不推荐字符 也就是避用字符集合使用它们是不明智的:<br>{  }  |   \   ^  [   ]   `::数字1键前::       {8个}<br>不明智的原因:网关有时会修改这样的字符,或者将其作为分隔符使用.这并不意味着网关总会修改这些字符,但这种情况可能发生.如果真是要使用这些字符,请做转义处理.<br>第四组   例外字符集<br>这组字符集是所有的ASCII控制字符组成.包含空格字符以下列字符:<br>&lt;   &gt;   #   %   “      {5 个}<br>控制字符是不可打印的US-ASCII字符(十六进制00~1F及7F)<br>如果使用,请转义处理.有些字符#(哈希)和%(百分比)在URL上下文中有着特殊含义,你可以把它们当作保留字符对待.这个集合中的其它字符无法被打印,因此对它们进行转义是唯一的表示方式, &lt;   &gt;   “   这三个字符需要被转义，因为这些字符通常用来在文本中分隔URL</p>
<p>编码/转义————————-<br>通常将它的ASCII十六进制值加上一个%字符．<br>如空格字符的URL编码是　%20<br>%字符本身被编码为%25</p>
<p>这就是你所需要知道的所有URL的特殊字符，当然，从这些字符外，英文字母<br>和数字是可以直接使用而不需要进行编码的：）</p>
<p>！！！　必须记住<br>URL应该始终保持其编码形式．只有当你要拆分URL的时候，才应该对其进行<br>解码．每个URL部分，都必须分别进行编码．<br>应该避免重复编码／解码一个URL．如果你编码一个URL一次，但解码两次，而<br>这个URL包含%字符，那么你将破坏掉你的URL<br>可以查看　RFC 2396 中的定义</p>
<p>绝对URL和相对URL———————————-<br>如果一个URL包含scheme部分的话（如http），那它就可以被看做绝对URL．<br>但相对URL就有点复杂了．<br>相对URL永远是代表着相对于另外一个URL而言的，其它的URL被称为base URL.<br>将相对URL变成绝对URL的形式，我们首先要了解它的base URL，接着把它跟相<br>对URL的语法结合之后就得到绝对URL．<br>在一个HTML文档中看到的相对URL，在这种情况有两个方法找到它的对应的<br>base URL．<br>１,base URL可能由html的<base>标签指出．<br>２,如果没有指定base标签，那么该html文档的url地址就被视为它的base URL.<br>一旦我们有了base URL ,我们就可以试着将我们的相对URL转成绝对URL.<br>首先要将相对URL拆分成单个的结构（scheme,authority(host,post),path,query<br>string,fragment)<br>拆解完成后，有几个地方需要注意，因为它们可能说明我们转换的相对URL不一定对．<br>１,如果没有［scheme］［authority］或［path］，那么这个相对URL是base URL的<br>一个引用．<br>２,如果有［scheme］，那么这个相对URL其实是绝对URL，所以用绝对URL的方式处理．<br>３,如果没有［scheme］，但是有［authority(host,post)］，那么我们相对URL可能是网路位址那么我们根据base URL的［模式］并且把它跟相对URL用://结合起来．<br>４,如果没有上述的这些特殊情形，那我们得到的则是一个完全的相对URL．现在我们需要根据如下的程序进行处理．<br>５,我们从base URL继承它的scheme以及authority(host,post).<br>６,如果相对URL开头是一个/，那么它是一个绝对路径，我们可以通过继承得到的authoruity和host，用适当的分隔号产生绝对url<br>７,如果相对URL的开头不是一个/，那我们把base URL中／以后的东西都移除．然后把我们相对URL加上去得到最后的路径，再根据前面的几个字符对相对URL做一点小处理．<br>８,如果最后的路径包含./　　<br>我们直接把它去掉（这代表我们的相对URL由./开始，就像./blah.html)<br>９,如果最后的路径包含../　　<br>我们可以去掉它并且把路径上移一个区段，就好像把所有像样的路径组合都去掉＂＜segment＞/../＂,持续这个过程，直到找不到任何的../这表示我们的相对路径开头是多个../像是../blah.htm或../../blah.html<br>１０,如果路径的结尾是.. ,那就去掉它并且把路径上移一个区段，比如移除””<segment>/../“<br> 这表示我们的相对路径是．．<br> １１,如果路径的结尾是．，那就把它去掉，表示我们的相对路径很有可能是．<br> 根据这些规则我们可以简单把相对URL的query或者fragment利用合适的分隔符号<br> 包含到我们的URL中去，这样就将相对URL转换成了绝对URL．</p>
<p> 范例：<br> base:  <a target="_blank" rel="noopener" href="http://www.blah.com/yadda1/yadda2/yadda3?param1=foo#barrelative:rel1">http://www.blah.com/yadda1/yadda2/yadda3?param1=foo#barrelative:rel1</a><br> final  :  <a target="_blank" rel="noopener" href="http://www.blah.com/yadda1/yadda2/rel1">http://www.blah.com/yadda1/yadda2/rel1</a></p>
<p> base:  <a target="_blank" rel="noopener" href="http://www.blah.com/yadda1/yadda2/yadda3?param1=foo#barrelative:/rel1">http://www.blah.com/yadda1/yadda2/yadda3?param1=foo#barrelative:/rel1</a><br> final :   <a target="_blank" rel="noopener" href="http://www.blah.com/rel1">http://www.blah.com/rel1</a></p>
<p> base:  <a target="_blank" rel="noopener" href="http://www.blah.com/yadda1/yadda2/yadda3?param1=foo#barrelative:../rel1">http://www.blah.com/yadda1/yadda2/yadda3?param1=foo#barrelative:../rel1</a><br> base:  <a target="_blank" rel="noopener" href="http://www.blah.com/yadda1/rel1">http://www.blah.com/yadda1/rel1</a></p>
<p> base:  <a target="_blank" rel="noopener" href="http://www.blah.com/yadda1/yadda2/yadda3?param1=foo#barrelative:./rel1?param2=baz#bar2">http://www.blah.com/yadda1/yadda2/yadda3?param1=foo#barrelative:./rel1?param2=baz#bar2</a><br> final:    <a target="_blank" rel="noopener" href="http://www.blah.com/yadda1/yadda2/rel1?param2=baz#bar2">http://www.blah.com/yadda1/yadda2/rel1?param2=baz#bar2</a></p>
<p>base:    <a target="_blank" rel="noopener" href="http://www.blah.com/yadda1/yadda2/yadda3?param1=foo#barrelative">http://www.blah.com/yadda1/yadda2/yadda3?param1=foo#barrelative</a>: ..<br> final :    <a target="_blank" rel="noopener" href="http://www.blah.com/yadda1/">http://www.blah.com/yadda1/</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/nirvana/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/nirvana/">1</a><a class="page-number" href="/nirvana/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/nirvana/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/nirvana/page/18/">18</a><a class="extend next" rel="next" href="/nirvana/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>


<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">nirvana</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">540k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">8:11</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/nirvana/js/utils.js"></script><script src="/nirvana/js/motion.js"></script><script src="/nirvana/js/next-boot.js"></script>

  






  





</body>
</html>
